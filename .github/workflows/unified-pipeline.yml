# ============================================================================
# THE UNIFIED HEALTH PLATFORM - UNIFIED CI/CD PIPELINE
# ============================================================================
#
# This single workflow consolidates ALL previously separate workflows into
# one unified, modular pipeline. It handles:
#
# 1. Code Quality & Linting
# 2. Unit & Integration Testing
# 3. Security Scanning (SAST, dependency audit, secrets, containers, IaC)
# 4. Docker Image Building & ECR Push
# 5. Terraform Infrastructure Management
# 6. Environment Deployments (dev, staging, production)
# 7. Performance Audits (Lighthouse)
# 8. SBOM Generation
# 9. Drift Detection
#
# MERGED WORKFLOWS:
# - ci-tests.yml
# - security-check.yml
# - web-frontend-deploy.yml
# - aws-provider-check.yml
# - lighthouse-ci.yml
# - sbom-generation.yml
# - terraform-aws.yml
# - terraform-dev-prod-gated.yml
# - scheduled-production-deploy.yml
# - terraform-drift-check.yml
# - test-actions.yml
#
# ============================================================================

name: Unified Pipeline

on:
  # Pull request triggers: validation, tests, and scans only
  pull_request:
    branches:
      - main
      - develop
    types:
      - opened
      - synchronize
      - reopened

  # Push triggers: full pipeline
  push:
    branches:
      - main
      - develop
      - 'release/**'

  # Manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: false
        type: choice
        default: 'none'
        options:
          - none
          - dev
          - staging
          - production
      terraform_action:
        description: 'Terraform action (if deploying infrastructure)'
        required: false
        type: choice
        default: 'plan'
        options:
          - plan
          - apply
      skip_tests:
        description: 'Skip test suite (NOT recommended for production)'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Dry run mode (no actual deployments)'
        required: false
        type: boolean
        default: false
      run_sbom:
        description: 'Generate SBOM'
        required: false
        type: boolean
        default: false
      run_drift_check:
        description: 'Run infrastructure drift check'
        required: false
        type: boolean
        default: false
      run_lighthouse:
        description: 'Run Lighthouse performance audit'
        required: false
        type: boolean
        default: false

  # Release triggers for SBOM generation
  release:
    types: [published]

  # Scheduled triggers
  schedule:
    # Drift check: every 6 hours
    - cron: '0 */6 * * *'
    # Production deployment window: Tuesday 9pm CST (3am UTC Wednesday)
    - cron: '0 3 * * 3'

# ============================================================================
# ENVIRONMENT VARIABLES
# ============================================================================
env:
  NODE_VERSION: '20'
  TF_VERSION: '1.6.0'
  AWS_REGION: 'us-east-1'
  TF_WORKING_DIR: 'infrastructure/terraform-aws'

# ============================================================================
# PERMISSIONS (Least Privilege)
# ============================================================================
permissions:
  id-token: write
  contents: read
  pull-requests: write
  security-events: write
  issues: write
  actions: read
  packages: write

# ============================================================================
# CONCURRENCY CONTROL
# ============================================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

# ============================================================================
# JOBS
# ============================================================================
jobs:
  # ==========================================================================
  # STAGE 1: SETUP & PREREQUISITES
  # ==========================================================================
  setup:
    name: Setup & Prerequisites
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
      should_run_tests: ${{ steps.determine.outputs.run_tests }}
      should_run_security: ${{ steps.determine.outputs.run_security }}
      should_run_terraform: ${{ steps.determine.outputs.run_terraform }}
      should_run_deploy: ${{ steps.determine.outputs.run_deploy }}
      should_run_lighthouse: ${{ steps.determine.outputs.run_lighthouse }}
      should_run_sbom: ${{ steps.determine.outputs.run_sbom }}
      should_run_drift: ${{ steps.determine.outputs.run_drift }}
      target_environment: ${{ steps.determine.outputs.target_env }}
      commit_sha: ${{ steps.meta.outputs.sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate metadata
        id: meta
        run: |
          echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "short_sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      - name: Generate cache key
        id: cache-key
        run: echo "key=${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}" >> $GITHUB_OUTPUT

      - name: Determine what to run
        id: determine
        run: |
          EVENT="${{ github.event_name }}"
          REF="${{ github.ref }}"

          # Defaults
          RUN_TESTS="true"
          RUN_SECURITY="true"
          RUN_TERRAFORM="false"
          RUN_DEPLOY="false"
          RUN_LIGHTHOUSE="false"
          RUN_SBOM="false"
          RUN_DRIFT="false"
          TARGET_ENV="none"

          # Pull Request: validation only
          if [ "$EVENT" == "pull_request" ]; then
            RUN_TESTS="true"
            RUN_SECURITY="true"
            RUN_TERRAFORM="true"  # Plan only
            RUN_LIGHTHOUSE="${{ github.event.inputs.run_lighthouse || 'false' }}"
          fi

          # Push to main: full pipeline
          if [ "$EVENT" == "push" ] && [ "$REF" == "refs/heads/main" ]; then
            RUN_TESTS="true"
            RUN_SECURITY="true"
            RUN_TERRAFORM="true"
            RUN_DEPLOY="true"
            TARGET_ENV="dev"
          fi

          # Release: generate SBOM
          if [ "$EVENT" == "release" ]; then
            RUN_SBOM="true"
          fi

          # Scheduled: drift check or production deploy
          if [ "$EVENT" == "schedule" ]; then
            HOUR=$(date -u +%H)
            # 3am UTC is production deploy window
            if [ "$HOUR" == "03" ]; then
              RUN_TESTS="true"
              RUN_SECURITY="true"
              RUN_DEPLOY="true"
              TARGET_ENV="production"
            else
              RUN_DRIFT="true"
            fi
          fi

          # Manual dispatch: respect inputs
          if [ "$EVENT" == "workflow_dispatch" ]; then
            RUN_TESTS="${{ github.event.inputs.skip_tests != 'true' }}"
            RUN_SECURITY="true"
            RUN_SBOM="${{ github.event.inputs.run_sbom }}"
            RUN_DRIFT="${{ github.event.inputs.run_drift_check }}"
            RUN_LIGHTHOUSE="${{ github.event.inputs.run_lighthouse }}"

            if [ "${{ github.event.inputs.environment }}" != "none" ]; then
              RUN_TERRAFORM="true"
              RUN_DEPLOY="true"
              TARGET_ENV="${{ github.event.inputs.environment }}"
            fi
          fi

          echo "run_tests=$RUN_TESTS" >> $GITHUB_OUTPUT
          echo "run_security=$RUN_SECURITY" >> $GITHUB_OUTPUT
          echo "run_terraform=$RUN_TERRAFORM" >> $GITHUB_OUTPUT
          echo "run_deploy=$RUN_DEPLOY" >> $GITHUB_OUTPUT
          echo "run_lighthouse=$RUN_LIGHTHOUSE" >> $GITHUB_OUTPUT
          echo "run_sbom=$RUN_SBOM" >> $GITHUB_OUTPUT
          echo "run_drift=$RUN_DRIFT" >> $GITHUB_OUTPUT
          echo "target_env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

  # ==========================================================================
  # STAGE 2: CODE QUALITY
  # ==========================================================================
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Restore pnpm cache
        uses: actions/cache@v4
        with:
          path: ~/.local/share/pnpm/store
          key: ${{ needs.setup.outputs.cache-key }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check branding consistency
        run: |
          echo "Checking for disallowed branding patterns..."
          DISALLOWED_PATTERNS=(
            "UnifiedHealth[^c]"
            "Unified Healthcare"
            "unified-health\.com"
            "unifiedhealth\.com"
          )
          EXCLUDE_PATTERNS="--exclude-dir=node_modules --exclude-dir=.git --exclude-dir=dist --exclude-dir=.pnpm --exclude=*.lock --exclude=pnpm-lock.yaml"
          WHITELIST_FILES="app.json|package.json|\.env|Dockerfile|docker-compose|kustomization|\.tf$|Chart\.yaml"

          FOUND_ISSUES=false
          for pattern in "${DISALLOWED_PATTERNS[@]}"; do
            MATCHES=$(grep -rniE "$pattern" \
              --include="*.html" --include="*.tsx" --include="*.ts" --include="*.md" \
              $EXCLUDE_PATTERNS apps/ services/ docs/ packages/i18n/ 2>/dev/null \
              | grep -vE "$WHITELIST_FILES" || true)
            if [ -n "$MATCHES" ]; then
              echo "::warning::Found disallowed branding pattern '$pattern'"
              FOUND_ISSUES=true
            fi
          done

          if [ "$FOUND_ISSUES" = true ]; then
            echo "::error::Branding consistency issues found"
            exit 1
          fi
          echo "Branding consistency check passed!"

      - name: Type check API service
        run: cd services/api && pnpm typecheck
        continue-on-error: true

      - name: Lint codebase
        run: pnpm lint
        continue-on-error: true

  # ==========================================================================
  # STAGE 3: UNIT & INTEGRATION TESTS
  # ==========================================================================
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_tests == 'true'

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: API
            path: services/api
            generate_prisma: true
          - name: Notification
            path: services/notification-service
            generate_prisma: true
          - name: Web
            path: apps/web
            generate_prisma: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Restore pnpm cache
        uses: actions/cache@v4
        with:
          path: ~/.local/share/pnpm/store
          key: ${{ needs.setup.outputs.cache-key }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma client
        if: matrix.generate_prisma
        run: cd ${{ matrix.path }} && pnpm db:generate
        continue-on-error: true

      - name: Run unit tests
        run: cd ${{ matrix.path }} && pnpm test
        env:
          NODE_ENV: test
          JWT_SECRET: test-secret-key-for-ci-tests-only-32chars
        continue-on-error: true

      - name: Upload coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-${{ matrix.name }}
          path: ${{ matrix.path }}/coverage/
          if-no-files-found: ignore

  security-tests:
    name: Security Tests
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_tests == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma client
        run: cd services/api && pnpm db:generate

      - name: Run security tests
        run: cd services/api && pnpm test -- tests/security/ --reporter=verbose
        env:
          NODE_ENV: test
          JWT_SECRET: test-secret-key-for-ci-tests-only-32chars
        continue-on-error: true

  # ==========================================================================
  # STAGE 4: SECURITY SCANNING
  # ==========================================================================
  dependency-audit:
    name: Dependency Audit
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_security == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run pnpm audit
        run: pnpm audit --audit-level=moderate || echo "::warning::Vulnerabilities found"
        continue-on-error: true

  sast:
    name: SAST Analysis
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_security == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/typescript
            p/nodejs
            p/secrets
            p/owasp-top-ten
          generateSarif: true
        continue-on-error: true

      - name: Upload SARIF results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: semgrep.sarif
          category: semgrep
        continue-on-error: true

  secret-scan:
    name: Secret Scanning
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_security == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_security == 'true'
    permissions:
      security-events: write
      actions: read
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript-typescript
          queries: security-extended,security-and-quality

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "codeql-javascript"

  iac-scan:
    name: IaC Security Scan
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_security == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Trivy IaC scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          scan-ref: './infrastructure'
          format: 'sarif'
          output: 'trivy-iac.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
        continue-on-error: true

      - name: Upload Trivy IaC results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-iac.sarif'
          category: 'trivy-iac'
        continue-on-error: true

  # ==========================================================================
  # STAGE 5: AWS PROVIDER VERIFICATION
  # ==========================================================================
  aws-provider-check:
    name: AWS Provider Verification
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_terraform == 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify AWS-only infrastructure
        run: |
          echo "Scanning for Azure contamination..."
          FAILED=0

          # Check for azurerm provider (excluding comments that document the policy)
          if grep -rE "^\s*provider\s+\"azurerm\"" infrastructure/terraform-aws/ --include="*.tf" 2>/dev/null; then
            echo "::error::Azure 'azurerm' provider block detected!"
            FAILED=1
          fi

          # Check for Azure resource types
          if grep -rE "^\s*resource\s+\"azurerm_" infrastructure/terraform-aws/ --include="*.tf" 2>/dev/null; then
            echo "::error::Azure resource types (azurerm_*) detected!"
            FAILED=1
          fi

          if [ $FAILED -eq 1 ]; then
            echo "::error::Azure contamination detected. This is an AWS-only deployment."
            exit 1
          fi

          echo "AWS-only verification passed"

      - name: Verify AWS provider exists
        run: |
          if ! grep -r "hashicorp/aws" infrastructure/terraform-aws/ --include="*.tf" 2>/dev/null; then
            echo "::error::AWS provider not found!"
            exit 1
          fi
          echo "AWS provider correctly configured"

  # ==========================================================================
  # STAGE 6: TERRAFORM VALIDATION & PLAN
  # ==========================================================================
  terraform-validate:
    name: Terraform Validate
    runs-on: ubuntu-latest
    needs: [setup, aws-provider-check]
    if: needs.setup.outputs.should_run_terraform == 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform validate

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [setup, terraform-validate]
    if: needs.setup.outputs.should_run_terraform == 'true'
    environment: ${{ needs.setup.outputs.target_environment != 'none' && needs.setup.outputs.target_environment || 'dev' }}

    outputs:
      plan_has_changes: ${{ steps.plan.outputs.has_changes }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          ENV="${{ needs.setup.outputs.target_environment }}"
          [ "$ENV" == "none" ] && ENV="dev"

          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=env/${ENV}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_LOCK_TABLE }}"

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          ENV="${{ needs.setup.outputs.target_environment }}"
          [ "$ENV" == "none" ] && ENV="dev"

          terraform plan \
            -var-file=environments/${ENV}.tfvars \
            -out=tfplan \
            -detailed-exitcode \
            -no-color 2>&1 | tee plan-output.txt

          EXITCODE=${PIPESTATUS[0]}
          if [ $EXITCODE -eq 2 ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            ${{ env.TF_WORKING_DIR }}/tfplan
            ${{ env.TF_WORKING_DIR }}/plan-output.txt
          retention-days: 7

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let planOutput = 'Plan output not available';
            try {
              planOutput = fs.readFileSync('${{ env.TF_WORKING_DIR }}/plan-output.txt', 'utf8');
              if (planOutput.length > 60000) {
                planOutput = planOutput.substring(0, 60000) + '\n\n... (truncated)';
              }
            } catch (e) {}

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Terraform Plan\n\n\`\`\`\n${planOutput}\n\`\`\``
            });

  # ==========================================================================
  # STAGE 7: BUILD DOCKER IMAGES
  # ==========================================================================
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [setup, unit-tests, security-tests, code-quality]
    if: |
      needs.setup.outputs.should_run_deploy == 'true' &&
      github.event.inputs.dry_run != 'true'

    strategy:
      fail-fast: false
      matrix:
        service:
          - name: api
            context: ./services/api
            dockerfile: ./services/api/Dockerfile
          - name: web
            context: .
            dockerfile: ./Dockerfile.web.pnpm
          - name: api-gateway
            context: ./services/api-gateway
            dockerfile: ./services/api-gateway/Dockerfile

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push ${{ matrix.service.name }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/unified-health-prod/${{ matrix.service.name }}:${{ needs.setup.outputs.commit_sha }}
            ${{ steps.login-ecr.outputs.registry }}/unified-health-prod/${{ matrix.service.name }}:latest
          cache-from: type=gha,scope=${{ matrix.service.name }}
          cache-to: type=gha,scope=${{ matrix.service.name }},mode=max

  # ==========================================================================
  # STAGE 8: CONTAINER SECURITY SCAN
  # ==========================================================================
  container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: build-images
    if: needs.build-images.result == 'success'

    strategy:
      matrix:
        service: [api, web, api-gateway]

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ secrets.ECR_REGISTRY }}/unified-health-prod/${{ matrix.service }}:latest'
          format: 'sarif'
          output: 'trivy-${{ matrix.service }}.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-${{ matrix.service }}.sarif'
          category: 'trivy-${{ matrix.service }}'
        continue-on-error: true

  # ==========================================================================
  # STAGE 9: DEPLOY TO ENVIRONMENT
  # ==========================================================================
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: [setup, build-images, terraform-plan]
    if: |
      needs.setup.outputs.should_run_deploy == 'true' &&
      needs.setup.outputs.target_environment == 'dev' &&
      needs.build-images.result == 'success'
    environment:
      name: dev
      url: https://dev.theunifiedhealth.com

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name unified-health-dev-cluster

      - name: Deploy to EKS
        run: |
          COMMIT_SHA="${{ needs.setup.outputs.commit_sha }}"

          kubectl set image deployment/api \
            api=${{ secrets.ECR_REGISTRY }}/unified-health-prod/api:$COMMIT_SHA \
            -n unified-health || echo "Deployment not found"

          kubectl set image deployment/web \
            web=${{ secrets.ECR_REGISTRY }}/unified-health-prod/web:$COMMIT_SHA \
            -n unified-health || echo "Deployment not found"

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/api -n unified-health --timeout=300s || true
          kubectl rollout status deployment/web -n unified-health --timeout=300s || true

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [setup, build-images, terraform-plan]
    if: |
      needs.setup.outputs.should_run_deploy == 'true' &&
      needs.setup.outputs.target_environment == 'staging' &&
      needs.build-images.result == 'success'
    environment:
      name: staging
      url: https://staging.theunifiedhealth.com

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_STAGING }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name unified-health-staging-cluster

      - name: Deploy to EKS
        run: |
          COMMIT_SHA="${{ needs.setup.outputs.commit_sha }}"

          kubectl set image deployment/api \
            api=${{ secrets.ECR_REGISTRY }}/unified-health-prod/api:$COMMIT_SHA \
            -n unified-health

          kubectl set image deployment/web \
            web=${{ secrets.ECR_REGISTRY }}/unified-health-prod/web:$COMMIT_SHA \
            -n unified-health

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/api -n unified-health --timeout=300s
          kubectl rollout status deployment/web -n unified-health --timeout=300s

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [setup, build-images, terraform-plan, container-scan]
    if: |
      needs.setup.outputs.should_run_deploy == 'true' &&
      needs.setup.outputs.target_environment == 'production' &&
      needs.build-images.result == 'success' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: production
      url: https://theunifiedhealth.com

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PROD }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name unified-health-prod-cluster

      - name: Deploy to EKS
        run: |
          COMMIT_SHA="${{ needs.setup.outputs.commit_sha }}"

          kubectl set image deployment/api \
            api=${{ secrets.ECR_REGISTRY }}/unified-health-prod/api:$COMMIT_SHA \
            -n unified-health

          kubectl set image deployment/web \
            web=${{ secrets.ECR_REGISTRY }}/unified-health-prod/web:$COMMIT_SHA \
            -n unified-health

          kubectl set image deployment/api-gateway \
            api-gateway=${{ secrets.ECR_REGISTRY }}/unified-health-prod/api-gateway:$COMMIT_SHA \
            -n unified-health

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/api -n unified-health --timeout=300s
          kubectl rollout status deployment/web -n unified-health --timeout=300s
          kubectl rollout status deployment/api-gateway -n unified-health --timeout=300s

      - name: Health check
        run: |
          kubectl wait --for=condition=ready pod -l app=api -n unified-health --timeout=120s
          kubectl wait --for=condition=ready pod -l app=web -n unified-health --timeout=120s
          echo "Production deployment verified"

  # ==========================================================================
  # STAGE 10: TERRAFORM APPLY (Production Only - Gated)
  # ==========================================================================
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [setup, terraform-plan, deploy-production]
    if: |
      needs.setup.outputs.should_run_terraform == 'true' &&
      needs.setup.outputs.target_environment == 'production' &&
      github.event.inputs.terraform_action == 'apply' &&
      needs.terraform-plan.outputs.plan_has_changes == 'true'
    environment:
      name: production-infrastructure
      url: https://console.aws.amazon.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PROD }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=env/production/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_LOCK_TABLE }}"

      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform apply -auto-approve tfplan

  # ==========================================================================
  # STAGE 11: LIGHTHOUSE PERFORMANCE AUDIT
  # ==========================================================================
  lighthouse:
    name: Lighthouse Audit
    runs-on: ubuntu-latest
    needs: setup
    if: |
      needs.setup.outputs.should_run_lighthouse == 'true' ||
      (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'lighthouse'))

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build web application
        run: pnpm --filter @unified-health/web build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_API_URL: http://localhost:4000
        continue-on-error: true

      - name: Install Chrome
        uses: browser-actions/setup-chrome@v1
        with:
          chrome-version: stable

      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli@0.13.x
          lhci autorun --config=lighthouserc.js || echo "Lighthouse completed with warnings"
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
        continue-on-error: true

      - name: Upload Lighthouse reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lighthouse-reports
          path: .lighthouseci
          retention-days: 30

  # ==========================================================================
  # STAGE 12: SBOM GENERATION
  # ==========================================================================
  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_sbom == 'true'
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="dev-$(git rev-parse --short HEAD)"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate SBOM
        run: |
          mkdir -p sbom-artifacts
          npx @cyclonedx/cyclonedx-npm \
            --output-file sbom-artifacts/sbom-${{ steps.version.outputs.version }}.json \
            --output-format JSON \
            --spec-version 1.5 \
            --mc-type application \
            --flatten-components

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ steps.version.outputs.version }}
          path: sbom-artifacts/
          retention-days: 90

      - name: Attach to release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: sbom-artifacts/*.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ==========================================================================
  # STAGE 13: DRIFT DETECTION
  # ==========================================================================
  drift-check:
    name: Infrastructure Drift Check
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_run_drift == 'true'

    strategy:
      matrix:
        environment: [dev, staging, prod]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=env/${{ matrix.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_LOCK_TABLE }}"

      - name: Terraform Plan (Drift Detection)
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform plan \
            -var-file=environments/${{ matrix.environment }}.tfvars \
            -detailed-exitcode \
            -no-color 2>&1 | tee drift-output.txt
          echo "exitcode=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Check for Drift
        if: steps.plan.outputs.exitcode == '2'
        run: |
          echo "::warning::Drift detected in ${{ matrix.environment }} environment!"

      - name: Create Issue for Drift
        if: steps.plan.outputs.exitcode == '2' && matrix.environment == 'prod'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[DRIFT] Infrastructure drift detected in ${{ matrix.environment }}`,
              body: `## Infrastructure Drift Detected\n\n**Environment:** ${{ matrix.environment }}\n**Detected:** ${new Date().toISOString()}\n\nPlease review and remediate.`,
              labels: ['drift', '${{ matrix.environment }}', 'infrastructure']
            });

  # ==========================================================================
  # STAGE 14: ROLLBACK (On Failure)
  # ==========================================================================
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [setup, deploy-production]
    if: failure() && needs.deploy-production.result == 'failure'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PROD }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name unified-health-prod-cluster

      - name: Rollback deployments
        run: |
          echo "::warning::Initiating rollback due to deployment failure"
          kubectl rollout undo deployment/api -n unified-health
          kubectl rollout undo deployment/web -n unified-health
          kubectl rollout undo deployment/api-gateway -n unified-health

          kubectl rollout status deployment/api -n unified-health --timeout=300s
          kubectl rollout status deployment/web -n unified-health --timeout=300s
          echo "Rollback completed"

  # ==========================================================================
  # STAGE 15: PIPELINE SUMMARY
  # ==========================================================================
  summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs:
      - setup
      - code-quality
      - unit-tests
      - security-tests
      - dependency-audit
      - sast
      - secret-scan
      - terraform-validate
      - terraform-plan
      - build-images
      - deploy-dev
      - deploy-staging
      - deploy-production
    if: always()

    steps:
      - name: Generate summary
        run: |
          echo "## Unified Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Setup | ${{ needs.setup.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Code Quality | ${{ needs.code-quality.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | ${{ needs.unit-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Security Tests | ${{ needs.security-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dependency Audit | ${{ needs.dependency-audit.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| SAST | ${{ needs.sast.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Secret Scan | ${{ needs.secret-scan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Validate | ${{ needs.terraform-validate.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Plan | ${{ needs.terraform-plan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Images | ${{ needs.build-images.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Dev | ${{ needs.deploy-dev.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Staging | ${{ needs.deploy-staging.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Production | ${{ needs.deploy-production.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ needs.setup.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Environment:** ${{ needs.setup.outputs.target_environment }}" >> $GITHUB_STEP_SUMMARY

      - name: Post PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              'Code Quality': '${{ needs.code-quality.result }}',
              'Unit Tests': '${{ needs.unit-tests.result }}',
              'Security Tests': '${{ needs.security-tests.result }}',
              'SAST': '${{ needs.sast.result }}',
              'Terraform': '${{ needs.terraform-plan.result }}'
            };

            let table = '| Check | Status |\n|-------|--------|\n';
            for (const [check, result] of Object.entries(results)) {
              const emoji = result === 'success' ? ':white_check_mark:' :
                           result === 'failure' ? ':x:' : ':warning:';
              table += `| ${check} | ${emoji} ${result} |\n`;
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Unified Pipeline Results\n\n${table}`
            });
