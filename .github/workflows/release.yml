# ============================================
# UnifiedHealth Platform - Release Automation
# Semantic versioning and automated release creation
# ============================================

name: Release

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '9'

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # ==========================================
  # Analyze Commits for Release
  # ==========================================
  analyze-commits:
    name: Analyze Commits
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.analyze.outputs.SHOULD_RELEASE }}
      version_bump: ${{ steps.analyze.outputs.VERSION_BUMP }}
      new_version: ${{ steps.analyze.outputs.NEW_VERSION }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze commits
        id: analyze
        run: |
          # Get latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Get commits since last tag
          COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")

          # Check for breaking changes
          if echo "$COMMITS" | grep -qi "BREAKING CHANGE\|breaking:"; then
            VERSION_BUMP="major"
            SHOULD_RELEASE="true"
          # Check for features
          elif echo "$COMMITS" | grep -qi "^feat(\|^feat:"; then
            VERSION_BUMP="minor"
            SHOULD_RELEASE="true"
          # Check for fixes
          elif echo "$COMMITS" | grep -qi "^fix(\|^fix:"; then
            VERSION_BUMP="patch"
            SHOULD_RELEASE="true"
          else
            VERSION_BUMP="none"
            SHOULD_RELEASE="false"
          fi

          # Override if manual trigger
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION_BUMP="${{ inputs.version_bump }}"
            SHOULD_RELEASE="true"
          fi

          echo "SHOULD_RELEASE=${SHOULD_RELEASE}" >> $GITHUB_OUTPUT
          echo "VERSION_BUMP=${VERSION_BUMP}" >> $GITHUB_OUTPUT

          # Calculate new version
          if [ "$SHOULD_RELEASE" == "true" ] && [ "$VERSION_BUMP" != "none" ]; then
            CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
            IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"

            MAJOR="${VERSION_PARTS[0]}"
            MINOR="${VERSION_PARTS[1]}"
            PATCH="${VERSION_PARTS[2]}"

            case $VERSION_BUMP in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
            echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_OUTPUT
            echo "New version will be: $NEW_VERSION"
          fi

  # ==========================================
  # Generate Changelog
  # ==========================================
  generate-changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should_release == 'true'
    outputs:
      changelog: ${{ steps.changelog.outputs.CHANGELOG }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s (%h)" --reverse)
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --reverse)
          fi

          # Categorize commits
          FEATURES=$(echo "$COMMITS" | grep -i "^- feat" || true)
          FIXES=$(echo "$COMMITS" | grep -i "^- fix" || true)
          BREAKING=$(echo "$COMMITS" | grep -i "breaking" || true)
          CHORES=$(echo "$COMMITS" | grep -i "^- chore\|^- docs\|^- style\|^- refactor" || true)

          # Build changelog
          CHANGELOG="## What's Changed\n\n"

          if [ -n "$BREAKING" ]; then
            CHANGELOG="${CHANGELOG}### Breaking Changes\n${BREAKING}\n\n"
          fi

          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### Features\n${FEATURES}\n\n"
          fi

          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### Bug Fixes\n${FIXES}\n\n"
          fi

          if [ -n "$CHORES" ]; then
            CHANGELOG="${CHANGELOG}### Other Changes\n${CHORES}\n\n"
          fi

          # Save to file and output
          echo -e "$CHANGELOG" > RELEASE_NOTES.md
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          cat RELEASE_NOTES.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: RELEASE_NOTES.md

  # ==========================================
  # Build and Test Release
  # ==========================================
  build-release:
    name: Build Release
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should_release == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run linting
        run: pnpm lint

      - name: Run type check
        run: pnpm typecheck

      - name: Run tests
        run: pnpm test

      - name: Build services
        run: pnpm build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            apps/*/dist
            apps/*/.next
            services/*/dist

  # ==========================================
  # Create Release Tag
  # ==========================================
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [analyze-commits, generate-changelog, build-release]
    if: needs.analyze-commits.outputs.should_release == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update version in package.json
        run: |
          NEW_VERSION="${{ needs.analyze-commits.outputs.new_version }}"
          VERSION_NUMBER=$(echo $NEW_VERSION | sed 's/^v//')

          # Update root package.json
          if [ -f package.json ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION_NUMBER\"/" package.json
          fi

          # Update workspace packages
          for pkg in apps/*/package.json services/*/package.json packages/*/package.json; do
            if [ -f "$pkg" ]; then
              sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION_NUMBER\"/" "$pkg"
            fi
          done

          git add .
          git commit -m "chore(release): $NEW_VERSION" || true

      - name: Create Git tag
        run: |
          NEW_VERSION="${{ needs.analyze-commits.outputs.new_version }}"
          git tag -a $NEW_VERSION -m "Release $NEW_VERSION"
          git push origin $NEW_VERSION
          git push origin main

      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: release-notes

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.analyze-commits.outputs.new_version }}
          name: Release ${{ needs.analyze-commits.outputs.new_version }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ==========================================
  # Build and Push Release Docker Images
  # ==========================================
  build-release-images:
    name: Build Release Images
    runs-on: ubuntu-latest
    needs: [create-release, analyze-commits]
    environment: production

    strategy:
      matrix:
        service:
          - name: api
            context: ./services/api
            dockerfile: ./services/api/Dockerfile
          - name: web
            context: ./apps/web
            dockerfile: ./apps/web/Dockerfile

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.analyze-commits.outputs.new_version }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        run: az acr login --name acrunifiedhealthdev2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push release images
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            acrunifiedhealthdev2.azurecr.io/unified-health-${{ matrix.service.name }}:${{ needs.analyze-commits.outputs.new_version }}
            acrunifiedhealthdev2.azurecr.io/unified-health-${{ matrix.service.name }}:latest
          cache-from: type=gha,scope=${{ matrix.service.name }}-release
          cache-to: type=gha,scope=${{ matrix.service.name }}-release,mode=max

  # ==========================================
  # Notify Release
  # ==========================================
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [create-release, build-release-images, analyze-commits]
    if: always()

    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.create-release.result }}" == "success" ]; then
            echo "STATUS=SUCCESS" >> $GITHUB_OUTPUT
            echo "COLOR=good" >> $GITHUB_OUTPUT
          else
            echo "STATUS=FAILED" >> $GITHUB_OUTPUT
            echo "COLOR=danger" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "New Release ${{ steps.status.outputs.STATUS }}: ${{ needs.analyze-commits.outputs.new_version }}",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.COLOR }}",
                  "fields": [
                    {
                      "title": "Version",
                      "value": "${{ needs.analyze-commits.outputs.new_version }}",
                      "short": true
                    },
                    {
                      "title": "Type",
                      "value": "${{ needs.analyze-commits.outputs.version_bump }}",
                      "short": true
                    },
                    {
                      "title": "Status",
                      "value": "${{ steps.status.outputs.STATUS }}",
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    }
                  ],
                  "actions": [
                    {
                      "type": "button",
                      "text": "View Release",
                      "url": "${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.analyze-commits.outputs.new_version }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true
