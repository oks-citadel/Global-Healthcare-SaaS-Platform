name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to deploy (e.g., v1.2.3)'
        required: true
        type: string
      skip_confirmation:
        description: 'Skip manual confirmation'
        required: false
        type: boolean
        default: false

env:
  ACR_NAME: unifiedhealthacr
  AKS_CLUSTER: unified-health-aks-prod
  RESOURCE_GROUP: unified-health-rg-prod
  ENVIRONMENT: production

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    environment: production-approval

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version }}
          fetch-depth: 0

      - name: Verify version tag
        run: |
          if ! git describe --exact-match --tags HEAD >/dev/null 2>&1; then
            echo "Error: Not on a tagged commit"
            exit 1
          fi

          TAG=$(git describe --exact-match --tags HEAD)
          if [ "$TAG" != "${{ inputs.version }}" ]; then
            echo "Error: Tag mismatch"
            exit 1
          fi

          echo "Version verified: $TAG"

      - name: Check for breaking changes
        run: |
          echo "Checking for breaking changes in CHANGELOG..."
          if grep -q "BREAKING CHANGE" CHANGELOG.md 2>/dev/null; then
            echo "::warning::Breaking changes detected in CHANGELOG"
          fi

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check staging deployment
        run: |
          echo "Verifying staging is healthy before production deployment..."

          az aks get-credentials \
            --resource-group unified-health-rg-staging \
            --name unified-health-aks-staging \
            --overwrite-existing

          READY_PODS=$(kubectl get pods -n unified-health-staging -l app=unified-health-api -o json | jq -r '.items[] | select(.status.phase=="Running") | .metadata.name' | wc -l)

          if [ "$READY_PODS" -eq 0 ]; then
            echo "::error::Staging environment is not healthy!"
            exit 1
          fi

          echo "Staging is healthy with $READY_PODS pods running"

  backup-database:
    name: Backup Production Database
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Create database backup
        run: |
          chmod +x scripts/db-backup.sh
          ./scripts/db-backup.sh production
        env:
          BACKUP_RETENTION_DAYS: 90

      - name: Store backup name
        id: backup
        run: |
          BACKUP_NAME=$(az keyvault secret show \
            --vault-name unified-health-kv-production \
            --name "latest-backup-production" \
            --query value -o tsv)
          echo "BACKUP_NAME=${BACKUP_NAME}" >> $GITHUB_OUTPUT

    outputs:
      backup_name: ${{ steps.backup.outputs.BACKUP_NAME }}

  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: backup-database
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build services
        run: pnpm build

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Set image tags
        id: tags
        run: |
          VERSION="${{ inputs.version }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${VERSION}-${TIMESTAMP}"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT

      - name: Build Docker images
        run: |
          docker build \
            -t ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:${{ steps.tags.outputs.IMAGE_TAG }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:latest \
            -t ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:${{ steps.tags.outputs.VERSION }} \
            -f services/api/Dockerfile \
            services/api

          docker build \
            -t ${{ env.ACR_NAME }}.azurecr.io/unified-health-web:${{ steps.tags.outputs.IMAGE_TAG }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/unified-health-web:latest \
            -t ${{ env.ACR_NAME }}.azurecr.io/unified-health-web:${{ steps.tags.outputs.VERSION }} \
            -f apps/web/Dockerfile \
            apps/web

      - name: Scan images for vulnerabilities
        run: |
          # Install Trivy
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy

          # Scan images
          trivy image --severity HIGH,CRITICAL ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:${{ steps.tags.outputs.IMAGE_TAG }}
          trivy image --severity HIGH,CRITICAL ${{ env.ACR_NAME }}.azurecr.io/unified-health-web:${{ steps.tags.outputs.IMAGE_TAG }}

      - name: Push Docker images
        run: |
          docker push ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:${{ steps.tags.outputs.IMAGE_TAG }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:${{ steps.tags.outputs.VERSION }}

          docker push ${{ env.ACR_NAME }}.azurecr.io/unified-health-web:${{ steps.tags.outputs.IMAGE_TAG }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/unified-health-web:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/unified-health-web:${{ steps.tags.outputs.VERSION }}

    outputs:
      image_tag: ${{ steps.tags.outputs.IMAGE_TAG }}

  deploy-blue-green:
    name: Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER }} \
            --overwrite-existing

      - name: Determine deployment colors
        id: colors
        run: |
          CURRENT_COLOR=$(kubectl get svc unified-health-api -n unified-health-prod -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "")

          if [ "$CURRENT_COLOR" == "blue" ]; then
            CURRENT_COLOR="blue"
            NEW_COLOR="green"
          else
            CURRENT_COLOR="green"
            NEW_COLOR="blue"
          fi

          echo "CURRENT_COLOR=${CURRENT_COLOR}" >> $GITHUB_OUTPUT
          echo "NEW_COLOR=${NEW_COLOR}" >> $GITHUB_OUTPUT

          echo "Current color: ${CURRENT_COLOR}"
          echo "New color: ${NEW_COLOR}"

      - name: Run database migrations
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: db-migration-${{ needs.build-and-push.outputs.image_tag }}
            namespace: unified-health-prod
          spec:
            ttlSecondsAfterFinished: 86400
            backoffLimit: 3
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: migration
                  image: ${{ env.ACR_NAME }}.azurecr.io/unified-health-api:${{ needs.build-and-push.outputs.image_tag }}
                  command: ["pnpm", "db:migrate:deploy"]
                  env:
                  - name: DATABASE_URL
                    valueFrom:
                      secretKeyRef:
                        name: unified-health-secrets
                        key: database-url
          EOF

          kubectl wait --for=condition=complete \
            --timeout=600s \
            -n unified-health-prod \
            job/db-migration-${{ needs.build-and-push.outputs.image_tag }}

      - name: Deploy to new color
        run: |
          export NEW_COLOR="${{ steps.colors.outputs.NEW_COLOR }}"
          export IMAGE_TAG="${{ needs.build-and-push.outputs.image_tag }}"
          export ACR_LOGIN_SERVER="${{ env.ACR_NAME }}.azurecr.io"

          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: unified-health-api-${NEW_COLOR}
            namespace: unified-health-prod
            labels:
              app: unified-health-api
              color: ${NEW_COLOR}
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: unified-health-api
                color: ${NEW_COLOR}
            template:
              metadata:
                labels:
                  app: unified-health-api
                  color: ${NEW_COLOR}
              spec:
                serviceAccountName: unified-health-api
                containers:
                - name: api
                  image: ${ACR_LOGIN_SERVER}/unified-health-api:${IMAGE_TAG}
                  ports:
                  - containerPort: 8080
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: DATABASE_URL
                    valueFrom:
                      secretKeyRef:
                        name: unified-health-secrets
                        key: database-url
                  resources:
                    requests:
                      cpu: "500m"
                      memory: "512Mi"
                    limits:
                      cpu: "2000m"
                      memory: "2Gi"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: 8080
                    initialDelaySeconds: 10
                    periodSeconds: 5
          EOF

      - name: Wait for new deployment
        run: |
          kubectl rollout status deployment/unified-health-api-${{ steps.colors.outputs.NEW_COLOR }} \
            -n unified-health-prod \
            --timeout=600s

      - name: Verify new deployment
        run: |
          sleep 30

          READY_PODS=$(kubectl get pods -n unified-health-prod -l "app=unified-health-api,color=${{ steps.colors.outputs.NEW_COLOR }}" -o json | jq -r '.items[] | select(.status.phase=="Running") | .metadata.name' | wc -l)

          if [ "$READY_PODS" -eq 0 ]; then
            echo "::error::No pods are running!"
            exit 1
          fi

          echo "New deployment verified: $READY_PODS pods running"

      - name: Switch traffic to new deployment
        run: |
          kubectl patch svc unified-health-api -n unified-health-prod \
            -p '{"spec":{"selector":{"app":"unified-health-api","color":"${{ steps.colors.outputs.NEW_COLOR }}"}}}'

      - name: Monitor new deployment
        run: |
          echo "Monitoring deployment for 2 minutes..."

          for i in {1..12}; do
            FAILING_PODS=$(kubectl get pods -n unified-health-prod -l "app=unified-health-api,color=${{ steps.colors.outputs.NEW_COLOR }}" -o json | jq -r '.items[] | select(.status.phase!="Running") | .metadata.name' | wc -l)

            if [ "$FAILING_PODS" -gt 0 ]; then
              echo "::error::$FAILING_PODS pods are failing!"
              exit 1
            fi

            echo "All pods healthy (check $i/12)..."
            sleep 10
          done

      - name: Scale down old deployment
        if: success()
        run: |
          if [ -n "${{ steps.colors.outputs.CURRENT_COLOR }}" ]; then
            kubectl scale deployment unified-health-api-${{ steps.colors.outputs.CURRENT_COLOR }} \
              -n unified-health-prod \
              --replicas=0 || echo "Old deployment not found"
          fi

    outputs:
      new_color: ${{ steps.colors.outputs.NEW_COLOR }}
      current_color: ${{ steps.colors.outputs.CURRENT_COLOR }}

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [backup-database, deploy-blue-green]
    if: failure()
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER }} \
            --overwrite-existing

      - name: Rollback Kubernetes deployment
        run: |
          chmod +x scripts/rollback.sh
          SKIP_CONFIRMATION=true ./scripts/rollback.sh production

      - name: Restore database
        run: |
          chmod +x scripts/db-restore.sh
          SKIP_CONFIRMATION=true ./scripts/db-restore.sh ${{ needs.backup-database.outputs.backup_name }} production

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [deploy-blue-green, rollback]
    if: always()

    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.deploy-blue-green.result }}" == "success" ]; then
            echo "STATUS=SUCCESS" >> $GITHUB_OUTPUT
            echo "COLOR=good" >> $GITHUB_OUTPUT
          else
            echo "STATUS=FAILED" >> $GITHUB_OUTPUT
            echo "COLOR=danger" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "Production Deployment ${{ steps.status.outputs.STATUS }}",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.COLOR }}",
                  "fields": [
                    {
                      "title": "Environment",
                      "value": "production",
                      "short": true
                    },
                    {
                      "title": "Version",
                      "value": "${{ inputs.version }}",
                      "short": true
                    },
                    {
                      "title": "Deployment Color",
                      "value": "${{ needs.deploy-blue-green.outputs.new_color }}",
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    },
                    {
                      "title": "Status",
                      "value": "${{ steps.status.outputs.STATUS }}",
                      "short": false
                    }
                  ],
                  "actions": [
                    {
                      "type": "button",
                      "text": "View Workflow",
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Send email notification
        if: steps.status.outputs.STATUS == 'FAILED'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "Production Deployment Failed - ${{ inputs.version }}"
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          from: UnifiedHealth Platform
          body: |
            Production deployment has failed.

            Version: ${{ inputs.version }}
            Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            Please investigate immediately.
