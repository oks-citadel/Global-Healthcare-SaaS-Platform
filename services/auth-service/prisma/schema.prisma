// Authentication Service Database Schema
generator client {
  output = "./../src/generated/client"
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// User & Authentication
// ==========================================

model User {
  id            String     @id @default(uuid())
  email         String     @unique
  passwordHash  String
  firstName     String
  lastName      String
  phone         String?
  dateOfBirth   DateTime?
  role          Role       @default(patient)
  status        UserStatus @default(active)
  emailVerified Boolean    @default(false)

  // Account security
  failedLoginAttempts Int      @default(0)
  lockedUntil         DateTime?
  lastLoginAt         DateTime?
  lastLoginIp         String?

  // MFA (Multi-Factor Authentication)
  mfaEnabled          Boolean   @default(false)
  mfaSecret           String?   // Encrypted TOTP secret
  mfaBackupCodes      String[]  // Encrypted backup codes (array of hashed codes)
  mfaVerifiedAt       DateTime? // When MFA was first verified/enabled

  // Relations
  refreshTokens       RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]
  socialAccounts      SocialAccount[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([role])
  @@index([status])
  @@index([emailVerified])
  @@index([lockedUntil])
  @@index([mfaEnabled])
}

enum Role {
  patient
  provider
  admin
}

enum UserStatus {
  active
  inactive
  pending
  suspended
}

// ==========================================
// Refresh Tokens (Token Rotation)
// ==========================================

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Token rotation tracking
  tokenFamily String   // Same family for rotated tokens
  isRevoked   Boolean  @default(false)

  // Metadata
  userAgent   String?
  ipAddress   String?

  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([tokenFamily])
  @@index([expiresAt])
  @@index([userId, isRevoked])
}

// ==========================================
// Password Reset
// ==========================================

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  isUsed    Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ==========================================
// Email Verification
// ==========================================

model EmailVerificationToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  isUsed    Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ==========================================
// MFA Session Tokens
// ==========================================

model MfaToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String

  // Metadata
  ipAddress String?
  userAgent String?

  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ==========================================
// Social Accounts (OAuth2 Integration)
// ==========================================

model SocialAccount {
  id          String   @id @default(uuid())
  provider    String   // OAuth provider name (google, facebook, apple, microsoft, etc.)
  providerId  String   // Unique ID from the OAuth provider
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // OAuth tokens (encrypted)
  accessToken  String?
  refreshToken String?
  tokenExpiry  DateTime?

  // Profile data from provider
  email        String?
  displayName  String?
  avatarUrl    String?
  profileData  Json?    // Additional provider-specific profile data

  linkedAt    DateTime @default(now())
  lastUsedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Unique constraint: one provider account per user
  @@unique([provider, providerId])
  @@unique([provider, userId])
  @@index([userId])
  @@index([provider])
  @@index([providerId])
  @@index([linkedAt])
}

// ==========================================
// OAuth State (CSRF Protection)
// ==========================================

model OAuthState {
  id          String   @id @default(uuid())
  state       String   @unique   // Random state parameter for CSRF protection
  provider    String              // OAuth provider (google, facebook, apple)

  // For account linking (optional - set when linking to existing user)
  userId      String?

  // Return URL after OAuth callback
  redirectUrl String?

  // Additional data to pass through the OAuth flow
  metadata    Json?

  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([state])
  @@index([expiresAt])
}

// ==========================================
// Audit Log (Security Events)
// ==========================================

model AuditLog {
  id          String   @id @default(uuid())
  userId      String?
  action      String   // login, logout, password_change, mfa_enable, social_link, etc.
  resource    String?  // The resource being accessed/modified
  resourceId  String?

  // Request metadata
  ipAddress   String?
  userAgent   String?
  sessionId   String?

  // Result
  success     Boolean  @default(true)
  failureReason String?

  // Additional context
  metadata    Json?

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@index([success])
  @@index([userId, action])
}
