
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model Assessment
 * 
 */
export type Assessment = $Result.DefaultSelection<Prisma.$AssessmentPayload>
/**
 * Model QuestionnaireTemplate
 * 
 */
export type QuestionnaireTemplate = $Result.DefaultSelection<Prisma.$QuestionnaireTemplatePayload>
/**
 * Model QuestionnaireResponse
 * 
 */
export type QuestionnaireResponse = $Result.DefaultSelection<Prisma.$QuestionnaireResponsePayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model ContractAmendment
 * 
 */
export type ContractAmendment = $Result.DefaultSelection<Prisma.$ContractAmendmentPayload>
/**
 * Model ContractRenewal
 * 
 */
export type ContractRenewal = $Result.DefaultSelection<Prisma.$ContractRenewalPayload>
/**
 * Model Certification
 * 
 */
export type Certification = $Result.DefaultSelection<Prisma.$CertificationPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model RemediationTask
 * 
 */
export type RemediationTask = $Result.DefaultSelection<Prisma.$RemediationTaskPayload>
/**
 * Model VendorAuditLog
 * 
 */
export type VendorAuditLog = $Result.DefaultSelection<Prisma.$VendorAuditLogPayload>
/**
 * Model RiskScoringCriteria
 * 
 */
export type RiskScoringCriteria = $Result.DefaultSelection<Prisma.$RiskScoringCriteriaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const VendorCategory: {
  CLOUD_HOSTING: 'CLOUD_HOSTING',
  SOFTWARE_SAAS: 'SOFTWARE_SAAS',
  DATA_ANALYTICS: 'DATA_ANALYTICS',
  IT_SERVICES: 'IT_SERVICES',
  CONSULTING: 'CONSULTING',
  MEDICAL_DEVICES: 'MEDICAL_DEVICES',
  LABORATORY: 'LABORATORY',
  PHARMACY: 'PHARMACY',
  BILLING: 'BILLING',
  CLEARINGHOUSE: 'CLEARINGHOUSE',
  STORAGE_BACKUP: 'STORAGE_BACKUP',
  NETWORK_SECURITY: 'NETWORK_SECURITY',
  TELECOMMUNICATIONS: 'TELECOMMUNICATIONS',
  STAFFING: 'STAFFING',
  OTHER: 'OTHER'
};

export type VendorCategory = (typeof VendorCategory)[keyof typeof VendorCategory]


export const VendorTier: {
  TIER_1: 'TIER_1',
  TIER_2: 'TIER_2',
  TIER_3: 'TIER_3',
  TIER_4: 'TIER_4'
};

export type VendorTier = (typeof VendorTier)[keyof typeof VendorTier]


export const VendorStatus: {
  PENDING: 'PENDING',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  CONDITIONAL: 'CONDITIONAL',
  SUSPENDED: 'SUSPENDED',
  TERMINATED: 'TERMINATED',
  ARCHIVED: 'ARCHIVED'
};

export type VendorStatus = (typeof VendorStatus)[keyof typeof VendorStatus]


export const RiskLevel: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW',
  MINIMAL: 'MINIMAL',
  UNKNOWN: 'UNKNOWN'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]


export const DataAccessLevel: {
  NONE: 'NONE',
  MINIMAL: 'MINIMAL',
  LIMITED: 'LIMITED',
  MODERATE: 'MODERATE',
  EXTENSIVE: 'EXTENSIVE',
  FULL: 'FULL'
};

export type DataAccessLevel = (typeof DataAccessLevel)[keyof typeof DataAccessLevel]


export const AssessmentType: {
  INITIAL_ONBOARDING: 'INITIAL_ONBOARDING',
  ANNUAL_REVIEW: 'ANNUAL_REVIEW',
  AD_HOC: 'AD_HOC',
  SIG_CORE: 'SIG_CORE',
  SIG_LITE: 'SIG_LITE',
  CAIQ: 'CAIQ',
  HECVAT: 'HECVAT',
  VSAQ: 'VSAQ',
  CUSTOM: 'CUSTOM'
};

export type AssessmentType = (typeof AssessmentType)[keyof typeof AssessmentType]


export const AssessmentStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type AssessmentStatus = (typeof AssessmentStatus)[keyof typeof AssessmentStatus]


export const QuestionnaireType: {
  SIG_CORE: 'SIG_CORE',
  SIG_LITE: 'SIG_LITE',
  CAIQ: 'CAIQ',
  HECVAT: 'HECVAT',
  VSAQ: 'VSAQ',
  CUSTOM: 'CUSTOM'
};

export type QuestionnaireType = (typeof QuestionnaireType)[keyof typeof QuestionnaireType]


export const QuestionnaireStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type QuestionnaireStatus = (typeof QuestionnaireStatus)[keyof typeof QuestionnaireStatus]


export const ContractType: {
  BAA: 'BAA',
  MSA: 'MSA',
  SLA: 'SLA',
  NDA: 'NDA',
  DPA: 'DPA',
  SOW: 'SOW',
  AMENDMENT: 'AMENDMENT',
  OTHER: 'OTHER'
};

export type ContractType = (typeof ContractType)[keyof typeof ContractType]


export const ContractStatus: {
  DRAFT: 'DRAFT',
  PENDING_SIGNATURE: 'PENDING_SIGNATURE',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  TERMINATED: 'TERMINATED',
  RENEWED: 'RENEWED',
  SUSPENDED: 'SUSPENDED'
};

export type ContractStatus = (typeof ContractStatus)[keyof typeof ContractStatus]


export const CertificationType: {
  SOC_2_TYPE_1: 'SOC_2_TYPE_1',
  SOC_2_TYPE_2: 'SOC_2_TYPE_2',
  SOC_1: 'SOC_1',
  HITRUST: 'HITRUST',
  ISO_27001: 'ISO_27001',
  ISO_27017: 'ISO_27017',
  ISO_27018: 'ISO_27018',
  PCI_DSS: 'PCI_DSS',
  HIPAA_ATTESTATION: 'HIPAA_ATTESTATION',
  FedRAMP: 'FedRAMP',
  StateRAMP: 'StateRAMP',
  CSA_STAR: 'CSA_STAR',
  NIST_CSF: 'NIST_CSF',
  OTHER: 'OTHER'
};

export type CertificationType = (typeof CertificationType)[keyof typeof CertificationType]


export const CertificationStatus: {
  PENDING: 'PENDING',
  VALID: 'VALID',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED',
  NOT_APPLICABLE: 'NOT_APPLICABLE'
};

export type CertificationStatus = (typeof CertificationStatus)[keyof typeof CertificationStatus]


export const IncidentType: {
  DATA_BREACH: 'DATA_BREACH',
  SECURITY_INCIDENT: 'SECURITY_INCIDENT',
  PRIVACY_VIOLATION: 'PRIVACY_VIOLATION',
  AVAILABILITY_ISSUE: 'AVAILABILITY_ISSUE',
  COMPLIANCE_VIOLATION: 'COMPLIANCE_VIOLATION',
  UNAUTHORIZED_ACCESS: 'UNAUTHORIZED_ACCESS',
  MALWARE: 'MALWARE',
  PHISHING: 'PHISHING',
  INSIDER_THREAT: 'INSIDER_THREAT',
  PHYSICAL_SECURITY: 'PHYSICAL_SECURITY',
  OTHER: 'OTHER'
};

export type IncidentType = (typeof IncidentType)[keyof typeof IncidentType]


export const IncidentSeverity: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type IncidentSeverity = (typeof IncidentSeverity)[keyof typeof IncidentSeverity]


export const IncidentStatus: {
  OPEN: 'OPEN',
  INVESTIGATING: 'INVESTIGATING',
  CONTAINED: 'CONTAINED',
  REMEDIATED: 'REMEDIATED',
  CLOSED: 'CLOSED',
  MONITORING: 'MONITORING'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const RemediationType: {
  CONTROL_GAP: 'CONTROL_GAP',
  ASSESSMENT_FINDING: 'ASSESSMENT_FINDING',
  INCIDENT_RESPONSE: 'INCIDENT_RESPONSE',
  CERTIFICATION_REQUIREMENT: 'CERTIFICATION_REQUIREMENT',
  CONTRACT_REQUIREMENT: 'CONTRACT_REQUIREMENT',
  POLICY_UPDATE: 'POLICY_UPDATE',
  TRAINING: 'TRAINING',
  TECHNICAL_FIX: 'TECHNICAL_FIX',
  PROCESS_IMPROVEMENT: 'PROCESS_IMPROVEMENT',
  OTHER: 'OTHER'
};

export type RemediationType = (typeof RemediationType)[keyof typeof RemediationType]


export const TaskPriority: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const TaskStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  PENDING_VERIFICATION: 'PENDING_VERIFICATION',
  COMPLETED: 'COMPLETED',
  DEFERRED: 'DEFERRED',
  CANCELLED: 'CANCELLED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]

}

export type VendorCategory = $Enums.VendorCategory

export const VendorCategory: typeof $Enums.VendorCategory

export type VendorTier = $Enums.VendorTier

export const VendorTier: typeof $Enums.VendorTier

export type VendorStatus = $Enums.VendorStatus

export const VendorStatus: typeof $Enums.VendorStatus

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

export type DataAccessLevel = $Enums.DataAccessLevel

export const DataAccessLevel: typeof $Enums.DataAccessLevel

export type AssessmentType = $Enums.AssessmentType

export const AssessmentType: typeof $Enums.AssessmentType

export type AssessmentStatus = $Enums.AssessmentStatus

export const AssessmentStatus: typeof $Enums.AssessmentStatus

export type QuestionnaireType = $Enums.QuestionnaireType

export const QuestionnaireType: typeof $Enums.QuestionnaireType

export type QuestionnaireStatus = $Enums.QuestionnaireStatus

export const QuestionnaireStatus: typeof $Enums.QuestionnaireStatus

export type ContractType = $Enums.ContractType

export const ContractType: typeof $Enums.ContractType

export type ContractStatus = $Enums.ContractStatus

export const ContractStatus: typeof $Enums.ContractStatus

export type CertificationType = $Enums.CertificationType

export const CertificationType: typeof $Enums.CertificationType

export type CertificationStatus = $Enums.CertificationStatus

export const CertificationStatus: typeof $Enums.CertificationStatus

export type IncidentType = $Enums.IncidentType

export const IncidentType: typeof $Enums.IncidentType

export type IncidentSeverity = $Enums.IncidentSeverity

export const IncidentSeverity: typeof $Enums.IncidentSeverity

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type RemediationType = $Enums.RemediationType

export const RemediationType: typeof $Enums.RemediationType

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Vendors
 * const vendors = await prisma.vendor.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Vendors
   * const vendors = await prisma.vendor.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs>;

  /**
   * `prisma.assessment`: Exposes CRUD operations for the **Assessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assessments
    * const assessments = await prisma.assessment.findMany()
    * ```
    */
  get assessment(): Prisma.AssessmentDelegate<ExtArgs>;

  /**
   * `prisma.questionnaireTemplate`: Exposes CRUD operations for the **QuestionnaireTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionnaireTemplates
    * const questionnaireTemplates = await prisma.questionnaireTemplate.findMany()
    * ```
    */
  get questionnaireTemplate(): Prisma.QuestionnaireTemplateDelegate<ExtArgs>;

  /**
   * `prisma.questionnaireResponse`: Exposes CRUD operations for the **QuestionnaireResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionnaireResponses
    * const questionnaireResponses = await prisma.questionnaireResponse.findMany()
    * ```
    */
  get questionnaireResponse(): Prisma.QuestionnaireResponseDelegate<ExtArgs>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs>;

  /**
   * `prisma.contractAmendment`: Exposes CRUD operations for the **ContractAmendment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractAmendments
    * const contractAmendments = await prisma.contractAmendment.findMany()
    * ```
    */
  get contractAmendment(): Prisma.ContractAmendmentDelegate<ExtArgs>;

  /**
   * `prisma.contractRenewal`: Exposes CRUD operations for the **ContractRenewal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractRenewals
    * const contractRenewals = await prisma.contractRenewal.findMany()
    * ```
    */
  get contractRenewal(): Prisma.ContractRenewalDelegate<ExtArgs>;

  /**
   * `prisma.certification`: Exposes CRUD operations for the **Certification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certification.findMany()
    * ```
    */
  get certification(): Prisma.CertificationDelegate<ExtArgs>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs>;

  /**
   * `prisma.remediationTask`: Exposes CRUD operations for the **RemediationTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RemediationTasks
    * const remediationTasks = await prisma.remediationTask.findMany()
    * ```
    */
  get remediationTask(): Prisma.RemediationTaskDelegate<ExtArgs>;

  /**
   * `prisma.vendorAuditLog`: Exposes CRUD operations for the **VendorAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorAuditLogs
    * const vendorAuditLogs = await prisma.vendorAuditLog.findMany()
    * ```
    */
  get vendorAuditLog(): Prisma.VendorAuditLogDelegate<ExtArgs>;

  /**
   * `prisma.riskScoringCriteria`: Exposes CRUD operations for the **RiskScoringCriteria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskScoringCriteria
    * const riskScoringCriteria = await prisma.riskScoringCriteria.findMany()
    * ```
    */
  get riskScoringCriteria(): Prisma.RiskScoringCriteriaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Vendor: 'Vendor',
    Assessment: 'Assessment',
    QuestionnaireTemplate: 'QuestionnaireTemplate',
    QuestionnaireResponse: 'QuestionnaireResponse',
    Contract: 'Contract',
    ContractAmendment: 'ContractAmendment',
    ContractRenewal: 'ContractRenewal',
    Certification: 'Certification',
    Incident: 'Incident',
    RemediationTask: 'RemediationTask',
    VendorAuditLog: 'VendorAuditLog',
    RiskScoringCriteria: 'RiskScoringCriteria'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "vendor" | "assessment" | "questionnaireTemplate" | "questionnaireResponse" | "contract" | "contractAmendment" | "contractRenewal" | "certification" | "incident" | "remediationTask" | "vendorAuditLog" | "riskScoringCriteria"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Assessment: {
        payload: Prisma.$AssessmentPayload<ExtArgs>
        fields: Prisma.AssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findFirst: {
            args: Prisma.AssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findMany: {
            args: Prisma.AssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          create: {
            args: Prisma.AssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          createMany: {
            args: Prisma.AssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          delete: {
            args: Prisma.AssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          update: {
            args: Prisma.AssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          aggregate: {
            args: Prisma.AssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessment>
          }
          groupBy: {
            args: Prisma.AssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentCountAggregateOutputType> | number
          }
        }
      }
      QuestionnaireTemplate: {
        payload: Prisma.$QuestionnaireTemplatePayload<ExtArgs>
        fields: Prisma.QuestionnaireTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionnaireTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionnaireTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>
          }
          findFirst: {
            args: Prisma.QuestionnaireTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionnaireTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>
          }
          findMany: {
            args: Prisma.QuestionnaireTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>[]
          }
          create: {
            args: Prisma.QuestionnaireTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>
          }
          createMany: {
            args: Prisma.QuestionnaireTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionnaireTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>[]
          }
          delete: {
            args: Prisma.QuestionnaireTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>
          }
          update: {
            args: Prisma.QuestionnaireTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>
          }
          deleteMany: {
            args: Prisma.QuestionnaireTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionnaireTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionnaireTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireTemplatePayload>
          }
          aggregate: {
            args: Prisma.QuestionnaireTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaireTemplate>
          }
          groupBy: {
            args: Prisma.QuestionnaireTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionnaireTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireTemplateCountAggregateOutputType> | number
          }
        }
      }
      QuestionnaireResponse: {
        payload: Prisma.$QuestionnaireResponsePayload<ExtArgs>
        fields: Prisma.QuestionnaireResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionnaireResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionnaireResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>
          }
          findFirst: {
            args: Prisma.QuestionnaireResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionnaireResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>
          }
          findMany: {
            args: Prisma.QuestionnaireResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>[]
          }
          create: {
            args: Prisma.QuestionnaireResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>
          }
          createMany: {
            args: Prisma.QuestionnaireResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionnaireResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>[]
          }
          delete: {
            args: Prisma.QuestionnaireResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>
          }
          update: {
            args: Prisma.QuestionnaireResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>
          }
          deleteMany: {
            args: Prisma.QuestionnaireResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionnaireResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionnaireResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireResponsePayload>
          }
          aggregate: {
            args: Prisma.QuestionnaireResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaireResponse>
          }
          groupBy: {
            args: Prisma.QuestionnaireResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionnaireResponseCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireResponseCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      ContractAmendment: {
        payload: Prisma.$ContractAmendmentPayload<ExtArgs>
        fields: Prisma.ContractAmendmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractAmendmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractAmendmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>
          }
          findFirst: {
            args: Prisma.ContractAmendmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractAmendmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>
          }
          findMany: {
            args: Prisma.ContractAmendmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>[]
          }
          create: {
            args: Prisma.ContractAmendmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>
          }
          createMany: {
            args: Prisma.ContractAmendmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractAmendmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>[]
          }
          delete: {
            args: Prisma.ContractAmendmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>
          }
          update: {
            args: Prisma.ContractAmendmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>
          }
          deleteMany: {
            args: Prisma.ContractAmendmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractAmendmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractAmendmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractAmendmentPayload>
          }
          aggregate: {
            args: Prisma.ContractAmendmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractAmendment>
          }
          groupBy: {
            args: Prisma.ContractAmendmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractAmendmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractAmendmentCountArgs<ExtArgs>
            result: $Utils.Optional<ContractAmendmentCountAggregateOutputType> | number
          }
        }
      }
      ContractRenewal: {
        payload: Prisma.$ContractRenewalPayload<ExtArgs>
        fields: Prisma.ContractRenewalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractRenewalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractRenewalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>
          }
          findFirst: {
            args: Prisma.ContractRenewalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractRenewalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>
          }
          findMany: {
            args: Prisma.ContractRenewalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>[]
          }
          create: {
            args: Prisma.ContractRenewalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>
          }
          createMany: {
            args: Prisma.ContractRenewalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractRenewalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>[]
          }
          delete: {
            args: Prisma.ContractRenewalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>
          }
          update: {
            args: Prisma.ContractRenewalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>
          }
          deleteMany: {
            args: Prisma.ContractRenewalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractRenewalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractRenewalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractRenewalPayload>
          }
          aggregate: {
            args: Prisma.ContractRenewalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractRenewal>
          }
          groupBy: {
            args: Prisma.ContractRenewalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractRenewalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractRenewalCountArgs<ExtArgs>
            result: $Utils.Optional<ContractRenewalCountAggregateOutputType> | number
          }
        }
      }
      Certification: {
        payload: Prisma.$CertificationPayload<ExtArgs>
        fields: Prisma.CertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findFirst: {
            args: Prisma.CertificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findMany: {
            args: Prisma.CertificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          create: {
            args: Prisma.CertificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          createMany: {
            args: Prisma.CertificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          delete: {
            args: Prisma.CertificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          update: {
            args: Prisma.CertificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          deleteMany: {
            args: Prisma.CertificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          aggregate: {
            args: Prisma.CertificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertification>
          }
          groupBy: {
            args: Prisma.CertificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      RemediationTask: {
        payload: Prisma.$RemediationTaskPayload<ExtArgs>
        fields: Prisma.RemediationTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RemediationTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RemediationTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>
          }
          findFirst: {
            args: Prisma.RemediationTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RemediationTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>
          }
          findMany: {
            args: Prisma.RemediationTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>[]
          }
          create: {
            args: Prisma.RemediationTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>
          }
          createMany: {
            args: Prisma.RemediationTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RemediationTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>[]
          }
          delete: {
            args: Prisma.RemediationTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>
          }
          update: {
            args: Prisma.RemediationTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>
          }
          deleteMany: {
            args: Prisma.RemediationTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RemediationTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RemediationTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemediationTaskPayload>
          }
          aggregate: {
            args: Prisma.RemediationTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRemediationTask>
          }
          groupBy: {
            args: Prisma.RemediationTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemediationTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.RemediationTaskCountArgs<ExtArgs>
            result: $Utils.Optional<RemediationTaskCountAggregateOutputType> | number
          }
        }
      }
      VendorAuditLog: {
        payload: Prisma.$VendorAuditLogPayload<ExtArgs>
        fields: Prisma.VendorAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>
          }
          findFirst: {
            args: Prisma.VendorAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>
          }
          findMany: {
            args: Prisma.VendorAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>[]
          }
          create: {
            args: Prisma.VendorAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>
          }
          createMany: {
            args: Prisma.VendorAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>[]
          }
          delete: {
            args: Prisma.VendorAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>
          }
          update: {
            args: Prisma.VendorAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.VendorAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAuditLogPayload>
          }
          aggregate: {
            args: Prisma.VendorAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorAuditLog>
          }
          groupBy: {
            args: Prisma.VendorAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<VendorAuditLogCountAggregateOutputType> | number
          }
        }
      }
      RiskScoringCriteria: {
        payload: Prisma.$RiskScoringCriteriaPayload<ExtArgs>
        fields: Prisma.RiskScoringCriteriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskScoringCriteriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskScoringCriteriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>
          }
          findFirst: {
            args: Prisma.RiskScoringCriteriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskScoringCriteriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>
          }
          findMany: {
            args: Prisma.RiskScoringCriteriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>[]
          }
          create: {
            args: Prisma.RiskScoringCriteriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>
          }
          createMany: {
            args: Prisma.RiskScoringCriteriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskScoringCriteriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>[]
          }
          delete: {
            args: Prisma.RiskScoringCriteriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>
          }
          update: {
            args: Prisma.RiskScoringCriteriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>
          }
          deleteMany: {
            args: Prisma.RiskScoringCriteriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskScoringCriteriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskScoringCriteriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScoringCriteriaPayload>
          }
          aggregate: {
            args: Prisma.RiskScoringCriteriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskScoringCriteria>
          }
          groupBy: {
            args: Prisma.RiskScoringCriteriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskScoringCriteriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskScoringCriteriaCountArgs<ExtArgs>
            result: $Utils.Optional<RiskScoringCriteriaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    assessments: number
    contracts: number
    certifications: number
    incidents: number
    remediations: number
    questionnaires: number
    auditLogs: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessments?: boolean | VendorCountOutputTypeCountAssessmentsArgs
    contracts?: boolean | VendorCountOutputTypeCountContractsArgs
    certifications?: boolean | VendorCountOutputTypeCountCertificationsArgs
    incidents?: boolean | VendorCountOutputTypeCountIncidentsArgs
    remediations?: boolean | VendorCountOutputTypeCountRemediationsArgs
    questionnaires?: boolean | VendorCountOutputTypeCountQuestionnairesArgs
    auditLogs?: boolean | VendorCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountRemediationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemediationTaskWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountQuestionnairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireResponseWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorAuditLogWhereInput
  }


  /**
   * Count Type QuestionnaireTemplateCountOutputType
   */

  export type QuestionnaireTemplateCountOutputType = {
    responses: number
  }

  export type QuestionnaireTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | QuestionnaireTemplateCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * QuestionnaireTemplateCountOutputType without action
   */
  export type QuestionnaireTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplateCountOutputType
     */
    select?: QuestionnaireTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionnaireTemplateCountOutputType without action
   */
  export type QuestionnaireTemplateCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireResponseWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    amendments: number
    renewalHistory: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    amendments?: boolean | ContractCountOutputTypeCountAmendmentsArgs
    renewalHistory?: boolean | ContractCountOutputTypeCountRenewalHistoryArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountAmendmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractAmendmentWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountRenewalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractRenewalWhereInput
  }


  /**
   * Count Type IncidentCountOutputType
   */

  export type IncidentCountOutputType = {
    remediations: number
  }

  export type IncidentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    remediations?: boolean | IncidentCountOutputTypeCountRemediationsArgs
  }

  // Custom InputTypes
  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCountOutputType
     */
    select?: IncidentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountRemediationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemediationTaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type VendorSumAggregateOutputType = {
    riskScore: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    dbaName: string | null
    taxId: string | null
    dunsNumber: string | null
    website: string | null
    description: string | null
    category: $Enums.VendorCategory | null
    tier: $Enums.VendorTier | null
    status: $Enums.VendorStatus | null
    riskScore: number | null
    riskLevel: $Enums.RiskLevel | null
    primaryContactName: string | null
    primaryContactEmail: string | null
    primaryContactPhone: string | null
    dataAccessLevel: $Enums.DataAccessLevel | null
    phiAccess: boolean | null
    piiAccess: boolean | null
    onboardingDate: Date | null
    lastReviewDate: Date | null
    nextReviewDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    dbaName: string | null
    taxId: string | null
    dunsNumber: string | null
    website: string | null
    description: string | null
    category: $Enums.VendorCategory | null
    tier: $Enums.VendorTier | null
    status: $Enums.VendorStatus | null
    riskScore: number | null
    riskLevel: $Enums.RiskLevel | null
    primaryContactName: string | null
    primaryContactEmail: string | null
    primaryContactPhone: string | null
    dataAccessLevel: $Enums.DataAccessLevel | null
    phiAccess: boolean | null
    piiAccess: boolean | null
    onboardingDate: Date | null
    lastReviewDate: Date | null
    nextReviewDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    legalName: number
    dbaName: number
    taxId: number
    dunsNumber: number
    website: number
    description: number
    category: number
    tier: number
    status: number
    riskScore: number
    riskLevel: number
    primaryContactName: number
    primaryContactEmail: number
    primaryContactPhone: number
    address: number
    dataAccessLevel: number
    phiAccess: number
    piiAccess: number
    onboardingDate: number
    lastReviewDate: number
    nextReviewDate: number
    notes: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    riskScore?: true
  }

  export type VendorSumAggregateInputType = {
    riskScore?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    dbaName?: true
    taxId?: true
    dunsNumber?: true
    website?: true
    description?: true
    category?: true
    tier?: true
    status?: true
    riskScore?: true
    riskLevel?: true
    primaryContactName?: true
    primaryContactEmail?: true
    primaryContactPhone?: true
    dataAccessLevel?: true
    phiAccess?: true
    piiAccess?: true
    onboardingDate?: true
    lastReviewDate?: true
    nextReviewDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    dbaName?: true
    taxId?: true
    dunsNumber?: true
    website?: true
    description?: true
    category?: true
    tier?: true
    status?: true
    riskScore?: true
    riskLevel?: true
    primaryContactName?: true
    primaryContactEmail?: true
    primaryContactPhone?: true
    dataAccessLevel?: true
    phiAccess?: true
    piiAccess?: true
    onboardingDate?: true
    lastReviewDate?: true
    nextReviewDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    dbaName?: true
    taxId?: true
    dunsNumber?: true
    website?: true
    description?: true
    category?: true
    tier?: true
    status?: true
    riskScore?: true
    riskLevel?: true
    primaryContactName?: true
    primaryContactEmail?: true
    primaryContactPhone?: true
    address?: true
    dataAccessLevel?: true
    phiAccess?: true
    piiAccess?: true
    onboardingDate?: true
    lastReviewDate?: true
    nextReviewDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    name: string
    legalName: string | null
    dbaName: string | null
    taxId: string | null
    dunsNumber: string | null
    website: string | null
    description: string | null
    category: $Enums.VendorCategory
    tier: $Enums.VendorTier
    status: $Enums.VendorStatus
    riskScore: number
    riskLevel: $Enums.RiskLevel
    primaryContactName: string | null
    primaryContactEmail: string | null
    primaryContactPhone: string | null
    address: JsonValue | null
    dataAccessLevel: $Enums.DataAccessLevel
    phiAccess: boolean
    piiAccess: boolean
    onboardingDate: Date | null
    lastReviewDate: Date | null
    nextReviewDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    dbaName?: boolean
    taxId?: boolean
    dunsNumber?: boolean
    website?: boolean
    description?: boolean
    category?: boolean
    tier?: boolean
    status?: boolean
    riskScore?: boolean
    riskLevel?: boolean
    primaryContactName?: boolean
    primaryContactEmail?: boolean
    primaryContactPhone?: boolean
    address?: boolean
    dataAccessLevel?: boolean
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: boolean
    lastReviewDate?: boolean
    nextReviewDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    assessments?: boolean | Vendor$assessmentsArgs<ExtArgs>
    contracts?: boolean | Vendor$contractsArgs<ExtArgs>
    certifications?: boolean | Vendor$certificationsArgs<ExtArgs>
    incidents?: boolean | Vendor$incidentsArgs<ExtArgs>
    remediations?: boolean | Vendor$remediationsArgs<ExtArgs>
    questionnaires?: boolean | Vendor$questionnairesArgs<ExtArgs>
    auditLogs?: boolean | Vendor$auditLogsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    dbaName?: boolean
    taxId?: boolean
    dunsNumber?: boolean
    website?: boolean
    description?: boolean
    category?: boolean
    tier?: boolean
    status?: boolean
    riskScore?: boolean
    riskLevel?: boolean
    primaryContactName?: boolean
    primaryContactEmail?: boolean
    primaryContactPhone?: boolean
    address?: boolean
    dataAccessLevel?: boolean
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: boolean
    lastReviewDate?: boolean
    nextReviewDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    legalName?: boolean
    dbaName?: boolean
    taxId?: boolean
    dunsNumber?: boolean
    website?: boolean
    description?: boolean
    category?: boolean
    tier?: boolean
    status?: boolean
    riskScore?: boolean
    riskLevel?: boolean
    primaryContactName?: boolean
    primaryContactEmail?: boolean
    primaryContactPhone?: boolean
    address?: boolean
    dataAccessLevel?: boolean
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: boolean
    lastReviewDate?: boolean
    nextReviewDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessments?: boolean | Vendor$assessmentsArgs<ExtArgs>
    contracts?: boolean | Vendor$contractsArgs<ExtArgs>
    certifications?: boolean | Vendor$certificationsArgs<ExtArgs>
    incidents?: boolean | Vendor$incidentsArgs<ExtArgs>
    remediations?: boolean | Vendor$remediationsArgs<ExtArgs>
    questionnaires?: boolean | Vendor$questionnairesArgs<ExtArgs>
    auditLogs?: boolean | Vendor$auditLogsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      assessments: Prisma.$AssessmentPayload<ExtArgs>[]
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      remediations: Prisma.$RemediationTaskPayload<ExtArgs>[]
      questionnaires: Prisma.$QuestionnaireResponsePayload<ExtArgs>[]
      auditLogs: Prisma.$VendorAuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      legalName: string | null
      dbaName: string | null
      taxId: string | null
      dunsNumber: string | null
      website: string | null
      description: string | null
      category: $Enums.VendorCategory
      tier: $Enums.VendorTier
      status: $Enums.VendorStatus
      riskScore: number
      riskLevel: $Enums.RiskLevel
      primaryContactName: string | null
      primaryContactEmail: string | null
      primaryContactPhone: string | null
      address: Prisma.JsonValue | null
      dataAccessLevel: $Enums.DataAccessLevel
      phiAccess: boolean
      piiAccess: boolean
      onboardingDate: Date | null
      lastReviewDate: Date | null
      nextReviewDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assessments<T extends Vendor$assessmentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$assessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    contracts<T extends Vendor$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    certifications<T extends Vendor$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany"> | Null>
    incidents<T extends Vendor$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    remediations<T extends Vendor$remediationsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$remediationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "findMany"> | Null>
    questionnaires<T extends Vendor$questionnairesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$questionnairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Vendor$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */ 
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly legalName: FieldRef<"Vendor", 'String'>
    readonly dbaName: FieldRef<"Vendor", 'String'>
    readonly taxId: FieldRef<"Vendor", 'String'>
    readonly dunsNumber: FieldRef<"Vendor", 'String'>
    readonly website: FieldRef<"Vendor", 'String'>
    readonly description: FieldRef<"Vendor", 'String'>
    readonly category: FieldRef<"Vendor", 'VendorCategory'>
    readonly tier: FieldRef<"Vendor", 'VendorTier'>
    readonly status: FieldRef<"Vendor", 'VendorStatus'>
    readonly riskScore: FieldRef<"Vendor", 'Int'>
    readonly riskLevel: FieldRef<"Vendor", 'RiskLevel'>
    readonly primaryContactName: FieldRef<"Vendor", 'String'>
    readonly primaryContactEmail: FieldRef<"Vendor", 'String'>
    readonly primaryContactPhone: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'Json'>
    readonly dataAccessLevel: FieldRef<"Vendor", 'DataAccessLevel'>
    readonly phiAccess: FieldRef<"Vendor", 'Boolean'>
    readonly piiAccess: FieldRef<"Vendor", 'Boolean'>
    readonly onboardingDate: FieldRef<"Vendor", 'DateTime'>
    readonly lastReviewDate: FieldRef<"Vendor", 'DateTime'>
    readonly nextReviewDate: FieldRef<"Vendor", 'DateTime'>
    readonly notes: FieldRef<"Vendor", 'String'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
    readonly createdBy: FieldRef<"Vendor", 'String'>
    readonly updatedBy: FieldRef<"Vendor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor.assessments
   */
  export type Vendor$assessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    cursor?: AssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Vendor.contracts
   */
  export type Vendor$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Vendor.certifications
   */
  export type Vendor$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Vendor.incidents
   */
  export type Vendor$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Vendor.remediations
   */
  export type Vendor$remediationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    where?: RemediationTaskWhereInput
    orderBy?: RemediationTaskOrderByWithRelationInput | RemediationTaskOrderByWithRelationInput[]
    cursor?: RemediationTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemediationTaskScalarFieldEnum | RemediationTaskScalarFieldEnum[]
  }

  /**
   * Vendor.questionnaires
   */
  export type Vendor$questionnairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    where?: QuestionnaireResponseWhereInput
    orderBy?: QuestionnaireResponseOrderByWithRelationInput | QuestionnaireResponseOrderByWithRelationInput[]
    cursor?: QuestionnaireResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionnaireResponseScalarFieldEnum | QuestionnaireResponseScalarFieldEnum[]
  }

  /**
   * Vendor.auditLogs
   */
  export type Vendor$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    where?: VendorAuditLogWhereInput
    orderBy?: VendorAuditLogOrderByWithRelationInput | VendorAuditLogOrderByWithRelationInput[]
    cursor?: VendorAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorAuditLogScalarFieldEnum | VendorAuditLogScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model Assessment
   */

  export type AggregateAssessment = {
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  export type AssessmentAvgAggregateOutputType = {
    score: number | null
    maxScore: number | null
    passThreshold: number | null
  }

  export type AssessmentSumAggregateOutputType = {
    score: number | null
    maxScore: number | null
    passThreshold: number | null
  }

  export type AssessmentMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.AssessmentType | null
    status: $Enums.AssessmentStatus | null
    dueDate: Date | null
    completedDate: Date | null
    score: number | null
    maxScore: number | null
    passThreshold: number | null
    passed: boolean | null
    reviewer: string | null
    reviewerEmail: string | null
    recommendations: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type AssessmentMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.AssessmentType | null
    status: $Enums.AssessmentStatus | null
    dueDate: Date | null
    completedDate: Date | null
    score: number | null
    maxScore: number | null
    passThreshold: number | null
    passed: boolean | null
    reviewer: string | null
    reviewerEmail: string | null
    recommendations: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type AssessmentCountAggregateOutputType = {
    id: number
    vendorId: number
    type: number
    status: number
    dueDate: number
    completedDate: number
    score: number
    maxScore: number
    passThreshold: number
    passed: number
    reviewer: number
    reviewerEmail: number
    findings: number
    recommendations: number
    attachments: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type AssessmentAvgAggregateInputType = {
    score?: true
    maxScore?: true
    passThreshold?: true
  }

  export type AssessmentSumAggregateInputType = {
    score?: true
    maxScore?: true
    passThreshold?: true
  }

  export type AssessmentMinAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    status?: true
    dueDate?: true
    completedDate?: true
    score?: true
    maxScore?: true
    passThreshold?: true
    passed?: true
    reviewer?: true
    reviewerEmail?: true
    recommendations?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type AssessmentMaxAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    status?: true
    dueDate?: true
    completedDate?: true
    score?: true
    maxScore?: true
    passThreshold?: true
    passed?: true
    reviewer?: true
    reviewerEmail?: true
    recommendations?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type AssessmentCountAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    status?: true
    dueDate?: true
    completedDate?: true
    score?: true
    maxScore?: true
    passThreshold?: true
    passed?: true
    reviewer?: true
    reviewerEmail?: true
    findings?: true
    recommendations?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type AssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessment to aggregate.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assessments
    **/
    _count?: true | AssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentMaxAggregateInputType
  }

  export type GetAssessmentAggregateType<T extends AssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessment[P]>
      : GetScalarType<T[P], AggregateAssessment[P]>
  }




  export type AssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithAggregationInput | AssessmentOrderByWithAggregationInput[]
    by: AssessmentScalarFieldEnum[] | AssessmentScalarFieldEnum
    having?: AssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentCountAggregateInputType | true
    _avg?: AssessmentAvgAggregateInputType
    _sum?: AssessmentSumAggregateInputType
    _min?: AssessmentMinAggregateInputType
    _max?: AssessmentMaxAggregateInputType
  }

  export type AssessmentGroupByOutputType = {
    id: string
    vendorId: string
    type: $Enums.AssessmentType
    status: $Enums.AssessmentStatus
    dueDate: Date | null
    completedDate: Date | null
    score: number | null
    maxScore: number | null
    passThreshold: number | null
    passed: boolean | null
    reviewer: string | null
    reviewerEmail: string | null
    findings: JsonValue | null
    recommendations: string | null
    attachments: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  type GetAssessmentGroupByPayload<T extends AssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    score?: boolean
    maxScore?: boolean
    passThreshold?: boolean
    passed?: boolean
    reviewer?: boolean
    reviewerEmail?: boolean
    findings?: boolean
    recommendations?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    score?: boolean
    maxScore?: boolean
    passThreshold?: boolean
    passed?: boolean
    reviewer?: boolean
    reviewerEmail?: boolean
    findings?: boolean
    recommendations?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectScalar = {
    id?: boolean
    vendorId?: boolean
    type?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    score?: boolean
    maxScore?: boolean
    passThreshold?: boolean
    passed?: boolean
    reviewer?: boolean
    reviewerEmail?: boolean
    findings?: boolean
    recommendations?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type AssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type AssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $AssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assessment"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      type: $Enums.AssessmentType
      status: $Enums.AssessmentStatus
      dueDate: Date | null
      completedDate: Date | null
      score: number | null
      maxScore: number | null
      passThreshold: number | null
      passed: boolean | null
      reviewer: string | null
      reviewerEmail: string | null
      findings: Prisma.JsonValue | null
      recommendations: string | null
      attachments: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["assessment"]>
    composites: {}
  }

  type AssessmentGetPayload<S extends boolean | null | undefined | AssessmentDefaultArgs> = $Result.GetResult<Prisma.$AssessmentPayload, S>

  type AssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentCountAggregateInputType | true
    }

  export interface AssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assessment'], meta: { name: 'Assessment' } }
    /**
     * Find zero or one Assessment that matches the filter.
     * @param {AssessmentFindUniqueArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentFindUniqueArgs>(args: SelectSubset<T, AssessmentFindUniqueArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Assessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentFindUniqueOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Assessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentFindFirstArgs>(args?: SelectSubset<T, AssessmentFindFirstArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Assessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessment.findMany()
     * 
     * // Get first 10 Assessments
     * const assessments = await prisma.assessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentWithIdOnly = await prisma.assessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentFindManyArgs>(args?: SelectSubset<T, AssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Assessment.
     * @param {AssessmentCreateArgs} args - Arguments to create a Assessment.
     * @example
     * // Create one Assessment
     * const Assessment = await prisma.assessment.create({
     *   data: {
     *     // ... data to create a Assessment
     *   }
     * })
     * 
     */
    create<T extends AssessmentCreateArgs>(args: SelectSubset<T, AssessmentCreateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assessments.
     * @param {AssessmentCreateManyArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentCreateManyArgs>(args?: SelectSubset<T, AssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assessments and returns the data saved in the database.
     * @param {AssessmentCreateManyAndReturnArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assessments and only return the `id`
     * const assessmentWithIdOnly = await prisma.assessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Assessment.
     * @param {AssessmentDeleteArgs} args - Arguments to delete one Assessment.
     * @example
     * // Delete one Assessment
     * const Assessment = await prisma.assessment.delete({
     *   where: {
     *     // ... filter to delete one Assessment
     *   }
     * })
     * 
     */
    delete<T extends AssessmentDeleteArgs>(args: SelectSubset<T, AssessmentDeleteArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Assessment.
     * @param {AssessmentUpdateArgs} args - Arguments to update one Assessment.
     * @example
     * // Update one Assessment
     * const assessment = await prisma.assessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentUpdateArgs>(args: SelectSubset<T, AssessmentUpdateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assessments.
     * @param {AssessmentDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentDeleteManyArgs>(args?: SelectSubset<T, AssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentUpdateManyArgs>(args: SelectSubset<T, AssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assessment.
     * @param {AssessmentUpsertArgs} args - Arguments to update or create a Assessment.
     * @example
     * // Update or create a Assessment
     * const assessment = await prisma.assessment.upsert({
     *   create: {
     *     // ... data to create a Assessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessment we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentUpsertArgs>(args: SelectSubset<T, AssessmentUpsertArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessment.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
    **/
    count<T extends AssessmentCountArgs>(
      args?: Subset<T, AssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentAggregateArgs>(args: Subset<T, AssessmentAggregateArgs>): Prisma.PrismaPromise<GetAssessmentAggregateType<T>>

    /**
     * Group by Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assessment model
   */
  readonly fields: AssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assessment model
   */ 
  interface AssessmentFieldRefs {
    readonly id: FieldRef<"Assessment", 'String'>
    readonly vendorId: FieldRef<"Assessment", 'String'>
    readonly type: FieldRef<"Assessment", 'AssessmentType'>
    readonly status: FieldRef<"Assessment", 'AssessmentStatus'>
    readonly dueDate: FieldRef<"Assessment", 'DateTime'>
    readonly completedDate: FieldRef<"Assessment", 'DateTime'>
    readonly score: FieldRef<"Assessment", 'Int'>
    readonly maxScore: FieldRef<"Assessment", 'Int'>
    readonly passThreshold: FieldRef<"Assessment", 'Int'>
    readonly passed: FieldRef<"Assessment", 'Boolean'>
    readonly reviewer: FieldRef<"Assessment", 'String'>
    readonly reviewerEmail: FieldRef<"Assessment", 'String'>
    readonly findings: FieldRef<"Assessment", 'Json'>
    readonly recommendations: FieldRef<"Assessment", 'String'>
    readonly attachments: FieldRef<"Assessment", 'Json'>
    readonly createdAt: FieldRef<"Assessment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assessment", 'DateTime'>
    readonly createdBy: FieldRef<"Assessment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Assessment findUnique
   */
  export type AssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findUniqueOrThrow
   */
  export type AssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findFirst
   */
  export type AssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findFirstOrThrow
   */
  export type AssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findMany
   */
  export type AssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment create
   */
  export type AssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assessment.
     */
    data: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
  }

  /**
   * Assessment createMany
   */
  export type AssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assessment createManyAndReturn
   */
  export type AssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assessment update
   */
  export type AssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assessment.
     */
    data: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
    /**
     * Choose, which Assessment to update.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment updateMany
   */
  export type AssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentWhereInput
  }

  /**
   * Assessment upsert
   */
  export type AssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assessment to update in case it exists.
     */
    where: AssessmentWhereUniqueInput
    /**
     * In case the Assessment found by the `where` argument doesn't exist, create a new Assessment with this data.
     */
    create: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
    /**
     * In case the Assessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
  }

  /**
   * Assessment delete
   */
  export type AssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter which Assessment to delete.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment deleteMany
   */
  export type AssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessments to delete
     */
    where?: AssessmentWhereInput
  }

  /**
   * Assessment without action
   */
  export type AssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
  }


  /**
   * Model QuestionnaireTemplate
   */

  export type AggregateQuestionnaireTemplate = {
    _count: QuestionnaireTemplateCountAggregateOutputType | null
    _avg: QuestionnaireTemplateAvgAggregateOutputType | null
    _sum: QuestionnaireTemplateSumAggregateOutputType | null
    _min: QuestionnaireTemplateMinAggregateOutputType | null
    _max: QuestionnaireTemplateMaxAggregateOutputType | null
  }

  export type QuestionnaireTemplateAvgAggregateOutputType = {
    totalQuestions: number | null
  }

  export type QuestionnaireTemplateSumAggregateOutputType = {
    totalQuestions: number | null
  }

  export type QuestionnaireTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    type: $Enums.QuestionnaireType | null
    description: string | null
    totalQuestions: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    type: $Enums.QuestionnaireType | null
    description: string | null
    totalQuestions: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireTemplateCountAggregateOutputType = {
    id: number
    name: number
    version: number
    type: number
    description: number
    sections: number
    totalQuestions: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionnaireTemplateAvgAggregateInputType = {
    totalQuestions?: true
  }

  export type QuestionnaireTemplateSumAggregateInputType = {
    totalQuestions?: true
  }

  export type QuestionnaireTemplateMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    type?: true
    description?: true
    totalQuestions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    type?: true
    description?: true
    totalQuestions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireTemplateCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    type?: true
    description?: true
    sections?: true
    totalQuestions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionnaireTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireTemplate to aggregate.
     */
    where?: QuestionnaireTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireTemplates to fetch.
     */
    orderBy?: QuestionnaireTemplateOrderByWithRelationInput | QuestionnaireTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionnaireTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionnaireTemplates
    **/
    _count?: true | QuestionnaireTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionnaireTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionnaireTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnaireTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnaireTemplateMaxAggregateInputType
  }

  export type GetQuestionnaireTemplateAggregateType<T extends QuestionnaireTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaireTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaireTemplate[P]>
      : GetScalarType<T[P], AggregateQuestionnaireTemplate[P]>
  }




  export type QuestionnaireTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireTemplateWhereInput
    orderBy?: QuestionnaireTemplateOrderByWithAggregationInput | QuestionnaireTemplateOrderByWithAggregationInput[]
    by: QuestionnaireTemplateScalarFieldEnum[] | QuestionnaireTemplateScalarFieldEnum
    having?: QuestionnaireTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnaireTemplateCountAggregateInputType | true
    _avg?: QuestionnaireTemplateAvgAggregateInputType
    _sum?: QuestionnaireTemplateSumAggregateInputType
    _min?: QuestionnaireTemplateMinAggregateInputType
    _max?: QuestionnaireTemplateMaxAggregateInputType
  }

  export type QuestionnaireTemplateGroupByOutputType = {
    id: string
    name: string
    version: string
    type: $Enums.QuestionnaireType
    description: string | null
    sections: JsonValue
    totalQuestions: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: QuestionnaireTemplateCountAggregateOutputType | null
    _avg: QuestionnaireTemplateAvgAggregateOutputType | null
    _sum: QuestionnaireTemplateSumAggregateOutputType | null
    _min: QuestionnaireTemplateMinAggregateOutputType | null
    _max: QuestionnaireTemplateMaxAggregateOutputType | null
  }

  type GetQuestionnaireTemplateGroupByPayload<T extends QuestionnaireTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnaireTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnaireTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnaireTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnaireTemplateGroupByOutputType[P]>
        }
      >
    >


  export type QuestionnaireTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    type?: boolean
    description?: boolean
    sections?: boolean
    totalQuestions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responses?: boolean | QuestionnaireTemplate$responsesArgs<ExtArgs>
    _count?: boolean | QuestionnaireTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireTemplate"]>

  export type QuestionnaireTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    type?: boolean
    description?: boolean
    sections?: boolean
    totalQuestions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["questionnaireTemplate"]>

  export type QuestionnaireTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    type?: boolean
    description?: boolean
    sections?: boolean
    totalQuestions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionnaireTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | QuestionnaireTemplate$responsesArgs<ExtArgs>
    _count?: boolean | QuestionnaireTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionnaireTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuestionnaireTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionnaireTemplate"
    objects: {
      responses: Prisma.$QuestionnaireResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      version: string
      type: $Enums.QuestionnaireType
      description: string | null
      sections: Prisma.JsonValue
      totalQuestions: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionnaireTemplate"]>
    composites: {}
  }

  type QuestionnaireTemplateGetPayload<S extends boolean | null | undefined | QuestionnaireTemplateDefaultArgs> = $Result.GetResult<Prisma.$QuestionnaireTemplatePayload, S>

  type QuestionnaireTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionnaireTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionnaireTemplateCountAggregateInputType | true
    }

  export interface QuestionnaireTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionnaireTemplate'], meta: { name: 'QuestionnaireTemplate' } }
    /**
     * Find zero or one QuestionnaireTemplate that matches the filter.
     * @param {QuestionnaireTemplateFindUniqueArgs} args - Arguments to find a QuestionnaireTemplate
     * @example
     * // Get one QuestionnaireTemplate
     * const questionnaireTemplate = await prisma.questionnaireTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionnaireTemplateFindUniqueArgs>(args: SelectSubset<T, QuestionnaireTemplateFindUniqueArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionnaireTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionnaireTemplateFindUniqueOrThrowArgs} args - Arguments to find a QuestionnaireTemplate
     * @example
     * // Get one QuestionnaireTemplate
     * const questionnaireTemplate = await prisma.questionnaireTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionnaireTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionnaireTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionnaireTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireTemplateFindFirstArgs} args - Arguments to find a QuestionnaireTemplate
     * @example
     * // Get one QuestionnaireTemplate
     * const questionnaireTemplate = await prisma.questionnaireTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionnaireTemplateFindFirstArgs>(args?: SelectSubset<T, QuestionnaireTemplateFindFirstArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionnaireTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireTemplateFindFirstOrThrowArgs} args - Arguments to find a QuestionnaireTemplate
     * @example
     * // Get one QuestionnaireTemplate
     * const questionnaireTemplate = await prisma.questionnaireTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionnaireTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionnaireTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionnaireTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionnaireTemplates
     * const questionnaireTemplates = await prisma.questionnaireTemplate.findMany()
     * 
     * // Get first 10 QuestionnaireTemplates
     * const questionnaireTemplates = await prisma.questionnaireTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnaireTemplateWithIdOnly = await prisma.questionnaireTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionnaireTemplateFindManyArgs>(args?: SelectSubset<T, QuestionnaireTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionnaireTemplate.
     * @param {QuestionnaireTemplateCreateArgs} args - Arguments to create a QuestionnaireTemplate.
     * @example
     * // Create one QuestionnaireTemplate
     * const QuestionnaireTemplate = await prisma.questionnaireTemplate.create({
     *   data: {
     *     // ... data to create a QuestionnaireTemplate
     *   }
     * })
     * 
     */
    create<T extends QuestionnaireTemplateCreateArgs>(args: SelectSubset<T, QuestionnaireTemplateCreateArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionnaireTemplates.
     * @param {QuestionnaireTemplateCreateManyArgs} args - Arguments to create many QuestionnaireTemplates.
     * @example
     * // Create many QuestionnaireTemplates
     * const questionnaireTemplate = await prisma.questionnaireTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionnaireTemplateCreateManyArgs>(args?: SelectSubset<T, QuestionnaireTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionnaireTemplates and returns the data saved in the database.
     * @param {QuestionnaireTemplateCreateManyAndReturnArgs} args - Arguments to create many QuestionnaireTemplates.
     * @example
     * // Create many QuestionnaireTemplates
     * const questionnaireTemplate = await prisma.questionnaireTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionnaireTemplates and only return the `id`
     * const questionnaireTemplateWithIdOnly = await prisma.questionnaireTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionnaireTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionnaireTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionnaireTemplate.
     * @param {QuestionnaireTemplateDeleteArgs} args - Arguments to delete one QuestionnaireTemplate.
     * @example
     * // Delete one QuestionnaireTemplate
     * const QuestionnaireTemplate = await prisma.questionnaireTemplate.delete({
     *   where: {
     *     // ... filter to delete one QuestionnaireTemplate
     *   }
     * })
     * 
     */
    delete<T extends QuestionnaireTemplateDeleteArgs>(args: SelectSubset<T, QuestionnaireTemplateDeleteArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionnaireTemplate.
     * @param {QuestionnaireTemplateUpdateArgs} args - Arguments to update one QuestionnaireTemplate.
     * @example
     * // Update one QuestionnaireTemplate
     * const questionnaireTemplate = await prisma.questionnaireTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionnaireTemplateUpdateArgs>(args: SelectSubset<T, QuestionnaireTemplateUpdateArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionnaireTemplates.
     * @param {QuestionnaireTemplateDeleteManyArgs} args - Arguments to filter QuestionnaireTemplates to delete.
     * @example
     * // Delete a few QuestionnaireTemplates
     * const { count } = await prisma.questionnaireTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionnaireTemplateDeleteManyArgs>(args?: SelectSubset<T, QuestionnaireTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionnaireTemplates
     * const questionnaireTemplate = await prisma.questionnaireTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionnaireTemplateUpdateManyArgs>(args: SelectSubset<T, QuestionnaireTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionnaireTemplate.
     * @param {QuestionnaireTemplateUpsertArgs} args - Arguments to update or create a QuestionnaireTemplate.
     * @example
     * // Update or create a QuestionnaireTemplate
     * const questionnaireTemplate = await prisma.questionnaireTemplate.upsert({
     *   create: {
     *     // ... data to create a QuestionnaireTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionnaireTemplate we want to update
     *   }
     * })
     */
    upsert<T extends QuestionnaireTemplateUpsertArgs>(args: SelectSubset<T, QuestionnaireTemplateUpsertArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionnaireTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireTemplateCountArgs} args - Arguments to filter QuestionnaireTemplates to count.
     * @example
     * // Count the number of QuestionnaireTemplates
     * const count = await prisma.questionnaireTemplate.count({
     *   where: {
     *     // ... the filter for the QuestionnaireTemplates we want to count
     *   }
     * })
    **/
    count<T extends QuestionnaireTemplateCountArgs>(
      args?: Subset<T, QuestionnaireTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnaireTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionnaireTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnaireTemplateAggregateArgs>(args: Subset<T, QuestionnaireTemplateAggregateArgs>): Prisma.PrismaPromise<GetQuestionnaireTemplateAggregateType<T>>

    /**
     * Group by QuestionnaireTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionnaireTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionnaireTemplateGroupByArgs['orderBy'] }
        : { orderBy?: QuestionnaireTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionnaireTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnaireTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionnaireTemplate model
   */
  readonly fields: QuestionnaireTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionnaireTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionnaireTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responses<T extends QuestionnaireTemplate$responsesArgs<ExtArgs> = {}>(args?: Subset<T, QuestionnaireTemplate$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionnaireTemplate model
   */ 
  interface QuestionnaireTemplateFieldRefs {
    readonly id: FieldRef<"QuestionnaireTemplate", 'String'>
    readonly name: FieldRef<"QuestionnaireTemplate", 'String'>
    readonly version: FieldRef<"QuestionnaireTemplate", 'String'>
    readonly type: FieldRef<"QuestionnaireTemplate", 'QuestionnaireType'>
    readonly description: FieldRef<"QuestionnaireTemplate", 'String'>
    readonly sections: FieldRef<"QuestionnaireTemplate", 'Json'>
    readonly totalQuestions: FieldRef<"QuestionnaireTemplate", 'Int'>
    readonly isActive: FieldRef<"QuestionnaireTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"QuestionnaireTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionnaireTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionnaireTemplate findUnique
   */
  export type QuestionnaireTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireTemplate to fetch.
     */
    where: QuestionnaireTemplateWhereUniqueInput
  }

  /**
   * QuestionnaireTemplate findUniqueOrThrow
   */
  export type QuestionnaireTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireTemplate to fetch.
     */
    where: QuestionnaireTemplateWhereUniqueInput
  }

  /**
   * QuestionnaireTemplate findFirst
   */
  export type QuestionnaireTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireTemplate to fetch.
     */
    where?: QuestionnaireTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireTemplates to fetch.
     */
    orderBy?: QuestionnaireTemplateOrderByWithRelationInput | QuestionnaireTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireTemplates.
     */
    cursor?: QuestionnaireTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireTemplates.
     */
    distinct?: QuestionnaireTemplateScalarFieldEnum | QuestionnaireTemplateScalarFieldEnum[]
  }

  /**
   * QuestionnaireTemplate findFirstOrThrow
   */
  export type QuestionnaireTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireTemplate to fetch.
     */
    where?: QuestionnaireTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireTemplates to fetch.
     */
    orderBy?: QuestionnaireTemplateOrderByWithRelationInput | QuestionnaireTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireTemplates.
     */
    cursor?: QuestionnaireTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireTemplates.
     */
    distinct?: QuestionnaireTemplateScalarFieldEnum | QuestionnaireTemplateScalarFieldEnum[]
  }

  /**
   * QuestionnaireTemplate findMany
   */
  export type QuestionnaireTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireTemplates to fetch.
     */
    where?: QuestionnaireTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireTemplates to fetch.
     */
    orderBy?: QuestionnaireTemplateOrderByWithRelationInput | QuestionnaireTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionnaireTemplates.
     */
    cursor?: QuestionnaireTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireTemplates.
     */
    skip?: number
    distinct?: QuestionnaireTemplateScalarFieldEnum | QuestionnaireTemplateScalarFieldEnum[]
  }

  /**
   * QuestionnaireTemplate create
   */
  export type QuestionnaireTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionnaireTemplate.
     */
    data: XOR<QuestionnaireTemplateCreateInput, QuestionnaireTemplateUncheckedCreateInput>
  }

  /**
   * QuestionnaireTemplate createMany
   */
  export type QuestionnaireTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionnaireTemplates.
     */
    data: QuestionnaireTemplateCreateManyInput | QuestionnaireTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionnaireTemplate createManyAndReturn
   */
  export type QuestionnaireTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionnaireTemplates.
     */
    data: QuestionnaireTemplateCreateManyInput | QuestionnaireTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionnaireTemplate update
   */
  export type QuestionnaireTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionnaireTemplate.
     */
    data: XOR<QuestionnaireTemplateUpdateInput, QuestionnaireTemplateUncheckedUpdateInput>
    /**
     * Choose, which QuestionnaireTemplate to update.
     */
    where: QuestionnaireTemplateWhereUniqueInput
  }

  /**
   * QuestionnaireTemplate updateMany
   */
  export type QuestionnaireTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionnaireTemplates.
     */
    data: XOR<QuestionnaireTemplateUpdateManyMutationInput, QuestionnaireTemplateUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireTemplates to update
     */
    where?: QuestionnaireTemplateWhereInput
  }

  /**
   * QuestionnaireTemplate upsert
   */
  export type QuestionnaireTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionnaireTemplate to update in case it exists.
     */
    where: QuestionnaireTemplateWhereUniqueInput
    /**
     * In case the QuestionnaireTemplate found by the `where` argument doesn't exist, create a new QuestionnaireTemplate with this data.
     */
    create: XOR<QuestionnaireTemplateCreateInput, QuestionnaireTemplateUncheckedCreateInput>
    /**
     * In case the QuestionnaireTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionnaireTemplateUpdateInput, QuestionnaireTemplateUncheckedUpdateInput>
  }

  /**
   * QuestionnaireTemplate delete
   */
  export type QuestionnaireTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
    /**
     * Filter which QuestionnaireTemplate to delete.
     */
    where: QuestionnaireTemplateWhereUniqueInput
  }

  /**
   * QuestionnaireTemplate deleteMany
   */
  export type QuestionnaireTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireTemplates to delete
     */
    where?: QuestionnaireTemplateWhereInput
  }

  /**
   * QuestionnaireTemplate.responses
   */
  export type QuestionnaireTemplate$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    where?: QuestionnaireResponseWhereInput
    orderBy?: QuestionnaireResponseOrderByWithRelationInput | QuestionnaireResponseOrderByWithRelationInput[]
    cursor?: QuestionnaireResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionnaireResponseScalarFieldEnum | QuestionnaireResponseScalarFieldEnum[]
  }

  /**
   * QuestionnaireTemplate without action
   */
  export type QuestionnaireTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireTemplate
     */
    select?: QuestionnaireTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireTemplateInclude<ExtArgs> | null
  }


  /**
   * Model QuestionnaireResponse
   */

  export type AggregateQuestionnaireResponse = {
    _count: QuestionnaireResponseCountAggregateOutputType | null
    _avg: QuestionnaireResponseAvgAggregateOutputType | null
    _sum: QuestionnaireResponseSumAggregateOutputType | null
    _min: QuestionnaireResponseMinAggregateOutputType | null
    _max: QuestionnaireResponseMaxAggregateOutputType | null
  }

  export type QuestionnaireResponseAvgAggregateOutputType = {
    score: number | null
    maxScore: number | null
    percentComplete: number | null
  }

  export type QuestionnaireResponseSumAggregateOutputType = {
    score: number | null
    maxScore: number | null
    percentComplete: number | null
  }

  export type QuestionnaireResponseMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    templateId: string | null
    status: $Enums.QuestionnaireStatus | null
    score: number | null
    maxScore: number | null
    percentComplete: number | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireResponseMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    templateId: string | null
    status: $Enums.QuestionnaireStatus | null
    score: number | null
    maxScore: number | null
    percentComplete: number | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireResponseCountAggregateOutputType = {
    id: number
    vendorId: number
    templateId: number
    status: number
    responses: number
    score: number
    maxScore: number
    percentComplete: number
    submittedAt: number
    reviewedAt: number
    reviewedBy: number
    reviewNotes: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionnaireResponseAvgAggregateInputType = {
    score?: true
    maxScore?: true
    percentComplete?: true
  }

  export type QuestionnaireResponseSumAggregateInputType = {
    score?: true
    maxScore?: true
    percentComplete?: true
  }

  export type QuestionnaireResponseMinAggregateInputType = {
    id?: true
    vendorId?: true
    templateId?: true
    status?: true
    score?: true
    maxScore?: true
    percentComplete?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireResponseMaxAggregateInputType = {
    id?: true
    vendorId?: true
    templateId?: true
    status?: true
    score?: true
    maxScore?: true
    percentComplete?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireResponseCountAggregateInputType = {
    id?: true
    vendorId?: true
    templateId?: true
    status?: true
    responses?: true
    score?: true
    maxScore?: true
    percentComplete?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionnaireResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireResponse to aggregate.
     */
    where?: QuestionnaireResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireResponses to fetch.
     */
    orderBy?: QuestionnaireResponseOrderByWithRelationInput | QuestionnaireResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionnaireResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionnaireResponses
    **/
    _count?: true | QuestionnaireResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionnaireResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionnaireResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnaireResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnaireResponseMaxAggregateInputType
  }

  export type GetQuestionnaireResponseAggregateType<T extends QuestionnaireResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaireResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaireResponse[P]>
      : GetScalarType<T[P], AggregateQuestionnaireResponse[P]>
  }




  export type QuestionnaireResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireResponseWhereInput
    orderBy?: QuestionnaireResponseOrderByWithAggregationInput | QuestionnaireResponseOrderByWithAggregationInput[]
    by: QuestionnaireResponseScalarFieldEnum[] | QuestionnaireResponseScalarFieldEnum
    having?: QuestionnaireResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnaireResponseCountAggregateInputType | true
    _avg?: QuestionnaireResponseAvgAggregateInputType
    _sum?: QuestionnaireResponseSumAggregateInputType
    _min?: QuestionnaireResponseMinAggregateInputType
    _max?: QuestionnaireResponseMaxAggregateInputType
  }

  export type QuestionnaireResponseGroupByOutputType = {
    id: string
    vendorId: string
    templateId: string
    status: $Enums.QuestionnaireStatus
    responses: JsonValue | null
    score: number | null
    maxScore: number | null
    percentComplete: number
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: QuestionnaireResponseCountAggregateOutputType | null
    _avg: QuestionnaireResponseAvgAggregateOutputType | null
    _sum: QuestionnaireResponseSumAggregateOutputType | null
    _min: QuestionnaireResponseMinAggregateOutputType | null
    _max: QuestionnaireResponseMaxAggregateOutputType | null
  }

  type GetQuestionnaireResponseGroupByPayload<T extends QuestionnaireResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnaireResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnaireResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnaireResponseGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnaireResponseGroupByOutputType[P]>
        }
      >
    >


  export type QuestionnaireResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    templateId?: boolean
    status?: boolean
    responses?: boolean
    score?: boolean
    maxScore?: boolean
    percentComplete?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    template?: boolean | QuestionnaireTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireResponse"]>

  export type QuestionnaireResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    templateId?: boolean
    status?: boolean
    responses?: boolean
    score?: boolean
    maxScore?: boolean
    percentComplete?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    template?: boolean | QuestionnaireTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireResponse"]>

  export type QuestionnaireResponseSelectScalar = {
    id?: boolean
    vendorId?: boolean
    templateId?: boolean
    status?: boolean
    responses?: boolean
    score?: boolean
    maxScore?: boolean
    percentComplete?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionnaireResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    template?: boolean | QuestionnaireTemplateDefaultArgs<ExtArgs>
  }
  export type QuestionnaireResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    template?: boolean | QuestionnaireTemplateDefaultArgs<ExtArgs>
  }

  export type $QuestionnaireResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionnaireResponse"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      template: Prisma.$QuestionnaireTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      templateId: string
      status: $Enums.QuestionnaireStatus
      responses: Prisma.JsonValue | null
      score: number | null
      maxScore: number | null
      percentComplete: number
      submittedAt: Date | null
      reviewedAt: Date | null
      reviewedBy: string | null
      reviewNotes: string | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionnaireResponse"]>
    composites: {}
  }

  type QuestionnaireResponseGetPayload<S extends boolean | null | undefined | QuestionnaireResponseDefaultArgs> = $Result.GetResult<Prisma.$QuestionnaireResponsePayload, S>

  type QuestionnaireResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionnaireResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionnaireResponseCountAggregateInputType | true
    }

  export interface QuestionnaireResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionnaireResponse'], meta: { name: 'QuestionnaireResponse' } }
    /**
     * Find zero or one QuestionnaireResponse that matches the filter.
     * @param {QuestionnaireResponseFindUniqueArgs} args - Arguments to find a QuestionnaireResponse
     * @example
     * // Get one QuestionnaireResponse
     * const questionnaireResponse = await prisma.questionnaireResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionnaireResponseFindUniqueArgs>(args: SelectSubset<T, QuestionnaireResponseFindUniqueArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionnaireResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionnaireResponseFindUniqueOrThrowArgs} args - Arguments to find a QuestionnaireResponse
     * @example
     * // Get one QuestionnaireResponse
     * const questionnaireResponse = await prisma.questionnaireResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionnaireResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionnaireResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionnaireResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireResponseFindFirstArgs} args - Arguments to find a QuestionnaireResponse
     * @example
     * // Get one QuestionnaireResponse
     * const questionnaireResponse = await prisma.questionnaireResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionnaireResponseFindFirstArgs>(args?: SelectSubset<T, QuestionnaireResponseFindFirstArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionnaireResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireResponseFindFirstOrThrowArgs} args - Arguments to find a QuestionnaireResponse
     * @example
     * // Get one QuestionnaireResponse
     * const questionnaireResponse = await prisma.questionnaireResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionnaireResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionnaireResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionnaireResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionnaireResponses
     * const questionnaireResponses = await prisma.questionnaireResponse.findMany()
     * 
     * // Get first 10 QuestionnaireResponses
     * const questionnaireResponses = await prisma.questionnaireResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnaireResponseWithIdOnly = await prisma.questionnaireResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionnaireResponseFindManyArgs>(args?: SelectSubset<T, QuestionnaireResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionnaireResponse.
     * @param {QuestionnaireResponseCreateArgs} args - Arguments to create a QuestionnaireResponse.
     * @example
     * // Create one QuestionnaireResponse
     * const QuestionnaireResponse = await prisma.questionnaireResponse.create({
     *   data: {
     *     // ... data to create a QuestionnaireResponse
     *   }
     * })
     * 
     */
    create<T extends QuestionnaireResponseCreateArgs>(args: SelectSubset<T, QuestionnaireResponseCreateArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionnaireResponses.
     * @param {QuestionnaireResponseCreateManyArgs} args - Arguments to create many QuestionnaireResponses.
     * @example
     * // Create many QuestionnaireResponses
     * const questionnaireResponse = await prisma.questionnaireResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionnaireResponseCreateManyArgs>(args?: SelectSubset<T, QuestionnaireResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionnaireResponses and returns the data saved in the database.
     * @param {QuestionnaireResponseCreateManyAndReturnArgs} args - Arguments to create many QuestionnaireResponses.
     * @example
     * // Create many QuestionnaireResponses
     * const questionnaireResponse = await prisma.questionnaireResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionnaireResponses and only return the `id`
     * const questionnaireResponseWithIdOnly = await prisma.questionnaireResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionnaireResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionnaireResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionnaireResponse.
     * @param {QuestionnaireResponseDeleteArgs} args - Arguments to delete one QuestionnaireResponse.
     * @example
     * // Delete one QuestionnaireResponse
     * const QuestionnaireResponse = await prisma.questionnaireResponse.delete({
     *   where: {
     *     // ... filter to delete one QuestionnaireResponse
     *   }
     * })
     * 
     */
    delete<T extends QuestionnaireResponseDeleteArgs>(args: SelectSubset<T, QuestionnaireResponseDeleteArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionnaireResponse.
     * @param {QuestionnaireResponseUpdateArgs} args - Arguments to update one QuestionnaireResponse.
     * @example
     * // Update one QuestionnaireResponse
     * const questionnaireResponse = await prisma.questionnaireResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionnaireResponseUpdateArgs>(args: SelectSubset<T, QuestionnaireResponseUpdateArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionnaireResponses.
     * @param {QuestionnaireResponseDeleteManyArgs} args - Arguments to filter QuestionnaireResponses to delete.
     * @example
     * // Delete a few QuestionnaireResponses
     * const { count } = await prisma.questionnaireResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionnaireResponseDeleteManyArgs>(args?: SelectSubset<T, QuestionnaireResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionnaireResponses
     * const questionnaireResponse = await prisma.questionnaireResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionnaireResponseUpdateManyArgs>(args: SelectSubset<T, QuestionnaireResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionnaireResponse.
     * @param {QuestionnaireResponseUpsertArgs} args - Arguments to update or create a QuestionnaireResponse.
     * @example
     * // Update or create a QuestionnaireResponse
     * const questionnaireResponse = await prisma.questionnaireResponse.upsert({
     *   create: {
     *     // ... data to create a QuestionnaireResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionnaireResponse we want to update
     *   }
     * })
     */
    upsert<T extends QuestionnaireResponseUpsertArgs>(args: SelectSubset<T, QuestionnaireResponseUpsertArgs<ExtArgs>>): Prisma__QuestionnaireResponseClient<$Result.GetResult<Prisma.$QuestionnaireResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionnaireResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireResponseCountArgs} args - Arguments to filter QuestionnaireResponses to count.
     * @example
     * // Count the number of QuestionnaireResponses
     * const count = await prisma.questionnaireResponse.count({
     *   where: {
     *     // ... the filter for the QuestionnaireResponses we want to count
     *   }
     * })
    **/
    count<T extends QuestionnaireResponseCountArgs>(
      args?: Subset<T, QuestionnaireResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnaireResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionnaireResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnaireResponseAggregateArgs>(args: Subset<T, QuestionnaireResponseAggregateArgs>): Prisma.PrismaPromise<GetQuestionnaireResponseAggregateType<T>>

    /**
     * Group by QuestionnaireResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionnaireResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionnaireResponseGroupByArgs['orderBy'] }
        : { orderBy?: QuestionnaireResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionnaireResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnaireResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionnaireResponse model
   */
  readonly fields: QuestionnaireResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionnaireResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionnaireResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    template<T extends QuestionnaireTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionnaireTemplateDefaultArgs<ExtArgs>>): Prisma__QuestionnaireTemplateClient<$Result.GetResult<Prisma.$QuestionnaireTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionnaireResponse model
   */ 
  interface QuestionnaireResponseFieldRefs {
    readonly id: FieldRef<"QuestionnaireResponse", 'String'>
    readonly vendorId: FieldRef<"QuestionnaireResponse", 'String'>
    readonly templateId: FieldRef<"QuestionnaireResponse", 'String'>
    readonly status: FieldRef<"QuestionnaireResponse", 'QuestionnaireStatus'>
    readonly responses: FieldRef<"QuestionnaireResponse", 'Json'>
    readonly score: FieldRef<"QuestionnaireResponse", 'Int'>
    readonly maxScore: FieldRef<"QuestionnaireResponse", 'Int'>
    readonly percentComplete: FieldRef<"QuestionnaireResponse", 'Int'>
    readonly submittedAt: FieldRef<"QuestionnaireResponse", 'DateTime'>
    readonly reviewedAt: FieldRef<"QuestionnaireResponse", 'DateTime'>
    readonly reviewedBy: FieldRef<"QuestionnaireResponse", 'String'>
    readonly reviewNotes: FieldRef<"QuestionnaireResponse", 'String'>
    readonly expiresAt: FieldRef<"QuestionnaireResponse", 'DateTime'>
    readonly createdAt: FieldRef<"QuestionnaireResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionnaireResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionnaireResponse findUnique
   */
  export type QuestionnaireResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireResponse to fetch.
     */
    where: QuestionnaireResponseWhereUniqueInput
  }

  /**
   * QuestionnaireResponse findUniqueOrThrow
   */
  export type QuestionnaireResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireResponse to fetch.
     */
    where: QuestionnaireResponseWhereUniqueInput
  }

  /**
   * QuestionnaireResponse findFirst
   */
  export type QuestionnaireResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireResponse to fetch.
     */
    where?: QuestionnaireResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireResponses to fetch.
     */
    orderBy?: QuestionnaireResponseOrderByWithRelationInput | QuestionnaireResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireResponses.
     */
    cursor?: QuestionnaireResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireResponses.
     */
    distinct?: QuestionnaireResponseScalarFieldEnum | QuestionnaireResponseScalarFieldEnum[]
  }

  /**
   * QuestionnaireResponse findFirstOrThrow
   */
  export type QuestionnaireResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireResponse to fetch.
     */
    where?: QuestionnaireResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireResponses to fetch.
     */
    orderBy?: QuestionnaireResponseOrderByWithRelationInput | QuestionnaireResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireResponses.
     */
    cursor?: QuestionnaireResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireResponses.
     */
    distinct?: QuestionnaireResponseScalarFieldEnum | QuestionnaireResponseScalarFieldEnum[]
  }

  /**
   * QuestionnaireResponse findMany
   */
  export type QuestionnaireResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireResponses to fetch.
     */
    where?: QuestionnaireResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireResponses to fetch.
     */
    orderBy?: QuestionnaireResponseOrderByWithRelationInput | QuestionnaireResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionnaireResponses.
     */
    cursor?: QuestionnaireResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireResponses.
     */
    skip?: number
    distinct?: QuestionnaireResponseScalarFieldEnum | QuestionnaireResponseScalarFieldEnum[]
  }

  /**
   * QuestionnaireResponse create
   */
  export type QuestionnaireResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionnaireResponse.
     */
    data: XOR<QuestionnaireResponseCreateInput, QuestionnaireResponseUncheckedCreateInput>
  }

  /**
   * QuestionnaireResponse createMany
   */
  export type QuestionnaireResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionnaireResponses.
     */
    data: QuestionnaireResponseCreateManyInput | QuestionnaireResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionnaireResponse createManyAndReturn
   */
  export type QuestionnaireResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionnaireResponses.
     */
    data: QuestionnaireResponseCreateManyInput | QuestionnaireResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionnaireResponse update
   */
  export type QuestionnaireResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionnaireResponse.
     */
    data: XOR<QuestionnaireResponseUpdateInput, QuestionnaireResponseUncheckedUpdateInput>
    /**
     * Choose, which QuestionnaireResponse to update.
     */
    where: QuestionnaireResponseWhereUniqueInput
  }

  /**
   * QuestionnaireResponse updateMany
   */
  export type QuestionnaireResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionnaireResponses.
     */
    data: XOR<QuestionnaireResponseUpdateManyMutationInput, QuestionnaireResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireResponses to update
     */
    where?: QuestionnaireResponseWhereInput
  }

  /**
   * QuestionnaireResponse upsert
   */
  export type QuestionnaireResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionnaireResponse to update in case it exists.
     */
    where: QuestionnaireResponseWhereUniqueInput
    /**
     * In case the QuestionnaireResponse found by the `where` argument doesn't exist, create a new QuestionnaireResponse with this data.
     */
    create: XOR<QuestionnaireResponseCreateInput, QuestionnaireResponseUncheckedCreateInput>
    /**
     * In case the QuestionnaireResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionnaireResponseUpdateInput, QuestionnaireResponseUncheckedUpdateInput>
  }

  /**
   * QuestionnaireResponse delete
   */
  export type QuestionnaireResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
    /**
     * Filter which QuestionnaireResponse to delete.
     */
    where: QuestionnaireResponseWhereUniqueInput
  }

  /**
   * QuestionnaireResponse deleteMany
   */
  export type QuestionnaireResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireResponses to delete
     */
    where?: QuestionnaireResponseWhereInput
  }

  /**
   * QuestionnaireResponse without action
   */
  export type QuestionnaireResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireResponse
     */
    select?: QuestionnaireResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireResponseInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    renewalTermMonths: number | null
    terminationNoticeDays: number | null
    value: number | null
    dataRetentionDays: number | null
    liabilityLimit: number | null
    insuranceMinimum: number | null
  }

  export type ContractSumAggregateOutputType = {
    renewalTermMonths: number | null
    terminationNoticeDays: number | null
    value: number | null
    dataRetentionDays: number | null
    liabilityLimit: number | null
    insuranceMinimum: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    contractNumber: string | null
    type: $Enums.ContractType | null
    status: $Enums.ContractStatus | null
    title: string | null
    description: string | null
    effectiveDate: Date | null
    expirationDate: Date | null
    autoRenewal: boolean | null
    renewalTermMonths: number | null
    terminationNoticeDays: number | null
    value: number | null
    currency: string | null
    paymentTerms: string | null
    dataRetentionDays: number | null
    liabilityLimit: number | null
    indemnification: boolean | null
    insuranceRequired: boolean | null
    insuranceMinimum: number | null
    documentUrl: string | null
    signedDate: Date | null
    signedBy: string | null
    counterSignedDate: Date | null
    counterSignedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    contractNumber: string | null
    type: $Enums.ContractType | null
    status: $Enums.ContractStatus | null
    title: string | null
    description: string | null
    effectiveDate: Date | null
    expirationDate: Date | null
    autoRenewal: boolean | null
    renewalTermMonths: number | null
    terminationNoticeDays: number | null
    value: number | null
    currency: string | null
    paymentTerms: string | null
    dataRetentionDays: number | null
    liabilityLimit: number | null
    indemnification: boolean | null
    insuranceRequired: boolean | null
    insuranceMinimum: number | null
    documentUrl: string | null
    signedDate: Date | null
    signedBy: string | null
    counterSignedDate: Date | null
    counterSignedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    vendorId: number
    contractNumber: number
    type: number
    status: number
    title: number
    description: number
    effectiveDate: number
    expirationDate: number
    autoRenewal: number
    renewalTermMonths: number
    terminationNoticeDays: number
    value: number
    currency: number
    paymentTerms: number
    slaTerms: number
    securityRequirements: number
    dataRetentionDays: number
    liabilityLimit: number
    indemnification: number
    insuranceRequired: number
    insuranceMinimum: number
    documentUrl: number
    signedDate: number
    signedBy: number
    counterSignedDate: number
    counterSignedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    renewalTermMonths?: true
    terminationNoticeDays?: true
    value?: true
    dataRetentionDays?: true
    liabilityLimit?: true
    insuranceMinimum?: true
  }

  export type ContractSumAggregateInputType = {
    renewalTermMonths?: true
    terminationNoticeDays?: true
    value?: true
    dataRetentionDays?: true
    liabilityLimit?: true
    insuranceMinimum?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    vendorId?: true
    contractNumber?: true
    type?: true
    status?: true
    title?: true
    description?: true
    effectiveDate?: true
    expirationDate?: true
    autoRenewal?: true
    renewalTermMonths?: true
    terminationNoticeDays?: true
    value?: true
    currency?: true
    paymentTerms?: true
    dataRetentionDays?: true
    liabilityLimit?: true
    indemnification?: true
    insuranceRequired?: true
    insuranceMinimum?: true
    documentUrl?: true
    signedDate?: true
    signedBy?: true
    counterSignedDate?: true
    counterSignedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    vendorId?: true
    contractNumber?: true
    type?: true
    status?: true
    title?: true
    description?: true
    effectiveDate?: true
    expirationDate?: true
    autoRenewal?: true
    renewalTermMonths?: true
    terminationNoticeDays?: true
    value?: true
    currency?: true
    paymentTerms?: true
    dataRetentionDays?: true
    liabilityLimit?: true
    indemnification?: true
    insuranceRequired?: true
    insuranceMinimum?: true
    documentUrl?: true
    signedDate?: true
    signedBy?: true
    counterSignedDate?: true
    counterSignedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    vendorId?: true
    contractNumber?: true
    type?: true
    status?: true
    title?: true
    description?: true
    effectiveDate?: true
    expirationDate?: true
    autoRenewal?: true
    renewalTermMonths?: true
    terminationNoticeDays?: true
    value?: true
    currency?: true
    paymentTerms?: true
    slaTerms?: true
    securityRequirements?: true
    dataRetentionDays?: true
    liabilityLimit?: true
    indemnification?: true
    insuranceRequired?: true
    insuranceMinimum?: true
    documentUrl?: true
    signedDate?: true
    signedBy?: true
    counterSignedDate?: true
    counterSignedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    vendorId: string
    contractNumber: string | null
    type: $Enums.ContractType
    status: $Enums.ContractStatus
    title: string
    description: string | null
    effectiveDate: Date | null
    expirationDate: Date | null
    autoRenewal: boolean
    renewalTermMonths: number | null
    terminationNoticeDays: number | null
    value: number | null
    currency: string
    paymentTerms: string | null
    slaTerms: JsonValue | null
    securityRequirements: JsonValue | null
    dataRetentionDays: number | null
    liabilityLimit: number | null
    indemnification: boolean
    insuranceRequired: boolean
    insuranceMinimum: number | null
    documentUrl: string | null
    signedDate: Date | null
    signedBy: string | null
    counterSignedDate: Date | null
    counterSignedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    contractNumber?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    autoRenewal?: boolean
    renewalTermMonths?: boolean
    terminationNoticeDays?: boolean
    value?: boolean
    currency?: boolean
    paymentTerms?: boolean
    slaTerms?: boolean
    securityRequirements?: boolean
    dataRetentionDays?: boolean
    liabilityLimit?: boolean
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: boolean
    documentUrl?: boolean
    signedDate?: boolean
    signedBy?: boolean
    counterSignedDate?: boolean
    counterSignedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    amendments?: boolean | Contract$amendmentsArgs<ExtArgs>
    renewalHistory?: boolean | Contract$renewalHistoryArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    contractNumber?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    autoRenewal?: boolean
    renewalTermMonths?: boolean
    terminationNoticeDays?: boolean
    value?: boolean
    currency?: boolean
    paymentTerms?: boolean
    slaTerms?: boolean
    securityRequirements?: boolean
    dataRetentionDays?: boolean
    liabilityLimit?: boolean
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: boolean
    documentUrl?: boolean
    signedDate?: boolean
    signedBy?: boolean
    counterSignedDate?: boolean
    counterSignedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    vendorId?: boolean
    contractNumber?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    autoRenewal?: boolean
    renewalTermMonths?: boolean
    terminationNoticeDays?: boolean
    value?: boolean
    currency?: boolean
    paymentTerms?: boolean
    slaTerms?: boolean
    securityRequirements?: boolean
    dataRetentionDays?: boolean
    liabilityLimit?: boolean
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: boolean
    documentUrl?: boolean
    signedDate?: boolean
    signedBy?: boolean
    counterSignedDate?: boolean
    counterSignedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    amendments?: boolean | Contract$amendmentsArgs<ExtArgs>
    renewalHistory?: boolean | Contract$renewalHistoryArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      amendments: Prisma.$ContractAmendmentPayload<ExtArgs>[]
      renewalHistory: Prisma.$ContractRenewalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      contractNumber: string | null
      type: $Enums.ContractType
      status: $Enums.ContractStatus
      title: string
      description: string | null
      effectiveDate: Date | null
      expirationDate: Date | null
      autoRenewal: boolean
      renewalTermMonths: number | null
      terminationNoticeDays: number | null
      value: number | null
      currency: string
      paymentTerms: string | null
      slaTerms: Prisma.JsonValue | null
      securityRequirements: Prisma.JsonValue | null
      dataRetentionDays: number | null
      liabilityLimit: number | null
      indemnification: boolean
      insuranceRequired: boolean
      insuranceMinimum: number | null
      documentUrl: string | null
      signedDate: Date | null
      signedBy: string | null
      counterSignedDate: Date | null
      counterSignedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    amendments<T extends Contract$amendmentsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$amendmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "findMany"> | Null>
    renewalHistory<T extends Contract$renewalHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Contract$renewalHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly vendorId: FieldRef<"Contract", 'String'>
    readonly contractNumber: FieldRef<"Contract", 'String'>
    readonly type: FieldRef<"Contract", 'ContractType'>
    readonly status: FieldRef<"Contract", 'ContractStatus'>
    readonly title: FieldRef<"Contract", 'String'>
    readonly description: FieldRef<"Contract", 'String'>
    readonly effectiveDate: FieldRef<"Contract", 'DateTime'>
    readonly expirationDate: FieldRef<"Contract", 'DateTime'>
    readonly autoRenewal: FieldRef<"Contract", 'Boolean'>
    readonly renewalTermMonths: FieldRef<"Contract", 'Int'>
    readonly terminationNoticeDays: FieldRef<"Contract", 'Int'>
    readonly value: FieldRef<"Contract", 'Float'>
    readonly currency: FieldRef<"Contract", 'String'>
    readonly paymentTerms: FieldRef<"Contract", 'String'>
    readonly slaTerms: FieldRef<"Contract", 'Json'>
    readonly securityRequirements: FieldRef<"Contract", 'Json'>
    readonly dataRetentionDays: FieldRef<"Contract", 'Int'>
    readonly liabilityLimit: FieldRef<"Contract", 'Float'>
    readonly indemnification: FieldRef<"Contract", 'Boolean'>
    readonly insuranceRequired: FieldRef<"Contract", 'Boolean'>
    readonly insuranceMinimum: FieldRef<"Contract", 'Float'>
    readonly documentUrl: FieldRef<"Contract", 'String'>
    readonly signedDate: FieldRef<"Contract", 'DateTime'>
    readonly signedBy: FieldRef<"Contract", 'String'>
    readonly counterSignedDate: FieldRef<"Contract", 'DateTime'>
    readonly counterSignedBy: FieldRef<"Contract", 'String'>
    readonly notes: FieldRef<"Contract", 'String'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
    readonly createdBy: FieldRef<"Contract", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
  }

  /**
   * Contract.amendments
   */
  export type Contract$amendmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    where?: ContractAmendmentWhereInput
    orderBy?: ContractAmendmentOrderByWithRelationInput | ContractAmendmentOrderByWithRelationInput[]
    cursor?: ContractAmendmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractAmendmentScalarFieldEnum | ContractAmendmentScalarFieldEnum[]
  }

  /**
   * Contract.renewalHistory
   */
  export type Contract$renewalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    where?: ContractRenewalWhereInput
    orderBy?: ContractRenewalOrderByWithRelationInput | ContractRenewalOrderByWithRelationInput[]
    cursor?: ContractRenewalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractRenewalScalarFieldEnum | ContractRenewalScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model ContractAmendment
   */

  export type AggregateContractAmendment = {
    _count: ContractAmendmentCountAggregateOutputType | null
    _avg: ContractAmendmentAvgAggregateOutputType | null
    _sum: ContractAmendmentSumAggregateOutputType | null
    _min: ContractAmendmentMinAggregateOutputType | null
    _max: ContractAmendmentMaxAggregateOutputType | null
  }

  export type ContractAmendmentAvgAggregateOutputType = {
    amendmentNumber: number | null
  }

  export type ContractAmendmentSumAggregateOutputType = {
    amendmentNumber: number | null
  }

  export type ContractAmendmentMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    amendmentNumber: number | null
    title: string | null
    description: string | null
    effectiveDate: Date | null
    documentUrl: string | null
    signedDate: Date | null
    signedBy: string | null
    createdAt: Date | null
  }

  export type ContractAmendmentMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    amendmentNumber: number | null
    title: string | null
    description: string | null
    effectiveDate: Date | null
    documentUrl: string | null
    signedDate: Date | null
    signedBy: string | null
    createdAt: Date | null
  }

  export type ContractAmendmentCountAggregateOutputType = {
    id: number
    contractId: number
    amendmentNumber: number
    title: number
    description: number
    effectiveDate: number
    documentUrl: number
    signedDate: number
    signedBy: number
    createdAt: number
    _all: number
  }


  export type ContractAmendmentAvgAggregateInputType = {
    amendmentNumber?: true
  }

  export type ContractAmendmentSumAggregateInputType = {
    amendmentNumber?: true
  }

  export type ContractAmendmentMinAggregateInputType = {
    id?: true
    contractId?: true
    amendmentNumber?: true
    title?: true
    description?: true
    effectiveDate?: true
    documentUrl?: true
    signedDate?: true
    signedBy?: true
    createdAt?: true
  }

  export type ContractAmendmentMaxAggregateInputType = {
    id?: true
    contractId?: true
    amendmentNumber?: true
    title?: true
    description?: true
    effectiveDate?: true
    documentUrl?: true
    signedDate?: true
    signedBy?: true
    createdAt?: true
  }

  export type ContractAmendmentCountAggregateInputType = {
    id?: true
    contractId?: true
    amendmentNumber?: true
    title?: true
    description?: true
    effectiveDate?: true
    documentUrl?: true
    signedDate?: true
    signedBy?: true
    createdAt?: true
    _all?: true
  }

  export type ContractAmendmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractAmendment to aggregate.
     */
    where?: ContractAmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractAmendments to fetch.
     */
    orderBy?: ContractAmendmentOrderByWithRelationInput | ContractAmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractAmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractAmendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractAmendments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractAmendments
    **/
    _count?: true | ContractAmendmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAmendmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractAmendmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractAmendmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractAmendmentMaxAggregateInputType
  }

  export type GetContractAmendmentAggregateType<T extends ContractAmendmentAggregateArgs> = {
        [P in keyof T & keyof AggregateContractAmendment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractAmendment[P]>
      : GetScalarType<T[P], AggregateContractAmendment[P]>
  }




  export type ContractAmendmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractAmendmentWhereInput
    orderBy?: ContractAmendmentOrderByWithAggregationInput | ContractAmendmentOrderByWithAggregationInput[]
    by: ContractAmendmentScalarFieldEnum[] | ContractAmendmentScalarFieldEnum
    having?: ContractAmendmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractAmendmentCountAggregateInputType | true
    _avg?: ContractAmendmentAvgAggregateInputType
    _sum?: ContractAmendmentSumAggregateInputType
    _min?: ContractAmendmentMinAggregateInputType
    _max?: ContractAmendmentMaxAggregateInputType
  }

  export type ContractAmendmentGroupByOutputType = {
    id: string
    contractId: string
    amendmentNumber: number
    title: string
    description: string | null
    effectiveDate: Date
    documentUrl: string | null
    signedDate: Date | null
    signedBy: string | null
    createdAt: Date
    _count: ContractAmendmentCountAggregateOutputType | null
    _avg: ContractAmendmentAvgAggregateOutputType | null
    _sum: ContractAmendmentSumAggregateOutputType | null
    _min: ContractAmendmentMinAggregateOutputType | null
    _max: ContractAmendmentMaxAggregateOutputType | null
  }

  type GetContractAmendmentGroupByPayload<T extends ContractAmendmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractAmendmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractAmendmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractAmendmentGroupByOutputType[P]>
            : GetScalarType<T[P], ContractAmendmentGroupByOutputType[P]>
        }
      >
    >


  export type ContractAmendmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    amendmentNumber?: boolean
    title?: boolean
    description?: boolean
    effectiveDate?: boolean
    documentUrl?: boolean
    signedDate?: boolean
    signedBy?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractAmendment"]>

  export type ContractAmendmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    amendmentNumber?: boolean
    title?: boolean
    description?: boolean
    effectiveDate?: boolean
    documentUrl?: boolean
    signedDate?: boolean
    signedBy?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractAmendment"]>

  export type ContractAmendmentSelectScalar = {
    id?: boolean
    contractId?: boolean
    amendmentNumber?: boolean
    title?: boolean
    description?: boolean
    effectiveDate?: boolean
    documentUrl?: boolean
    signedDate?: boolean
    signedBy?: boolean
    createdAt?: boolean
  }

  export type ContractAmendmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type ContractAmendmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $ContractAmendmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractAmendment"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      amendmentNumber: number
      title: string
      description: string | null
      effectiveDate: Date
      documentUrl: string | null
      signedDate: Date | null
      signedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["contractAmendment"]>
    composites: {}
  }

  type ContractAmendmentGetPayload<S extends boolean | null | undefined | ContractAmendmentDefaultArgs> = $Result.GetResult<Prisma.$ContractAmendmentPayload, S>

  type ContractAmendmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractAmendmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractAmendmentCountAggregateInputType | true
    }

  export interface ContractAmendmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractAmendment'], meta: { name: 'ContractAmendment' } }
    /**
     * Find zero or one ContractAmendment that matches the filter.
     * @param {ContractAmendmentFindUniqueArgs} args - Arguments to find a ContractAmendment
     * @example
     * // Get one ContractAmendment
     * const contractAmendment = await prisma.contractAmendment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractAmendmentFindUniqueArgs>(args: SelectSubset<T, ContractAmendmentFindUniqueArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContractAmendment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractAmendmentFindUniqueOrThrowArgs} args - Arguments to find a ContractAmendment
     * @example
     * // Get one ContractAmendment
     * const contractAmendment = await prisma.contractAmendment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractAmendmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractAmendmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContractAmendment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAmendmentFindFirstArgs} args - Arguments to find a ContractAmendment
     * @example
     * // Get one ContractAmendment
     * const contractAmendment = await prisma.contractAmendment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractAmendmentFindFirstArgs>(args?: SelectSubset<T, ContractAmendmentFindFirstArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContractAmendment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAmendmentFindFirstOrThrowArgs} args - Arguments to find a ContractAmendment
     * @example
     * // Get one ContractAmendment
     * const contractAmendment = await prisma.contractAmendment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractAmendmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractAmendmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContractAmendments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAmendmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractAmendments
     * const contractAmendments = await prisma.contractAmendment.findMany()
     * 
     * // Get first 10 ContractAmendments
     * const contractAmendments = await prisma.contractAmendment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractAmendmentWithIdOnly = await prisma.contractAmendment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractAmendmentFindManyArgs>(args?: SelectSubset<T, ContractAmendmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContractAmendment.
     * @param {ContractAmendmentCreateArgs} args - Arguments to create a ContractAmendment.
     * @example
     * // Create one ContractAmendment
     * const ContractAmendment = await prisma.contractAmendment.create({
     *   data: {
     *     // ... data to create a ContractAmendment
     *   }
     * })
     * 
     */
    create<T extends ContractAmendmentCreateArgs>(args: SelectSubset<T, ContractAmendmentCreateArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContractAmendments.
     * @param {ContractAmendmentCreateManyArgs} args - Arguments to create many ContractAmendments.
     * @example
     * // Create many ContractAmendments
     * const contractAmendment = await prisma.contractAmendment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractAmendmentCreateManyArgs>(args?: SelectSubset<T, ContractAmendmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractAmendments and returns the data saved in the database.
     * @param {ContractAmendmentCreateManyAndReturnArgs} args - Arguments to create many ContractAmendments.
     * @example
     * // Create many ContractAmendments
     * const contractAmendment = await prisma.contractAmendment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractAmendments and only return the `id`
     * const contractAmendmentWithIdOnly = await prisma.contractAmendment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractAmendmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractAmendmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContractAmendment.
     * @param {ContractAmendmentDeleteArgs} args - Arguments to delete one ContractAmendment.
     * @example
     * // Delete one ContractAmendment
     * const ContractAmendment = await prisma.contractAmendment.delete({
     *   where: {
     *     // ... filter to delete one ContractAmendment
     *   }
     * })
     * 
     */
    delete<T extends ContractAmendmentDeleteArgs>(args: SelectSubset<T, ContractAmendmentDeleteArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContractAmendment.
     * @param {ContractAmendmentUpdateArgs} args - Arguments to update one ContractAmendment.
     * @example
     * // Update one ContractAmendment
     * const contractAmendment = await prisma.contractAmendment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractAmendmentUpdateArgs>(args: SelectSubset<T, ContractAmendmentUpdateArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContractAmendments.
     * @param {ContractAmendmentDeleteManyArgs} args - Arguments to filter ContractAmendments to delete.
     * @example
     * // Delete a few ContractAmendments
     * const { count } = await prisma.contractAmendment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractAmendmentDeleteManyArgs>(args?: SelectSubset<T, ContractAmendmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractAmendments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAmendmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractAmendments
     * const contractAmendment = await prisma.contractAmendment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractAmendmentUpdateManyArgs>(args: SelectSubset<T, ContractAmendmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractAmendment.
     * @param {ContractAmendmentUpsertArgs} args - Arguments to update or create a ContractAmendment.
     * @example
     * // Update or create a ContractAmendment
     * const contractAmendment = await prisma.contractAmendment.upsert({
     *   create: {
     *     // ... data to create a ContractAmendment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractAmendment we want to update
     *   }
     * })
     */
    upsert<T extends ContractAmendmentUpsertArgs>(args: SelectSubset<T, ContractAmendmentUpsertArgs<ExtArgs>>): Prisma__ContractAmendmentClient<$Result.GetResult<Prisma.$ContractAmendmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContractAmendments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAmendmentCountArgs} args - Arguments to filter ContractAmendments to count.
     * @example
     * // Count the number of ContractAmendments
     * const count = await prisma.contractAmendment.count({
     *   where: {
     *     // ... the filter for the ContractAmendments we want to count
     *   }
     * })
    **/
    count<T extends ContractAmendmentCountArgs>(
      args?: Subset<T, ContractAmendmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractAmendmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractAmendment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAmendmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAmendmentAggregateArgs>(args: Subset<T, ContractAmendmentAggregateArgs>): Prisma.PrismaPromise<GetContractAmendmentAggregateType<T>>

    /**
     * Group by ContractAmendment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAmendmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractAmendmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractAmendmentGroupByArgs['orderBy'] }
        : { orderBy?: ContractAmendmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractAmendmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractAmendmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractAmendment model
   */
  readonly fields: ContractAmendmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractAmendment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractAmendmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractAmendment model
   */ 
  interface ContractAmendmentFieldRefs {
    readonly id: FieldRef<"ContractAmendment", 'String'>
    readonly contractId: FieldRef<"ContractAmendment", 'String'>
    readonly amendmentNumber: FieldRef<"ContractAmendment", 'Int'>
    readonly title: FieldRef<"ContractAmendment", 'String'>
    readonly description: FieldRef<"ContractAmendment", 'String'>
    readonly effectiveDate: FieldRef<"ContractAmendment", 'DateTime'>
    readonly documentUrl: FieldRef<"ContractAmendment", 'String'>
    readonly signedDate: FieldRef<"ContractAmendment", 'DateTime'>
    readonly signedBy: FieldRef<"ContractAmendment", 'String'>
    readonly createdAt: FieldRef<"ContractAmendment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractAmendment findUnique
   */
  export type ContractAmendmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * Filter, which ContractAmendment to fetch.
     */
    where: ContractAmendmentWhereUniqueInput
  }

  /**
   * ContractAmendment findUniqueOrThrow
   */
  export type ContractAmendmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * Filter, which ContractAmendment to fetch.
     */
    where: ContractAmendmentWhereUniqueInput
  }

  /**
   * ContractAmendment findFirst
   */
  export type ContractAmendmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * Filter, which ContractAmendment to fetch.
     */
    where?: ContractAmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractAmendments to fetch.
     */
    orderBy?: ContractAmendmentOrderByWithRelationInput | ContractAmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractAmendments.
     */
    cursor?: ContractAmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractAmendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractAmendments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractAmendments.
     */
    distinct?: ContractAmendmentScalarFieldEnum | ContractAmendmentScalarFieldEnum[]
  }

  /**
   * ContractAmendment findFirstOrThrow
   */
  export type ContractAmendmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * Filter, which ContractAmendment to fetch.
     */
    where?: ContractAmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractAmendments to fetch.
     */
    orderBy?: ContractAmendmentOrderByWithRelationInput | ContractAmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractAmendments.
     */
    cursor?: ContractAmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractAmendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractAmendments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractAmendments.
     */
    distinct?: ContractAmendmentScalarFieldEnum | ContractAmendmentScalarFieldEnum[]
  }

  /**
   * ContractAmendment findMany
   */
  export type ContractAmendmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * Filter, which ContractAmendments to fetch.
     */
    where?: ContractAmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractAmendments to fetch.
     */
    orderBy?: ContractAmendmentOrderByWithRelationInput | ContractAmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractAmendments.
     */
    cursor?: ContractAmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractAmendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractAmendments.
     */
    skip?: number
    distinct?: ContractAmendmentScalarFieldEnum | ContractAmendmentScalarFieldEnum[]
  }

  /**
   * ContractAmendment create
   */
  export type ContractAmendmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractAmendment.
     */
    data: XOR<ContractAmendmentCreateInput, ContractAmendmentUncheckedCreateInput>
  }

  /**
   * ContractAmendment createMany
   */
  export type ContractAmendmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractAmendments.
     */
    data: ContractAmendmentCreateManyInput | ContractAmendmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractAmendment createManyAndReturn
   */
  export type ContractAmendmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContractAmendments.
     */
    data: ContractAmendmentCreateManyInput | ContractAmendmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractAmendment update
   */
  export type ContractAmendmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractAmendment.
     */
    data: XOR<ContractAmendmentUpdateInput, ContractAmendmentUncheckedUpdateInput>
    /**
     * Choose, which ContractAmendment to update.
     */
    where: ContractAmendmentWhereUniqueInput
  }

  /**
   * ContractAmendment updateMany
   */
  export type ContractAmendmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractAmendments.
     */
    data: XOR<ContractAmendmentUpdateManyMutationInput, ContractAmendmentUncheckedUpdateManyInput>
    /**
     * Filter which ContractAmendments to update
     */
    where?: ContractAmendmentWhereInput
  }

  /**
   * ContractAmendment upsert
   */
  export type ContractAmendmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractAmendment to update in case it exists.
     */
    where: ContractAmendmentWhereUniqueInput
    /**
     * In case the ContractAmendment found by the `where` argument doesn't exist, create a new ContractAmendment with this data.
     */
    create: XOR<ContractAmendmentCreateInput, ContractAmendmentUncheckedCreateInput>
    /**
     * In case the ContractAmendment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractAmendmentUpdateInput, ContractAmendmentUncheckedUpdateInput>
  }

  /**
   * ContractAmendment delete
   */
  export type ContractAmendmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
    /**
     * Filter which ContractAmendment to delete.
     */
    where: ContractAmendmentWhereUniqueInput
  }

  /**
   * ContractAmendment deleteMany
   */
  export type ContractAmendmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractAmendments to delete
     */
    where?: ContractAmendmentWhereInput
  }

  /**
   * ContractAmendment without action
   */
  export type ContractAmendmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractAmendment
     */
    select?: ContractAmendmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractAmendmentInclude<ExtArgs> | null
  }


  /**
   * Model ContractRenewal
   */

  export type AggregateContractRenewal = {
    _count: ContractRenewalCountAggregateOutputType | null
    _min: ContractRenewalMinAggregateOutputType | null
    _max: ContractRenewalMaxAggregateOutputType | null
  }

  export type ContractRenewalMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    previousEndDate: Date | null
    newEndDate: Date | null
    renewalDate: Date | null
    renewedBy: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ContractRenewalMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    previousEndDate: Date | null
    newEndDate: Date | null
    renewalDate: Date | null
    renewedBy: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ContractRenewalCountAggregateOutputType = {
    id: number
    contractId: number
    previousEndDate: number
    newEndDate: number
    renewalDate: number
    renewedBy: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ContractRenewalMinAggregateInputType = {
    id?: true
    contractId?: true
    previousEndDate?: true
    newEndDate?: true
    renewalDate?: true
    renewedBy?: true
    notes?: true
    createdAt?: true
  }

  export type ContractRenewalMaxAggregateInputType = {
    id?: true
    contractId?: true
    previousEndDate?: true
    newEndDate?: true
    renewalDate?: true
    renewedBy?: true
    notes?: true
    createdAt?: true
  }

  export type ContractRenewalCountAggregateInputType = {
    id?: true
    contractId?: true
    previousEndDate?: true
    newEndDate?: true
    renewalDate?: true
    renewedBy?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ContractRenewalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractRenewal to aggregate.
     */
    where?: ContractRenewalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractRenewals to fetch.
     */
    orderBy?: ContractRenewalOrderByWithRelationInput | ContractRenewalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractRenewalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractRenewals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractRenewals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractRenewals
    **/
    _count?: true | ContractRenewalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractRenewalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractRenewalMaxAggregateInputType
  }

  export type GetContractRenewalAggregateType<T extends ContractRenewalAggregateArgs> = {
        [P in keyof T & keyof AggregateContractRenewal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractRenewal[P]>
      : GetScalarType<T[P], AggregateContractRenewal[P]>
  }




  export type ContractRenewalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractRenewalWhereInput
    orderBy?: ContractRenewalOrderByWithAggregationInput | ContractRenewalOrderByWithAggregationInput[]
    by: ContractRenewalScalarFieldEnum[] | ContractRenewalScalarFieldEnum
    having?: ContractRenewalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractRenewalCountAggregateInputType | true
    _min?: ContractRenewalMinAggregateInputType
    _max?: ContractRenewalMaxAggregateInputType
  }

  export type ContractRenewalGroupByOutputType = {
    id: string
    contractId: string
    previousEndDate: Date
    newEndDate: Date
    renewalDate: Date
    renewedBy: string | null
    notes: string | null
    createdAt: Date
    _count: ContractRenewalCountAggregateOutputType | null
    _min: ContractRenewalMinAggregateOutputType | null
    _max: ContractRenewalMaxAggregateOutputType | null
  }

  type GetContractRenewalGroupByPayload<T extends ContractRenewalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractRenewalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractRenewalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractRenewalGroupByOutputType[P]>
            : GetScalarType<T[P], ContractRenewalGroupByOutputType[P]>
        }
      >
    >


  export type ContractRenewalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    previousEndDate?: boolean
    newEndDate?: boolean
    renewalDate?: boolean
    renewedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractRenewal"]>

  export type ContractRenewalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    previousEndDate?: boolean
    newEndDate?: boolean
    renewalDate?: boolean
    renewedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractRenewal"]>

  export type ContractRenewalSelectScalar = {
    id?: boolean
    contractId?: boolean
    previousEndDate?: boolean
    newEndDate?: boolean
    renewalDate?: boolean
    renewedBy?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ContractRenewalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type ContractRenewalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $ContractRenewalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractRenewal"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      previousEndDate: Date
      newEndDate: Date
      renewalDate: Date
      renewedBy: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["contractRenewal"]>
    composites: {}
  }

  type ContractRenewalGetPayload<S extends boolean | null | undefined | ContractRenewalDefaultArgs> = $Result.GetResult<Prisma.$ContractRenewalPayload, S>

  type ContractRenewalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractRenewalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractRenewalCountAggregateInputType | true
    }

  export interface ContractRenewalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractRenewal'], meta: { name: 'ContractRenewal' } }
    /**
     * Find zero or one ContractRenewal that matches the filter.
     * @param {ContractRenewalFindUniqueArgs} args - Arguments to find a ContractRenewal
     * @example
     * // Get one ContractRenewal
     * const contractRenewal = await prisma.contractRenewal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractRenewalFindUniqueArgs>(args: SelectSubset<T, ContractRenewalFindUniqueArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContractRenewal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractRenewalFindUniqueOrThrowArgs} args - Arguments to find a ContractRenewal
     * @example
     * // Get one ContractRenewal
     * const contractRenewal = await prisma.contractRenewal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractRenewalFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractRenewalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContractRenewal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractRenewalFindFirstArgs} args - Arguments to find a ContractRenewal
     * @example
     * // Get one ContractRenewal
     * const contractRenewal = await prisma.contractRenewal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractRenewalFindFirstArgs>(args?: SelectSubset<T, ContractRenewalFindFirstArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContractRenewal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractRenewalFindFirstOrThrowArgs} args - Arguments to find a ContractRenewal
     * @example
     * // Get one ContractRenewal
     * const contractRenewal = await prisma.contractRenewal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractRenewalFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractRenewalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContractRenewals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractRenewalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractRenewals
     * const contractRenewals = await prisma.contractRenewal.findMany()
     * 
     * // Get first 10 ContractRenewals
     * const contractRenewals = await prisma.contractRenewal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractRenewalWithIdOnly = await prisma.contractRenewal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractRenewalFindManyArgs>(args?: SelectSubset<T, ContractRenewalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContractRenewal.
     * @param {ContractRenewalCreateArgs} args - Arguments to create a ContractRenewal.
     * @example
     * // Create one ContractRenewal
     * const ContractRenewal = await prisma.contractRenewal.create({
     *   data: {
     *     // ... data to create a ContractRenewal
     *   }
     * })
     * 
     */
    create<T extends ContractRenewalCreateArgs>(args: SelectSubset<T, ContractRenewalCreateArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContractRenewals.
     * @param {ContractRenewalCreateManyArgs} args - Arguments to create many ContractRenewals.
     * @example
     * // Create many ContractRenewals
     * const contractRenewal = await prisma.contractRenewal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractRenewalCreateManyArgs>(args?: SelectSubset<T, ContractRenewalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractRenewals and returns the data saved in the database.
     * @param {ContractRenewalCreateManyAndReturnArgs} args - Arguments to create many ContractRenewals.
     * @example
     * // Create many ContractRenewals
     * const contractRenewal = await prisma.contractRenewal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractRenewals and only return the `id`
     * const contractRenewalWithIdOnly = await prisma.contractRenewal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractRenewalCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractRenewalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContractRenewal.
     * @param {ContractRenewalDeleteArgs} args - Arguments to delete one ContractRenewal.
     * @example
     * // Delete one ContractRenewal
     * const ContractRenewal = await prisma.contractRenewal.delete({
     *   where: {
     *     // ... filter to delete one ContractRenewal
     *   }
     * })
     * 
     */
    delete<T extends ContractRenewalDeleteArgs>(args: SelectSubset<T, ContractRenewalDeleteArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContractRenewal.
     * @param {ContractRenewalUpdateArgs} args - Arguments to update one ContractRenewal.
     * @example
     * // Update one ContractRenewal
     * const contractRenewal = await prisma.contractRenewal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractRenewalUpdateArgs>(args: SelectSubset<T, ContractRenewalUpdateArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContractRenewals.
     * @param {ContractRenewalDeleteManyArgs} args - Arguments to filter ContractRenewals to delete.
     * @example
     * // Delete a few ContractRenewals
     * const { count } = await prisma.contractRenewal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractRenewalDeleteManyArgs>(args?: SelectSubset<T, ContractRenewalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractRenewals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractRenewalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractRenewals
     * const contractRenewal = await prisma.contractRenewal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractRenewalUpdateManyArgs>(args: SelectSubset<T, ContractRenewalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractRenewal.
     * @param {ContractRenewalUpsertArgs} args - Arguments to update or create a ContractRenewal.
     * @example
     * // Update or create a ContractRenewal
     * const contractRenewal = await prisma.contractRenewal.upsert({
     *   create: {
     *     // ... data to create a ContractRenewal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractRenewal we want to update
     *   }
     * })
     */
    upsert<T extends ContractRenewalUpsertArgs>(args: SelectSubset<T, ContractRenewalUpsertArgs<ExtArgs>>): Prisma__ContractRenewalClient<$Result.GetResult<Prisma.$ContractRenewalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContractRenewals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractRenewalCountArgs} args - Arguments to filter ContractRenewals to count.
     * @example
     * // Count the number of ContractRenewals
     * const count = await prisma.contractRenewal.count({
     *   where: {
     *     // ... the filter for the ContractRenewals we want to count
     *   }
     * })
    **/
    count<T extends ContractRenewalCountArgs>(
      args?: Subset<T, ContractRenewalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractRenewalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractRenewal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractRenewalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractRenewalAggregateArgs>(args: Subset<T, ContractRenewalAggregateArgs>): Prisma.PrismaPromise<GetContractRenewalAggregateType<T>>

    /**
     * Group by ContractRenewal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractRenewalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractRenewalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractRenewalGroupByArgs['orderBy'] }
        : { orderBy?: ContractRenewalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractRenewalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractRenewalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractRenewal model
   */
  readonly fields: ContractRenewalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractRenewal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractRenewalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractRenewal model
   */ 
  interface ContractRenewalFieldRefs {
    readonly id: FieldRef<"ContractRenewal", 'String'>
    readonly contractId: FieldRef<"ContractRenewal", 'String'>
    readonly previousEndDate: FieldRef<"ContractRenewal", 'DateTime'>
    readonly newEndDate: FieldRef<"ContractRenewal", 'DateTime'>
    readonly renewalDate: FieldRef<"ContractRenewal", 'DateTime'>
    readonly renewedBy: FieldRef<"ContractRenewal", 'String'>
    readonly notes: FieldRef<"ContractRenewal", 'String'>
    readonly createdAt: FieldRef<"ContractRenewal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractRenewal findUnique
   */
  export type ContractRenewalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * Filter, which ContractRenewal to fetch.
     */
    where: ContractRenewalWhereUniqueInput
  }

  /**
   * ContractRenewal findUniqueOrThrow
   */
  export type ContractRenewalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * Filter, which ContractRenewal to fetch.
     */
    where: ContractRenewalWhereUniqueInput
  }

  /**
   * ContractRenewal findFirst
   */
  export type ContractRenewalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * Filter, which ContractRenewal to fetch.
     */
    where?: ContractRenewalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractRenewals to fetch.
     */
    orderBy?: ContractRenewalOrderByWithRelationInput | ContractRenewalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractRenewals.
     */
    cursor?: ContractRenewalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractRenewals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractRenewals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractRenewals.
     */
    distinct?: ContractRenewalScalarFieldEnum | ContractRenewalScalarFieldEnum[]
  }

  /**
   * ContractRenewal findFirstOrThrow
   */
  export type ContractRenewalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * Filter, which ContractRenewal to fetch.
     */
    where?: ContractRenewalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractRenewals to fetch.
     */
    orderBy?: ContractRenewalOrderByWithRelationInput | ContractRenewalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractRenewals.
     */
    cursor?: ContractRenewalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractRenewals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractRenewals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractRenewals.
     */
    distinct?: ContractRenewalScalarFieldEnum | ContractRenewalScalarFieldEnum[]
  }

  /**
   * ContractRenewal findMany
   */
  export type ContractRenewalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * Filter, which ContractRenewals to fetch.
     */
    where?: ContractRenewalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractRenewals to fetch.
     */
    orderBy?: ContractRenewalOrderByWithRelationInput | ContractRenewalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractRenewals.
     */
    cursor?: ContractRenewalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractRenewals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractRenewals.
     */
    skip?: number
    distinct?: ContractRenewalScalarFieldEnum | ContractRenewalScalarFieldEnum[]
  }

  /**
   * ContractRenewal create
   */
  export type ContractRenewalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractRenewal.
     */
    data: XOR<ContractRenewalCreateInput, ContractRenewalUncheckedCreateInput>
  }

  /**
   * ContractRenewal createMany
   */
  export type ContractRenewalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractRenewals.
     */
    data: ContractRenewalCreateManyInput | ContractRenewalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractRenewal createManyAndReturn
   */
  export type ContractRenewalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContractRenewals.
     */
    data: ContractRenewalCreateManyInput | ContractRenewalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractRenewal update
   */
  export type ContractRenewalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractRenewal.
     */
    data: XOR<ContractRenewalUpdateInput, ContractRenewalUncheckedUpdateInput>
    /**
     * Choose, which ContractRenewal to update.
     */
    where: ContractRenewalWhereUniqueInput
  }

  /**
   * ContractRenewal updateMany
   */
  export type ContractRenewalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractRenewals.
     */
    data: XOR<ContractRenewalUpdateManyMutationInput, ContractRenewalUncheckedUpdateManyInput>
    /**
     * Filter which ContractRenewals to update
     */
    where?: ContractRenewalWhereInput
  }

  /**
   * ContractRenewal upsert
   */
  export type ContractRenewalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractRenewal to update in case it exists.
     */
    where: ContractRenewalWhereUniqueInput
    /**
     * In case the ContractRenewal found by the `where` argument doesn't exist, create a new ContractRenewal with this data.
     */
    create: XOR<ContractRenewalCreateInput, ContractRenewalUncheckedCreateInput>
    /**
     * In case the ContractRenewal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractRenewalUpdateInput, ContractRenewalUncheckedUpdateInput>
  }

  /**
   * ContractRenewal delete
   */
  export type ContractRenewalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
    /**
     * Filter which ContractRenewal to delete.
     */
    where: ContractRenewalWhereUniqueInput
  }

  /**
   * ContractRenewal deleteMany
   */
  export type ContractRenewalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractRenewals to delete
     */
    where?: ContractRenewalWhereInput
  }

  /**
   * ContractRenewal without action
   */
  export type ContractRenewalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractRenewal
     */
    select?: ContractRenewalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractRenewalInclude<ExtArgs> | null
  }


  /**
   * Model Certification
   */

  export type AggregateCertification = {
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  export type CertificationMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.CertificationType | null
    name: string | null
    issuingBody: string | null
    certificationNumber: string | null
    scope: string | null
    issueDate: Date | null
    expirationDate: Date | null
    status: $Enums.CertificationStatus | null
    verified: boolean | null
    verifiedDate: Date | null
    verifiedBy: string | null
    documentUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.CertificationType | null
    name: string | null
    issuingBody: string | null
    certificationNumber: string | null
    scope: string | null
    issueDate: Date | null
    expirationDate: Date | null
    status: $Enums.CertificationStatus | null
    verified: boolean | null
    verifiedDate: Date | null
    verifiedBy: string | null
    documentUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationCountAggregateOutputType = {
    id: number
    vendorId: number
    type: number
    name: number
    issuingBody: number
    certificationNumber: number
    scope: number
    issueDate: number
    expirationDate: number
    status: number
    verified: number
    verifiedDate: number
    verifiedBy: number
    documentUrl: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificationMinAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    name?: true
    issuingBody?: true
    certificationNumber?: true
    scope?: true
    issueDate?: true
    expirationDate?: true
    status?: true
    verified?: true
    verifiedDate?: true
    verifiedBy?: true
    documentUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationMaxAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    name?: true
    issuingBody?: true
    certificationNumber?: true
    scope?: true
    issueDate?: true
    expirationDate?: true
    status?: true
    verified?: true
    verifiedDate?: true
    verifiedBy?: true
    documentUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationCountAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    name?: true
    issuingBody?: true
    certificationNumber?: true
    scope?: true
    issueDate?: true
    expirationDate?: true
    status?: true
    verified?: true
    verifiedDate?: true
    verifiedBy?: true
    documentUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certification to aggregate.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationMaxAggregateInputType
  }

  export type GetCertificationAggregateType<T extends CertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertification[P]>
      : GetScalarType<T[P], AggregateCertification[P]>
  }




  export type CertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithAggregationInput | CertificationOrderByWithAggregationInput[]
    by: CertificationScalarFieldEnum[] | CertificationScalarFieldEnum
    having?: CertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationCountAggregateInputType | true
    _min?: CertificationMinAggregateInputType
    _max?: CertificationMaxAggregateInputType
  }

  export type CertificationGroupByOutputType = {
    id: string
    vendorId: string
    type: $Enums.CertificationType
    name: string
    issuingBody: string | null
    certificationNumber: string | null
    scope: string | null
    issueDate: Date | null
    expirationDate: Date | null
    status: $Enums.CertificationStatus
    verified: boolean
    verifiedDate: Date | null
    verifiedBy: string | null
    documentUrl: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  type GetCertificationGroupByPayload<T extends CertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    name?: boolean
    issuingBody?: boolean
    certificationNumber?: boolean
    scope?: boolean
    issueDate?: boolean
    expirationDate?: boolean
    status?: boolean
    verified?: boolean
    verifiedDate?: boolean
    verifiedBy?: boolean
    documentUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    name?: boolean
    issuingBody?: boolean
    certificationNumber?: boolean
    scope?: boolean
    issueDate?: boolean
    expirationDate?: boolean
    status?: boolean
    verified?: boolean
    verifiedDate?: boolean
    verifiedBy?: boolean
    documentUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectScalar = {
    id?: boolean
    vendorId?: boolean
    type?: boolean
    name?: boolean
    issuingBody?: boolean
    certificationNumber?: boolean
    scope?: boolean
    issueDate?: boolean
    expirationDate?: boolean
    status?: boolean
    verified?: boolean
    verifiedDate?: boolean
    verifiedBy?: boolean
    documentUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type CertificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $CertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certification"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      type: $Enums.CertificationType
      name: string
      issuingBody: string | null
      certificationNumber: string | null
      scope: string | null
      issueDate: Date | null
      expirationDate: Date | null
      status: $Enums.CertificationStatus
      verified: boolean
      verifiedDate: Date | null
      verifiedBy: string | null
      documentUrl: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certification"]>
    composites: {}
  }

  type CertificationGetPayload<S extends boolean | null | undefined | CertificationDefaultArgs> = $Result.GetResult<Prisma.$CertificationPayload, S>

  type CertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificationCountAggregateInputType | true
    }

  export interface CertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certification'], meta: { name: 'Certification' } }
    /**
     * Find zero or one Certification that matches the filter.
     * @param {CertificationFindUniqueArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationFindUniqueArgs>(args: SelectSubset<T, CertificationFindUniqueArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificationFindUniqueOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationFindFirstArgs>(args?: SelectSubset<T, CertificationFindFirstArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certification.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationWithIdOnly = await prisma.certification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationFindManyArgs>(args?: SelectSubset<T, CertificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certification.
     * @param {CertificationCreateArgs} args - Arguments to create a Certification.
     * @example
     * // Create one Certification
     * const Certification = await prisma.certification.create({
     *   data: {
     *     // ... data to create a Certification
     *   }
     * })
     * 
     */
    create<T extends CertificationCreateArgs>(args: SelectSubset<T, CertificationCreateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certifications.
     * @param {CertificationCreateManyArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationCreateManyArgs>(args?: SelectSubset<T, CertificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certifications and returns the data saved in the database.
     * @param {CertificationCreateManyAndReturnArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certifications and only return the `id`
     * const certificationWithIdOnly = await prisma.certification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certification.
     * @param {CertificationDeleteArgs} args - Arguments to delete one Certification.
     * @example
     * // Delete one Certification
     * const Certification = await prisma.certification.delete({
     *   where: {
     *     // ... filter to delete one Certification
     *   }
     * })
     * 
     */
    delete<T extends CertificationDeleteArgs>(args: SelectSubset<T, CertificationDeleteArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certification.
     * @param {CertificationUpdateArgs} args - Arguments to update one Certification.
     * @example
     * // Update one Certification
     * const certification = await prisma.certification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationUpdateArgs>(args: SelectSubset<T, CertificationUpdateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationDeleteManyArgs>(args?: SelectSubset<T, CertificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationUpdateManyArgs>(args: SelectSubset<T, CertificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certification.
     * @param {CertificationUpsertArgs} args - Arguments to update or create a Certification.
     * @example
     * // Update or create a Certification
     * const certification = await prisma.certification.upsert({
     *   create: {
     *     // ... data to create a Certification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certification we want to update
     *   }
     * })
     */
    upsert<T extends CertificationUpsertArgs>(args: SelectSubset<T, CertificationUpsertArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certification.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationCountArgs>(
      args?: Subset<T, CertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationAggregateArgs>(args: Subset<T, CertificationAggregateArgs>): Prisma.PrismaPromise<GetCertificationAggregateType<T>>

    /**
     * Group by Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationGroupByArgs['orderBy'] }
        : { orderBy?: CertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certification model
   */
  readonly fields: CertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certification model
   */ 
  interface CertificationFieldRefs {
    readonly id: FieldRef<"Certification", 'String'>
    readonly vendorId: FieldRef<"Certification", 'String'>
    readonly type: FieldRef<"Certification", 'CertificationType'>
    readonly name: FieldRef<"Certification", 'String'>
    readonly issuingBody: FieldRef<"Certification", 'String'>
    readonly certificationNumber: FieldRef<"Certification", 'String'>
    readonly scope: FieldRef<"Certification", 'String'>
    readonly issueDate: FieldRef<"Certification", 'DateTime'>
    readonly expirationDate: FieldRef<"Certification", 'DateTime'>
    readonly status: FieldRef<"Certification", 'CertificationStatus'>
    readonly verified: FieldRef<"Certification", 'Boolean'>
    readonly verifiedDate: FieldRef<"Certification", 'DateTime'>
    readonly verifiedBy: FieldRef<"Certification", 'String'>
    readonly documentUrl: FieldRef<"Certification", 'String'>
    readonly notes: FieldRef<"Certification", 'String'>
    readonly createdAt: FieldRef<"Certification", 'DateTime'>
    readonly updatedAt: FieldRef<"Certification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certification findUnique
   */
  export type CertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findUniqueOrThrow
   */
  export type CertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findFirst
   */
  export type CertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findFirstOrThrow
   */
  export type CertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findMany
   */
  export type CertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification create
   */
  export type CertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Certification.
     */
    data: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
  }

  /**
   * Certification createMany
   */
  export type CertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certification createManyAndReturn
   */
  export type CertificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certification update
   */
  export type CertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Certification.
     */
    data: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
    /**
     * Choose, which Certification to update.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification updateMany
   */
  export type CertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
  }

  /**
   * Certification upsert
   */
  export type CertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Certification to update in case it exists.
     */
    where: CertificationWhereUniqueInput
    /**
     * In case the Certification found by the `where` argument doesn't exist, create a new Certification with this data.
     */
    create: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
    /**
     * In case the Certification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
  }

  /**
   * Certification delete
   */
  export type CertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter which Certification to delete.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification deleteMany
   */
  export type CertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationWhereInput
  }

  /**
   * Certification without action
   */
  export type CertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentAvgAggregateOutputType = {
    recordsAffected: number | null
  }

  export type IncidentSumAggregateOutputType = {
    recordsAffected: number | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.IncidentType | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    title: string | null
    description: string | null
    discoveredAt: Date | null
    reportedAt: Date | null
    resolvedAt: Date | null
    recordsAffected: number | null
    phiInvolved: boolean | null
    piiInvolved: boolean | null
    rootCause: string | null
    immediateActions: string | null
    correctiveActions: string | null
    preventiveActions: string | null
    notificationRequired: boolean | null
    notificationDate: Date | null
    regulatoryReportRequired: boolean | null
    regulatoryReportDate: Date | null
    lessonLearned: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    type: $Enums.IncidentType | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    title: string | null
    description: string | null
    discoveredAt: Date | null
    reportedAt: Date | null
    resolvedAt: Date | null
    recordsAffected: number | null
    phiInvolved: boolean | null
    piiInvolved: boolean | null
    rootCause: string | null
    immediateActions: string | null
    correctiveActions: string | null
    preventiveActions: string | null
    notificationRequired: boolean | null
    notificationDate: Date | null
    regulatoryReportRequired: boolean | null
    regulatoryReportDate: Date | null
    lessonLearned: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    vendorId: number
    type: number
    severity: number
    status: number
    title: number
    description: number
    discoveredAt: number
    reportedAt: number
    resolvedAt: number
    affectedSystems: number
    affectedDataTypes: number
    recordsAffected: number
    phiInvolved: number
    piiInvolved: number
    rootCause: number
    immediateActions: number
    correctiveActions: number
    preventiveActions: number
    notificationRequired: number
    notifiedParties: number
    notificationDate: number
    regulatoryReportRequired: number
    regulatoryReportDate: number
    lessonLearned: number
    attachments: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type IncidentAvgAggregateInputType = {
    recordsAffected?: true
  }

  export type IncidentSumAggregateInputType = {
    recordsAffected?: true
  }

  export type IncidentMinAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    discoveredAt?: true
    reportedAt?: true
    resolvedAt?: true
    recordsAffected?: true
    phiInvolved?: true
    piiInvolved?: true
    rootCause?: true
    immediateActions?: true
    correctiveActions?: true
    preventiveActions?: true
    notificationRequired?: true
    notificationDate?: true
    regulatoryReportRequired?: true
    regulatoryReportDate?: true
    lessonLearned?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    discoveredAt?: true
    reportedAt?: true
    resolvedAt?: true
    recordsAffected?: true
    phiInvolved?: true
    piiInvolved?: true
    rootCause?: true
    immediateActions?: true
    correctiveActions?: true
    preventiveActions?: true
    notificationRequired?: true
    notificationDate?: true
    regulatoryReportRequired?: true
    regulatoryReportDate?: true
    lessonLearned?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    vendorId?: true
    type?: true
    severity?: true
    status?: true
    title?: true
    description?: true
    discoveredAt?: true
    reportedAt?: true
    resolvedAt?: true
    affectedSystems?: true
    affectedDataTypes?: true
    recordsAffected?: true
    phiInvolved?: true
    piiInvolved?: true
    rootCause?: true
    immediateActions?: true
    correctiveActions?: true
    preventiveActions?: true
    notificationRequired?: true
    notifiedParties?: true
    notificationDate?: true
    regulatoryReportRequired?: true
    regulatoryReportDate?: true
    lessonLearned?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncidentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncidentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _avg?: IncidentAvgAggregateInputType
    _sum?: IncidentSumAggregateInputType
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    vendorId: string
    type: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    status: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date
    reportedAt: Date
    resolvedAt: Date | null
    affectedSystems: string[]
    affectedDataTypes: string[]
    recordsAffected: number | null
    phiInvolved: boolean
    piiInvolved: boolean
    rootCause: string | null
    immediateActions: string | null
    correctiveActions: string | null
    preventiveActions: string | null
    notificationRequired: boolean
    notifiedParties: string[]
    notificationDate: Date | null
    regulatoryReportRequired: boolean
    regulatoryReportDate: Date | null
    lessonLearned: string | null
    attachments: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    discoveredAt?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    affectedSystems?: boolean
    affectedDataTypes?: boolean
    recordsAffected?: boolean
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: boolean
    immediateActions?: boolean
    correctiveActions?: boolean
    preventiveActions?: boolean
    notificationRequired?: boolean
    notifiedParties?: boolean
    notificationDate?: boolean
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: boolean
    lessonLearned?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    remediations?: boolean | Incident$remediationsArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    discoveredAt?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    affectedSystems?: boolean
    affectedDataTypes?: boolean
    recordsAffected?: boolean
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: boolean
    immediateActions?: boolean
    correctiveActions?: boolean
    preventiveActions?: boolean
    notificationRequired?: boolean
    notifiedParties?: boolean
    notificationDate?: boolean
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: boolean
    lessonLearned?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    vendorId?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    discoveredAt?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    affectedSystems?: boolean
    affectedDataTypes?: boolean
    recordsAffected?: boolean
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: boolean
    immediateActions?: boolean
    correctiveActions?: boolean
    preventiveActions?: boolean
    notificationRequired?: boolean
    notifiedParties?: boolean
    notificationDate?: boolean
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: boolean
    lessonLearned?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    remediations?: boolean | Incident$remediationsArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      remediations: Prisma.$RemediationTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      type: $Enums.IncidentType
      severity: $Enums.IncidentSeverity
      status: $Enums.IncidentStatus
      title: string
      description: string
      discoveredAt: Date
      reportedAt: Date
      resolvedAt: Date | null
      affectedSystems: string[]
      affectedDataTypes: string[]
      recordsAffected: number | null
      phiInvolved: boolean
      piiInvolved: boolean
      rootCause: string | null
      immediateActions: string | null
      correctiveActions: string | null
      preventiveActions: string | null
      notificationRequired: boolean
      notifiedParties: string[]
      notificationDate: Date | null
      regulatoryReportRequired: boolean
      regulatoryReportDate: Date | null
      lessonLearned: string | null
      attachments: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    remediations<T extends Incident$remediationsArgs<ExtArgs> = {}>(args?: Subset<T, Incident$remediationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */ 
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly vendorId: FieldRef<"Incident", 'String'>
    readonly type: FieldRef<"Incident", 'IncidentType'>
    readonly severity: FieldRef<"Incident", 'IncidentSeverity'>
    readonly status: FieldRef<"Incident", 'IncidentStatus'>
    readonly title: FieldRef<"Incident", 'String'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly discoveredAt: FieldRef<"Incident", 'DateTime'>
    readonly reportedAt: FieldRef<"Incident", 'DateTime'>
    readonly resolvedAt: FieldRef<"Incident", 'DateTime'>
    readonly affectedSystems: FieldRef<"Incident", 'String[]'>
    readonly affectedDataTypes: FieldRef<"Incident", 'String[]'>
    readonly recordsAffected: FieldRef<"Incident", 'Int'>
    readonly phiInvolved: FieldRef<"Incident", 'Boolean'>
    readonly piiInvolved: FieldRef<"Incident", 'Boolean'>
    readonly rootCause: FieldRef<"Incident", 'String'>
    readonly immediateActions: FieldRef<"Incident", 'String'>
    readonly correctiveActions: FieldRef<"Incident", 'String'>
    readonly preventiveActions: FieldRef<"Incident", 'String'>
    readonly notificationRequired: FieldRef<"Incident", 'Boolean'>
    readonly notifiedParties: FieldRef<"Incident", 'String[]'>
    readonly notificationDate: FieldRef<"Incident", 'DateTime'>
    readonly regulatoryReportRequired: FieldRef<"Incident", 'Boolean'>
    readonly regulatoryReportDate: FieldRef<"Incident", 'DateTime'>
    readonly lessonLearned: FieldRef<"Incident", 'String'>
    readonly attachments: FieldRef<"Incident", 'Json'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
    readonly createdBy: FieldRef<"Incident", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident.remediations
   */
  export type Incident$remediationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    where?: RemediationTaskWhereInput
    orderBy?: RemediationTaskOrderByWithRelationInput | RemediationTaskOrderByWithRelationInput[]
    cursor?: RemediationTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemediationTaskScalarFieldEnum | RemediationTaskScalarFieldEnum[]
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model RemediationTask
   */

  export type AggregateRemediationTask = {
    _count: RemediationTaskCountAggregateOutputType | null
    _min: RemediationTaskMinAggregateOutputType | null
    _max: RemediationTaskMaxAggregateOutputType | null
  }

  export type RemediationTaskMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    incidentId: string | null
    type: $Enums.RemediationType | null
    priority: $Enums.TaskPriority | null
    status: $Enums.TaskStatus | null
    title: string | null
    description: string | null
    requirement: string | null
    controlReference: string | null
    dueDate: Date | null
    completedDate: Date | null
    assignedTo: string | null
    assignedToEmail: string | null
    verifiedBy: string | null
    verifiedDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type RemediationTaskMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    incidentId: string | null
    type: $Enums.RemediationType | null
    priority: $Enums.TaskPriority | null
    status: $Enums.TaskStatus | null
    title: string | null
    description: string | null
    requirement: string | null
    controlReference: string | null
    dueDate: Date | null
    completedDate: Date | null
    assignedTo: string | null
    assignedToEmail: string | null
    verifiedBy: string | null
    verifiedDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type RemediationTaskCountAggregateOutputType = {
    id: number
    vendorId: number
    incidentId: number
    type: number
    priority: number
    status: number
    title: number
    description: number
    requirement: number
    controlReference: number
    dueDate: number
    completedDate: number
    assignedTo: number
    assignedToEmail: number
    evidence: number
    verifiedBy: number
    verifiedDate: number
    notes: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type RemediationTaskMinAggregateInputType = {
    id?: true
    vendorId?: true
    incidentId?: true
    type?: true
    priority?: true
    status?: true
    title?: true
    description?: true
    requirement?: true
    controlReference?: true
    dueDate?: true
    completedDate?: true
    assignedTo?: true
    assignedToEmail?: true
    verifiedBy?: true
    verifiedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type RemediationTaskMaxAggregateInputType = {
    id?: true
    vendorId?: true
    incidentId?: true
    type?: true
    priority?: true
    status?: true
    title?: true
    description?: true
    requirement?: true
    controlReference?: true
    dueDate?: true
    completedDate?: true
    assignedTo?: true
    assignedToEmail?: true
    verifiedBy?: true
    verifiedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type RemediationTaskCountAggregateInputType = {
    id?: true
    vendorId?: true
    incidentId?: true
    type?: true
    priority?: true
    status?: true
    title?: true
    description?: true
    requirement?: true
    controlReference?: true
    dueDate?: true
    completedDate?: true
    assignedTo?: true
    assignedToEmail?: true
    evidence?: true
    verifiedBy?: true
    verifiedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type RemediationTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemediationTask to aggregate.
     */
    where?: RemediationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemediationTasks to fetch.
     */
    orderBy?: RemediationTaskOrderByWithRelationInput | RemediationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RemediationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemediationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemediationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RemediationTasks
    **/
    _count?: true | RemediationTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemediationTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemediationTaskMaxAggregateInputType
  }

  export type GetRemediationTaskAggregateType<T extends RemediationTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateRemediationTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemediationTask[P]>
      : GetScalarType<T[P], AggregateRemediationTask[P]>
  }




  export type RemediationTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemediationTaskWhereInput
    orderBy?: RemediationTaskOrderByWithAggregationInput | RemediationTaskOrderByWithAggregationInput[]
    by: RemediationTaskScalarFieldEnum[] | RemediationTaskScalarFieldEnum
    having?: RemediationTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemediationTaskCountAggregateInputType | true
    _min?: RemediationTaskMinAggregateInputType
    _max?: RemediationTaskMaxAggregateInputType
  }

  export type RemediationTaskGroupByOutputType = {
    id: string
    vendorId: string
    incidentId: string | null
    type: $Enums.RemediationType
    priority: $Enums.TaskPriority
    status: $Enums.TaskStatus
    title: string
    description: string
    requirement: string | null
    controlReference: string | null
    dueDate: Date | null
    completedDate: Date | null
    assignedTo: string | null
    assignedToEmail: string | null
    evidence: JsonValue | null
    verifiedBy: string | null
    verifiedDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: RemediationTaskCountAggregateOutputType | null
    _min: RemediationTaskMinAggregateOutputType | null
    _max: RemediationTaskMaxAggregateOutputType | null
  }

  type GetRemediationTaskGroupByPayload<T extends RemediationTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemediationTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemediationTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemediationTaskGroupByOutputType[P]>
            : GetScalarType<T[P], RemediationTaskGroupByOutputType[P]>
        }
      >
    >


  export type RemediationTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    incidentId?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    requirement?: boolean
    controlReference?: boolean
    dueDate?: boolean
    completedDate?: boolean
    assignedTo?: boolean
    assignedToEmail?: boolean
    evidence?: boolean
    verifiedBy?: boolean
    verifiedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    incident?: boolean | RemediationTask$incidentArgs<ExtArgs>
  }, ExtArgs["result"]["remediationTask"]>

  export type RemediationTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    incidentId?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    requirement?: boolean
    controlReference?: boolean
    dueDate?: boolean
    completedDate?: boolean
    assignedTo?: boolean
    assignedToEmail?: boolean
    evidence?: boolean
    verifiedBy?: boolean
    verifiedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    incident?: boolean | RemediationTask$incidentArgs<ExtArgs>
  }, ExtArgs["result"]["remediationTask"]>

  export type RemediationTaskSelectScalar = {
    id?: boolean
    vendorId?: boolean
    incidentId?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    title?: boolean
    description?: boolean
    requirement?: boolean
    controlReference?: boolean
    dueDate?: boolean
    completedDate?: boolean
    assignedTo?: boolean
    assignedToEmail?: boolean
    evidence?: boolean
    verifiedBy?: boolean
    verifiedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type RemediationTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    incident?: boolean | RemediationTask$incidentArgs<ExtArgs>
  }
  export type RemediationTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    incident?: boolean | RemediationTask$incidentArgs<ExtArgs>
  }

  export type $RemediationTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RemediationTask"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      incident: Prisma.$IncidentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      incidentId: string | null
      type: $Enums.RemediationType
      priority: $Enums.TaskPriority
      status: $Enums.TaskStatus
      title: string
      description: string
      requirement: string | null
      controlReference: string | null
      dueDate: Date | null
      completedDate: Date | null
      assignedTo: string | null
      assignedToEmail: string | null
      evidence: Prisma.JsonValue | null
      verifiedBy: string | null
      verifiedDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["remediationTask"]>
    composites: {}
  }

  type RemediationTaskGetPayload<S extends boolean | null | undefined | RemediationTaskDefaultArgs> = $Result.GetResult<Prisma.$RemediationTaskPayload, S>

  type RemediationTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RemediationTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RemediationTaskCountAggregateInputType | true
    }

  export interface RemediationTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RemediationTask'], meta: { name: 'RemediationTask' } }
    /**
     * Find zero or one RemediationTask that matches the filter.
     * @param {RemediationTaskFindUniqueArgs} args - Arguments to find a RemediationTask
     * @example
     * // Get one RemediationTask
     * const remediationTask = await prisma.remediationTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RemediationTaskFindUniqueArgs>(args: SelectSubset<T, RemediationTaskFindUniqueArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RemediationTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RemediationTaskFindUniqueOrThrowArgs} args - Arguments to find a RemediationTask
     * @example
     * // Get one RemediationTask
     * const remediationTask = await prisma.remediationTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RemediationTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, RemediationTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RemediationTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemediationTaskFindFirstArgs} args - Arguments to find a RemediationTask
     * @example
     * // Get one RemediationTask
     * const remediationTask = await prisma.remediationTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RemediationTaskFindFirstArgs>(args?: SelectSubset<T, RemediationTaskFindFirstArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RemediationTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemediationTaskFindFirstOrThrowArgs} args - Arguments to find a RemediationTask
     * @example
     * // Get one RemediationTask
     * const remediationTask = await prisma.remediationTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RemediationTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, RemediationTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RemediationTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemediationTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RemediationTasks
     * const remediationTasks = await prisma.remediationTask.findMany()
     * 
     * // Get first 10 RemediationTasks
     * const remediationTasks = await prisma.remediationTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remediationTaskWithIdOnly = await prisma.remediationTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RemediationTaskFindManyArgs>(args?: SelectSubset<T, RemediationTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RemediationTask.
     * @param {RemediationTaskCreateArgs} args - Arguments to create a RemediationTask.
     * @example
     * // Create one RemediationTask
     * const RemediationTask = await prisma.remediationTask.create({
     *   data: {
     *     // ... data to create a RemediationTask
     *   }
     * })
     * 
     */
    create<T extends RemediationTaskCreateArgs>(args: SelectSubset<T, RemediationTaskCreateArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RemediationTasks.
     * @param {RemediationTaskCreateManyArgs} args - Arguments to create many RemediationTasks.
     * @example
     * // Create many RemediationTasks
     * const remediationTask = await prisma.remediationTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RemediationTaskCreateManyArgs>(args?: SelectSubset<T, RemediationTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RemediationTasks and returns the data saved in the database.
     * @param {RemediationTaskCreateManyAndReturnArgs} args - Arguments to create many RemediationTasks.
     * @example
     * // Create many RemediationTasks
     * const remediationTask = await prisma.remediationTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RemediationTasks and only return the `id`
     * const remediationTaskWithIdOnly = await prisma.remediationTask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RemediationTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, RemediationTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RemediationTask.
     * @param {RemediationTaskDeleteArgs} args - Arguments to delete one RemediationTask.
     * @example
     * // Delete one RemediationTask
     * const RemediationTask = await prisma.remediationTask.delete({
     *   where: {
     *     // ... filter to delete one RemediationTask
     *   }
     * })
     * 
     */
    delete<T extends RemediationTaskDeleteArgs>(args: SelectSubset<T, RemediationTaskDeleteArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RemediationTask.
     * @param {RemediationTaskUpdateArgs} args - Arguments to update one RemediationTask.
     * @example
     * // Update one RemediationTask
     * const remediationTask = await prisma.remediationTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RemediationTaskUpdateArgs>(args: SelectSubset<T, RemediationTaskUpdateArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RemediationTasks.
     * @param {RemediationTaskDeleteManyArgs} args - Arguments to filter RemediationTasks to delete.
     * @example
     * // Delete a few RemediationTasks
     * const { count } = await prisma.remediationTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RemediationTaskDeleteManyArgs>(args?: SelectSubset<T, RemediationTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemediationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemediationTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RemediationTasks
     * const remediationTask = await prisma.remediationTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RemediationTaskUpdateManyArgs>(args: SelectSubset<T, RemediationTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RemediationTask.
     * @param {RemediationTaskUpsertArgs} args - Arguments to update or create a RemediationTask.
     * @example
     * // Update or create a RemediationTask
     * const remediationTask = await prisma.remediationTask.upsert({
     *   create: {
     *     // ... data to create a RemediationTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RemediationTask we want to update
     *   }
     * })
     */
    upsert<T extends RemediationTaskUpsertArgs>(args: SelectSubset<T, RemediationTaskUpsertArgs<ExtArgs>>): Prisma__RemediationTaskClient<$Result.GetResult<Prisma.$RemediationTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RemediationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemediationTaskCountArgs} args - Arguments to filter RemediationTasks to count.
     * @example
     * // Count the number of RemediationTasks
     * const count = await prisma.remediationTask.count({
     *   where: {
     *     // ... the filter for the RemediationTasks we want to count
     *   }
     * })
    **/
    count<T extends RemediationTaskCountArgs>(
      args?: Subset<T, RemediationTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemediationTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RemediationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemediationTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemediationTaskAggregateArgs>(args: Subset<T, RemediationTaskAggregateArgs>): Prisma.PrismaPromise<GetRemediationTaskAggregateType<T>>

    /**
     * Group by RemediationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemediationTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemediationTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemediationTaskGroupByArgs['orderBy'] }
        : { orderBy?: RemediationTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemediationTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemediationTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RemediationTask model
   */
  readonly fields: RemediationTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RemediationTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RemediationTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    incident<T extends RemediationTask$incidentArgs<ExtArgs> = {}>(args?: Subset<T, RemediationTask$incidentArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RemediationTask model
   */ 
  interface RemediationTaskFieldRefs {
    readonly id: FieldRef<"RemediationTask", 'String'>
    readonly vendorId: FieldRef<"RemediationTask", 'String'>
    readonly incidentId: FieldRef<"RemediationTask", 'String'>
    readonly type: FieldRef<"RemediationTask", 'RemediationType'>
    readonly priority: FieldRef<"RemediationTask", 'TaskPriority'>
    readonly status: FieldRef<"RemediationTask", 'TaskStatus'>
    readonly title: FieldRef<"RemediationTask", 'String'>
    readonly description: FieldRef<"RemediationTask", 'String'>
    readonly requirement: FieldRef<"RemediationTask", 'String'>
    readonly controlReference: FieldRef<"RemediationTask", 'String'>
    readonly dueDate: FieldRef<"RemediationTask", 'DateTime'>
    readonly completedDate: FieldRef<"RemediationTask", 'DateTime'>
    readonly assignedTo: FieldRef<"RemediationTask", 'String'>
    readonly assignedToEmail: FieldRef<"RemediationTask", 'String'>
    readonly evidence: FieldRef<"RemediationTask", 'Json'>
    readonly verifiedBy: FieldRef<"RemediationTask", 'String'>
    readonly verifiedDate: FieldRef<"RemediationTask", 'DateTime'>
    readonly notes: FieldRef<"RemediationTask", 'String'>
    readonly createdAt: FieldRef<"RemediationTask", 'DateTime'>
    readonly updatedAt: FieldRef<"RemediationTask", 'DateTime'>
    readonly createdBy: FieldRef<"RemediationTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RemediationTask findUnique
   */
  export type RemediationTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * Filter, which RemediationTask to fetch.
     */
    where: RemediationTaskWhereUniqueInput
  }

  /**
   * RemediationTask findUniqueOrThrow
   */
  export type RemediationTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * Filter, which RemediationTask to fetch.
     */
    where: RemediationTaskWhereUniqueInput
  }

  /**
   * RemediationTask findFirst
   */
  export type RemediationTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * Filter, which RemediationTask to fetch.
     */
    where?: RemediationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemediationTasks to fetch.
     */
    orderBy?: RemediationTaskOrderByWithRelationInput | RemediationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemediationTasks.
     */
    cursor?: RemediationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemediationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemediationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemediationTasks.
     */
    distinct?: RemediationTaskScalarFieldEnum | RemediationTaskScalarFieldEnum[]
  }

  /**
   * RemediationTask findFirstOrThrow
   */
  export type RemediationTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * Filter, which RemediationTask to fetch.
     */
    where?: RemediationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemediationTasks to fetch.
     */
    orderBy?: RemediationTaskOrderByWithRelationInput | RemediationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemediationTasks.
     */
    cursor?: RemediationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemediationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemediationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemediationTasks.
     */
    distinct?: RemediationTaskScalarFieldEnum | RemediationTaskScalarFieldEnum[]
  }

  /**
   * RemediationTask findMany
   */
  export type RemediationTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * Filter, which RemediationTasks to fetch.
     */
    where?: RemediationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemediationTasks to fetch.
     */
    orderBy?: RemediationTaskOrderByWithRelationInput | RemediationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RemediationTasks.
     */
    cursor?: RemediationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemediationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemediationTasks.
     */
    skip?: number
    distinct?: RemediationTaskScalarFieldEnum | RemediationTaskScalarFieldEnum[]
  }

  /**
   * RemediationTask create
   */
  export type RemediationTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a RemediationTask.
     */
    data: XOR<RemediationTaskCreateInput, RemediationTaskUncheckedCreateInput>
  }

  /**
   * RemediationTask createMany
   */
  export type RemediationTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RemediationTasks.
     */
    data: RemediationTaskCreateManyInput | RemediationTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RemediationTask createManyAndReturn
   */
  export type RemediationTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RemediationTasks.
     */
    data: RemediationTaskCreateManyInput | RemediationTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RemediationTask update
   */
  export type RemediationTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a RemediationTask.
     */
    data: XOR<RemediationTaskUpdateInput, RemediationTaskUncheckedUpdateInput>
    /**
     * Choose, which RemediationTask to update.
     */
    where: RemediationTaskWhereUniqueInput
  }

  /**
   * RemediationTask updateMany
   */
  export type RemediationTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RemediationTasks.
     */
    data: XOR<RemediationTaskUpdateManyMutationInput, RemediationTaskUncheckedUpdateManyInput>
    /**
     * Filter which RemediationTasks to update
     */
    where?: RemediationTaskWhereInput
  }

  /**
   * RemediationTask upsert
   */
  export type RemediationTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the RemediationTask to update in case it exists.
     */
    where: RemediationTaskWhereUniqueInput
    /**
     * In case the RemediationTask found by the `where` argument doesn't exist, create a new RemediationTask with this data.
     */
    create: XOR<RemediationTaskCreateInput, RemediationTaskUncheckedCreateInput>
    /**
     * In case the RemediationTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RemediationTaskUpdateInput, RemediationTaskUncheckedUpdateInput>
  }

  /**
   * RemediationTask delete
   */
  export type RemediationTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
    /**
     * Filter which RemediationTask to delete.
     */
    where: RemediationTaskWhereUniqueInput
  }

  /**
   * RemediationTask deleteMany
   */
  export type RemediationTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemediationTasks to delete
     */
    where?: RemediationTaskWhereInput
  }

  /**
   * RemediationTask.incident
   */
  export type RemediationTask$incidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
  }

  /**
   * RemediationTask without action
   */
  export type RemediationTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemediationTask
     */
    select?: RemediationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemediationTaskInclude<ExtArgs> | null
  }


  /**
   * Model VendorAuditLog
   */

  export type AggregateVendorAuditLog = {
    _count: VendorAuditLogCountAggregateOutputType | null
    _min: VendorAuditLogMinAggregateOutputType | null
    _max: VendorAuditLogMaxAggregateOutputType | null
  }

  export type VendorAuditLogMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    userEmail: string | null
    userRole: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type VendorAuditLogMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    userEmail: string | null
    userRole: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type VendorAuditLogCountAggregateOutputType = {
    id: number
    vendorId: number
    action: number
    entityType: number
    entityId: number
    userId: number
    userEmail: number
    userRole: number
    ipAddress: number
    userAgent: number
    oldValues: number
    newValues: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type VendorAuditLogMinAggregateInputType = {
    id?: true
    vendorId?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    userEmail?: true
    userRole?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type VendorAuditLogMaxAggregateInputType = {
    id?: true
    vendorId?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    userEmail?: true
    userRole?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type VendorAuditLogCountAggregateInputType = {
    id?: true
    vendorId?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    userEmail?: true
    userRole?: true
    ipAddress?: true
    userAgent?: true
    oldValues?: true
    newValues?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type VendorAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorAuditLog to aggregate.
     */
    where?: VendorAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAuditLogs to fetch.
     */
    orderBy?: VendorAuditLogOrderByWithRelationInput | VendorAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorAuditLogs
    **/
    _count?: true | VendorAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorAuditLogMaxAggregateInputType
  }

  export type GetVendorAuditLogAggregateType<T extends VendorAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorAuditLog[P]>
      : GetScalarType<T[P], AggregateVendorAuditLog[P]>
  }




  export type VendorAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorAuditLogWhereInput
    orderBy?: VendorAuditLogOrderByWithAggregationInput | VendorAuditLogOrderByWithAggregationInput[]
    by: VendorAuditLogScalarFieldEnum[] | VendorAuditLogScalarFieldEnum
    having?: VendorAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorAuditLogCountAggregateInputType | true
    _min?: VendorAuditLogMinAggregateInputType
    _max?: VendorAuditLogMaxAggregateInputType
  }

  export type VendorAuditLogGroupByOutputType = {
    id: string
    vendorId: string | null
    action: string
    entityType: string
    entityId: string | null
    userId: string
    userEmail: string | null
    userRole: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValues: JsonValue | null
    newValues: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    _count: VendorAuditLogCountAggregateOutputType | null
    _min: VendorAuditLogMinAggregateOutputType | null
    _max: VendorAuditLogMaxAggregateOutputType | null
  }

  type GetVendorAuditLogGroupByPayload<T extends VendorAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], VendorAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type VendorAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    userEmail?: boolean
    userRole?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorAuditLog$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAuditLog"]>

  export type VendorAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    userEmail?: boolean
    userRole?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorAuditLog$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAuditLog"]>

  export type VendorAuditLogSelectScalar = {
    id?: boolean
    vendorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    userEmail?: boolean
    userRole?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type VendorAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorAuditLog$vendorArgs<ExtArgs>
  }
  export type VendorAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorAuditLog$vendorArgs<ExtArgs>
  }

  export type $VendorAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorAuditLog"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string | null
      action: string
      entityType: string
      entityId: string | null
      userId: string
      userEmail: string | null
      userRole: string | null
      ipAddress: string | null
      userAgent: string | null
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["vendorAuditLog"]>
    composites: {}
  }

  type VendorAuditLogGetPayload<S extends boolean | null | undefined | VendorAuditLogDefaultArgs> = $Result.GetResult<Prisma.$VendorAuditLogPayload, S>

  type VendorAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorAuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorAuditLogCountAggregateInputType | true
    }

  export interface VendorAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorAuditLog'], meta: { name: 'VendorAuditLog' } }
    /**
     * Find zero or one VendorAuditLog that matches the filter.
     * @param {VendorAuditLogFindUniqueArgs} args - Arguments to find a VendorAuditLog
     * @example
     * // Get one VendorAuditLog
     * const vendorAuditLog = await prisma.vendorAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorAuditLogFindUniqueArgs>(args: SelectSubset<T, VendorAuditLogFindUniqueArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VendorAuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorAuditLogFindUniqueOrThrowArgs} args - Arguments to find a VendorAuditLog
     * @example
     * // Get one VendorAuditLog
     * const vendorAuditLog = await prisma.vendorAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VendorAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAuditLogFindFirstArgs} args - Arguments to find a VendorAuditLog
     * @example
     * // Get one VendorAuditLog
     * const vendorAuditLog = await prisma.vendorAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorAuditLogFindFirstArgs>(args?: SelectSubset<T, VendorAuditLogFindFirstArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VendorAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAuditLogFindFirstOrThrowArgs} args - Arguments to find a VendorAuditLog
     * @example
     * // Get one VendorAuditLog
     * const vendorAuditLog = await prisma.vendorAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VendorAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorAuditLogs
     * const vendorAuditLogs = await prisma.vendorAuditLog.findMany()
     * 
     * // Get first 10 VendorAuditLogs
     * const vendorAuditLogs = await prisma.vendorAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorAuditLogWithIdOnly = await prisma.vendorAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorAuditLogFindManyArgs>(args?: SelectSubset<T, VendorAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VendorAuditLog.
     * @param {VendorAuditLogCreateArgs} args - Arguments to create a VendorAuditLog.
     * @example
     * // Create one VendorAuditLog
     * const VendorAuditLog = await prisma.vendorAuditLog.create({
     *   data: {
     *     // ... data to create a VendorAuditLog
     *   }
     * })
     * 
     */
    create<T extends VendorAuditLogCreateArgs>(args: SelectSubset<T, VendorAuditLogCreateArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VendorAuditLogs.
     * @param {VendorAuditLogCreateManyArgs} args - Arguments to create many VendorAuditLogs.
     * @example
     * // Create many VendorAuditLogs
     * const vendorAuditLog = await prisma.vendorAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorAuditLogCreateManyArgs>(args?: SelectSubset<T, VendorAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorAuditLogs and returns the data saved in the database.
     * @param {VendorAuditLogCreateManyAndReturnArgs} args - Arguments to create many VendorAuditLogs.
     * @example
     * // Create many VendorAuditLogs
     * const vendorAuditLog = await prisma.vendorAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorAuditLogs and only return the `id`
     * const vendorAuditLogWithIdOnly = await prisma.vendorAuditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VendorAuditLog.
     * @param {VendorAuditLogDeleteArgs} args - Arguments to delete one VendorAuditLog.
     * @example
     * // Delete one VendorAuditLog
     * const VendorAuditLog = await prisma.vendorAuditLog.delete({
     *   where: {
     *     // ... filter to delete one VendorAuditLog
     *   }
     * })
     * 
     */
    delete<T extends VendorAuditLogDeleteArgs>(args: SelectSubset<T, VendorAuditLogDeleteArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VendorAuditLog.
     * @param {VendorAuditLogUpdateArgs} args - Arguments to update one VendorAuditLog.
     * @example
     * // Update one VendorAuditLog
     * const vendorAuditLog = await prisma.vendorAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorAuditLogUpdateArgs>(args: SelectSubset<T, VendorAuditLogUpdateArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VendorAuditLogs.
     * @param {VendorAuditLogDeleteManyArgs} args - Arguments to filter VendorAuditLogs to delete.
     * @example
     * // Delete a few VendorAuditLogs
     * const { count } = await prisma.vendorAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorAuditLogDeleteManyArgs>(args?: SelectSubset<T, VendorAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorAuditLogs
     * const vendorAuditLog = await prisma.vendorAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorAuditLogUpdateManyArgs>(args: SelectSubset<T, VendorAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorAuditLog.
     * @param {VendorAuditLogUpsertArgs} args - Arguments to update or create a VendorAuditLog.
     * @example
     * // Update or create a VendorAuditLog
     * const vendorAuditLog = await prisma.vendorAuditLog.upsert({
     *   create: {
     *     // ... data to create a VendorAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends VendorAuditLogUpsertArgs>(args: SelectSubset<T, VendorAuditLogUpsertArgs<ExtArgs>>): Prisma__VendorAuditLogClient<$Result.GetResult<Prisma.$VendorAuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VendorAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAuditLogCountArgs} args - Arguments to filter VendorAuditLogs to count.
     * @example
     * // Count the number of VendorAuditLogs
     * const count = await prisma.vendorAuditLog.count({
     *   where: {
     *     // ... the filter for the VendorAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends VendorAuditLogCountArgs>(
      args?: Subset<T, VendorAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAuditLogAggregateArgs>(args: Subset<T, VendorAuditLogAggregateArgs>): Prisma.PrismaPromise<GetVendorAuditLogAggregateType<T>>

    /**
     * Group by VendorAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: VendorAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorAuditLog model
   */
  readonly fields: VendorAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorAuditLog$vendorArgs<ExtArgs> = {}>(args?: Subset<T, VendorAuditLog$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorAuditLog model
   */ 
  interface VendorAuditLogFieldRefs {
    readonly id: FieldRef<"VendorAuditLog", 'String'>
    readonly vendorId: FieldRef<"VendorAuditLog", 'String'>
    readonly action: FieldRef<"VendorAuditLog", 'String'>
    readonly entityType: FieldRef<"VendorAuditLog", 'String'>
    readonly entityId: FieldRef<"VendorAuditLog", 'String'>
    readonly userId: FieldRef<"VendorAuditLog", 'String'>
    readonly userEmail: FieldRef<"VendorAuditLog", 'String'>
    readonly userRole: FieldRef<"VendorAuditLog", 'String'>
    readonly ipAddress: FieldRef<"VendorAuditLog", 'String'>
    readonly userAgent: FieldRef<"VendorAuditLog", 'String'>
    readonly oldValues: FieldRef<"VendorAuditLog", 'Json'>
    readonly newValues: FieldRef<"VendorAuditLog", 'Json'>
    readonly metadata: FieldRef<"VendorAuditLog", 'Json'>
    readonly createdAt: FieldRef<"VendorAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorAuditLog findUnique
   */
  export type VendorAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which VendorAuditLog to fetch.
     */
    where: VendorAuditLogWhereUniqueInput
  }

  /**
   * VendorAuditLog findUniqueOrThrow
   */
  export type VendorAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which VendorAuditLog to fetch.
     */
    where: VendorAuditLogWhereUniqueInput
  }

  /**
   * VendorAuditLog findFirst
   */
  export type VendorAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which VendorAuditLog to fetch.
     */
    where?: VendorAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAuditLogs to fetch.
     */
    orderBy?: VendorAuditLogOrderByWithRelationInput | VendorAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorAuditLogs.
     */
    cursor?: VendorAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorAuditLogs.
     */
    distinct?: VendorAuditLogScalarFieldEnum | VendorAuditLogScalarFieldEnum[]
  }

  /**
   * VendorAuditLog findFirstOrThrow
   */
  export type VendorAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which VendorAuditLog to fetch.
     */
    where?: VendorAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAuditLogs to fetch.
     */
    orderBy?: VendorAuditLogOrderByWithRelationInput | VendorAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorAuditLogs.
     */
    cursor?: VendorAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorAuditLogs.
     */
    distinct?: VendorAuditLogScalarFieldEnum | VendorAuditLogScalarFieldEnum[]
  }

  /**
   * VendorAuditLog findMany
   */
  export type VendorAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which VendorAuditLogs to fetch.
     */
    where?: VendorAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAuditLogs to fetch.
     */
    orderBy?: VendorAuditLogOrderByWithRelationInput | VendorAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorAuditLogs.
     */
    cursor?: VendorAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAuditLogs.
     */
    skip?: number
    distinct?: VendorAuditLogScalarFieldEnum | VendorAuditLogScalarFieldEnum[]
  }

  /**
   * VendorAuditLog create
   */
  export type VendorAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorAuditLog.
     */
    data: XOR<VendorAuditLogCreateInput, VendorAuditLogUncheckedCreateInput>
  }

  /**
   * VendorAuditLog createMany
   */
  export type VendorAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorAuditLogs.
     */
    data: VendorAuditLogCreateManyInput | VendorAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorAuditLog createManyAndReturn
   */
  export type VendorAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VendorAuditLogs.
     */
    data: VendorAuditLogCreateManyInput | VendorAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorAuditLog update
   */
  export type VendorAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorAuditLog.
     */
    data: XOR<VendorAuditLogUpdateInput, VendorAuditLogUncheckedUpdateInput>
    /**
     * Choose, which VendorAuditLog to update.
     */
    where: VendorAuditLogWhereUniqueInput
  }

  /**
   * VendorAuditLog updateMany
   */
  export type VendorAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorAuditLogs.
     */
    data: XOR<VendorAuditLogUpdateManyMutationInput, VendorAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which VendorAuditLogs to update
     */
    where?: VendorAuditLogWhereInput
  }

  /**
   * VendorAuditLog upsert
   */
  export type VendorAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorAuditLog to update in case it exists.
     */
    where: VendorAuditLogWhereUniqueInput
    /**
     * In case the VendorAuditLog found by the `where` argument doesn't exist, create a new VendorAuditLog with this data.
     */
    create: XOR<VendorAuditLogCreateInput, VendorAuditLogUncheckedCreateInput>
    /**
     * In case the VendorAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorAuditLogUpdateInput, VendorAuditLogUncheckedUpdateInput>
  }

  /**
   * VendorAuditLog delete
   */
  export type VendorAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
    /**
     * Filter which VendorAuditLog to delete.
     */
    where: VendorAuditLogWhereUniqueInput
  }

  /**
   * VendorAuditLog deleteMany
   */
  export type VendorAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorAuditLogs to delete
     */
    where?: VendorAuditLogWhereInput
  }

  /**
   * VendorAuditLog.vendor
   */
  export type VendorAuditLog$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * VendorAuditLog without action
   */
  export type VendorAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAuditLog
     */
    select?: VendorAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model RiskScoringCriteria
   */

  export type AggregateRiskScoringCriteria = {
    _count: RiskScoringCriteriaCountAggregateOutputType | null
    _avg: RiskScoringCriteriaAvgAggregateOutputType | null
    _sum: RiskScoringCriteriaSumAggregateOutputType | null
    _min: RiskScoringCriteriaMinAggregateOutputType | null
    _max: RiskScoringCriteriaMaxAggregateOutputType | null
  }

  export type RiskScoringCriteriaAvgAggregateOutputType = {
    weight: number | null
    maxPoints: number | null
  }

  export type RiskScoringCriteriaSumAggregateOutputType = {
    weight: number | null
    maxPoints: number | null
  }

  export type RiskScoringCriteriaMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    weight: number | null
    maxPoints: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskScoringCriteriaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    weight: number | null
    maxPoints: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskScoringCriteriaCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    weight: number
    maxPoints: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskScoringCriteriaAvgAggregateInputType = {
    weight?: true
    maxPoints?: true
  }

  export type RiskScoringCriteriaSumAggregateInputType = {
    weight?: true
    maxPoints?: true
  }

  export type RiskScoringCriteriaMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    weight?: true
    maxPoints?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskScoringCriteriaMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    weight?: true
    maxPoints?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskScoringCriteriaCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    weight?: true
    maxPoints?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskScoringCriteriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskScoringCriteria to aggregate.
     */
    where?: RiskScoringCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScoringCriteria to fetch.
     */
    orderBy?: RiskScoringCriteriaOrderByWithRelationInput | RiskScoringCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskScoringCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScoringCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScoringCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskScoringCriteria
    **/
    _count?: true | RiskScoringCriteriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskScoringCriteriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskScoringCriteriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskScoringCriteriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskScoringCriteriaMaxAggregateInputType
  }

  export type GetRiskScoringCriteriaAggregateType<T extends RiskScoringCriteriaAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskScoringCriteria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskScoringCriteria[P]>
      : GetScalarType<T[P], AggregateRiskScoringCriteria[P]>
  }




  export type RiskScoringCriteriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskScoringCriteriaWhereInput
    orderBy?: RiskScoringCriteriaOrderByWithAggregationInput | RiskScoringCriteriaOrderByWithAggregationInput[]
    by: RiskScoringCriteriaScalarFieldEnum[] | RiskScoringCriteriaScalarFieldEnum
    having?: RiskScoringCriteriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskScoringCriteriaCountAggregateInputType | true
    _avg?: RiskScoringCriteriaAvgAggregateInputType
    _sum?: RiskScoringCriteriaSumAggregateInputType
    _min?: RiskScoringCriteriaMinAggregateInputType
    _max?: RiskScoringCriteriaMaxAggregateInputType
  }

  export type RiskScoringCriteriaGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    weight: number
    maxPoints: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RiskScoringCriteriaCountAggregateOutputType | null
    _avg: RiskScoringCriteriaAvgAggregateOutputType | null
    _sum: RiskScoringCriteriaSumAggregateOutputType | null
    _min: RiskScoringCriteriaMinAggregateOutputType | null
    _max: RiskScoringCriteriaMaxAggregateOutputType | null
  }

  type GetRiskScoringCriteriaGroupByPayload<T extends RiskScoringCriteriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskScoringCriteriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskScoringCriteriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskScoringCriteriaGroupByOutputType[P]>
            : GetScalarType<T[P], RiskScoringCriteriaGroupByOutputType[P]>
        }
      >
    >


  export type RiskScoringCriteriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    weight?: boolean
    maxPoints?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["riskScoringCriteria"]>

  export type RiskScoringCriteriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    weight?: boolean
    maxPoints?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["riskScoringCriteria"]>

  export type RiskScoringCriteriaSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    weight?: boolean
    maxPoints?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RiskScoringCriteriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskScoringCriteria"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      weight: number
      maxPoints: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskScoringCriteria"]>
    composites: {}
  }

  type RiskScoringCriteriaGetPayload<S extends boolean | null | undefined | RiskScoringCriteriaDefaultArgs> = $Result.GetResult<Prisma.$RiskScoringCriteriaPayload, S>

  type RiskScoringCriteriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskScoringCriteriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskScoringCriteriaCountAggregateInputType | true
    }

  export interface RiskScoringCriteriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskScoringCriteria'], meta: { name: 'RiskScoringCriteria' } }
    /**
     * Find zero or one RiskScoringCriteria that matches the filter.
     * @param {RiskScoringCriteriaFindUniqueArgs} args - Arguments to find a RiskScoringCriteria
     * @example
     * // Get one RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskScoringCriteriaFindUniqueArgs>(args: SelectSubset<T, RiskScoringCriteriaFindUniqueArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskScoringCriteria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskScoringCriteriaFindUniqueOrThrowArgs} args - Arguments to find a RiskScoringCriteria
     * @example
     * // Get one RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskScoringCriteriaFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskScoringCriteriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskScoringCriteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoringCriteriaFindFirstArgs} args - Arguments to find a RiskScoringCriteria
     * @example
     * // Get one RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskScoringCriteriaFindFirstArgs>(args?: SelectSubset<T, RiskScoringCriteriaFindFirstArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskScoringCriteria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoringCriteriaFindFirstOrThrowArgs} args - Arguments to find a RiskScoringCriteria
     * @example
     * // Get one RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskScoringCriteriaFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskScoringCriteriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskScoringCriteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoringCriteriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.findMany()
     * 
     * // Get first 10 RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskScoringCriteriaWithIdOnly = await prisma.riskScoringCriteria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskScoringCriteriaFindManyArgs>(args?: SelectSubset<T, RiskScoringCriteriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskScoringCriteria.
     * @param {RiskScoringCriteriaCreateArgs} args - Arguments to create a RiskScoringCriteria.
     * @example
     * // Create one RiskScoringCriteria
     * const RiskScoringCriteria = await prisma.riskScoringCriteria.create({
     *   data: {
     *     // ... data to create a RiskScoringCriteria
     *   }
     * })
     * 
     */
    create<T extends RiskScoringCriteriaCreateArgs>(args: SelectSubset<T, RiskScoringCriteriaCreateArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskScoringCriteria.
     * @param {RiskScoringCriteriaCreateManyArgs} args - Arguments to create many RiskScoringCriteria.
     * @example
     * // Create many RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskScoringCriteriaCreateManyArgs>(args?: SelectSubset<T, RiskScoringCriteriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskScoringCriteria and returns the data saved in the database.
     * @param {RiskScoringCriteriaCreateManyAndReturnArgs} args - Arguments to create many RiskScoringCriteria.
     * @example
     * // Create many RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskScoringCriteria and only return the `id`
     * const riskScoringCriteriaWithIdOnly = await prisma.riskScoringCriteria.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskScoringCriteriaCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskScoringCriteriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskScoringCriteria.
     * @param {RiskScoringCriteriaDeleteArgs} args - Arguments to delete one RiskScoringCriteria.
     * @example
     * // Delete one RiskScoringCriteria
     * const RiskScoringCriteria = await prisma.riskScoringCriteria.delete({
     *   where: {
     *     // ... filter to delete one RiskScoringCriteria
     *   }
     * })
     * 
     */
    delete<T extends RiskScoringCriteriaDeleteArgs>(args: SelectSubset<T, RiskScoringCriteriaDeleteArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskScoringCriteria.
     * @param {RiskScoringCriteriaUpdateArgs} args - Arguments to update one RiskScoringCriteria.
     * @example
     * // Update one RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskScoringCriteriaUpdateArgs>(args: SelectSubset<T, RiskScoringCriteriaUpdateArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskScoringCriteria.
     * @param {RiskScoringCriteriaDeleteManyArgs} args - Arguments to filter RiskScoringCriteria to delete.
     * @example
     * // Delete a few RiskScoringCriteria
     * const { count } = await prisma.riskScoringCriteria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskScoringCriteriaDeleteManyArgs>(args?: SelectSubset<T, RiskScoringCriteriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskScoringCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoringCriteriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskScoringCriteriaUpdateManyArgs>(args: SelectSubset<T, RiskScoringCriteriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskScoringCriteria.
     * @param {RiskScoringCriteriaUpsertArgs} args - Arguments to update or create a RiskScoringCriteria.
     * @example
     * // Update or create a RiskScoringCriteria
     * const riskScoringCriteria = await prisma.riskScoringCriteria.upsert({
     *   create: {
     *     // ... data to create a RiskScoringCriteria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskScoringCriteria we want to update
     *   }
     * })
     */
    upsert<T extends RiskScoringCriteriaUpsertArgs>(args: SelectSubset<T, RiskScoringCriteriaUpsertArgs<ExtArgs>>): Prisma__RiskScoringCriteriaClient<$Result.GetResult<Prisma.$RiskScoringCriteriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskScoringCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoringCriteriaCountArgs} args - Arguments to filter RiskScoringCriteria to count.
     * @example
     * // Count the number of RiskScoringCriteria
     * const count = await prisma.riskScoringCriteria.count({
     *   where: {
     *     // ... the filter for the RiskScoringCriteria we want to count
     *   }
     * })
    **/
    count<T extends RiskScoringCriteriaCountArgs>(
      args?: Subset<T, RiskScoringCriteriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskScoringCriteriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskScoringCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoringCriteriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskScoringCriteriaAggregateArgs>(args: Subset<T, RiskScoringCriteriaAggregateArgs>): Prisma.PrismaPromise<GetRiskScoringCriteriaAggregateType<T>>

    /**
     * Group by RiskScoringCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoringCriteriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskScoringCriteriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskScoringCriteriaGroupByArgs['orderBy'] }
        : { orderBy?: RiskScoringCriteriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskScoringCriteriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskScoringCriteriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskScoringCriteria model
   */
  readonly fields: RiskScoringCriteriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskScoringCriteria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskScoringCriteriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskScoringCriteria model
   */ 
  interface RiskScoringCriteriaFieldRefs {
    readonly id: FieldRef<"RiskScoringCriteria", 'String'>
    readonly name: FieldRef<"RiskScoringCriteria", 'String'>
    readonly description: FieldRef<"RiskScoringCriteria", 'String'>
    readonly category: FieldRef<"RiskScoringCriteria", 'String'>
    readonly weight: FieldRef<"RiskScoringCriteria", 'Float'>
    readonly maxPoints: FieldRef<"RiskScoringCriteria", 'Int'>
    readonly isActive: FieldRef<"RiskScoringCriteria", 'Boolean'>
    readonly createdAt: FieldRef<"RiskScoringCriteria", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskScoringCriteria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskScoringCriteria findUnique
   */
  export type RiskScoringCriteriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * Filter, which RiskScoringCriteria to fetch.
     */
    where: RiskScoringCriteriaWhereUniqueInput
  }

  /**
   * RiskScoringCriteria findUniqueOrThrow
   */
  export type RiskScoringCriteriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * Filter, which RiskScoringCriteria to fetch.
     */
    where: RiskScoringCriteriaWhereUniqueInput
  }

  /**
   * RiskScoringCriteria findFirst
   */
  export type RiskScoringCriteriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * Filter, which RiskScoringCriteria to fetch.
     */
    where?: RiskScoringCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScoringCriteria to fetch.
     */
    orderBy?: RiskScoringCriteriaOrderByWithRelationInput | RiskScoringCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskScoringCriteria.
     */
    cursor?: RiskScoringCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScoringCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScoringCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskScoringCriteria.
     */
    distinct?: RiskScoringCriteriaScalarFieldEnum | RiskScoringCriteriaScalarFieldEnum[]
  }

  /**
   * RiskScoringCriteria findFirstOrThrow
   */
  export type RiskScoringCriteriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * Filter, which RiskScoringCriteria to fetch.
     */
    where?: RiskScoringCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScoringCriteria to fetch.
     */
    orderBy?: RiskScoringCriteriaOrderByWithRelationInput | RiskScoringCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskScoringCriteria.
     */
    cursor?: RiskScoringCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScoringCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScoringCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskScoringCriteria.
     */
    distinct?: RiskScoringCriteriaScalarFieldEnum | RiskScoringCriteriaScalarFieldEnum[]
  }

  /**
   * RiskScoringCriteria findMany
   */
  export type RiskScoringCriteriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * Filter, which RiskScoringCriteria to fetch.
     */
    where?: RiskScoringCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScoringCriteria to fetch.
     */
    orderBy?: RiskScoringCriteriaOrderByWithRelationInput | RiskScoringCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskScoringCriteria.
     */
    cursor?: RiskScoringCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScoringCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScoringCriteria.
     */
    skip?: number
    distinct?: RiskScoringCriteriaScalarFieldEnum | RiskScoringCriteriaScalarFieldEnum[]
  }

  /**
   * RiskScoringCriteria create
   */
  export type RiskScoringCriteriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * The data needed to create a RiskScoringCriteria.
     */
    data: XOR<RiskScoringCriteriaCreateInput, RiskScoringCriteriaUncheckedCreateInput>
  }

  /**
   * RiskScoringCriteria createMany
   */
  export type RiskScoringCriteriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskScoringCriteria.
     */
    data: RiskScoringCriteriaCreateManyInput | RiskScoringCriteriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskScoringCriteria createManyAndReturn
   */
  export type RiskScoringCriteriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskScoringCriteria.
     */
    data: RiskScoringCriteriaCreateManyInput | RiskScoringCriteriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskScoringCriteria update
   */
  export type RiskScoringCriteriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * The data needed to update a RiskScoringCriteria.
     */
    data: XOR<RiskScoringCriteriaUpdateInput, RiskScoringCriteriaUncheckedUpdateInput>
    /**
     * Choose, which RiskScoringCriteria to update.
     */
    where: RiskScoringCriteriaWhereUniqueInput
  }

  /**
   * RiskScoringCriteria updateMany
   */
  export type RiskScoringCriteriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskScoringCriteria.
     */
    data: XOR<RiskScoringCriteriaUpdateManyMutationInput, RiskScoringCriteriaUncheckedUpdateManyInput>
    /**
     * Filter which RiskScoringCriteria to update
     */
    where?: RiskScoringCriteriaWhereInput
  }

  /**
   * RiskScoringCriteria upsert
   */
  export type RiskScoringCriteriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * The filter to search for the RiskScoringCriteria to update in case it exists.
     */
    where: RiskScoringCriteriaWhereUniqueInput
    /**
     * In case the RiskScoringCriteria found by the `where` argument doesn't exist, create a new RiskScoringCriteria with this data.
     */
    create: XOR<RiskScoringCriteriaCreateInput, RiskScoringCriteriaUncheckedCreateInput>
    /**
     * In case the RiskScoringCriteria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskScoringCriteriaUpdateInput, RiskScoringCriteriaUncheckedUpdateInput>
  }

  /**
   * RiskScoringCriteria delete
   */
  export type RiskScoringCriteriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
    /**
     * Filter which RiskScoringCriteria to delete.
     */
    where: RiskScoringCriteriaWhereUniqueInput
  }

  /**
   * RiskScoringCriteria deleteMany
   */
  export type RiskScoringCriteriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskScoringCriteria to delete
     */
    where?: RiskScoringCriteriaWhereInput
  }

  /**
   * RiskScoringCriteria without action
   */
  export type RiskScoringCriteriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScoringCriteria
     */
    select?: RiskScoringCriteriaSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    legalName: 'legalName',
    dbaName: 'dbaName',
    taxId: 'taxId',
    dunsNumber: 'dunsNumber',
    website: 'website',
    description: 'description',
    category: 'category',
    tier: 'tier',
    status: 'status',
    riskScore: 'riskScore',
    riskLevel: 'riskLevel',
    primaryContactName: 'primaryContactName',
    primaryContactEmail: 'primaryContactEmail',
    primaryContactPhone: 'primaryContactPhone',
    address: 'address',
    dataAccessLevel: 'dataAccessLevel',
    phiAccess: 'phiAccess',
    piiAccess: 'piiAccess',
    onboardingDate: 'onboardingDate',
    lastReviewDate: 'lastReviewDate',
    nextReviewDate: 'nextReviewDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const AssessmentScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    type: 'type',
    status: 'status',
    dueDate: 'dueDate',
    completedDate: 'completedDate',
    score: 'score',
    maxScore: 'maxScore',
    passThreshold: 'passThreshold',
    passed: 'passed',
    reviewer: 'reviewer',
    reviewerEmail: 'reviewerEmail',
    findings: 'findings',
    recommendations: 'recommendations',
    attachments: 'attachments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type AssessmentScalarFieldEnum = (typeof AssessmentScalarFieldEnum)[keyof typeof AssessmentScalarFieldEnum]


  export const QuestionnaireTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    type: 'type',
    description: 'description',
    sections: 'sections',
    totalQuestions: 'totalQuestions',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionnaireTemplateScalarFieldEnum = (typeof QuestionnaireTemplateScalarFieldEnum)[keyof typeof QuestionnaireTemplateScalarFieldEnum]


  export const QuestionnaireResponseScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    templateId: 'templateId',
    status: 'status',
    responses: 'responses',
    score: 'score',
    maxScore: 'maxScore',
    percentComplete: 'percentComplete',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    reviewNotes: 'reviewNotes',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionnaireResponseScalarFieldEnum = (typeof QuestionnaireResponseScalarFieldEnum)[keyof typeof QuestionnaireResponseScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    contractNumber: 'contractNumber',
    type: 'type',
    status: 'status',
    title: 'title',
    description: 'description',
    effectiveDate: 'effectiveDate',
    expirationDate: 'expirationDate',
    autoRenewal: 'autoRenewal',
    renewalTermMonths: 'renewalTermMonths',
    terminationNoticeDays: 'terminationNoticeDays',
    value: 'value',
    currency: 'currency',
    paymentTerms: 'paymentTerms',
    slaTerms: 'slaTerms',
    securityRequirements: 'securityRequirements',
    dataRetentionDays: 'dataRetentionDays',
    liabilityLimit: 'liabilityLimit',
    indemnification: 'indemnification',
    insuranceRequired: 'insuranceRequired',
    insuranceMinimum: 'insuranceMinimum',
    documentUrl: 'documentUrl',
    signedDate: 'signedDate',
    signedBy: 'signedBy',
    counterSignedDate: 'counterSignedDate',
    counterSignedBy: 'counterSignedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const ContractAmendmentScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    amendmentNumber: 'amendmentNumber',
    title: 'title',
    description: 'description',
    effectiveDate: 'effectiveDate',
    documentUrl: 'documentUrl',
    signedDate: 'signedDate',
    signedBy: 'signedBy',
    createdAt: 'createdAt'
  };

  export type ContractAmendmentScalarFieldEnum = (typeof ContractAmendmentScalarFieldEnum)[keyof typeof ContractAmendmentScalarFieldEnum]


  export const ContractRenewalScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    previousEndDate: 'previousEndDate',
    newEndDate: 'newEndDate',
    renewalDate: 'renewalDate',
    renewedBy: 'renewedBy',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ContractRenewalScalarFieldEnum = (typeof ContractRenewalScalarFieldEnum)[keyof typeof ContractRenewalScalarFieldEnum]


  export const CertificationScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    type: 'type',
    name: 'name',
    issuingBody: 'issuingBody',
    certificationNumber: 'certificationNumber',
    scope: 'scope',
    issueDate: 'issueDate',
    expirationDate: 'expirationDate',
    status: 'status',
    verified: 'verified',
    verifiedDate: 'verifiedDate',
    verifiedBy: 'verifiedBy',
    documentUrl: 'documentUrl',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificationScalarFieldEnum = (typeof CertificationScalarFieldEnum)[keyof typeof CertificationScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    type: 'type',
    severity: 'severity',
    status: 'status',
    title: 'title',
    description: 'description',
    discoveredAt: 'discoveredAt',
    reportedAt: 'reportedAt',
    resolvedAt: 'resolvedAt',
    affectedSystems: 'affectedSystems',
    affectedDataTypes: 'affectedDataTypes',
    recordsAffected: 'recordsAffected',
    phiInvolved: 'phiInvolved',
    piiInvolved: 'piiInvolved',
    rootCause: 'rootCause',
    immediateActions: 'immediateActions',
    correctiveActions: 'correctiveActions',
    preventiveActions: 'preventiveActions',
    notificationRequired: 'notificationRequired',
    notifiedParties: 'notifiedParties',
    notificationDate: 'notificationDate',
    regulatoryReportRequired: 'regulatoryReportRequired',
    regulatoryReportDate: 'regulatoryReportDate',
    lessonLearned: 'lessonLearned',
    attachments: 'attachments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const RemediationTaskScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    incidentId: 'incidentId',
    type: 'type',
    priority: 'priority',
    status: 'status',
    title: 'title',
    description: 'description',
    requirement: 'requirement',
    controlReference: 'controlReference',
    dueDate: 'dueDate',
    completedDate: 'completedDate',
    assignedTo: 'assignedTo',
    assignedToEmail: 'assignedToEmail',
    evidence: 'evidence',
    verifiedBy: 'verifiedBy',
    verifiedDate: 'verifiedDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type RemediationTaskScalarFieldEnum = (typeof RemediationTaskScalarFieldEnum)[keyof typeof RemediationTaskScalarFieldEnum]


  export const VendorAuditLogScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    userId: 'userId',
    userEmail: 'userEmail',
    userRole: 'userRole',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    oldValues: 'oldValues',
    newValues: 'newValues',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type VendorAuditLogScalarFieldEnum = (typeof VendorAuditLogScalarFieldEnum)[keyof typeof VendorAuditLogScalarFieldEnum]


  export const RiskScoringCriteriaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    weight: 'weight',
    maxPoints: 'maxPoints',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskScoringCriteriaScalarFieldEnum = (typeof RiskScoringCriteriaScalarFieldEnum)[keyof typeof RiskScoringCriteriaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'VendorCategory'
   */
  export type EnumVendorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorCategory'>
    


  /**
   * Reference to a field of type 'VendorCategory[]'
   */
  export type ListEnumVendorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorCategory[]'>
    


  /**
   * Reference to a field of type 'VendorTier'
   */
  export type EnumVendorTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorTier'>
    


  /**
   * Reference to a field of type 'VendorTier[]'
   */
  export type ListEnumVendorTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorTier[]'>
    


  /**
   * Reference to a field of type 'VendorStatus'
   */
  export type EnumVendorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorStatus'>
    


  /**
   * Reference to a field of type 'VendorStatus[]'
   */
  export type ListEnumVendorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DataAccessLevel'
   */
  export type EnumDataAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataAccessLevel'>
    


  /**
   * Reference to a field of type 'DataAccessLevel[]'
   */
  export type ListEnumDataAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataAccessLevel[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AssessmentType'
   */
  export type EnumAssessmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentType'>
    


  /**
   * Reference to a field of type 'AssessmentType[]'
   */
  export type ListEnumAssessmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentType[]'>
    


  /**
   * Reference to a field of type 'AssessmentStatus'
   */
  export type EnumAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentStatus'>
    


  /**
   * Reference to a field of type 'AssessmentStatus[]'
   */
  export type ListEnumAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionnaireType'
   */
  export type EnumQuestionnaireTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionnaireType'>
    


  /**
   * Reference to a field of type 'QuestionnaireType[]'
   */
  export type ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionnaireType[]'>
    


  /**
   * Reference to a field of type 'QuestionnaireStatus'
   */
  export type EnumQuestionnaireStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionnaireStatus'>
    


  /**
   * Reference to a field of type 'QuestionnaireStatus[]'
   */
  export type ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionnaireStatus[]'>
    


  /**
   * Reference to a field of type 'ContractType'
   */
  export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


  /**
   * Reference to a field of type 'ContractType[]'
   */
  export type ListEnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType[]'>
    


  /**
   * Reference to a field of type 'ContractStatus'
   */
  export type EnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus'>
    


  /**
   * Reference to a field of type 'ContractStatus[]'
   */
  export type ListEnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CertificationType'
   */
  export type EnumCertificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationType'>
    


  /**
   * Reference to a field of type 'CertificationType[]'
   */
  export type ListEnumCertificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationType[]'>
    


  /**
   * Reference to a field of type 'CertificationStatus'
   */
  export type EnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus'>
    


  /**
   * Reference to a field of type 'CertificationStatus[]'
   */
  export type ListEnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus[]'>
    


  /**
   * Reference to a field of type 'IncidentType'
   */
  export type EnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType'>
    


  /**
   * Reference to a field of type 'IncidentType[]'
   */
  export type ListEnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType[]'>
    


  /**
   * Reference to a field of type 'IncidentSeverity'
   */
  export type EnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity'>
    


  /**
   * Reference to a field of type 'IncidentSeverity[]'
   */
  export type ListEnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity[]'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'RemediationType'
   */
  export type EnumRemediationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RemediationType'>
    


  /**
   * Reference to a field of type 'RemediationType[]'
   */
  export type ListEnumRemediationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RemediationType[]'>
    


  /**
   * Reference to a field of type 'TaskPriority'
   */
  export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


  /**
   * Reference to a field of type 'TaskPriority[]'
   */
  export type ListEnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    legalName?: StringNullableFilter<"Vendor"> | string | null
    dbaName?: StringNullableFilter<"Vendor"> | string | null
    taxId?: StringNullableFilter<"Vendor"> | string | null
    dunsNumber?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    description?: StringNullableFilter<"Vendor"> | string | null
    category?: EnumVendorCategoryFilter<"Vendor"> | $Enums.VendorCategory
    tier?: EnumVendorTierFilter<"Vendor"> | $Enums.VendorTier
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    riskScore?: IntFilter<"Vendor"> | number
    riskLevel?: EnumRiskLevelFilter<"Vendor"> | $Enums.RiskLevel
    primaryContactName?: StringNullableFilter<"Vendor"> | string | null
    primaryContactEmail?: StringNullableFilter<"Vendor"> | string | null
    primaryContactPhone?: StringNullableFilter<"Vendor"> | string | null
    address?: JsonNullableFilter<"Vendor">
    dataAccessLevel?: EnumDataAccessLevelFilter<"Vendor"> | $Enums.DataAccessLevel
    phiAccess?: BoolFilter<"Vendor"> | boolean
    piiAccess?: BoolFilter<"Vendor"> | boolean
    onboardingDate?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    lastReviewDate?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    nextReviewDate?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    notes?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    createdBy?: StringNullableFilter<"Vendor"> | string | null
    updatedBy?: StringNullableFilter<"Vendor"> | string | null
    assessments?: AssessmentListRelationFilter
    contracts?: ContractListRelationFilter
    certifications?: CertificationListRelationFilter
    incidents?: IncidentListRelationFilter
    remediations?: RemediationTaskListRelationFilter
    questionnaires?: QuestionnaireResponseListRelationFilter
    auditLogs?: VendorAuditLogListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    dbaName?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    dunsNumber?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    primaryContactName?: SortOrderInput | SortOrder
    primaryContactEmail?: SortOrderInput | SortOrder
    primaryContactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dataAccessLevel?: SortOrder
    phiAccess?: SortOrder
    piiAccess?: SortOrder
    onboardingDate?: SortOrderInput | SortOrder
    lastReviewDate?: SortOrderInput | SortOrder
    nextReviewDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    assessments?: AssessmentOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    certifications?: CertificationOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    remediations?: RemediationTaskOrderByRelationAggregateInput
    questionnaires?: QuestionnaireResponseOrderByRelationAggregateInput
    auditLogs?: VendorAuditLogOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    legalName?: StringNullableFilter<"Vendor"> | string | null
    dbaName?: StringNullableFilter<"Vendor"> | string | null
    taxId?: StringNullableFilter<"Vendor"> | string | null
    dunsNumber?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    description?: StringNullableFilter<"Vendor"> | string | null
    category?: EnumVendorCategoryFilter<"Vendor"> | $Enums.VendorCategory
    tier?: EnumVendorTierFilter<"Vendor"> | $Enums.VendorTier
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    riskScore?: IntFilter<"Vendor"> | number
    riskLevel?: EnumRiskLevelFilter<"Vendor"> | $Enums.RiskLevel
    primaryContactName?: StringNullableFilter<"Vendor"> | string | null
    primaryContactEmail?: StringNullableFilter<"Vendor"> | string | null
    primaryContactPhone?: StringNullableFilter<"Vendor"> | string | null
    address?: JsonNullableFilter<"Vendor">
    dataAccessLevel?: EnumDataAccessLevelFilter<"Vendor"> | $Enums.DataAccessLevel
    phiAccess?: BoolFilter<"Vendor"> | boolean
    piiAccess?: BoolFilter<"Vendor"> | boolean
    onboardingDate?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    lastReviewDate?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    nextReviewDate?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    notes?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    createdBy?: StringNullableFilter<"Vendor"> | string | null
    updatedBy?: StringNullableFilter<"Vendor"> | string | null
    assessments?: AssessmentListRelationFilter
    contracts?: ContractListRelationFilter
    certifications?: CertificationListRelationFilter
    incidents?: IncidentListRelationFilter
    remediations?: RemediationTaskListRelationFilter
    questionnaires?: QuestionnaireResponseListRelationFilter
    auditLogs?: VendorAuditLogListRelationFilter
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    dbaName?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    dunsNumber?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    primaryContactName?: SortOrderInput | SortOrder
    primaryContactEmail?: SortOrderInput | SortOrder
    primaryContactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dataAccessLevel?: SortOrder
    phiAccess?: SortOrder
    piiAccess?: SortOrder
    onboardingDate?: SortOrderInput | SortOrder
    lastReviewDate?: SortOrderInput | SortOrder
    nextReviewDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    legalName?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    dbaName?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    dunsNumber?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    website?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    description?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    category?: EnumVendorCategoryWithAggregatesFilter<"Vendor"> | $Enums.VendorCategory
    tier?: EnumVendorTierWithAggregatesFilter<"Vendor"> | $Enums.VendorTier
    status?: EnumVendorStatusWithAggregatesFilter<"Vendor"> | $Enums.VendorStatus
    riskScore?: IntWithAggregatesFilter<"Vendor"> | number
    riskLevel?: EnumRiskLevelWithAggregatesFilter<"Vendor"> | $Enums.RiskLevel
    primaryContactName?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    primaryContactEmail?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    primaryContactPhone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: JsonNullableWithAggregatesFilter<"Vendor">
    dataAccessLevel?: EnumDataAccessLevelWithAggregatesFilter<"Vendor"> | $Enums.DataAccessLevel
    phiAccess?: BoolWithAggregatesFilter<"Vendor"> | boolean
    piiAccess?: BoolWithAggregatesFilter<"Vendor"> | boolean
    onboardingDate?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    lastReviewDate?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    nextReviewDate?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
  }

  export type AssessmentWhereInput = {
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    id?: StringFilter<"Assessment"> | string
    vendorId?: StringFilter<"Assessment"> | string
    type?: EnumAssessmentTypeFilter<"Assessment"> | $Enums.AssessmentType
    status?: EnumAssessmentStatusFilter<"Assessment"> | $Enums.AssessmentStatus
    dueDate?: DateTimeNullableFilter<"Assessment"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Assessment"> | Date | string | null
    score?: IntNullableFilter<"Assessment"> | number | null
    maxScore?: IntNullableFilter<"Assessment"> | number | null
    passThreshold?: IntNullableFilter<"Assessment"> | number | null
    passed?: BoolNullableFilter<"Assessment"> | boolean | null
    reviewer?: StringNullableFilter<"Assessment"> | string | null
    reviewerEmail?: StringNullableFilter<"Assessment"> | string | null
    findings?: JsonNullableFilter<"Assessment">
    recommendations?: StringNullableFilter<"Assessment"> | string | null
    attachments?: JsonNullableFilter<"Assessment">
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    createdBy?: StringNullableFilter<"Assessment"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type AssessmentOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    passThreshold?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    reviewer?: SortOrderInput | SortOrder
    reviewerEmail?: SortOrderInput | SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type AssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    vendorId?: StringFilter<"Assessment"> | string
    type?: EnumAssessmentTypeFilter<"Assessment"> | $Enums.AssessmentType
    status?: EnumAssessmentStatusFilter<"Assessment"> | $Enums.AssessmentStatus
    dueDate?: DateTimeNullableFilter<"Assessment"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Assessment"> | Date | string | null
    score?: IntNullableFilter<"Assessment"> | number | null
    maxScore?: IntNullableFilter<"Assessment"> | number | null
    passThreshold?: IntNullableFilter<"Assessment"> | number | null
    passed?: BoolNullableFilter<"Assessment"> | boolean | null
    reviewer?: StringNullableFilter<"Assessment"> | string | null
    reviewerEmail?: StringNullableFilter<"Assessment"> | string | null
    findings?: JsonNullableFilter<"Assessment">
    recommendations?: StringNullableFilter<"Assessment"> | string | null
    attachments?: JsonNullableFilter<"Assessment">
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    createdBy?: StringNullableFilter<"Assessment"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id">

  export type AssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    passThreshold?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    reviewer?: SortOrderInput | SortOrder
    reviewerEmail?: SortOrderInput | SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: AssessmentCountOrderByAggregateInput
    _avg?: AssessmentAvgOrderByAggregateInput
    _max?: AssessmentMaxOrderByAggregateInput
    _min?: AssessmentMinOrderByAggregateInput
    _sum?: AssessmentSumOrderByAggregateInput
  }

  export type AssessmentScalarWhereWithAggregatesInput = {
    AND?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    OR?: AssessmentScalarWhereWithAggregatesInput[]
    NOT?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assessment"> | string
    vendorId?: StringWithAggregatesFilter<"Assessment"> | string
    type?: EnumAssessmentTypeWithAggregatesFilter<"Assessment"> | $Enums.AssessmentType
    status?: EnumAssessmentStatusWithAggregatesFilter<"Assessment"> | $Enums.AssessmentStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"Assessment"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"Assessment"> | Date | string | null
    score?: IntNullableWithAggregatesFilter<"Assessment"> | number | null
    maxScore?: IntNullableWithAggregatesFilter<"Assessment"> | number | null
    passThreshold?: IntNullableWithAggregatesFilter<"Assessment"> | number | null
    passed?: BoolNullableWithAggregatesFilter<"Assessment"> | boolean | null
    reviewer?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    reviewerEmail?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    findings?: JsonNullableWithAggregatesFilter<"Assessment">
    recommendations?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"Assessment">
    createdAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
  }

  export type QuestionnaireTemplateWhereInput = {
    AND?: QuestionnaireTemplateWhereInput | QuestionnaireTemplateWhereInput[]
    OR?: QuestionnaireTemplateWhereInput[]
    NOT?: QuestionnaireTemplateWhereInput | QuestionnaireTemplateWhereInput[]
    id?: StringFilter<"QuestionnaireTemplate"> | string
    name?: StringFilter<"QuestionnaireTemplate"> | string
    version?: StringFilter<"QuestionnaireTemplate"> | string
    type?: EnumQuestionnaireTypeFilter<"QuestionnaireTemplate"> | $Enums.QuestionnaireType
    description?: StringNullableFilter<"QuestionnaireTemplate"> | string | null
    sections?: JsonFilter<"QuestionnaireTemplate">
    totalQuestions?: IntFilter<"QuestionnaireTemplate"> | number
    isActive?: BoolFilter<"QuestionnaireTemplate"> | boolean
    createdAt?: DateTimeFilter<"QuestionnaireTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireTemplate"> | Date | string
    responses?: QuestionnaireResponseListRelationFilter
  }

  export type QuestionnaireTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    sections?: SortOrder
    totalQuestions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responses?: QuestionnaireResponseOrderByRelationAggregateInput
  }

  export type QuestionnaireTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_version?: QuestionnaireTemplateNameVersionCompoundUniqueInput
    AND?: QuestionnaireTemplateWhereInput | QuestionnaireTemplateWhereInput[]
    OR?: QuestionnaireTemplateWhereInput[]
    NOT?: QuestionnaireTemplateWhereInput | QuestionnaireTemplateWhereInput[]
    name?: StringFilter<"QuestionnaireTemplate"> | string
    version?: StringFilter<"QuestionnaireTemplate"> | string
    type?: EnumQuestionnaireTypeFilter<"QuestionnaireTemplate"> | $Enums.QuestionnaireType
    description?: StringNullableFilter<"QuestionnaireTemplate"> | string | null
    sections?: JsonFilter<"QuestionnaireTemplate">
    totalQuestions?: IntFilter<"QuestionnaireTemplate"> | number
    isActive?: BoolFilter<"QuestionnaireTemplate"> | boolean
    createdAt?: DateTimeFilter<"QuestionnaireTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireTemplate"> | Date | string
    responses?: QuestionnaireResponseListRelationFilter
  }, "id" | "name_version">

  export type QuestionnaireTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    sections?: SortOrder
    totalQuestions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionnaireTemplateCountOrderByAggregateInput
    _avg?: QuestionnaireTemplateAvgOrderByAggregateInput
    _max?: QuestionnaireTemplateMaxOrderByAggregateInput
    _min?: QuestionnaireTemplateMinOrderByAggregateInput
    _sum?: QuestionnaireTemplateSumOrderByAggregateInput
  }

  export type QuestionnaireTemplateScalarWhereWithAggregatesInput = {
    AND?: QuestionnaireTemplateScalarWhereWithAggregatesInput | QuestionnaireTemplateScalarWhereWithAggregatesInput[]
    OR?: QuestionnaireTemplateScalarWhereWithAggregatesInput[]
    NOT?: QuestionnaireTemplateScalarWhereWithAggregatesInput | QuestionnaireTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionnaireTemplate"> | string
    name?: StringWithAggregatesFilter<"QuestionnaireTemplate"> | string
    version?: StringWithAggregatesFilter<"QuestionnaireTemplate"> | string
    type?: EnumQuestionnaireTypeWithAggregatesFilter<"QuestionnaireTemplate"> | $Enums.QuestionnaireType
    description?: StringNullableWithAggregatesFilter<"QuestionnaireTemplate"> | string | null
    sections?: JsonWithAggregatesFilter<"QuestionnaireTemplate">
    totalQuestions?: IntWithAggregatesFilter<"QuestionnaireTemplate"> | number
    isActive?: BoolWithAggregatesFilter<"QuestionnaireTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QuestionnaireTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionnaireTemplate"> | Date | string
  }

  export type QuestionnaireResponseWhereInput = {
    AND?: QuestionnaireResponseWhereInput | QuestionnaireResponseWhereInput[]
    OR?: QuestionnaireResponseWhereInput[]
    NOT?: QuestionnaireResponseWhereInput | QuestionnaireResponseWhereInput[]
    id?: StringFilter<"QuestionnaireResponse"> | string
    vendorId?: StringFilter<"QuestionnaireResponse"> | string
    templateId?: StringFilter<"QuestionnaireResponse"> | string
    status?: EnumQuestionnaireStatusFilter<"QuestionnaireResponse"> | $Enums.QuestionnaireStatus
    responses?: JsonNullableFilter<"QuestionnaireResponse">
    score?: IntNullableFilter<"QuestionnaireResponse"> | number | null
    maxScore?: IntNullableFilter<"QuestionnaireResponse"> | number | null
    percentComplete?: IntFilter<"QuestionnaireResponse"> | number
    submittedAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedBy?: StringNullableFilter<"QuestionnaireResponse"> | string | null
    reviewNotes?: StringNullableFilter<"QuestionnaireResponse"> | string | null
    expiresAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"QuestionnaireResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireResponse"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    template?: XOR<QuestionnaireTemplateRelationFilter, QuestionnaireTemplateWhereInput>
  }

  export type QuestionnaireResponseOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    responses?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    percentComplete?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    template?: QuestionnaireTemplateOrderByWithRelationInput
  }

  export type QuestionnaireResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionnaireResponseWhereInput | QuestionnaireResponseWhereInput[]
    OR?: QuestionnaireResponseWhereInput[]
    NOT?: QuestionnaireResponseWhereInput | QuestionnaireResponseWhereInput[]
    vendorId?: StringFilter<"QuestionnaireResponse"> | string
    templateId?: StringFilter<"QuestionnaireResponse"> | string
    status?: EnumQuestionnaireStatusFilter<"QuestionnaireResponse"> | $Enums.QuestionnaireStatus
    responses?: JsonNullableFilter<"QuestionnaireResponse">
    score?: IntNullableFilter<"QuestionnaireResponse"> | number | null
    maxScore?: IntNullableFilter<"QuestionnaireResponse"> | number | null
    percentComplete?: IntFilter<"QuestionnaireResponse"> | number
    submittedAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedBy?: StringNullableFilter<"QuestionnaireResponse"> | string | null
    reviewNotes?: StringNullableFilter<"QuestionnaireResponse"> | string | null
    expiresAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"QuestionnaireResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireResponse"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    template?: XOR<QuestionnaireTemplateRelationFilter, QuestionnaireTemplateWhereInput>
  }, "id">

  export type QuestionnaireResponseOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    responses?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    percentComplete?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionnaireResponseCountOrderByAggregateInput
    _avg?: QuestionnaireResponseAvgOrderByAggregateInput
    _max?: QuestionnaireResponseMaxOrderByAggregateInput
    _min?: QuestionnaireResponseMinOrderByAggregateInput
    _sum?: QuestionnaireResponseSumOrderByAggregateInput
  }

  export type QuestionnaireResponseScalarWhereWithAggregatesInput = {
    AND?: QuestionnaireResponseScalarWhereWithAggregatesInput | QuestionnaireResponseScalarWhereWithAggregatesInput[]
    OR?: QuestionnaireResponseScalarWhereWithAggregatesInput[]
    NOT?: QuestionnaireResponseScalarWhereWithAggregatesInput | QuestionnaireResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionnaireResponse"> | string
    vendorId?: StringWithAggregatesFilter<"QuestionnaireResponse"> | string
    templateId?: StringWithAggregatesFilter<"QuestionnaireResponse"> | string
    status?: EnumQuestionnaireStatusWithAggregatesFilter<"QuestionnaireResponse"> | $Enums.QuestionnaireStatus
    responses?: JsonNullableWithAggregatesFilter<"QuestionnaireResponse">
    score?: IntNullableWithAggregatesFilter<"QuestionnaireResponse"> | number | null
    maxScore?: IntNullableWithAggregatesFilter<"QuestionnaireResponse"> | number | null
    percentComplete?: IntWithAggregatesFilter<"QuestionnaireResponse"> | number
    submittedAt?: DateTimeNullableWithAggregatesFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"QuestionnaireResponse"> | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"QuestionnaireResponse"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"QuestionnaireResponse"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuestionnaireResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionnaireResponse"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    vendorId?: StringFilter<"Contract"> | string
    contractNumber?: StringNullableFilter<"Contract"> | string | null
    type?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    title?: StringFilter<"Contract"> | string
    description?: StringNullableFilter<"Contract"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    autoRenewal?: BoolFilter<"Contract"> | boolean
    renewalTermMonths?: IntNullableFilter<"Contract"> | number | null
    terminationNoticeDays?: IntNullableFilter<"Contract"> | number | null
    value?: FloatNullableFilter<"Contract"> | number | null
    currency?: StringFilter<"Contract"> | string
    paymentTerms?: StringNullableFilter<"Contract"> | string | null
    slaTerms?: JsonNullableFilter<"Contract">
    securityRequirements?: JsonNullableFilter<"Contract">
    dataRetentionDays?: IntNullableFilter<"Contract"> | number | null
    liabilityLimit?: FloatNullableFilter<"Contract"> | number | null
    indemnification?: BoolFilter<"Contract"> | boolean
    insuranceRequired?: BoolFilter<"Contract"> | boolean
    insuranceMinimum?: FloatNullableFilter<"Contract"> | number | null
    documentUrl?: StringNullableFilter<"Contract"> | string | null
    signedDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    signedBy?: StringNullableFilter<"Contract"> | string | null
    counterSignedDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    counterSignedBy?: StringNullableFilter<"Contract"> | string | null
    notes?: StringNullableFilter<"Contract"> | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    createdBy?: StringNullableFilter<"Contract"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    amendments?: ContractAmendmentListRelationFilter
    renewalHistory?: ContractRenewalListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    contractNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    autoRenewal?: SortOrder
    renewalTermMonths?: SortOrderInput | SortOrder
    terminationNoticeDays?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    currency?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    slaTerms?: SortOrderInput | SortOrder
    securityRequirements?: SortOrderInput | SortOrder
    dataRetentionDays?: SortOrderInput | SortOrder
    liabilityLimit?: SortOrderInput | SortOrder
    indemnification?: SortOrder
    insuranceRequired?: SortOrder
    insuranceMinimum?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    signedDate?: SortOrderInput | SortOrder
    signedBy?: SortOrderInput | SortOrder
    counterSignedDate?: SortOrderInput | SortOrder
    counterSignedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    vendor?: VendorOrderByWithRelationInput
    amendments?: ContractAmendmentOrderByRelationAggregateInput
    renewalHistory?: ContractRenewalOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    vendorId?: StringFilter<"Contract"> | string
    contractNumber?: StringNullableFilter<"Contract"> | string | null
    type?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    title?: StringFilter<"Contract"> | string
    description?: StringNullableFilter<"Contract"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    autoRenewal?: BoolFilter<"Contract"> | boolean
    renewalTermMonths?: IntNullableFilter<"Contract"> | number | null
    terminationNoticeDays?: IntNullableFilter<"Contract"> | number | null
    value?: FloatNullableFilter<"Contract"> | number | null
    currency?: StringFilter<"Contract"> | string
    paymentTerms?: StringNullableFilter<"Contract"> | string | null
    slaTerms?: JsonNullableFilter<"Contract">
    securityRequirements?: JsonNullableFilter<"Contract">
    dataRetentionDays?: IntNullableFilter<"Contract"> | number | null
    liabilityLimit?: FloatNullableFilter<"Contract"> | number | null
    indemnification?: BoolFilter<"Contract"> | boolean
    insuranceRequired?: BoolFilter<"Contract"> | boolean
    insuranceMinimum?: FloatNullableFilter<"Contract"> | number | null
    documentUrl?: StringNullableFilter<"Contract"> | string | null
    signedDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    signedBy?: StringNullableFilter<"Contract"> | string | null
    counterSignedDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    counterSignedBy?: StringNullableFilter<"Contract"> | string | null
    notes?: StringNullableFilter<"Contract"> | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    createdBy?: StringNullableFilter<"Contract"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    amendments?: ContractAmendmentListRelationFilter
    renewalHistory?: ContractRenewalListRelationFilter
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    contractNumber?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    autoRenewal?: SortOrder
    renewalTermMonths?: SortOrderInput | SortOrder
    terminationNoticeDays?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    currency?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    slaTerms?: SortOrderInput | SortOrder
    securityRequirements?: SortOrderInput | SortOrder
    dataRetentionDays?: SortOrderInput | SortOrder
    liabilityLimit?: SortOrderInput | SortOrder
    indemnification?: SortOrder
    insuranceRequired?: SortOrder
    insuranceMinimum?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    signedDate?: SortOrderInput | SortOrder
    signedBy?: SortOrderInput | SortOrder
    counterSignedDate?: SortOrderInput | SortOrder
    counterSignedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    vendorId?: StringWithAggregatesFilter<"Contract"> | string
    contractNumber?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    type?: EnumContractTypeWithAggregatesFilter<"Contract"> | $Enums.ContractType
    status?: EnumContractStatusWithAggregatesFilter<"Contract"> | $Enums.ContractStatus
    title?: StringWithAggregatesFilter<"Contract"> | string
    description?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    effectiveDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    expirationDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    autoRenewal?: BoolWithAggregatesFilter<"Contract"> | boolean
    renewalTermMonths?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    terminationNoticeDays?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    value?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    currency?: StringWithAggregatesFilter<"Contract"> | string
    paymentTerms?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    slaTerms?: JsonNullableWithAggregatesFilter<"Contract">
    securityRequirements?: JsonNullableWithAggregatesFilter<"Contract">
    dataRetentionDays?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    liabilityLimit?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    indemnification?: BoolWithAggregatesFilter<"Contract"> | boolean
    insuranceRequired?: BoolWithAggregatesFilter<"Contract"> | boolean
    insuranceMinimum?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    documentUrl?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    signedDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    signedBy?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    counterSignedDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    counterSignedBy?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Contract"> | string | null
  }

  export type ContractAmendmentWhereInput = {
    AND?: ContractAmendmentWhereInput | ContractAmendmentWhereInput[]
    OR?: ContractAmendmentWhereInput[]
    NOT?: ContractAmendmentWhereInput | ContractAmendmentWhereInput[]
    id?: StringFilter<"ContractAmendment"> | string
    contractId?: StringFilter<"ContractAmendment"> | string
    amendmentNumber?: IntFilter<"ContractAmendment"> | number
    title?: StringFilter<"ContractAmendment"> | string
    description?: StringNullableFilter<"ContractAmendment"> | string | null
    effectiveDate?: DateTimeFilter<"ContractAmendment"> | Date | string
    documentUrl?: StringNullableFilter<"ContractAmendment"> | string | null
    signedDate?: DateTimeNullableFilter<"ContractAmendment"> | Date | string | null
    signedBy?: StringNullableFilter<"ContractAmendment"> | string | null
    createdAt?: DateTimeFilter<"ContractAmendment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }

  export type ContractAmendmentOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    amendmentNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    signedDate?: SortOrderInput | SortOrder
    signedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
  }

  export type ContractAmendmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractAmendmentWhereInput | ContractAmendmentWhereInput[]
    OR?: ContractAmendmentWhereInput[]
    NOT?: ContractAmendmentWhereInput | ContractAmendmentWhereInput[]
    contractId?: StringFilter<"ContractAmendment"> | string
    amendmentNumber?: IntFilter<"ContractAmendment"> | number
    title?: StringFilter<"ContractAmendment"> | string
    description?: StringNullableFilter<"ContractAmendment"> | string | null
    effectiveDate?: DateTimeFilter<"ContractAmendment"> | Date | string
    documentUrl?: StringNullableFilter<"ContractAmendment"> | string | null
    signedDate?: DateTimeNullableFilter<"ContractAmendment"> | Date | string | null
    signedBy?: StringNullableFilter<"ContractAmendment"> | string | null
    createdAt?: DateTimeFilter<"ContractAmendment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }, "id">

  export type ContractAmendmentOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    amendmentNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    signedDate?: SortOrderInput | SortOrder
    signedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContractAmendmentCountOrderByAggregateInput
    _avg?: ContractAmendmentAvgOrderByAggregateInput
    _max?: ContractAmendmentMaxOrderByAggregateInput
    _min?: ContractAmendmentMinOrderByAggregateInput
    _sum?: ContractAmendmentSumOrderByAggregateInput
  }

  export type ContractAmendmentScalarWhereWithAggregatesInput = {
    AND?: ContractAmendmentScalarWhereWithAggregatesInput | ContractAmendmentScalarWhereWithAggregatesInput[]
    OR?: ContractAmendmentScalarWhereWithAggregatesInput[]
    NOT?: ContractAmendmentScalarWhereWithAggregatesInput | ContractAmendmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractAmendment"> | string
    contractId?: StringWithAggregatesFilter<"ContractAmendment"> | string
    amendmentNumber?: IntWithAggregatesFilter<"ContractAmendment"> | number
    title?: StringWithAggregatesFilter<"ContractAmendment"> | string
    description?: StringNullableWithAggregatesFilter<"ContractAmendment"> | string | null
    effectiveDate?: DateTimeWithAggregatesFilter<"ContractAmendment"> | Date | string
    documentUrl?: StringNullableWithAggregatesFilter<"ContractAmendment"> | string | null
    signedDate?: DateTimeNullableWithAggregatesFilter<"ContractAmendment"> | Date | string | null
    signedBy?: StringNullableWithAggregatesFilter<"ContractAmendment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContractAmendment"> | Date | string
  }

  export type ContractRenewalWhereInput = {
    AND?: ContractRenewalWhereInput | ContractRenewalWhereInput[]
    OR?: ContractRenewalWhereInput[]
    NOT?: ContractRenewalWhereInput | ContractRenewalWhereInput[]
    id?: StringFilter<"ContractRenewal"> | string
    contractId?: StringFilter<"ContractRenewal"> | string
    previousEndDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    newEndDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    renewalDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    renewedBy?: StringNullableFilter<"ContractRenewal"> | string | null
    notes?: StringNullableFilter<"ContractRenewal"> | string | null
    createdAt?: DateTimeFilter<"ContractRenewal"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }

  export type ContractRenewalOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    previousEndDate?: SortOrder
    newEndDate?: SortOrder
    renewalDate?: SortOrder
    renewedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
  }

  export type ContractRenewalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractRenewalWhereInput | ContractRenewalWhereInput[]
    OR?: ContractRenewalWhereInput[]
    NOT?: ContractRenewalWhereInput | ContractRenewalWhereInput[]
    contractId?: StringFilter<"ContractRenewal"> | string
    previousEndDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    newEndDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    renewalDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    renewedBy?: StringNullableFilter<"ContractRenewal"> | string | null
    notes?: StringNullableFilter<"ContractRenewal"> | string | null
    createdAt?: DateTimeFilter<"ContractRenewal"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }, "id">

  export type ContractRenewalOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    previousEndDate?: SortOrder
    newEndDate?: SortOrder
    renewalDate?: SortOrder
    renewedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContractRenewalCountOrderByAggregateInput
    _max?: ContractRenewalMaxOrderByAggregateInput
    _min?: ContractRenewalMinOrderByAggregateInput
  }

  export type ContractRenewalScalarWhereWithAggregatesInput = {
    AND?: ContractRenewalScalarWhereWithAggregatesInput | ContractRenewalScalarWhereWithAggregatesInput[]
    OR?: ContractRenewalScalarWhereWithAggregatesInput[]
    NOT?: ContractRenewalScalarWhereWithAggregatesInput | ContractRenewalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractRenewal"> | string
    contractId?: StringWithAggregatesFilter<"ContractRenewal"> | string
    previousEndDate?: DateTimeWithAggregatesFilter<"ContractRenewal"> | Date | string
    newEndDate?: DateTimeWithAggregatesFilter<"ContractRenewal"> | Date | string
    renewalDate?: DateTimeWithAggregatesFilter<"ContractRenewal"> | Date | string
    renewedBy?: StringNullableWithAggregatesFilter<"ContractRenewal"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ContractRenewal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContractRenewal"> | Date | string
  }

  export type CertificationWhereInput = {
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    id?: StringFilter<"Certification"> | string
    vendorId?: StringFilter<"Certification"> | string
    type?: EnumCertificationTypeFilter<"Certification"> | $Enums.CertificationType
    name?: StringFilter<"Certification"> | string
    issuingBody?: StringNullableFilter<"Certification"> | string | null
    certificationNumber?: StringNullableFilter<"Certification"> | string | null
    scope?: StringNullableFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    verified?: BoolFilter<"Certification"> | boolean
    verifiedDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    verifiedBy?: StringNullableFilter<"Certification"> | string | null
    documentUrl?: StringNullableFilter<"Certification"> | string | null
    notes?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type CertificationOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    issuingBody?: SortOrderInput | SortOrder
    certificationNumber?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    verified?: SortOrder
    verifiedDate?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type CertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    vendorId?: StringFilter<"Certification"> | string
    type?: EnumCertificationTypeFilter<"Certification"> | $Enums.CertificationType
    name?: StringFilter<"Certification"> | string
    issuingBody?: StringNullableFilter<"Certification"> | string | null
    certificationNumber?: StringNullableFilter<"Certification"> | string | null
    scope?: StringNullableFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    verified?: BoolFilter<"Certification"> | boolean
    verifiedDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    verifiedBy?: StringNullableFilter<"Certification"> | string | null
    documentUrl?: StringNullableFilter<"Certification"> | string | null
    notes?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id">

  export type CertificationOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    issuingBody?: SortOrderInput | SortOrder
    certificationNumber?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    verified?: SortOrder
    verifiedDate?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificationCountOrderByAggregateInput
    _max?: CertificationMaxOrderByAggregateInput
    _min?: CertificationMinOrderByAggregateInput
  }

  export type CertificationScalarWhereWithAggregatesInput = {
    AND?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    OR?: CertificationScalarWhereWithAggregatesInput[]
    NOT?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certification"> | string
    vendorId?: StringWithAggregatesFilter<"Certification"> | string
    type?: EnumCertificationTypeWithAggregatesFilter<"Certification"> | $Enums.CertificationType
    name?: StringWithAggregatesFilter<"Certification"> | string
    issuingBody?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    certificationNumber?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    expirationDate?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    status?: EnumCertificationStatusWithAggregatesFilter<"Certification"> | $Enums.CertificationStatus
    verified?: BoolWithAggregatesFilter<"Certification"> | boolean
    verifiedDate?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    documentUrl?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    vendorId?: StringFilter<"Incident"> | string
    type?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    discoveredAt?: DateTimeFilter<"Incident"> | Date | string
    reportedAt?: DateTimeFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    affectedSystems?: StringNullableListFilter<"Incident">
    affectedDataTypes?: StringNullableListFilter<"Incident">
    recordsAffected?: IntNullableFilter<"Incident"> | number | null
    phiInvolved?: BoolFilter<"Incident"> | boolean
    piiInvolved?: BoolFilter<"Incident"> | boolean
    rootCause?: StringNullableFilter<"Incident"> | string | null
    immediateActions?: StringNullableFilter<"Incident"> | string | null
    correctiveActions?: StringNullableFilter<"Incident"> | string | null
    preventiveActions?: StringNullableFilter<"Incident"> | string | null
    notificationRequired?: BoolFilter<"Incident"> | boolean
    notifiedParties?: StringNullableListFilter<"Incident">
    notificationDate?: DateTimeNullableFilter<"Incident"> | Date | string | null
    regulatoryReportRequired?: BoolFilter<"Incident"> | boolean
    regulatoryReportDate?: DateTimeNullableFilter<"Incident"> | Date | string | null
    lessonLearned?: StringNullableFilter<"Incident"> | string | null
    attachments?: JsonNullableFilter<"Incident">
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    createdBy?: StringNullableFilter<"Incident"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    remediations?: RemediationTaskListRelationFilter
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discoveredAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    affectedSystems?: SortOrder
    affectedDataTypes?: SortOrder
    recordsAffected?: SortOrderInput | SortOrder
    phiInvolved?: SortOrder
    piiInvolved?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    immediateActions?: SortOrderInput | SortOrder
    correctiveActions?: SortOrderInput | SortOrder
    preventiveActions?: SortOrderInput | SortOrder
    notificationRequired?: SortOrder
    notifiedParties?: SortOrder
    notificationDate?: SortOrderInput | SortOrder
    regulatoryReportRequired?: SortOrder
    regulatoryReportDate?: SortOrderInput | SortOrder
    lessonLearned?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    vendor?: VendorOrderByWithRelationInput
    remediations?: RemediationTaskOrderByRelationAggregateInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    vendorId?: StringFilter<"Incident"> | string
    type?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    discoveredAt?: DateTimeFilter<"Incident"> | Date | string
    reportedAt?: DateTimeFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    affectedSystems?: StringNullableListFilter<"Incident">
    affectedDataTypes?: StringNullableListFilter<"Incident">
    recordsAffected?: IntNullableFilter<"Incident"> | number | null
    phiInvolved?: BoolFilter<"Incident"> | boolean
    piiInvolved?: BoolFilter<"Incident"> | boolean
    rootCause?: StringNullableFilter<"Incident"> | string | null
    immediateActions?: StringNullableFilter<"Incident"> | string | null
    correctiveActions?: StringNullableFilter<"Incident"> | string | null
    preventiveActions?: StringNullableFilter<"Incident"> | string | null
    notificationRequired?: BoolFilter<"Incident"> | boolean
    notifiedParties?: StringNullableListFilter<"Incident">
    notificationDate?: DateTimeNullableFilter<"Incident"> | Date | string | null
    regulatoryReportRequired?: BoolFilter<"Incident"> | boolean
    regulatoryReportDate?: DateTimeNullableFilter<"Incident"> | Date | string | null
    lessonLearned?: StringNullableFilter<"Incident"> | string | null
    attachments?: JsonNullableFilter<"Incident">
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    createdBy?: StringNullableFilter<"Incident"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    remediations?: RemediationTaskListRelationFilter
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discoveredAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    affectedSystems?: SortOrder
    affectedDataTypes?: SortOrder
    recordsAffected?: SortOrderInput | SortOrder
    phiInvolved?: SortOrder
    piiInvolved?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    immediateActions?: SortOrderInput | SortOrder
    correctiveActions?: SortOrderInput | SortOrder
    preventiveActions?: SortOrderInput | SortOrder
    notificationRequired?: SortOrder
    notifiedParties?: SortOrder
    notificationDate?: SortOrderInput | SortOrder
    regulatoryReportRequired?: SortOrder
    regulatoryReportDate?: SortOrderInput | SortOrder
    lessonLearned?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _avg?: IncidentAvgOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
    _sum?: IncidentSumOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    vendorId?: StringWithAggregatesFilter<"Incident"> | string
    type?: EnumIncidentTypeWithAggregatesFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityWithAggregatesFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusWithAggregatesFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringWithAggregatesFilter<"Incident"> | string
    description?: StringWithAggregatesFilter<"Incident"> | string
    discoveredAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    reportedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    affectedSystems?: StringNullableListFilter<"Incident">
    affectedDataTypes?: StringNullableListFilter<"Incident">
    recordsAffected?: IntNullableWithAggregatesFilter<"Incident"> | number | null
    phiInvolved?: BoolWithAggregatesFilter<"Incident"> | boolean
    piiInvolved?: BoolWithAggregatesFilter<"Incident"> | boolean
    rootCause?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    immediateActions?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    correctiveActions?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    preventiveActions?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    notificationRequired?: BoolWithAggregatesFilter<"Incident"> | boolean
    notifiedParties?: StringNullableListFilter<"Incident">
    notificationDate?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    regulatoryReportRequired?: BoolWithAggregatesFilter<"Incident"> | boolean
    regulatoryReportDate?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    lessonLearned?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"Incident">
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Incident"> | string | null
  }

  export type RemediationTaskWhereInput = {
    AND?: RemediationTaskWhereInput | RemediationTaskWhereInput[]
    OR?: RemediationTaskWhereInput[]
    NOT?: RemediationTaskWhereInput | RemediationTaskWhereInput[]
    id?: StringFilter<"RemediationTask"> | string
    vendorId?: StringFilter<"RemediationTask"> | string
    incidentId?: StringNullableFilter<"RemediationTask"> | string | null
    type?: EnumRemediationTypeFilter<"RemediationTask"> | $Enums.RemediationType
    priority?: EnumTaskPriorityFilter<"RemediationTask"> | $Enums.TaskPriority
    status?: EnumTaskStatusFilter<"RemediationTask"> | $Enums.TaskStatus
    title?: StringFilter<"RemediationTask"> | string
    description?: StringFilter<"RemediationTask"> | string
    requirement?: StringNullableFilter<"RemediationTask"> | string | null
    controlReference?: StringNullableFilter<"RemediationTask"> | string | null
    dueDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    assignedTo?: StringNullableFilter<"RemediationTask"> | string | null
    assignedToEmail?: StringNullableFilter<"RemediationTask"> | string | null
    evidence?: JsonNullableFilter<"RemediationTask">
    verifiedBy?: StringNullableFilter<"RemediationTask"> | string | null
    verifiedDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    notes?: StringNullableFilter<"RemediationTask"> | string | null
    createdAt?: DateTimeFilter<"RemediationTask"> | Date | string
    updatedAt?: DateTimeFilter<"RemediationTask"> | Date | string
    createdBy?: StringNullableFilter<"RemediationTask"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    incident?: XOR<IncidentNullableRelationFilter, IncidentWhereInput> | null
  }

  export type RemediationTaskOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    incidentId?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirement?: SortOrderInput | SortOrder
    controlReference?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedToEmail?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    vendor?: VendorOrderByWithRelationInput
    incident?: IncidentOrderByWithRelationInput
  }

  export type RemediationTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RemediationTaskWhereInput | RemediationTaskWhereInput[]
    OR?: RemediationTaskWhereInput[]
    NOT?: RemediationTaskWhereInput | RemediationTaskWhereInput[]
    vendorId?: StringFilter<"RemediationTask"> | string
    incidentId?: StringNullableFilter<"RemediationTask"> | string | null
    type?: EnumRemediationTypeFilter<"RemediationTask"> | $Enums.RemediationType
    priority?: EnumTaskPriorityFilter<"RemediationTask"> | $Enums.TaskPriority
    status?: EnumTaskStatusFilter<"RemediationTask"> | $Enums.TaskStatus
    title?: StringFilter<"RemediationTask"> | string
    description?: StringFilter<"RemediationTask"> | string
    requirement?: StringNullableFilter<"RemediationTask"> | string | null
    controlReference?: StringNullableFilter<"RemediationTask"> | string | null
    dueDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    assignedTo?: StringNullableFilter<"RemediationTask"> | string | null
    assignedToEmail?: StringNullableFilter<"RemediationTask"> | string | null
    evidence?: JsonNullableFilter<"RemediationTask">
    verifiedBy?: StringNullableFilter<"RemediationTask"> | string | null
    verifiedDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    notes?: StringNullableFilter<"RemediationTask"> | string | null
    createdAt?: DateTimeFilter<"RemediationTask"> | Date | string
    updatedAt?: DateTimeFilter<"RemediationTask"> | Date | string
    createdBy?: StringNullableFilter<"RemediationTask"> | string | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    incident?: XOR<IncidentNullableRelationFilter, IncidentWhereInput> | null
  }, "id">

  export type RemediationTaskOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    incidentId?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirement?: SortOrderInput | SortOrder
    controlReference?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedToEmail?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: RemediationTaskCountOrderByAggregateInput
    _max?: RemediationTaskMaxOrderByAggregateInput
    _min?: RemediationTaskMinOrderByAggregateInput
  }

  export type RemediationTaskScalarWhereWithAggregatesInput = {
    AND?: RemediationTaskScalarWhereWithAggregatesInput | RemediationTaskScalarWhereWithAggregatesInput[]
    OR?: RemediationTaskScalarWhereWithAggregatesInput[]
    NOT?: RemediationTaskScalarWhereWithAggregatesInput | RemediationTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RemediationTask"> | string
    vendorId?: StringWithAggregatesFilter<"RemediationTask"> | string
    incidentId?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
    type?: EnumRemediationTypeWithAggregatesFilter<"RemediationTask"> | $Enums.RemediationType
    priority?: EnumTaskPriorityWithAggregatesFilter<"RemediationTask"> | $Enums.TaskPriority
    status?: EnumTaskStatusWithAggregatesFilter<"RemediationTask"> | $Enums.TaskStatus
    title?: StringWithAggregatesFilter<"RemediationTask"> | string
    description?: StringWithAggregatesFilter<"RemediationTask"> | string
    requirement?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
    controlReference?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"RemediationTask"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"RemediationTask"> | Date | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
    assignedToEmail?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
    evidence?: JsonNullableWithAggregatesFilter<"RemediationTask">
    verifiedBy?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
    verifiedDate?: DateTimeNullableWithAggregatesFilter<"RemediationTask"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RemediationTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RemediationTask"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"RemediationTask"> | string | null
  }

  export type VendorAuditLogWhereInput = {
    AND?: VendorAuditLogWhereInput | VendorAuditLogWhereInput[]
    OR?: VendorAuditLogWhereInput[]
    NOT?: VendorAuditLogWhereInput | VendorAuditLogWhereInput[]
    id?: StringFilter<"VendorAuditLog"> | string
    vendorId?: StringNullableFilter<"VendorAuditLog"> | string | null
    action?: StringFilter<"VendorAuditLog"> | string
    entityType?: StringFilter<"VendorAuditLog"> | string
    entityId?: StringNullableFilter<"VendorAuditLog"> | string | null
    userId?: StringFilter<"VendorAuditLog"> | string
    userEmail?: StringNullableFilter<"VendorAuditLog"> | string | null
    userRole?: StringNullableFilter<"VendorAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"VendorAuditLog"> | string | null
    userAgent?: StringNullableFilter<"VendorAuditLog"> | string | null
    oldValues?: JsonNullableFilter<"VendorAuditLog">
    newValues?: JsonNullableFilter<"VendorAuditLog">
    metadata?: JsonNullableFilter<"VendorAuditLog">
    createdAt?: DateTimeFilter<"VendorAuditLog"> | Date | string
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
  }

  export type VendorAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorAuditLogWhereInput | VendorAuditLogWhereInput[]
    OR?: VendorAuditLogWhereInput[]
    NOT?: VendorAuditLogWhereInput | VendorAuditLogWhereInput[]
    vendorId?: StringNullableFilter<"VendorAuditLog"> | string | null
    action?: StringFilter<"VendorAuditLog"> | string
    entityType?: StringFilter<"VendorAuditLog"> | string
    entityId?: StringNullableFilter<"VendorAuditLog"> | string | null
    userId?: StringFilter<"VendorAuditLog"> | string
    userEmail?: StringNullableFilter<"VendorAuditLog"> | string | null
    userRole?: StringNullableFilter<"VendorAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"VendorAuditLog"> | string | null
    userAgent?: StringNullableFilter<"VendorAuditLog"> | string | null
    oldValues?: JsonNullableFilter<"VendorAuditLog">
    newValues?: JsonNullableFilter<"VendorAuditLog">
    metadata?: JsonNullableFilter<"VendorAuditLog">
    createdAt?: DateTimeFilter<"VendorAuditLog"> | Date | string
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
  }, "id">

  export type VendorAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VendorAuditLogCountOrderByAggregateInput
    _max?: VendorAuditLogMaxOrderByAggregateInput
    _min?: VendorAuditLogMinOrderByAggregateInput
  }

  export type VendorAuditLogScalarWhereWithAggregatesInput = {
    AND?: VendorAuditLogScalarWhereWithAggregatesInput | VendorAuditLogScalarWhereWithAggregatesInput[]
    OR?: VendorAuditLogScalarWhereWithAggregatesInput[]
    NOT?: VendorAuditLogScalarWhereWithAggregatesInput | VendorAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorAuditLog"> | string
    vendorId?: StringNullableWithAggregatesFilter<"VendorAuditLog"> | string | null
    action?: StringWithAggregatesFilter<"VendorAuditLog"> | string
    entityType?: StringWithAggregatesFilter<"VendorAuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"VendorAuditLog"> | string | null
    userId?: StringWithAggregatesFilter<"VendorAuditLog"> | string
    userEmail?: StringNullableWithAggregatesFilter<"VendorAuditLog"> | string | null
    userRole?: StringNullableWithAggregatesFilter<"VendorAuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"VendorAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"VendorAuditLog"> | string | null
    oldValues?: JsonNullableWithAggregatesFilter<"VendorAuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"VendorAuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"VendorAuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"VendorAuditLog"> | Date | string
  }

  export type RiskScoringCriteriaWhereInput = {
    AND?: RiskScoringCriteriaWhereInput | RiskScoringCriteriaWhereInput[]
    OR?: RiskScoringCriteriaWhereInput[]
    NOT?: RiskScoringCriteriaWhereInput | RiskScoringCriteriaWhereInput[]
    id?: StringFilter<"RiskScoringCriteria"> | string
    name?: StringFilter<"RiskScoringCriteria"> | string
    description?: StringNullableFilter<"RiskScoringCriteria"> | string | null
    category?: StringFilter<"RiskScoringCriteria"> | string
    weight?: FloatFilter<"RiskScoringCriteria"> | number
    maxPoints?: IntFilter<"RiskScoringCriteria"> | number
    isActive?: BoolFilter<"RiskScoringCriteria"> | boolean
    createdAt?: DateTimeFilter<"RiskScoringCriteria"> | Date | string
    updatedAt?: DateTimeFilter<"RiskScoringCriteria"> | Date | string
  }

  export type RiskScoringCriteriaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    weight?: SortOrder
    maxPoints?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoringCriteriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RiskScoringCriteriaWhereInput | RiskScoringCriteriaWhereInput[]
    OR?: RiskScoringCriteriaWhereInput[]
    NOT?: RiskScoringCriteriaWhereInput | RiskScoringCriteriaWhereInput[]
    description?: StringNullableFilter<"RiskScoringCriteria"> | string | null
    category?: StringFilter<"RiskScoringCriteria"> | string
    weight?: FloatFilter<"RiskScoringCriteria"> | number
    maxPoints?: IntFilter<"RiskScoringCriteria"> | number
    isActive?: BoolFilter<"RiskScoringCriteria"> | boolean
    createdAt?: DateTimeFilter<"RiskScoringCriteria"> | Date | string
    updatedAt?: DateTimeFilter<"RiskScoringCriteria"> | Date | string
  }, "id" | "name">

  export type RiskScoringCriteriaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    weight?: SortOrder
    maxPoints?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskScoringCriteriaCountOrderByAggregateInput
    _avg?: RiskScoringCriteriaAvgOrderByAggregateInput
    _max?: RiskScoringCriteriaMaxOrderByAggregateInput
    _min?: RiskScoringCriteriaMinOrderByAggregateInput
    _sum?: RiskScoringCriteriaSumOrderByAggregateInput
  }

  export type RiskScoringCriteriaScalarWhereWithAggregatesInput = {
    AND?: RiskScoringCriteriaScalarWhereWithAggregatesInput | RiskScoringCriteriaScalarWhereWithAggregatesInput[]
    OR?: RiskScoringCriteriaScalarWhereWithAggregatesInput[]
    NOT?: RiskScoringCriteriaScalarWhereWithAggregatesInput | RiskScoringCriteriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskScoringCriteria"> | string
    name?: StringWithAggregatesFilter<"RiskScoringCriteria"> | string
    description?: StringNullableWithAggregatesFilter<"RiskScoringCriteria"> | string | null
    category?: StringWithAggregatesFilter<"RiskScoringCriteria"> | string
    weight?: FloatWithAggregatesFilter<"RiskScoringCriteria"> | number
    maxPoints?: IntWithAggregatesFilter<"RiskScoringCriteria"> | number
    isActive?: BoolWithAggregatesFilter<"RiskScoringCriteria"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RiskScoringCriteria"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskScoringCriteria"> | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentCreateNestedManyWithoutVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    certifications?: CertificationCreateNestedManyWithoutVendorInput
    incidents?: IncidentCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentUncheckedCreateNestedManyWithoutVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutVendorInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUpdateManyWithoutVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUncheckedUpdateManyWithoutVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentCreateInput = {
    id?: string
    type: $Enums.AssessmentType
    status?: $Enums.AssessmentStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    score?: number | null
    maxScore?: number | null
    passThreshold?: number | null
    passed?: boolean | null
    reviewer?: string | null
    reviewerEmail?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutAssessmentsInput
  }

  export type AssessmentUncheckedCreateInput = {
    id?: string
    vendorId: string
    type: $Enums.AssessmentType
    status?: $Enums.AssessmentStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    score?: number | null
    maxScore?: number | null
    passThreshold?: number | null
    passed?: boolean | null
    reviewer?: string | null
    reviewerEmail?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    passThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type AssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    passThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentCreateManyInput = {
    id?: string
    vendorId: string
    type: $Enums.AssessmentType
    status?: $Enums.AssessmentStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    score?: number | null
    maxScore?: number | null
    passThreshold?: number | null
    passed?: boolean | null
    reviewer?: string | null
    reviewerEmail?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    passThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    passThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionnaireTemplateCreateInput = {
    id?: string
    name: string
    version: string
    type: $Enums.QuestionnaireType
    description?: string | null
    sections: JsonNullValueInput | InputJsonValue
    totalQuestions: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionnaireResponseCreateNestedManyWithoutTemplateInput
  }

  export type QuestionnaireTemplateUncheckedCreateInput = {
    id?: string
    name: string
    version: string
    type: $Enums.QuestionnaireType
    description?: string | null
    sections: JsonNullValueInput | InputJsonValue
    totalQuestions: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionnaireResponseUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type QuestionnaireTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionnaireTypeFieldUpdateOperationsInput | $Enums.QuestionnaireType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionnaireResponseUpdateManyWithoutTemplateNestedInput
  }

  export type QuestionnaireTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionnaireTypeFieldUpdateOperationsInput | $Enums.QuestionnaireType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionnaireResponseUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type QuestionnaireTemplateCreateManyInput = {
    id?: string
    name: string
    version: string
    type: $Enums.QuestionnaireType
    description?: string | null
    sections: JsonNullValueInput | InputJsonValue
    totalQuestions: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionnaireTypeFieldUpdateOperationsInput | $Enums.QuestionnaireType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionnaireTypeFieldUpdateOperationsInput | $Enums.QuestionnaireType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireResponseCreateInput = {
    id?: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutQuestionnairesInput
    template: QuestionnaireTemplateCreateNestedOneWithoutResponsesInput
  }

  export type QuestionnaireResponseUncheckedCreateInput = {
    id?: string
    vendorId: string
    templateId: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutQuestionnairesNestedInput
    template?: QuestionnaireTemplateUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type QuestionnaireResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireResponseCreateManyInput = {
    id?: string
    vendorId: string
    templateId: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    id?: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutContractsInput
    amendments?: ContractAmendmentCreateNestedManyWithoutContractInput
    renewalHistory?: ContractRenewalCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    vendorId: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    amendments?: ContractAmendmentUncheckedCreateNestedManyWithoutContractInput
    renewalHistory?: ContractRenewalUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    amendments?: ContractAmendmentUpdateManyWithoutContractNestedInput
    renewalHistory?: ContractRenewalUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    amendments?: ContractAmendmentUncheckedUpdateManyWithoutContractNestedInput
    renewalHistory?: ContractRenewalUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    id?: string
    vendorId: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractAmendmentCreateInput = {
    id?: string
    amendmentNumber: number
    title: string
    description?: string | null
    effectiveDate: Date | string
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    createdAt?: Date | string
    contract: ContractCreateNestedOneWithoutAmendmentsInput
  }

  export type ContractAmendmentUncheckedCreateInput = {
    id?: string
    contractId: string
    amendmentNumber: number
    title: string
    description?: string | null
    effectiveDate: Date | string
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    createdAt?: Date | string
  }

  export type ContractAmendmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amendmentNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutAmendmentsNestedInput
  }

  export type ContractAmendmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    amendmentNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractAmendmentCreateManyInput = {
    id?: string
    contractId: string
    amendmentNumber: number
    title: string
    description?: string | null
    effectiveDate: Date | string
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    createdAt?: Date | string
  }

  export type ContractAmendmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amendmentNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractAmendmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    amendmentNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractRenewalCreateInput = {
    id?: string
    previousEndDate: Date | string
    newEndDate: Date | string
    renewalDate?: Date | string
    renewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    contract: ContractCreateNestedOneWithoutRenewalHistoryInput
  }

  export type ContractRenewalUncheckedCreateInput = {
    id?: string
    contractId: string
    previousEndDate: Date | string
    newEndDate: Date | string
    renewalDate?: Date | string
    renewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContractRenewalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutRenewalHistoryNestedInput
  }

  export type ContractRenewalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    previousEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractRenewalCreateManyInput = {
    id?: string
    contractId: string
    previousEndDate: Date | string
    newEndDate: Date | string
    renewalDate?: Date | string
    renewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContractRenewalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractRenewalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    previousEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateInput = {
    id?: string
    type: $Enums.CertificationType
    name: string
    issuingBody?: string | null
    certificationNumber?: string | null
    scope?: string | null
    issueDate?: Date | string | null
    expirationDate?: Date | string | null
    status?: $Enums.CertificationStatus
    verified?: boolean
    verifiedDate?: Date | string | null
    verifiedBy?: string | null
    documentUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateInput = {
    id?: string
    vendorId: string
    type: $Enums.CertificationType
    name: string
    issuingBody?: string | null
    certificationNumber?: string | null
    scope?: string | null
    issueDate?: Date | string | null
    expirationDate?: Date | string | null
    status?: $Enums.CertificationStatus
    verified?: boolean
    verifiedDate?: Date | string | null
    verifiedBy?: string | null
    documentUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificationTypeFieldUpdateOperationsInput | $Enums.CertificationType
    name?: StringFieldUpdateOperationsInput | string
    issuingBody?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificationTypeFieldUpdateOperationsInput | $Enums.CertificationType
    name?: StringFieldUpdateOperationsInput | string
    issuingBody?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyInput = {
    id?: string
    vendorId: string
    type: $Enums.CertificationType
    name: string
    issuingBody?: string | null
    certificationNumber?: string | null
    scope?: string | null
    issueDate?: Date | string | null
    expirationDate?: Date | string | null
    status?: $Enums.CertificationStatus
    verified?: boolean
    verifiedDate?: Date | string | null
    verifiedBy?: string | null
    documentUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificationTypeFieldUpdateOperationsInput | $Enums.CertificationType
    name?: StringFieldUpdateOperationsInput | string
    issuingBody?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificationTypeFieldUpdateOperationsInput | $Enums.CertificationType
    name?: StringFieldUpdateOperationsInput | string
    issuingBody?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutIncidentsInput
    remediations?: RemediationTaskCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    vendorId: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutIncidentsNestedInput
    remediations?: RemediationTaskUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    remediations?: RemediationTaskUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentCreateManyInput = {
    id?: string
    vendorId: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemediationTaskCreateInput = {
    id?: string
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutRemediationsInput
    incident?: IncidentCreateNestedOneWithoutRemediationsInput
  }

  export type RemediationTaskUncheckedCreateInput = {
    id?: string
    vendorId: string
    incidentId?: string | null
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RemediationTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutRemediationsNestedInput
    incident?: IncidentUpdateOneWithoutRemediationsNestedInput
  }

  export type RemediationTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemediationTaskCreateManyInput = {
    id?: string
    vendorId: string
    incidentId?: string | null
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RemediationTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemediationTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorAuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    userId: string
    userEmail?: string | null
    userRole?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutAuditLogsInput
  }

  export type VendorAuditLogUncheckedCreateInput = {
    id?: string
    vendorId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    userId: string
    userEmail?: string | null
    userRole?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VendorAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutAuditLogsNestedInput
  }

  export type VendorAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAuditLogCreateManyInput = {
    id?: string
    vendorId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    userId: string
    userEmail?: string | null
    userRole?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VendorAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoringCriteriaCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    weight?: number
    maxPoints: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskScoringCriteriaUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    weight?: number
    maxPoints: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskScoringCriteriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    maxPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoringCriteriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    maxPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoringCriteriaCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    weight?: number
    maxPoints: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskScoringCriteriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    maxPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoringCriteriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    maxPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumVendorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryFilter<$PrismaModel> | $Enums.VendorCategory
  }

  export type EnumVendorTierFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorTier | EnumVendorTierFieldRefInput<$PrismaModel>
    in?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorTierFilter<$PrismaModel> | $Enums.VendorTier
  }

  export type EnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumDataAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DataAccessLevel | EnumDataAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDataAccessLevelFilter<$PrismaModel> | $Enums.DataAccessLevel
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AssessmentListRelationFilter = {
    every?: AssessmentWhereInput
    some?: AssessmentWhereInput
    none?: AssessmentWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type CertificationListRelationFilter = {
    every?: CertificationWhereInput
    some?: CertificationWhereInput
    none?: CertificationWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type RemediationTaskListRelationFilter = {
    every?: RemediationTaskWhereInput
    some?: RemediationTaskWhereInput
    none?: RemediationTaskWhereInput
  }

  export type QuestionnaireResponseListRelationFilter = {
    every?: QuestionnaireResponseWhereInput
    some?: QuestionnaireResponseWhereInput
    none?: QuestionnaireResponseWhereInput
  }

  export type VendorAuditLogListRelationFilter = {
    every?: VendorAuditLogWhereInput
    some?: VendorAuditLogWhereInput
    none?: VendorAuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RemediationTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionnaireResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    dbaName?: SortOrder
    taxId?: SortOrder
    dunsNumber?: SortOrder
    website?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    primaryContactName?: SortOrder
    primaryContactEmail?: SortOrder
    primaryContactPhone?: SortOrder
    address?: SortOrder
    dataAccessLevel?: SortOrder
    phiAccess?: SortOrder
    piiAccess?: SortOrder
    onboardingDate?: SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    dbaName?: SortOrder
    taxId?: SortOrder
    dunsNumber?: SortOrder
    website?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    primaryContactName?: SortOrder
    primaryContactEmail?: SortOrder
    primaryContactPhone?: SortOrder
    dataAccessLevel?: SortOrder
    phiAccess?: SortOrder
    piiAccess?: SortOrder
    onboardingDate?: SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    dbaName?: SortOrder
    taxId?: SortOrder
    dunsNumber?: SortOrder
    website?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    riskLevel?: SortOrder
    primaryContactName?: SortOrder
    primaryContactEmail?: SortOrder
    primaryContactPhone?: SortOrder
    dataAccessLevel?: SortOrder
    phiAccess?: SortOrder
    piiAccess?: SortOrder
    onboardingDate?: SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumVendorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VendorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorCategoryFilter<$PrismaModel>
    _max?: NestedEnumVendorCategoryFilter<$PrismaModel>
  }

  export type EnumVendorTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorTier | EnumVendorTierFieldRefInput<$PrismaModel>
    in?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorTierWithAggregatesFilter<$PrismaModel> | $Enums.VendorTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorTierFilter<$PrismaModel>
    _max?: NestedEnumVendorTierFilter<$PrismaModel>
  }

  export type EnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumDataAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataAccessLevel | EnumDataAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDataAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.DataAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumDataAccessLevelFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAssessmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentTypeFilter<$PrismaModel> | $Enums.AssessmentType
  }

  export type EnumAssessmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusFilter<$PrismaModel> | $Enums.AssessmentStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type AssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    passThreshold?: SortOrder
    passed?: SortOrder
    reviewer?: SortOrder
    reviewerEmail?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AssessmentAvgOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
    passThreshold?: SortOrder
  }

  export type AssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    passThreshold?: SortOrder
    passed?: SortOrder
    reviewer?: SortOrder
    reviewerEmail?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    passThreshold?: SortOrder
    passed?: SortOrder
    reviewer?: SortOrder
    reviewerEmail?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AssessmentSumOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
    passThreshold?: SortOrder
  }

  export type EnumAssessmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAssessmentTypeFilter<$PrismaModel>
  }

  export type EnumAssessmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssessmentStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumQuestionnaireTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireType | EnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireTypeFilter<$PrismaModel> | $Enums.QuestionnaireType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type QuestionnaireTemplateNameVersionCompoundUniqueInput = {
    name: string
    version: string
  }

  export type QuestionnaireTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    description?: SortOrder
    sections?: SortOrder
    totalQuestions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireTemplateAvgOrderByAggregateInput = {
    totalQuestions?: SortOrder
  }

  export type QuestionnaireTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    description?: SortOrder
    totalQuestions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    type?: SortOrder
    description?: SortOrder
    totalQuestions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireTemplateSumOrderByAggregateInput = {
    totalQuestions?: SortOrder
  }

  export type EnumQuestionnaireTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireType | EnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionnaireType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionnaireTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionnaireTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumQuestionnaireStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusFilter<$PrismaModel> | $Enums.QuestionnaireStatus
  }

  export type QuestionnaireTemplateRelationFilter = {
    is?: QuestionnaireTemplateWhereInput
    isNot?: QuestionnaireTemplateWhereInput
  }

  export type QuestionnaireResponseCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    responses?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    percentComplete?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireResponseAvgOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
    percentComplete?: SortOrder
  }

  export type QuestionnaireResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    percentComplete?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireResponseMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    templateId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    percentComplete?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireResponseSumOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
    percentComplete?: SortOrder
  }

  export type EnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionnaireStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
  }

  export type EnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type EnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ContractAmendmentListRelationFilter = {
    every?: ContractAmendmentWhereInput
    some?: ContractAmendmentWhereInput
    none?: ContractAmendmentWhereInput
  }

  export type ContractRenewalListRelationFilter = {
    every?: ContractRenewalWhereInput
    some?: ContractRenewalWhereInput
    none?: ContractRenewalWhereInput
  }

  export type ContractAmendmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractRenewalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    autoRenewal?: SortOrder
    renewalTermMonths?: SortOrder
    terminationNoticeDays?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    paymentTerms?: SortOrder
    slaTerms?: SortOrder
    securityRequirements?: SortOrder
    dataRetentionDays?: SortOrder
    liabilityLimit?: SortOrder
    indemnification?: SortOrder
    insuranceRequired?: SortOrder
    insuranceMinimum?: SortOrder
    documentUrl?: SortOrder
    signedDate?: SortOrder
    signedBy?: SortOrder
    counterSignedDate?: SortOrder
    counterSignedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    renewalTermMonths?: SortOrder
    terminationNoticeDays?: SortOrder
    value?: SortOrder
    dataRetentionDays?: SortOrder
    liabilityLimit?: SortOrder
    insuranceMinimum?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    autoRenewal?: SortOrder
    renewalTermMonths?: SortOrder
    terminationNoticeDays?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    paymentTerms?: SortOrder
    dataRetentionDays?: SortOrder
    liabilityLimit?: SortOrder
    indemnification?: SortOrder
    insuranceRequired?: SortOrder
    insuranceMinimum?: SortOrder
    documentUrl?: SortOrder
    signedDate?: SortOrder
    signedBy?: SortOrder
    counterSignedDate?: SortOrder
    counterSignedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    autoRenewal?: SortOrder
    renewalTermMonths?: SortOrder
    terminationNoticeDays?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    paymentTerms?: SortOrder
    dataRetentionDays?: SortOrder
    liabilityLimit?: SortOrder
    indemnification?: SortOrder
    insuranceRequired?: SortOrder
    insuranceMinimum?: SortOrder
    documentUrl?: SortOrder
    signedDate?: SortOrder
    signedBy?: SortOrder
    counterSignedDate?: SortOrder
    counterSignedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    renewalTermMonths?: SortOrder
    terminationNoticeDays?: SortOrder
    value?: SortOrder
    dataRetentionDays?: SortOrder
    liabilityLimit?: SortOrder
    insuranceMinimum?: SortOrder
  }

  export type EnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type EnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ContractRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type ContractAmendmentCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    amendmentNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    effectiveDate?: SortOrder
    documentUrl?: SortOrder
    signedDate?: SortOrder
    signedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractAmendmentAvgOrderByAggregateInput = {
    amendmentNumber?: SortOrder
  }

  export type ContractAmendmentMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    amendmentNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    effectiveDate?: SortOrder
    documentUrl?: SortOrder
    signedDate?: SortOrder
    signedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractAmendmentMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    amendmentNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    effectiveDate?: SortOrder
    documentUrl?: SortOrder
    signedDate?: SortOrder
    signedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractAmendmentSumOrderByAggregateInput = {
    amendmentNumber?: SortOrder
  }

  export type ContractRenewalCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    previousEndDate?: SortOrder
    newEndDate?: SortOrder
    renewalDate?: SortOrder
    renewedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractRenewalMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    previousEndDate?: SortOrder
    newEndDate?: SortOrder
    renewalDate?: SortOrder
    renewedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractRenewalMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    previousEndDate?: SortOrder
    newEndDate?: SortOrder
    renewalDate?: SortOrder
    renewedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCertificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationType | EnumCertificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationTypeFilter<$PrismaModel> | $Enums.CertificationType
  }

  export type EnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type CertificationCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    issuingBody?: SortOrder
    certificationNumber?: SortOrder
    scope?: SortOrder
    issueDate?: SortOrder
    expirationDate?: SortOrder
    status?: SortOrder
    verified?: SortOrder
    verifiedDate?: SortOrder
    verifiedBy?: SortOrder
    documentUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    issuingBody?: SortOrder
    certificationNumber?: SortOrder
    scope?: SortOrder
    issueDate?: SortOrder
    expirationDate?: SortOrder
    status?: SortOrder
    verified?: SortOrder
    verifiedDate?: SortOrder
    verifiedBy?: SortOrder
    documentUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    issuingBody?: SortOrder
    certificationNumber?: SortOrder
    scope?: SortOrder
    issueDate?: SortOrder
    expirationDate?: SortOrder
    status?: SortOrder
    verified?: SortOrder
    verifiedDate?: SortOrder
    verifiedBy?: SortOrder
    documentUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCertificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationType | EnumCertificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificationTypeFilter<$PrismaModel>
  }

  export type EnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type EnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type EnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discoveredAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    affectedSystems?: SortOrder
    affectedDataTypes?: SortOrder
    recordsAffected?: SortOrder
    phiInvolved?: SortOrder
    piiInvolved?: SortOrder
    rootCause?: SortOrder
    immediateActions?: SortOrder
    correctiveActions?: SortOrder
    preventiveActions?: SortOrder
    notificationRequired?: SortOrder
    notifiedParties?: SortOrder
    notificationDate?: SortOrder
    regulatoryReportRequired?: SortOrder
    regulatoryReportDate?: SortOrder
    lessonLearned?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type IncidentAvgOrderByAggregateInput = {
    recordsAffected?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discoveredAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    recordsAffected?: SortOrder
    phiInvolved?: SortOrder
    piiInvolved?: SortOrder
    rootCause?: SortOrder
    immediateActions?: SortOrder
    correctiveActions?: SortOrder
    preventiveActions?: SortOrder
    notificationRequired?: SortOrder
    notificationDate?: SortOrder
    regulatoryReportRequired?: SortOrder
    regulatoryReportDate?: SortOrder
    lessonLearned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    discoveredAt?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    recordsAffected?: SortOrder
    phiInvolved?: SortOrder
    piiInvolved?: SortOrder
    rootCause?: SortOrder
    immediateActions?: SortOrder
    correctiveActions?: SortOrder
    preventiveActions?: SortOrder
    notificationRequired?: SortOrder
    notificationDate?: SortOrder
    regulatoryReportRequired?: SortOrder
    regulatoryReportDate?: SortOrder
    lessonLearned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type IncidentSumOrderByAggregateInput = {
    recordsAffected?: SortOrder
  }

  export type EnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type EnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type EnumRemediationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RemediationType | EnumRemediationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRemediationTypeFilter<$PrismaModel> | $Enums.RemediationType
  }

  export type EnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type IncidentNullableRelationFilter = {
    is?: IncidentWhereInput | null
    isNot?: IncidentWhereInput | null
  }

  export type RemediationTaskCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    incidentId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirement?: SortOrder
    controlReference?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    assignedTo?: SortOrder
    assignedToEmail?: SortOrder
    evidence?: SortOrder
    verifiedBy?: SortOrder
    verifiedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RemediationTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    incidentId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirement?: SortOrder
    controlReference?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    assignedTo?: SortOrder
    assignedToEmail?: SortOrder
    verifiedBy?: SortOrder
    verifiedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RemediationTaskMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    incidentId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirement?: SortOrder
    controlReference?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    assignedTo?: SortOrder
    assignedToEmail?: SortOrder
    verifiedBy?: SortOrder
    verifiedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumRemediationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RemediationType | EnumRemediationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRemediationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RemediationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRemediationTypeFilter<$PrismaModel>
    _max?: NestedEnumRemediationTypeFilter<$PrismaModel>
  }

  export type EnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type VendorNullableRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type VendorAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userRole?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userRole?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userRole?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RiskScoringCriteriaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    weight?: SortOrder
    maxPoints?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoringCriteriaAvgOrderByAggregateInput = {
    weight?: SortOrder
    maxPoints?: SortOrder
  }

  export type RiskScoringCriteriaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    weight?: SortOrder
    maxPoints?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoringCriteriaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    weight?: SortOrder
    maxPoints?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoringCriteriaSumOrderByAggregateInput = {
    weight?: SortOrder
    maxPoints?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AssessmentCreateNestedManyWithoutVendorInput = {
    create?: XOR<AssessmentCreateWithoutVendorInput, AssessmentUncheckedCreateWithoutVendorInput> | AssessmentCreateWithoutVendorInput[] | AssessmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutVendorInput | AssessmentCreateOrConnectWithoutVendorInput[]
    createMany?: AssessmentCreateManyVendorInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutVendorInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type CertificationCreateNestedManyWithoutVendorInput = {
    create?: XOR<CertificationCreateWithoutVendorInput, CertificationUncheckedCreateWithoutVendorInput> | CertificationCreateWithoutVendorInput[] | CertificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutVendorInput | CertificationCreateOrConnectWithoutVendorInput[]
    createMany?: CertificationCreateManyVendorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutVendorInput = {
    create?: XOR<IncidentCreateWithoutVendorInput, IncidentUncheckedCreateWithoutVendorInput> | IncidentCreateWithoutVendorInput[] | IncidentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVendorInput | IncidentCreateOrConnectWithoutVendorInput[]
    createMany?: IncidentCreateManyVendorInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type RemediationTaskCreateNestedManyWithoutVendorInput = {
    create?: XOR<RemediationTaskCreateWithoutVendorInput, RemediationTaskUncheckedCreateWithoutVendorInput> | RemediationTaskCreateWithoutVendorInput[] | RemediationTaskUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutVendorInput | RemediationTaskCreateOrConnectWithoutVendorInput[]
    createMany?: RemediationTaskCreateManyVendorInputEnvelope
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
  }

  export type QuestionnaireResponseCreateNestedManyWithoutVendorInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutVendorInput, QuestionnaireResponseUncheckedCreateWithoutVendorInput> | QuestionnaireResponseCreateWithoutVendorInput[] | QuestionnaireResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutVendorInput | QuestionnaireResponseCreateOrConnectWithoutVendorInput[]
    createMany?: QuestionnaireResponseCreateManyVendorInputEnvelope
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
  }

  export type VendorAuditLogCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorAuditLogCreateWithoutVendorInput, VendorAuditLogUncheckedCreateWithoutVendorInput> | VendorAuditLogCreateWithoutVendorInput[] | VendorAuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAuditLogCreateOrConnectWithoutVendorInput | VendorAuditLogCreateOrConnectWithoutVendorInput[]
    createMany?: VendorAuditLogCreateManyVendorInputEnvelope
    connect?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
  }

  export type AssessmentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<AssessmentCreateWithoutVendorInput, AssessmentUncheckedCreateWithoutVendorInput> | AssessmentCreateWithoutVendorInput[] | AssessmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutVendorInput | AssessmentCreateOrConnectWithoutVendorInput[]
    createMany?: AssessmentCreateManyVendorInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<CertificationCreateWithoutVendorInput, CertificationUncheckedCreateWithoutVendorInput> | CertificationCreateWithoutVendorInput[] | CertificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutVendorInput | CertificationCreateOrConnectWithoutVendorInput[]
    createMany?: CertificationCreateManyVendorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<IncidentCreateWithoutVendorInput, IncidentUncheckedCreateWithoutVendorInput> | IncidentCreateWithoutVendorInput[] | IncidentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVendorInput | IncidentCreateOrConnectWithoutVendorInput[]
    createMany?: IncidentCreateManyVendorInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type RemediationTaskUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<RemediationTaskCreateWithoutVendorInput, RemediationTaskUncheckedCreateWithoutVendorInput> | RemediationTaskCreateWithoutVendorInput[] | RemediationTaskUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutVendorInput | RemediationTaskCreateOrConnectWithoutVendorInput[]
    createMany?: RemediationTaskCreateManyVendorInputEnvelope
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
  }

  export type QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutVendorInput, QuestionnaireResponseUncheckedCreateWithoutVendorInput> | QuestionnaireResponseCreateWithoutVendorInput[] | QuestionnaireResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutVendorInput | QuestionnaireResponseCreateOrConnectWithoutVendorInput[]
    createMany?: QuestionnaireResponseCreateManyVendorInputEnvelope
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
  }

  export type VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorAuditLogCreateWithoutVendorInput, VendorAuditLogUncheckedCreateWithoutVendorInput> | VendorAuditLogCreateWithoutVendorInput[] | VendorAuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAuditLogCreateOrConnectWithoutVendorInput | VendorAuditLogCreateOrConnectWithoutVendorInput[]
    createMany?: VendorAuditLogCreateManyVendorInputEnvelope
    connect?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumVendorCategoryFieldUpdateOperationsInput = {
    set?: $Enums.VendorCategory
  }

  export type EnumVendorTierFieldUpdateOperationsInput = {
    set?: $Enums.VendorTier
  }

  export type EnumVendorStatusFieldUpdateOperationsInput = {
    set?: $Enums.VendorStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel
  }

  export type EnumDataAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.DataAccessLevel
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AssessmentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AssessmentCreateWithoutVendorInput, AssessmentUncheckedCreateWithoutVendorInput> | AssessmentCreateWithoutVendorInput[] | AssessmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutVendorInput | AssessmentCreateOrConnectWithoutVendorInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutVendorInput | AssessmentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AssessmentCreateManyVendorInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutVendorInput | AssessmentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutVendorInput | AssessmentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutVendorInput | ContractUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutVendorInput | ContractUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutVendorInput | ContractUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type CertificationUpdateManyWithoutVendorNestedInput = {
    create?: XOR<CertificationCreateWithoutVendorInput, CertificationUncheckedCreateWithoutVendorInput> | CertificationCreateWithoutVendorInput[] | CertificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutVendorInput | CertificationCreateOrConnectWithoutVendorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutVendorInput | CertificationUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: CertificationCreateManyVendorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutVendorInput | CertificationUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutVendorInput | CertificationUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<IncidentCreateWithoutVendorInput, IncidentUncheckedCreateWithoutVendorInput> | IncidentCreateWithoutVendorInput[] | IncidentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVendorInput | IncidentCreateOrConnectWithoutVendorInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutVendorInput | IncidentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: IncidentCreateManyVendorInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutVendorInput | IncidentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutVendorInput | IncidentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type RemediationTaskUpdateManyWithoutVendorNestedInput = {
    create?: XOR<RemediationTaskCreateWithoutVendorInput, RemediationTaskUncheckedCreateWithoutVendorInput> | RemediationTaskCreateWithoutVendorInput[] | RemediationTaskUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutVendorInput | RemediationTaskCreateOrConnectWithoutVendorInput[]
    upsert?: RemediationTaskUpsertWithWhereUniqueWithoutVendorInput | RemediationTaskUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: RemediationTaskCreateManyVendorInputEnvelope
    set?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    disconnect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    delete?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    update?: RemediationTaskUpdateWithWhereUniqueWithoutVendorInput | RemediationTaskUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: RemediationTaskUpdateManyWithWhereWithoutVendorInput | RemediationTaskUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: RemediationTaskScalarWhereInput | RemediationTaskScalarWhereInput[]
  }

  export type QuestionnaireResponseUpdateManyWithoutVendorNestedInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutVendorInput, QuestionnaireResponseUncheckedCreateWithoutVendorInput> | QuestionnaireResponseCreateWithoutVendorInput[] | QuestionnaireResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutVendorInput | QuestionnaireResponseCreateOrConnectWithoutVendorInput[]
    upsert?: QuestionnaireResponseUpsertWithWhereUniqueWithoutVendorInput | QuestionnaireResponseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: QuestionnaireResponseCreateManyVendorInputEnvelope
    set?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    disconnect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    delete?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    update?: QuestionnaireResponseUpdateWithWhereUniqueWithoutVendorInput | QuestionnaireResponseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: QuestionnaireResponseUpdateManyWithWhereWithoutVendorInput | QuestionnaireResponseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: QuestionnaireResponseScalarWhereInput | QuestionnaireResponseScalarWhereInput[]
  }

  export type VendorAuditLogUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorAuditLogCreateWithoutVendorInput, VendorAuditLogUncheckedCreateWithoutVendorInput> | VendorAuditLogCreateWithoutVendorInput[] | VendorAuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAuditLogCreateOrConnectWithoutVendorInput | VendorAuditLogCreateOrConnectWithoutVendorInput[]
    upsert?: VendorAuditLogUpsertWithWhereUniqueWithoutVendorInput | VendorAuditLogUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorAuditLogCreateManyVendorInputEnvelope
    set?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    disconnect?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    delete?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    connect?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    update?: VendorAuditLogUpdateWithWhereUniqueWithoutVendorInput | VendorAuditLogUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorAuditLogUpdateManyWithWhereWithoutVendorInput | VendorAuditLogUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorAuditLogScalarWhereInput | VendorAuditLogScalarWhereInput[]
  }

  export type AssessmentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AssessmentCreateWithoutVendorInput, AssessmentUncheckedCreateWithoutVendorInput> | AssessmentCreateWithoutVendorInput[] | AssessmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutVendorInput | AssessmentCreateOrConnectWithoutVendorInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutVendorInput | AssessmentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AssessmentCreateManyVendorInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutVendorInput | AssessmentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutVendorInput | AssessmentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutVendorInput | ContractUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutVendorInput | ContractUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutVendorInput | ContractUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<CertificationCreateWithoutVendorInput, CertificationUncheckedCreateWithoutVendorInput> | CertificationCreateWithoutVendorInput[] | CertificationUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutVendorInput | CertificationCreateOrConnectWithoutVendorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutVendorInput | CertificationUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: CertificationCreateManyVendorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutVendorInput | CertificationUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutVendorInput | CertificationUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<IncidentCreateWithoutVendorInput, IncidentUncheckedCreateWithoutVendorInput> | IncidentCreateWithoutVendorInput[] | IncidentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVendorInput | IncidentCreateOrConnectWithoutVendorInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutVendorInput | IncidentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: IncidentCreateManyVendorInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutVendorInput | IncidentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutVendorInput | IncidentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<RemediationTaskCreateWithoutVendorInput, RemediationTaskUncheckedCreateWithoutVendorInput> | RemediationTaskCreateWithoutVendorInput[] | RemediationTaskUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutVendorInput | RemediationTaskCreateOrConnectWithoutVendorInput[]
    upsert?: RemediationTaskUpsertWithWhereUniqueWithoutVendorInput | RemediationTaskUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: RemediationTaskCreateManyVendorInputEnvelope
    set?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    disconnect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    delete?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    update?: RemediationTaskUpdateWithWhereUniqueWithoutVendorInput | RemediationTaskUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: RemediationTaskUpdateManyWithWhereWithoutVendorInput | RemediationTaskUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: RemediationTaskScalarWhereInput | RemediationTaskScalarWhereInput[]
  }

  export type QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutVendorInput, QuestionnaireResponseUncheckedCreateWithoutVendorInput> | QuestionnaireResponseCreateWithoutVendorInput[] | QuestionnaireResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutVendorInput | QuestionnaireResponseCreateOrConnectWithoutVendorInput[]
    upsert?: QuestionnaireResponseUpsertWithWhereUniqueWithoutVendorInput | QuestionnaireResponseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: QuestionnaireResponseCreateManyVendorInputEnvelope
    set?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    disconnect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    delete?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    update?: QuestionnaireResponseUpdateWithWhereUniqueWithoutVendorInput | QuestionnaireResponseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: QuestionnaireResponseUpdateManyWithWhereWithoutVendorInput | QuestionnaireResponseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: QuestionnaireResponseScalarWhereInput | QuestionnaireResponseScalarWhereInput[]
  }

  export type VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorAuditLogCreateWithoutVendorInput, VendorAuditLogUncheckedCreateWithoutVendorInput> | VendorAuditLogCreateWithoutVendorInput[] | VendorAuditLogUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAuditLogCreateOrConnectWithoutVendorInput | VendorAuditLogCreateOrConnectWithoutVendorInput[]
    upsert?: VendorAuditLogUpsertWithWhereUniqueWithoutVendorInput | VendorAuditLogUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorAuditLogCreateManyVendorInputEnvelope
    set?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    disconnect?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    delete?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    connect?: VendorAuditLogWhereUniqueInput | VendorAuditLogWhereUniqueInput[]
    update?: VendorAuditLogUpdateWithWhereUniqueWithoutVendorInput | VendorAuditLogUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorAuditLogUpdateManyWithWhereWithoutVendorInput | VendorAuditLogUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorAuditLogScalarWhereInput | VendorAuditLogScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<VendorCreateWithoutAssessmentsInput, VendorUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAssessmentsInput
    connect?: VendorWhereUniqueInput
  }

  export type EnumAssessmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssessmentType
  }

  export type EnumAssessmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssessmentStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type VendorUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<VendorCreateWithoutAssessmentsInput, VendorUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAssessmentsInput
    upsert?: VendorUpsertWithoutAssessmentsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAssessmentsInput, VendorUpdateWithoutAssessmentsInput>, VendorUncheckedUpdateWithoutAssessmentsInput>
  }

  export type QuestionnaireResponseCreateNestedManyWithoutTemplateInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutTemplateInput, QuestionnaireResponseUncheckedCreateWithoutTemplateInput> | QuestionnaireResponseCreateWithoutTemplateInput[] | QuestionnaireResponseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutTemplateInput | QuestionnaireResponseCreateOrConnectWithoutTemplateInput[]
    createMany?: QuestionnaireResponseCreateManyTemplateInputEnvelope
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
  }

  export type QuestionnaireResponseUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutTemplateInput, QuestionnaireResponseUncheckedCreateWithoutTemplateInput> | QuestionnaireResponseCreateWithoutTemplateInput[] | QuestionnaireResponseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutTemplateInput | QuestionnaireResponseCreateOrConnectWithoutTemplateInput[]
    createMany?: QuestionnaireResponseCreateManyTemplateInputEnvelope
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
  }

  export type EnumQuestionnaireTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionnaireType
  }

  export type QuestionnaireResponseUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutTemplateInput, QuestionnaireResponseUncheckedCreateWithoutTemplateInput> | QuestionnaireResponseCreateWithoutTemplateInput[] | QuestionnaireResponseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutTemplateInput | QuestionnaireResponseCreateOrConnectWithoutTemplateInput[]
    upsert?: QuestionnaireResponseUpsertWithWhereUniqueWithoutTemplateInput | QuestionnaireResponseUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: QuestionnaireResponseCreateManyTemplateInputEnvelope
    set?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    disconnect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    delete?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    update?: QuestionnaireResponseUpdateWithWhereUniqueWithoutTemplateInput | QuestionnaireResponseUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: QuestionnaireResponseUpdateManyWithWhereWithoutTemplateInput | QuestionnaireResponseUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: QuestionnaireResponseScalarWhereInput | QuestionnaireResponseScalarWhereInput[]
  }

  export type QuestionnaireResponseUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<QuestionnaireResponseCreateWithoutTemplateInput, QuestionnaireResponseUncheckedCreateWithoutTemplateInput> | QuestionnaireResponseCreateWithoutTemplateInput[] | QuestionnaireResponseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: QuestionnaireResponseCreateOrConnectWithoutTemplateInput | QuestionnaireResponseCreateOrConnectWithoutTemplateInput[]
    upsert?: QuestionnaireResponseUpsertWithWhereUniqueWithoutTemplateInput | QuestionnaireResponseUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: QuestionnaireResponseCreateManyTemplateInputEnvelope
    set?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    disconnect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    delete?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    connect?: QuestionnaireResponseWhereUniqueInput | QuestionnaireResponseWhereUniqueInput[]
    update?: QuestionnaireResponseUpdateWithWhereUniqueWithoutTemplateInput | QuestionnaireResponseUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: QuestionnaireResponseUpdateManyWithWhereWithoutTemplateInput | QuestionnaireResponseUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: QuestionnaireResponseScalarWhereInput | QuestionnaireResponseScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutQuestionnairesInput = {
    create?: XOR<VendorCreateWithoutQuestionnairesInput, VendorUncheckedCreateWithoutQuestionnairesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutQuestionnairesInput
    connect?: VendorWhereUniqueInput
  }

  export type QuestionnaireTemplateCreateNestedOneWithoutResponsesInput = {
    create?: XOR<QuestionnaireTemplateCreateWithoutResponsesInput, QuestionnaireTemplateUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuestionnaireTemplateCreateOrConnectWithoutResponsesInput
    connect?: QuestionnaireTemplateWhereUniqueInput
  }

  export type EnumQuestionnaireStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuestionnaireStatus
  }

  export type VendorUpdateOneRequiredWithoutQuestionnairesNestedInput = {
    create?: XOR<VendorCreateWithoutQuestionnairesInput, VendorUncheckedCreateWithoutQuestionnairesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutQuestionnairesInput
    upsert?: VendorUpsertWithoutQuestionnairesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutQuestionnairesInput, VendorUpdateWithoutQuestionnairesInput>, VendorUncheckedUpdateWithoutQuestionnairesInput>
  }

  export type QuestionnaireTemplateUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<QuestionnaireTemplateCreateWithoutResponsesInput, QuestionnaireTemplateUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuestionnaireTemplateCreateOrConnectWithoutResponsesInput
    upsert?: QuestionnaireTemplateUpsertWithoutResponsesInput
    connect?: QuestionnaireTemplateWhereUniqueInput
    update?: XOR<XOR<QuestionnaireTemplateUpdateToOneWithWhereWithoutResponsesInput, QuestionnaireTemplateUpdateWithoutResponsesInput>, QuestionnaireTemplateUncheckedUpdateWithoutResponsesInput>
  }

  export type VendorCreateNestedOneWithoutContractsInput = {
    create?: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContractsInput
    connect?: VendorWhereUniqueInput
  }

  export type ContractAmendmentCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractAmendmentCreateWithoutContractInput, ContractAmendmentUncheckedCreateWithoutContractInput> | ContractAmendmentCreateWithoutContractInput[] | ContractAmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractAmendmentCreateOrConnectWithoutContractInput | ContractAmendmentCreateOrConnectWithoutContractInput[]
    createMany?: ContractAmendmentCreateManyContractInputEnvelope
    connect?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
  }

  export type ContractRenewalCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractRenewalCreateWithoutContractInput, ContractRenewalUncheckedCreateWithoutContractInput> | ContractRenewalCreateWithoutContractInput[] | ContractRenewalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractRenewalCreateOrConnectWithoutContractInput | ContractRenewalCreateOrConnectWithoutContractInput[]
    createMany?: ContractRenewalCreateManyContractInputEnvelope
    connect?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
  }

  export type ContractAmendmentUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractAmendmentCreateWithoutContractInput, ContractAmendmentUncheckedCreateWithoutContractInput> | ContractAmendmentCreateWithoutContractInput[] | ContractAmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractAmendmentCreateOrConnectWithoutContractInput | ContractAmendmentCreateOrConnectWithoutContractInput[]
    createMany?: ContractAmendmentCreateManyContractInputEnvelope
    connect?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
  }

  export type ContractRenewalUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractRenewalCreateWithoutContractInput, ContractRenewalUncheckedCreateWithoutContractInput> | ContractRenewalCreateWithoutContractInput[] | ContractRenewalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractRenewalCreateOrConnectWithoutContractInput | ContractRenewalCreateOrConnectWithoutContractInput[]
    createMany?: ContractRenewalCreateManyContractInputEnvelope
    connect?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
  }

  export type EnumContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContractType
  }

  export type EnumContractStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContractStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VendorUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContractsInput
    upsert?: VendorUpsertWithoutContractsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutContractsInput, VendorUpdateWithoutContractsInput>, VendorUncheckedUpdateWithoutContractsInput>
  }

  export type ContractAmendmentUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractAmendmentCreateWithoutContractInput, ContractAmendmentUncheckedCreateWithoutContractInput> | ContractAmendmentCreateWithoutContractInput[] | ContractAmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractAmendmentCreateOrConnectWithoutContractInput | ContractAmendmentCreateOrConnectWithoutContractInput[]
    upsert?: ContractAmendmentUpsertWithWhereUniqueWithoutContractInput | ContractAmendmentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractAmendmentCreateManyContractInputEnvelope
    set?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    disconnect?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    delete?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    connect?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    update?: ContractAmendmentUpdateWithWhereUniqueWithoutContractInput | ContractAmendmentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractAmendmentUpdateManyWithWhereWithoutContractInput | ContractAmendmentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractAmendmentScalarWhereInput | ContractAmendmentScalarWhereInput[]
  }

  export type ContractRenewalUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractRenewalCreateWithoutContractInput, ContractRenewalUncheckedCreateWithoutContractInput> | ContractRenewalCreateWithoutContractInput[] | ContractRenewalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractRenewalCreateOrConnectWithoutContractInput | ContractRenewalCreateOrConnectWithoutContractInput[]
    upsert?: ContractRenewalUpsertWithWhereUniqueWithoutContractInput | ContractRenewalUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractRenewalCreateManyContractInputEnvelope
    set?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    disconnect?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    delete?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    connect?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    update?: ContractRenewalUpdateWithWhereUniqueWithoutContractInput | ContractRenewalUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractRenewalUpdateManyWithWhereWithoutContractInput | ContractRenewalUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractRenewalScalarWhereInput | ContractRenewalScalarWhereInput[]
  }

  export type ContractAmendmentUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractAmendmentCreateWithoutContractInput, ContractAmendmentUncheckedCreateWithoutContractInput> | ContractAmendmentCreateWithoutContractInput[] | ContractAmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractAmendmentCreateOrConnectWithoutContractInput | ContractAmendmentCreateOrConnectWithoutContractInput[]
    upsert?: ContractAmendmentUpsertWithWhereUniqueWithoutContractInput | ContractAmendmentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractAmendmentCreateManyContractInputEnvelope
    set?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    disconnect?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    delete?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    connect?: ContractAmendmentWhereUniqueInput | ContractAmendmentWhereUniqueInput[]
    update?: ContractAmendmentUpdateWithWhereUniqueWithoutContractInput | ContractAmendmentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractAmendmentUpdateManyWithWhereWithoutContractInput | ContractAmendmentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractAmendmentScalarWhereInput | ContractAmendmentScalarWhereInput[]
  }

  export type ContractRenewalUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractRenewalCreateWithoutContractInput, ContractRenewalUncheckedCreateWithoutContractInput> | ContractRenewalCreateWithoutContractInput[] | ContractRenewalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractRenewalCreateOrConnectWithoutContractInput | ContractRenewalCreateOrConnectWithoutContractInput[]
    upsert?: ContractRenewalUpsertWithWhereUniqueWithoutContractInput | ContractRenewalUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractRenewalCreateManyContractInputEnvelope
    set?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    disconnect?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    delete?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    connect?: ContractRenewalWhereUniqueInput | ContractRenewalWhereUniqueInput[]
    update?: ContractRenewalUpdateWithWhereUniqueWithoutContractInput | ContractRenewalUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractRenewalUpdateManyWithWhereWithoutContractInput | ContractRenewalUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractRenewalScalarWhereInput | ContractRenewalScalarWhereInput[]
  }

  export type ContractCreateNestedOneWithoutAmendmentsInput = {
    create?: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAmendmentsInput
    connect?: ContractWhereUniqueInput
  }

  export type ContractUpdateOneRequiredWithoutAmendmentsNestedInput = {
    create?: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAmendmentsInput
    upsert?: ContractUpsertWithoutAmendmentsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutAmendmentsInput, ContractUpdateWithoutAmendmentsInput>, ContractUncheckedUpdateWithoutAmendmentsInput>
  }

  export type ContractCreateNestedOneWithoutRenewalHistoryInput = {
    create?: XOR<ContractCreateWithoutRenewalHistoryInput, ContractUncheckedCreateWithoutRenewalHistoryInput>
    connectOrCreate?: ContractCreateOrConnectWithoutRenewalHistoryInput
    connect?: ContractWhereUniqueInput
  }

  export type ContractUpdateOneRequiredWithoutRenewalHistoryNestedInput = {
    create?: XOR<ContractCreateWithoutRenewalHistoryInput, ContractUncheckedCreateWithoutRenewalHistoryInput>
    connectOrCreate?: ContractCreateOrConnectWithoutRenewalHistoryInput
    upsert?: ContractUpsertWithoutRenewalHistoryInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutRenewalHistoryInput, ContractUpdateWithoutRenewalHistoryInput>, ContractUncheckedUpdateWithoutRenewalHistoryInput>
  }

  export type VendorCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<VendorCreateWithoutCertificationsInput, VendorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutCertificationsInput
    connect?: VendorWhereUniqueInput
  }

  export type EnumCertificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.CertificationType
  }

  export type EnumCertificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.CertificationStatus
  }

  export type VendorUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<VendorCreateWithoutCertificationsInput, VendorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutCertificationsInput
    upsert?: VendorUpsertWithoutCertificationsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutCertificationsInput, VendorUpdateWithoutCertificationsInput>, VendorUncheckedUpdateWithoutCertificationsInput>
  }

  export type IncidentCreateaffectedSystemsInput = {
    set: string[]
  }

  export type IncidentCreateaffectedDataTypesInput = {
    set: string[]
  }

  export type IncidentCreatenotifiedPartiesInput = {
    set: string[]
  }

  export type VendorCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<VendorCreateWithoutIncidentsInput, VendorUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutIncidentsInput
    connect?: VendorWhereUniqueInput
  }

  export type RemediationTaskCreateNestedManyWithoutIncidentInput = {
    create?: XOR<RemediationTaskCreateWithoutIncidentInput, RemediationTaskUncheckedCreateWithoutIncidentInput> | RemediationTaskCreateWithoutIncidentInput[] | RemediationTaskUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutIncidentInput | RemediationTaskCreateOrConnectWithoutIncidentInput[]
    createMany?: RemediationTaskCreateManyIncidentInputEnvelope
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
  }

  export type RemediationTaskUncheckedCreateNestedManyWithoutIncidentInput = {
    create?: XOR<RemediationTaskCreateWithoutIncidentInput, RemediationTaskUncheckedCreateWithoutIncidentInput> | RemediationTaskCreateWithoutIncidentInput[] | RemediationTaskUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutIncidentInput | RemediationTaskCreateOrConnectWithoutIncidentInput[]
    createMany?: RemediationTaskCreateManyIncidentInputEnvelope
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
  }

  export type EnumIncidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.IncidentType
  }

  export type EnumIncidentSeverityFieldUpdateOperationsInput = {
    set?: $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type IncidentUpdateaffectedSystemsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IncidentUpdateaffectedDataTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IncidentUpdatenotifiedPartiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VendorUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<VendorCreateWithoutIncidentsInput, VendorUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutIncidentsInput
    upsert?: VendorUpsertWithoutIncidentsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutIncidentsInput, VendorUpdateWithoutIncidentsInput>, VendorUncheckedUpdateWithoutIncidentsInput>
  }

  export type RemediationTaskUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<RemediationTaskCreateWithoutIncidentInput, RemediationTaskUncheckedCreateWithoutIncidentInput> | RemediationTaskCreateWithoutIncidentInput[] | RemediationTaskUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutIncidentInput | RemediationTaskCreateOrConnectWithoutIncidentInput[]
    upsert?: RemediationTaskUpsertWithWhereUniqueWithoutIncidentInput | RemediationTaskUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: RemediationTaskCreateManyIncidentInputEnvelope
    set?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    disconnect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    delete?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    update?: RemediationTaskUpdateWithWhereUniqueWithoutIncidentInput | RemediationTaskUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: RemediationTaskUpdateManyWithWhereWithoutIncidentInput | RemediationTaskUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: RemediationTaskScalarWhereInput | RemediationTaskScalarWhereInput[]
  }

  export type RemediationTaskUncheckedUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<RemediationTaskCreateWithoutIncidentInput, RemediationTaskUncheckedCreateWithoutIncidentInput> | RemediationTaskCreateWithoutIncidentInput[] | RemediationTaskUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: RemediationTaskCreateOrConnectWithoutIncidentInput | RemediationTaskCreateOrConnectWithoutIncidentInput[]
    upsert?: RemediationTaskUpsertWithWhereUniqueWithoutIncidentInput | RemediationTaskUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: RemediationTaskCreateManyIncidentInputEnvelope
    set?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    disconnect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    delete?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    connect?: RemediationTaskWhereUniqueInput | RemediationTaskWhereUniqueInput[]
    update?: RemediationTaskUpdateWithWhereUniqueWithoutIncidentInput | RemediationTaskUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: RemediationTaskUpdateManyWithWhereWithoutIncidentInput | RemediationTaskUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: RemediationTaskScalarWhereInput | RemediationTaskScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutRemediationsInput = {
    create?: XOR<VendorCreateWithoutRemediationsInput, VendorUncheckedCreateWithoutRemediationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutRemediationsInput
    connect?: VendorWhereUniqueInput
  }

  export type IncidentCreateNestedOneWithoutRemediationsInput = {
    create?: XOR<IncidentCreateWithoutRemediationsInput, IncidentUncheckedCreateWithoutRemediationsInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutRemediationsInput
    connect?: IncidentWhereUniqueInput
  }

  export type EnumRemediationTypeFieldUpdateOperationsInput = {
    set?: $Enums.RemediationType
  }

  export type EnumTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TaskPriority
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type VendorUpdateOneRequiredWithoutRemediationsNestedInput = {
    create?: XOR<VendorCreateWithoutRemediationsInput, VendorUncheckedCreateWithoutRemediationsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutRemediationsInput
    upsert?: VendorUpsertWithoutRemediationsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutRemediationsInput, VendorUpdateWithoutRemediationsInput>, VendorUncheckedUpdateWithoutRemediationsInput>
  }

  export type IncidentUpdateOneWithoutRemediationsNestedInput = {
    create?: XOR<IncidentCreateWithoutRemediationsInput, IncidentUncheckedCreateWithoutRemediationsInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutRemediationsInput
    upsert?: IncidentUpsertWithoutRemediationsInput
    disconnect?: IncidentWhereInput | boolean
    delete?: IncidentWhereInput | boolean
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutRemediationsInput, IncidentUpdateWithoutRemediationsInput>, IncidentUncheckedUpdateWithoutRemediationsInput>
  }

  export type VendorCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAuditLogsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAuditLogsInput
    upsert?: VendorUpsertWithoutAuditLogsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAuditLogsInput, VendorUpdateWithoutAuditLogsInput>, VendorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumVendorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryFilter<$PrismaModel> | $Enums.VendorCategory
  }

  export type NestedEnumVendorTierFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorTier | EnumVendorTierFieldRefInput<$PrismaModel>
    in?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorTierFilter<$PrismaModel> | $Enums.VendorTier
  }

  export type NestedEnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type NestedEnumDataAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DataAccessLevel | EnumDataAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDataAccessLevelFilter<$PrismaModel> | $Enums.DataAccessLevel
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVendorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorCategory | EnumVendorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorCategory[] | ListEnumVendorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VendorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorCategoryFilter<$PrismaModel>
    _max?: NestedEnumVendorCategoryFilter<$PrismaModel>
  }

  export type NestedEnumVendorTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorTier | EnumVendorTierFieldRefInput<$PrismaModel>
    in?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorTier[] | ListEnumVendorTierFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorTierWithAggregatesFilter<$PrismaModel> | $Enums.VendorTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorTierFilter<$PrismaModel>
    _max?: NestedEnumVendorTierFilter<$PrismaModel>
  }

  export type NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDataAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataAccessLevel | EnumDataAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataAccessLevel[] | ListEnumDataAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDataAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.DataAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumDataAccessLevelFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAssessmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentTypeFilter<$PrismaModel> | $Enums.AssessmentType
  }

  export type NestedEnumAssessmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusFilter<$PrismaModel> | $Enums.AssessmentStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumAssessmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentType | EnumAssessmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentType[] | ListEnumAssessmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAssessmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssessmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentStatus | EnumAssessmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssessmentStatus[] | ListEnumAssessmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssessmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssessmentStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumQuestionnaireTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireType | EnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireTypeFilter<$PrismaModel> | $Enums.QuestionnaireType
  }

  export type NestedEnumQuestionnaireTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireType | EnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireType[] | ListEnumQuestionnaireTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionnaireType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionnaireTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionnaireTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumQuestionnaireStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusFilter<$PrismaModel> | $Enums.QuestionnaireStatus
  }

  export type NestedEnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionnaireStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
  }

  export type NestedEnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type NestedEnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type NestedEnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type NestedEnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCertificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationType | EnumCertificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationTypeFilter<$PrismaModel> | $Enums.CertificationType
  }

  export type NestedEnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type NestedEnumCertificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationType | EnumCertificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationType[] | ListEnumCertificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type NestedEnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRemediationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RemediationType | EnumRemediationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRemediationTypeFilter<$PrismaModel> | $Enums.RemediationType
  }

  export type NestedEnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumRemediationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RemediationType | EnumRemediationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RemediationType[] | ListEnumRemediationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRemediationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RemediationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRemediationTypeFilter<$PrismaModel>
    _max?: NestedEnumRemediationTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AssessmentCreateWithoutVendorInput = {
    id?: string
    type: $Enums.AssessmentType
    status?: $Enums.AssessmentStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    score?: number | null
    maxScore?: number | null
    passThreshold?: number | null
    passed?: boolean | null
    reviewer?: string | null
    reviewerEmail?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AssessmentUncheckedCreateWithoutVendorInput = {
    id?: string
    type: $Enums.AssessmentType
    status?: $Enums.AssessmentStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    score?: number | null
    maxScore?: number | null
    passThreshold?: number | null
    passed?: boolean | null
    reviewer?: string | null
    reviewerEmail?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AssessmentCreateOrConnectWithoutVendorInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutVendorInput, AssessmentUncheckedCreateWithoutVendorInput>
  }

  export type AssessmentCreateManyVendorInputEnvelope = {
    data: AssessmentCreateManyVendorInput | AssessmentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutVendorInput = {
    id?: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    amendments?: ContractAmendmentCreateNestedManyWithoutContractInput
    renewalHistory?: ContractRenewalCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutVendorInput = {
    id?: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    amendments?: ContractAmendmentUncheckedCreateNestedManyWithoutContractInput
    renewalHistory?: ContractRenewalUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutVendorInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput>
  }

  export type ContractCreateManyVendorInputEnvelope = {
    data: ContractCreateManyVendorInput | ContractCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type CertificationCreateWithoutVendorInput = {
    id?: string
    type: $Enums.CertificationType
    name: string
    issuingBody?: string | null
    certificationNumber?: string | null
    scope?: string | null
    issueDate?: Date | string | null
    expirationDate?: Date | string | null
    status?: $Enums.CertificationStatus
    verified?: boolean
    verifiedDate?: Date | string | null
    verifiedBy?: string | null
    documentUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUncheckedCreateWithoutVendorInput = {
    id?: string
    type: $Enums.CertificationType
    name: string
    issuingBody?: string | null
    certificationNumber?: string | null
    scope?: string | null
    issueDate?: Date | string | null
    expirationDate?: Date | string | null
    status?: $Enums.CertificationStatus
    verified?: boolean
    verifiedDate?: Date | string | null
    verifiedBy?: string | null
    documentUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutVendorInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutVendorInput, CertificationUncheckedCreateWithoutVendorInput>
  }

  export type CertificationCreateManyVendorInputEnvelope = {
    data: CertificationCreateManyVendorInput | CertificationCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutVendorInput = {
    id?: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    remediations?: RemediationTaskCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutVendorInput = {
    id?: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutVendorInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutVendorInput, IncidentUncheckedCreateWithoutVendorInput>
  }

  export type IncidentCreateManyVendorInputEnvelope = {
    data: IncidentCreateManyVendorInput | IncidentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type RemediationTaskCreateWithoutVendorInput = {
    id?: string
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    incident?: IncidentCreateNestedOneWithoutRemediationsInput
  }

  export type RemediationTaskUncheckedCreateWithoutVendorInput = {
    id?: string
    incidentId?: string | null
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RemediationTaskCreateOrConnectWithoutVendorInput = {
    where: RemediationTaskWhereUniqueInput
    create: XOR<RemediationTaskCreateWithoutVendorInput, RemediationTaskUncheckedCreateWithoutVendorInput>
  }

  export type RemediationTaskCreateManyVendorInputEnvelope = {
    data: RemediationTaskCreateManyVendorInput | RemediationTaskCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type QuestionnaireResponseCreateWithoutVendorInput = {
    id?: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: QuestionnaireTemplateCreateNestedOneWithoutResponsesInput
  }

  export type QuestionnaireResponseUncheckedCreateWithoutVendorInput = {
    id?: string
    templateId: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireResponseCreateOrConnectWithoutVendorInput = {
    where: QuestionnaireResponseWhereUniqueInput
    create: XOR<QuestionnaireResponseCreateWithoutVendorInput, QuestionnaireResponseUncheckedCreateWithoutVendorInput>
  }

  export type QuestionnaireResponseCreateManyVendorInputEnvelope = {
    data: QuestionnaireResponseCreateManyVendorInput | QuestionnaireResponseCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorAuditLogCreateWithoutVendorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    userId: string
    userEmail?: string | null
    userRole?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VendorAuditLogUncheckedCreateWithoutVendorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    userId: string
    userEmail?: string | null
    userRole?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VendorAuditLogCreateOrConnectWithoutVendorInput = {
    where: VendorAuditLogWhereUniqueInput
    create: XOR<VendorAuditLogCreateWithoutVendorInput, VendorAuditLogUncheckedCreateWithoutVendorInput>
  }

  export type VendorAuditLogCreateManyVendorInputEnvelope = {
    data: VendorAuditLogCreateManyVendorInput | VendorAuditLogCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentUpsertWithWhereUniqueWithoutVendorInput = {
    where: AssessmentWhereUniqueInput
    update: XOR<AssessmentUpdateWithoutVendorInput, AssessmentUncheckedUpdateWithoutVendorInput>
    create: XOR<AssessmentCreateWithoutVendorInput, AssessmentUncheckedCreateWithoutVendorInput>
  }

  export type AssessmentUpdateWithWhereUniqueWithoutVendorInput = {
    where: AssessmentWhereUniqueInput
    data: XOR<AssessmentUpdateWithoutVendorInput, AssessmentUncheckedUpdateWithoutVendorInput>
  }

  export type AssessmentUpdateManyWithWhereWithoutVendorInput = {
    where: AssessmentScalarWhereInput
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyWithoutVendorInput>
  }

  export type AssessmentScalarWhereInput = {
    AND?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    OR?: AssessmentScalarWhereInput[]
    NOT?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    id?: StringFilter<"Assessment"> | string
    vendorId?: StringFilter<"Assessment"> | string
    type?: EnumAssessmentTypeFilter<"Assessment"> | $Enums.AssessmentType
    status?: EnumAssessmentStatusFilter<"Assessment"> | $Enums.AssessmentStatus
    dueDate?: DateTimeNullableFilter<"Assessment"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Assessment"> | Date | string | null
    score?: IntNullableFilter<"Assessment"> | number | null
    maxScore?: IntNullableFilter<"Assessment"> | number | null
    passThreshold?: IntNullableFilter<"Assessment"> | number | null
    passed?: BoolNullableFilter<"Assessment"> | boolean | null
    reviewer?: StringNullableFilter<"Assessment"> | string | null
    reviewerEmail?: StringNullableFilter<"Assessment"> | string | null
    findings?: JsonNullableFilter<"Assessment">
    recommendations?: StringNullableFilter<"Assessment"> | string | null
    attachments?: JsonNullableFilter<"Assessment">
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    createdBy?: StringNullableFilter<"Assessment"> | string | null
  }

  export type ContractUpsertWithWhereUniqueWithoutVendorInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutVendorInput, ContractUncheckedUpdateWithoutVendorInput>
    create: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutVendorInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutVendorInput, ContractUncheckedUpdateWithoutVendorInput>
  }

  export type ContractUpdateManyWithWhereWithoutVendorInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutVendorInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    vendorId?: StringFilter<"Contract"> | string
    contractNumber?: StringNullableFilter<"Contract"> | string | null
    type?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    title?: StringFilter<"Contract"> | string
    description?: StringNullableFilter<"Contract"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    autoRenewal?: BoolFilter<"Contract"> | boolean
    renewalTermMonths?: IntNullableFilter<"Contract"> | number | null
    terminationNoticeDays?: IntNullableFilter<"Contract"> | number | null
    value?: FloatNullableFilter<"Contract"> | number | null
    currency?: StringFilter<"Contract"> | string
    paymentTerms?: StringNullableFilter<"Contract"> | string | null
    slaTerms?: JsonNullableFilter<"Contract">
    securityRequirements?: JsonNullableFilter<"Contract">
    dataRetentionDays?: IntNullableFilter<"Contract"> | number | null
    liabilityLimit?: FloatNullableFilter<"Contract"> | number | null
    indemnification?: BoolFilter<"Contract"> | boolean
    insuranceRequired?: BoolFilter<"Contract"> | boolean
    insuranceMinimum?: FloatNullableFilter<"Contract"> | number | null
    documentUrl?: StringNullableFilter<"Contract"> | string | null
    signedDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    signedBy?: StringNullableFilter<"Contract"> | string | null
    counterSignedDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    counterSignedBy?: StringNullableFilter<"Contract"> | string | null
    notes?: StringNullableFilter<"Contract"> | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    createdBy?: StringNullableFilter<"Contract"> | string | null
  }

  export type CertificationUpsertWithWhereUniqueWithoutVendorInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutVendorInput, CertificationUncheckedUpdateWithoutVendorInput>
    create: XOR<CertificationCreateWithoutVendorInput, CertificationUncheckedCreateWithoutVendorInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutVendorInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutVendorInput, CertificationUncheckedUpdateWithoutVendorInput>
  }

  export type CertificationUpdateManyWithWhereWithoutVendorInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutVendorInput>
  }

  export type CertificationScalarWhereInput = {
    AND?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    OR?: CertificationScalarWhereInput[]
    NOT?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    id?: StringFilter<"Certification"> | string
    vendorId?: StringFilter<"Certification"> | string
    type?: EnumCertificationTypeFilter<"Certification"> | $Enums.CertificationType
    name?: StringFilter<"Certification"> | string
    issuingBody?: StringNullableFilter<"Certification"> | string | null
    certificationNumber?: StringNullableFilter<"Certification"> | string | null
    scope?: StringNullableFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    verified?: BoolFilter<"Certification"> | boolean
    verifiedDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    verifiedBy?: StringNullableFilter<"Certification"> | string | null
    documentUrl?: StringNullableFilter<"Certification"> | string | null
    notes?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutVendorInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutVendorInput, IncidentUncheckedUpdateWithoutVendorInput>
    create: XOR<IncidentCreateWithoutVendorInput, IncidentUncheckedCreateWithoutVendorInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutVendorInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutVendorInput, IncidentUncheckedUpdateWithoutVendorInput>
  }

  export type IncidentUpdateManyWithWhereWithoutVendorInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutVendorInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    vendorId?: StringFilter<"Incident"> | string
    type?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    discoveredAt?: DateTimeFilter<"Incident"> | Date | string
    reportedAt?: DateTimeFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    affectedSystems?: StringNullableListFilter<"Incident">
    affectedDataTypes?: StringNullableListFilter<"Incident">
    recordsAffected?: IntNullableFilter<"Incident"> | number | null
    phiInvolved?: BoolFilter<"Incident"> | boolean
    piiInvolved?: BoolFilter<"Incident"> | boolean
    rootCause?: StringNullableFilter<"Incident"> | string | null
    immediateActions?: StringNullableFilter<"Incident"> | string | null
    correctiveActions?: StringNullableFilter<"Incident"> | string | null
    preventiveActions?: StringNullableFilter<"Incident"> | string | null
    notificationRequired?: BoolFilter<"Incident"> | boolean
    notifiedParties?: StringNullableListFilter<"Incident">
    notificationDate?: DateTimeNullableFilter<"Incident"> | Date | string | null
    regulatoryReportRequired?: BoolFilter<"Incident"> | boolean
    regulatoryReportDate?: DateTimeNullableFilter<"Incident"> | Date | string | null
    lessonLearned?: StringNullableFilter<"Incident"> | string | null
    attachments?: JsonNullableFilter<"Incident">
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    createdBy?: StringNullableFilter<"Incident"> | string | null
  }

  export type RemediationTaskUpsertWithWhereUniqueWithoutVendorInput = {
    where: RemediationTaskWhereUniqueInput
    update: XOR<RemediationTaskUpdateWithoutVendorInput, RemediationTaskUncheckedUpdateWithoutVendorInput>
    create: XOR<RemediationTaskCreateWithoutVendorInput, RemediationTaskUncheckedCreateWithoutVendorInput>
  }

  export type RemediationTaskUpdateWithWhereUniqueWithoutVendorInput = {
    where: RemediationTaskWhereUniqueInput
    data: XOR<RemediationTaskUpdateWithoutVendorInput, RemediationTaskUncheckedUpdateWithoutVendorInput>
  }

  export type RemediationTaskUpdateManyWithWhereWithoutVendorInput = {
    where: RemediationTaskScalarWhereInput
    data: XOR<RemediationTaskUpdateManyMutationInput, RemediationTaskUncheckedUpdateManyWithoutVendorInput>
  }

  export type RemediationTaskScalarWhereInput = {
    AND?: RemediationTaskScalarWhereInput | RemediationTaskScalarWhereInput[]
    OR?: RemediationTaskScalarWhereInput[]
    NOT?: RemediationTaskScalarWhereInput | RemediationTaskScalarWhereInput[]
    id?: StringFilter<"RemediationTask"> | string
    vendorId?: StringFilter<"RemediationTask"> | string
    incidentId?: StringNullableFilter<"RemediationTask"> | string | null
    type?: EnumRemediationTypeFilter<"RemediationTask"> | $Enums.RemediationType
    priority?: EnumTaskPriorityFilter<"RemediationTask"> | $Enums.TaskPriority
    status?: EnumTaskStatusFilter<"RemediationTask"> | $Enums.TaskStatus
    title?: StringFilter<"RemediationTask"> | string
    description?: StringFilter<"RemediationTask"> | string
    requirement?: StringNullableFilter<"RemediationTask"> | string | null
    controlReference?: StringNullableFilter<"RemediationTask"> | string | null
    dueDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    assignedTo?: StringNullableFilter<"RemediationTask"> | string | null
    assignedToEmail?: StringNullableFilter<"RemediationTask"> | string | null
    evidence?: JsonNullableFilter<"RemediationTask">
    verifiedBy?: StringNullableFilter<"RemediationTask"> | string | null
    verifiedDate?: DateTimeNullableFilter<"RemediationTask"> | Date | string | null
    notes?: StringNullableFilter<"RemediationTask"> | string | null
    createdAt?: DateTimeFilter<"RemediationTask"> | Date | string
    updatedAt?: DateTimeFilter<"RemediationTask"> | Date | string
    createdBy?: StringNullableFilter<"RemediationTask"> | string | null
  }

  export type QuestionnaireResponseUpsertWithWhereUniqueWithoutVendorInput = {
    where: QuestionnaireResponseWhereUniqueInput
    update: XOR<QuestionnaireResponseUpdateWithoutVendorInput, QuestionnaireResponseUncheckedUpdateWithoutVendorInput>
    create: XOR<QuestionnaireResponseCreateWithoutVendorInput, QuestionnaireResponseUncheckedCreateWithoutVendorInput>
  }

  export type QuestionnaireResponseUpdateWithWhereUniqueWithoutVendorInput = {
    where: QuestionnaireResponseWhereUniqueInput
    data: XOR<QuestionnaireResponseUpdateWithoutVendorInput, QuestionnaireResponseUncheckedUpdateWithoutVendorInput>
  }

  export type QuestionnaireResponseUpdateManyWithWhereWithoutVendorInput = {
    where: QuestionnaireResponseScalarWhereInput
    data: XOR<QuestionnaireResponseUpdateManyMutationInput, QuestionnaireResponseUncheckedUpdateManyWithoutVendorInput>
  }

  export type QuestionnaireResponseScalarWhereInput = {
    AND?: QuestionnaireResponseScalarWhereInput | QuestionnaireResponseScalarWhereInput[]
    OR?: QuestionnaireResponseScalarWhereInput[]
    NOT?: QuestionnaireResponseScalarWhereInput | QuestionnaireResponseScalarWhereInput[]
    id?: StringFilter<"QuestionnaireResponse"> | string
    vendorId?: StringFilter<"QuestionnaireResponse"> | string
    templateId?: StringFilter<"QuestionnaireResponse"> | string
    status?: EnumQuestionnaireStatusFilter<"QuestionnaireResponse"> | $Enums.QuestionnaireStatus
    responses?: JsonNullableFilter<"QuestionnaireResponse">
    score?: IntNullableFilter<"QuestionnaireResponse"> | number | null
    maxScore?: IntNullableFilter<"QuestionnaireResponse"> | number | null
    percentComplete?: IntFilter<"QuestionnaireResponse"> | number
    submittedAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    reviewedBy?: StringNullableFilter<"QuestionnaireResponse"> | string | null
    reviewNotes?: StringNullableFilter<"QuestionnaireResponse"> | string | null
    expiresAt?: DateTimeNullableFilter<"QuestionnaireResponse"> | Date | string | null
    createdAt?: DateTimeFilter<"QuestionnaireResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireResponse"> | Date | string
  }

  export type VendorAuditLogUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorAuditLogWhereUniqueInput
    update: XOR<VendorAuditLogUpdateWithoutVendorInput, VendorAuditLogUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorAuditLogCreateWithoutVendorInput, VendorAuditLogUncheckedCreateWithoutVendorInput>
  }

  export type VendorAuditLogUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorAuditLogWhereUniqueInput
    data: XOR<VendorAuditLogUpdateWithoutVendorInput, VendorAuditLogUncheckedUpdateWithoutVendorInput>
  }

  export type VendorAuditLogUpdateManyWithWhereWithoutVendorInput = {
    where: VendorAuditLogScalarWhereInput
    data: XOR<VendorAuditLogUpdateManyMutationInput, VendorAuditLogUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorAuditLogScalarWhereInput = {
    AND?: VendorAuditLogScalarWhereInput | VendorAuditLogScalarWhereInput[]
    OR?: VendorAuditLogScalarWhereInput[]
    NOT?: VendorAuditLogScalarWhereInput | VendorAuditLogScalarWhereInput[]
    id?: StringFilter<"VendorAuditLog"> | string
    vendorId?: StringNullableFilter<"VendorAuditLog"> | string | null
    action?: StringFilter<"VendorAuditLog"> | string
    entityType?: StringFilter<"VendorAuditLog"> | string
    entityId?: StringNullableFilter<"VendorAuditLog"> | string | null
    userId?: StringFilter<"VendorAuditLog"> | string
    userEmail?: StringNullableFilter<"VendorAuditLog"> | string | null
    userRole?: StringNullableFilter<"VendorAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"VendorAuditLog"> | string | null
    userAgent?: StringNullableFilter<"VendorAuditLog"> | string | null
    oldValues?: JsonNullableFilter<"VendorAuditLog">
    newValues?: JsonNullableFilter<"VendorAuditLog">
    metadata?: JsonNullableFilter<"VendorAuditLog">
    createdAt?: DateTimeFilter<"VendorAuditLog"> | Date | string
  }

  export type VendorCreateWithoutAssessmentsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    contracts?: ContractCreateNestedManyWithoutVendorInput
    certifications?: CertificationCreateNestedManyWithoutVendorInput
    incidents?: IncidentCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAssessmentsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutVendorInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAssessmentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAssessmentsInput, VendorUncheckedCreateWithoutAssessmentsInput>
  }

  export type VendorUpsertWithoutAssessmentsInput = {
    update: XOR<VendorUpdateWithoutAssessmentsInput, VendorUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<VendorCreateWithoutAssessmentsInput, VendorUncheckedCreateWithoutAssessmentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutAssessmentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutAssessmentsInput, VendorUncheckedUpdateWithoutAssessmentsInput>
  }

  export type VendorUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type QuestionnaireResponseCreateWithoutTemplateInput = {
    id?: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutQuestionnairesInput
  }

  export type QuestionnaireResponseUncheckedCreateWithoutTemplateInput = {
    id?: string
    vendorId: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireResponseCreateOrConnectWithoutTemplateInput = {
    where: QuestionnaireResponseWhereUniqueInput
    create: XOR<QuestionnaireResponseCreateWithoutTemplateInput, QuestionnaireResponseUncheckedCreateWithoutTemplateInput>
  }

  export type QuestionnaireResponseCreateManyTemplateInputEnvelope = {
    data: QuestionnaireResponseCreateManyTemplateInput | QuestionnaireResponseCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type QuestionnaireResponseUpsertWithWhereUniqueWithoutTemplateInput = {
    where: QuestionnaireResponseWhereUniqueInput
    update: XOR<QuestionnaireResponseUpdateWithoutTemplateInput, QuestionnaireResponseUncheckedUpdateWithoutTemplateInput>
    create: XOR<QuestionnaireResponseCreateWithoutTemplateInput, QuestionnaireResponseUncheckedCreateWithoutTemplateInput>
  }

  export type QuestionnaireResponseUpdateWithWhereUniqueWithoutTemplateInput = {
    where: QuestionnaireResponseWhereUniqueInput
    data: XOR<QuestionnaireResponseUpdateWithoutTemplateInput, QuestionnaireResponseUncheckedUpdateWithoutTemplateInput>
  }

  export type QuestionnaireResponseUpdateManyWithWhereWithoutTemplateInput = {
    where: QuestionnaireResponseScalarWhereInput
    data: XOR<QuestionnaireResponseUpdateManyMutationInput, QuestionnaireResponseUncheckedUpdateManyWithoutTemplateInput>
  }

  export type VendorCreateWithoutQuestionnairesInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentCreateNestedManyWithoutVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    certifications?: CertificationCreateNestedManyWithoutVendorInput
    incidents?: IncidentCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutQuestionnairesInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentUncheckedCreateNestedManyWithoutVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutVendorInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutQuestionnairesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutQuestionnairesInput, VendorUncheckedCreateWithoutQuestionnairesInput>
  }

  export type QuestionnaireTemplateCreateWithoutResponsesInput = {
    id?: string
    name: string
    version: string
    type: $Enums.QuestionnaireType
    description?: string | null
    sections: JsonNullValueInput | InputJsonValue
    totalQuestions: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireTemplateUncheckedCreateWithoutResponsesInput = {
    id?: string
    name: string
    version: string
    type: $Enums.QuestionnaireType
    description?: string | null
    sections: JsonNullValueInput | InputJsonValue
    totalQuestions: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireTemplateCreateOrConnectWithoutResponsesInput = {
    where: QuestionnaireTemplateWhereUniqueInput
    create: XOR<QuestionnaireTemplateCreateWithoutResponsesInput, QuestionnaireTemplateUncheckedCreateWithoutResponsesInput>
  }

  export type VendorUpsertWithoutQuestionnairesInput = {
    update: XOR<VendorUpdateWithoutQuestionnairesInput, VendorUncheckedUpdateWithoutQuestionnairesInput>
    create: XOR<VendorCreateWithoutQuestionnairesInput, VendorUncheckedCreateWithoutQuestionnairesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutQuestionnairesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutQuestionnairesInput, VendorUncheckedUpdateWithoutQuestionnairesInput>
  }

  export type VendorUpdateWithoutQuestionnairesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUpdateManyWithoutVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutQuestionnairesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUncheckedUpdateManyWithoutVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type QuestionnaireTemplateUpsertWithoutResponsesInput = {
    update: XOR<QuestionnaireTemplateUpdateWithoutResponsesInput, QuestionnaireTemplateUncheckedUpdateWithoutResponsesInput>
    create: XOR<QuestionnaireTemplateCreateWithoutResponsesInput, QuestionnaireTemplateUncheckedCreateWithoutResponsesInput>
    where?: QuestionnaireTemplateWhereInput
  }

  export type QuestionnaireTemplateUpdateToOneWithWhereWithoutResponsesInput = {
    where?: QuestionnaireTemplateWhereInput
    data: XOR<QuestionnaireTemplateUpdateWithoutResponsesInput, QuestionnaireTemplateUncheckedUpdateWithoutResponsesInput>
  }

  export type QuestionnaireTemplateUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionnaireTypeFieldUpdateOperationsInput | $Enums.QuestionnaireType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireTemplateUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionnaireTypeFieldUpdateOperationsInput | $Enums.QuestionnaireType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateWithoutContractsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentCreateNestedManyWithoutVendorInput
    certifications?: CertificationCreateNestedManyWithoutVendorInput
    incidents?: IncidentCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentUncheckedCreateNestedManyWithoutVendorInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutVendorInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutContractsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
  }

  export type ContractAmendmentCreateWithoutContractInput = {
    id?: string
    amendmentNumber: number
    title: string
    description?: string | null
    effectiveDate: Date | string
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    createdAt?: Date | string
  }

  export type ContractAmendmentUncheckedCreateWithoutContractInput = {
    id?: string
    amendmentNumber: number
    title: string
    description?: string | null
    effectiveDate: Date | string
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    createdAt?: Date | string
  }

  export type ContractAmendmentCreateOrConnectWithoutContractInput = {
    where: ContractAmendmentWhereUniqueInput
    create: XOR<ContractAmendmentCreateWithoutContractInput, ContractAmendmentUncheckedCreateWithoutContractInput>
  }

  export type ContractAmendmentCreateManyContractInputEnvelope = {
    data: ContractAmendmentCreateManyContractInput | ContractAmendmentCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ContractRenewalCreateWithoutContractInput = {
    id?: string
    previousEndDate: Date | string
    newEndDate: Date | string
    renewalDate?: Date | string
    renewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContractRenewalUncheckedCreateWithoutContractInput = {
    id?: string
    previousEndDate: Date | string
    newEndDate: Date | string
    renewalDate?: Date | string
    renewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContractRenewalCreateOrConnectWithoutContractInput = {
    where: ContractRenewalWhereUniqueInput
    create: XOR<ContractRenewalCreateWithoutContractInput, ContractRenewalUncheckedCreateWithoutContractInput>
  }

  export type ContractRenewalCreateManyContractInputEnvelope = {
    data: ContractRenewalCreateManyContractInput | ContractRenewalCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutContractsInput = {
    update: XOR<VendorUpdateWithoutContractsInput, VendorUncheckedUpdateWithoutContractsInput>
    create: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutContractsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutContractsInput, VendorUncheckedUpdateWithoutContractsInput>
  }

  export type VendorUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUncheckedUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ContractAmendmentUpsertWithWhereUniqueWithoutContractInput = {
    where: ContractAmendmentWhereUniqueInput
    update: XOR<ContractAmendmentUpdateWithoutContractInput, ContractAmendmentUncheckedUpdateWithoutContractInput>
    create: XOR<ContractAmendmentCreateWithoutContractInput, ContractAmendmentUncheckedCreateWithoutContractInput>
  }

  export type ContractAmendmentUpdateWithWhereUniqueWithoutContractInput = {
    where: ContractAmendmentWhereUniqueInput
    data: XOR<ContractAmendmentUpdateWithoutContractInput, ContractAmendmentUncheckedUpdateWithoutContractInput>
  }

  export type ContractAmendmentUpdateManyWithWhereWithoutContractInput = {
    where: ContractAmendmentScalarWhereInput
    data: XOR<ContractAmendmentUpdateManyMutationInput, ContractAmendmentUncheckedUpdateManyWithoutContractInput>
  }

  export type ContractAmendmentScalarWhereInput = {
    AND?: ContractAmendmentScalarWhereInput | ContractAmendmentScalarWhereInput[]
    OR?: ContractAmendmentScalarWhereInput[]
    NOT?: ContractAmendmentScalarWhereInput | ContractAmendmentScalarWhereInput[]
    id?: StringFilter<"ContractAmendment"> | string
    contractId?: StringFilter<"ContractAmendment"> | string
    amendmentNumber?: IntFilter<"ContractAmendment"> | number
    title?: StringFilter<"ContractAmendment"> | string
    description?: StringNullableFilter<"ContractAmendment"> | string | null
    effectiveDate?: DateTimeFilter<"ContractAmendment"> | Date | string
    documentUrl?: StringNullableFilter<"ContractAmendment"> | string | null
    signedDate?: DateTimeNullableFilter<"ContractAmendment"> | Date | string | null
    signedBy?: StringNullableFilter<"ContractAmendment"> | string | null
    createdAt?: DateTimeFilter<"ContractAmendment"> | Date | string
  }

  export type ContractRenewalUpsertWithWhereUniqueWithoutContractInput = {
    where: ContractRenewalWhereUniqueInput
    update: XOR<ContractRenewalUpdateWithoutContractInput, ContractRenewalUncheckedUpdateWithoutContractInput>
    create: XOR<ContractRenewalCreateWithoutContractInput, ContractRenewalUncheckedCreateWithoutContractInput>
  }

  export type ContractRenewalUpdateWithWhereUniqueWithoutContractInput = {
    where: ContractRenewalWhereUniqueInput
    data: XOR<ContractRenewalUpdateWithoutContractInput, ContractRenewalUncheckedUpdateWithoutContractInput>
  }

  export type ContractRenewalUpdateManyWithWhereWithoutContractInput = {
    where: ContractRenewalScalarWhereInput
    data: XOR<ContractRenewalUpdateManyMutationInput, ContractRenewalUncheckedUpdateManyWithoutContractInput>
  }

  export type ContractRenewalScalarWhereInput = {
    AND?: ContractRenewalScalarWhereInput | ContractRenewalScalarWhereInput[]
    OR?: ContractRenewalScalarWhereInput[]
    NOT?: ContractRenewalScalarWhereInput | ContractRenewalScalarWhereInput[]
    id?: StringFilter<"ContractRenewal"> | string
    contractId?: StringFilter<"ContractRenewal"> | string
    previousEndDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    newEndDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    renewalDate?: DateTimeFilter<"ContractRenewal"> | Date | string
    renewedBy?: StringNullableFilter<"ContractRenewal"> | string | null
    notes?: StringNullableFilter<"ContractRenewal"> | string | null
    createdAt?: DateTimeFilter<"ContractRenewal"> | Date | string
  }

  export type ContractCreateWithoutAmendmentsInput = {
    id?: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutContractsInput
    renewalHistory?: ContractRenewalCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutAmendmentsInput = {
    id?: string
    vendorId: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    renewalHistory?: ContractRenewalUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutAmendmentsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
  }

  export type ContractUpsertWithoutAmendmentsInput = {
    update: XOR<ContractUpdateWithoutAmendmentsInput, ContractUncheckedUpdateWithoutAmendmentsInput>
    create: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutAmendmentsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutAmendmentsInput, ContractUncheckedUpdateWithoutAmendmentsInput>
  }

  export type ContractUpdateWithoutAmendmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    renewalHistory?: ContractRenewalUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutAmendmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    renewalHistory?: ContractRenewalUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateWithoutRenewalHistoryInput = {
    id?: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutContractsInput
    amendments?: ContractAmendmentCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutRenewalHistoryInput = {
    id?: string
    vendorId: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    amendments?: ContractAmendmentUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutRenewalHistoryInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutRenewalHistoryInput, ContractUncheckedCreateWithoutRenewalHistoryInput>
  }

  export type ContractUpsertWithoutRenewalHistoryInput = {
    update: XOR<ContractUpdateWithoutRenewalHistoryInput, ContractUncheckedUpdateWithoutRenewalHistoryInput>
    create: XOR<ContractCreateWithoutRenewalHistoryInput, ContractUncheckedCreateWithoutRenewalHistoryInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutRenewalHistoryInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutRenewalHistoryInput, ContractUncheckedUpdateWithoutRenewalHistoryInput>
  }

  export type ContractUpdateWithoutRenewalHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    amendments?: ContractAmendmentUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutRenewalHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    amendments?: ContractAmendmentUncheckedUpdateManyWithoutContractNestedInput
  }

  export type VendorCreateWithoutCertificationsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentCreateNestedManyWithoutVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    incidents?: IncidentCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutCertificationsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentUncheckedCreateNestedManyWithoutVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutCertificationsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutCertificationsInput, VendorUncheckedCreateWithoutCertificationsInput>
  }

  export type VendorUpsertWithoutCertificationsInput = {
    update: XOR<VendorUpdateWithoutCertificationsInput, VendorUncheckedUpdateWithoutCertificationsInput>
    create: XOR<VendorCreateWithoutCertificationsInput, VendorUncheckedCreateWithoutCertificationsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutCertificationsInput, VendorUncheckedUpdateWithoutCertificationsInput>
  }

  export type VendorUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUpdateManyWithoutVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUncheckedUpdateManyWithoutVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateWithoutIncidentsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentCreateNestedManyWithoutVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    certifications?: CertificationCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutIncidentsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentUncheckedCreateNestedManyWithoutVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutIncidentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutIncidentsInput, VendorUncheckedCreateWithoutIncidentsInput>
  }

  export type RemediationTaskCreateWithoutIncidentInput = {
    id?: string
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutRemediationsInput
  }

  export type RemediationTaskUncheckedCreateWithoutIncidentInput = {
    id?: string
    vendorId: string
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RemediationTaskCreateOrConnectWithoutIncidentInput = {
    where: RemediationTaskWhereUniqueInput
    create: XOR<RemediationTaskCreateWithoutIncidentInput, RemediationTaskUncheckedCreateWithoutIncidentInput>
  }

  export type RemediationTaskCreateManyIncidentInputEnvelope = {
    data: RemediationTaskCreateManyIncidentInput | RemediationTaskCreateManyIncidentInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutIncidentsInput = {
    update: XOR<VendorUpdateWithoutIncidentsInput, VendorUncheckedUpdateWithoutIncidentsInput>
    create: XOR<VendorCreateWithoutIncidentsInput, VendorUncheckedCreateWithoutIncidentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutIncidentsInput, VendorUncheckedUpdateWithoutIncidentsInput>
  }

  export type VendorUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUpdateManyWithoutVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUncheckedUpdateManyWithoutVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type RemediationTaskUpsertWithWhereUniqueWithoutIncidentInput = {
    where: RemediationTaskWhereUniqueInput
    update: XOR<RemediationTaskUpdateWithoutIncidentInput, RemediationTaskUncheckedUpdateWithoutIncidentInput>
    create: XOR<RemediationTaskCreateWithoutIncidentInput, RemediationTaskUncheckedCreateWithoutIncidentInput>
  }

  export type RemediationTaskUpdateWithWhereUniqueWithoutIncidentInput = {
    where: RemediationTaskWhereUniqueInput
    data: XOR<RemediationTaskUpdateWithoutIncidentInput, RemediationTaskUncheckedUpdateWithoutIncidentInput>
  }

  export type RemediationTaskUpdateManyWithWhereWithoutIncidentInput = {
    where: RemediationTaskScalarWhereInput
    data: XOR<RemediationTaskUpdateManyMutationInput, RemediationTaskUncheckedUpdateManyWithoutIncidentInput>
  }

  export type VendorCreateWithoutRemediationsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentCreateNestedManyWithoutVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    certifications?: CertificationCreateNestedManyWithoutVendorInput
    incidents?: IncidentCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutRemediationsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentUncheckedCreateNestedManyWithoutVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutVendorInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput
    auditLogs?: VendorAuditLogUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutRemediationsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutRemediationsInput, VendorUncheckedCreateWithoutRemediationsInput>
  }

  export type IncidentCreateWithoutRemediationsInput = {
    id?: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    vendor: VendorCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutRemediationsInput = {
    id?: string
    vendorId: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type IncidentCreateOrConnectWithoutRemediationsInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutRemediationsInput, IncidentUncheckedCreateWithoutRemediationsInput>
  }

  export type VendorUpsertWithoutRemediationsInput = {
    update: XOR<VendorUpdateWithoutRemediationsInput, VendorUncheckedUpdateWithoutRemediationsInput>
    create: XOR<VendorCreateWithoutRemediationsInput, VendorUncheckedCreateWithoutRemediationsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutRemediationsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutRemediationsInput, VendorUncheckedUpdateWithoutRemediationsInput>
  }

  export type VendorUpdateWithoutRemediationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUpdateManyWithoutVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutRemediationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUncheckedUpdateManyWithoutVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput
    auditLogs?: VendorAuditLogUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type IncidentUpsertWithoutRemediationsInput = {
    update: XOR<IncidentUpdateWithoutRemediationsInput, IncidentUncheckedUpdateWithoutRemediationsInput>
    create: XOR<IncidentCreateWithoutRemediationsInput, IncidentUncheckedCreateWithoutRemediationsInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutRemediationsInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutRemediationsInput, IncidentUncheckedUpdateWithoutRemediationsInput>
  }

  export type IncidentUpdateWithoutRemediationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutRemediationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentCreateNestedManyWithoutVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    certifications?: CertificationCreateNestedManyWithoutVendorInput
    incidents?: IncidentCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    legalName?: string | null
    dbaName?: string | null
    taxId?: string | null
    dunsNumber?: string | null
    website?: string | null
    description?: string | null
    category: $Enums.VendorCategory
    tier?: $Enums.VendorTier
    status?: $Enums.VendorStatus
    riskScore?: number
    riskLevel?: $Enums.RiskLevel
    primaryContactName?: string | null
    primaryContactEmail?: string | null
    primaryContactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: $Enums.DataAccessLevel
    phiAccess?: boolean
    piiAccess?: boolean
    onboardingDate?: Date | string | null
    lastReviewDate?: Date | string | null
    nextReviewDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    assessments?: AssessmentUncheckedCreateNestedManyWithoutVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutVendorInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVendorInput
    remediations?: RemediationTaskUncheckedCreateNestedManyWithoutVendorInput
    questionnaires?: QuestionnaireResponseUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAuditLogsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
  }

  export type VendorUpsertWithoutAuditLogsInput = {
    update: XOR<VendorUpdateWithoutAuditLogsInput, VendorUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<VendorCreateWithoutAuditLogsInput, VendorUncheckedCreateWithoutAuditLogsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutAuditLogsInput, VendorUncheckedUpdateWithoutAuditLogsInput>
  }

  export type VendorUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUpdateManyWithoutVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    dbaName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    dunsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumVendorCategoryFieldUpdateOperationsInput | $Enums.VendorCategory
    tier?: EnumVendorTierFieldUpdateOperationsInput | $Enums.VendorTier
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    riskScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    primaryContactName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    dataAccessLevel?: EnumDataAccessLevelFieldUpdateOperationsInput | $Enums.DataAccessLevel
    phiAccess?: BoolFieldUpdateOperationsInput | boolean
    piiAccess?: BoolFieldUpdateOperationsInput | boolean
    onboardingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assessments?: AssessmentUncheckedUpdateManyWithoutVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutVendorNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVendorNestedInput
    remediations?: RemediationTaskUncheckedUpdateManyWithoutVendorNestedInput
    questionnaires?: QuestionnaireResponseUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type AssessmentCreateManyVendorInput = {
    id?: string
    type: $Enums.AssessmentType
    status?: $Enums.AssessmentStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    score?: number | null
    maxScore?: number | null
    passThreshold?: number | null
    passed?: boolean | null
    reviewer?: string | null
    reviewerEmail?: string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type ContractCreateManyVendorInput = {
    id?: string
    contractNumber?: string | null
    type: $Enums.ContractType
    status?: $Enums.ContractStatus
    title: string
    description?: string | null
    effectiveDate?: Date | string | null
    expirationDate?: Date | string | null
    autoRenewal?: boolean
    renewalTermMonths?: number | null
    terminationNoticeDays?: number | null
    value?: number | null
    currency?: string
    paymentTerms?: string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: number | null
    liabilityLimit?: number | null
    indemnification?: boolean
    insuranceRequired?: boolean
    insuranceMinimum?: number | null
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    counterSignedDate?: Date | string | null
    counterSignedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type CertificationCreateManyVendorInput = {
    id?: string
    type: $Enums.CertificationType
    name: string
    issuingBody?: string | null
    certificationNumber?: string | null
    scope?: string | null
    issueDate?: Date | string | null
    expirationDate?: Date | string | null
    status?: $Enums.CertificationStatus
    verified?: boolean
    verifiedDate?: Date | string | null
    verifiedBy?: string | null
    documentUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyVendorInput = {
    id?: string
    type: $Enums.IncidentType
    severity?: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    title: string
    description: string
    discoveredAt: Date | string
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    affectedSystems?: IncidentCreateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentCreateaffectedDataTypesInput | string[]
    recordsAffected?: number | null
    phiInvolved?: boolean
    piiInvolved?: boolean
    rootCause?: string | null
    immediateActions?: string | null
    correctiveActions?: string | null
    preventiveActions?: string | null
    notificationRequired?: boolean
    notifiedParties?: IncidentCreatenotifiedPartiesInput | string[]
    notificationDate?: Date | string | null
    regulatoryReportRequired?: boolean
    regulatoryReportDate?: Date | string | null
    lessonLearned?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RemediationTaskCreateManyVendorInput = {
    id?: string
    incidentId?: string | null
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type QuestionnaireResponseCreateManyVendorInput = {
    id?: string
    templateId: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorAuditLogCreateManyVendorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    userId: string
    userEmail?: string | null
    userRole?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AssessmentUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    passThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    passThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAssessmentTypeFieldUpdateOperationsInput | $Enums.AssessmentType
    status?: EnumAssessmentStatusFieldUpdateOperationsInput | $Enums.AssessmentStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    passThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewer?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    amendments?: ContractAmendmentUpdateManyWithoutContractNestedInput
    renewalHistory?: ContractRenewalUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    amendments?: ContractAmendmentUncheckedUpdateManyWithoutContractNestedInput
    renewalHistory?: ContractRenewalUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    renewalTermMonths?: NullableIntFieldUpdateOperationsInput | number | null
    terminationNoticeDays?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    slaTerms?: NullableJsonNullValueInput | InputJsonValue
    securityRequirements?: NullableJsonNullValueInput | InputJsonValue
    dataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    liabilityLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    indemnification?: BoolFieldUpdateOperationsInput | boolean
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    insuranceMinimum?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    counterSignedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterSignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificationUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificationTypeFieldUpdateOperationsInput | $Enums.CertificationType
    name?: StringFieldUpdateOperationsInput | string
    issuingBody?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificationTypeFieldUpdateOperationsInput | $Enums.CertificationType
    name?: StringFieldUpdateOperationsInput | string
    issuingBody?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCertificationTypeFieldUpdateOperationsInput | $Enums.CertificationType
    name?: StringFieldUpdateOperationsInput | string
    issuingBody?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    remediations?: RemediationTaskUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    remediations?: RemediationTaskUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affectedSystems?: IncidentUpdateaffectedSystemsInput | string[]
    affectedDataTypes?: IncidentUpdateaffectedDataTypesInput | string[]
    recordsAffected?: NullableIntFieldUpdateOperationsInput | number | null
    phiInvolved?: BoolFieldUpdateOperationsInput | boolean
    piiInvolved?: BoolFieldUpdateOperationsInput | boolean
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    correctiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveActions?: NullableStringFieldUpdateOperationsInput | string | null
    notificationRequired?: BoolFieldUpdateOperationsInput | boolean
    notifiedParties?: IncidentUpdatenotifiedPartiesInput | string[]
    notificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    regulatoryReportRequired?: BoolFieldUpdateOperationsInput | boolean
    regulatoryReportDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessonLearned?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemediationTaskUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    incident?: IncidentUpdateOneWithoutRemediationsNestedInput
  }

  export type RemediationTaskUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemediationTaskUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionnaireResponseUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: QuestionnaireTemplateUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type QuestionnaireResponseUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireResponseUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAuditLogUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAuditLogUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAuditLogUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireResponseCreateManyTemplateInput = {
    id?: string
    vendorId: string
    status?: $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    maxScore?: number | null
    percentComplete?: number
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireResponseUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutQuestionnairesNestedInput
  }

  export type QuestionnaireResponseUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireResponseUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    responses?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractAmendmentCreateManyContractInput = {
    id?: string
    amendmentNumber: number
    title: string
    description?: string | null
    effectiveDate: Date | string
    documentUrl?: string | null
    signedDate?: Date | string | null
    signedBy?: string | null
    createdAt?: Date | string
  }

  export type ContractRenewalCreateManyContractInput = {
    id?: string
    previousEndDate: Date | string
    newEndDate: Date | string
    renewalDate?: Date | string
    renewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContractAmendmentUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amendmentNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractAmendmentUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amendmentNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractAmendmentUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amendmentNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractRenewalUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractRenewalUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractRenewalUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    newEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemediationTaskCreateManyIncidentInput = {
    id?: string
    vendorId: string
    type: $Enums.RemediationType
    priority?: $Enums.TaskPriority
    status?: $Enums.TaskStatus
    title: string
    description: string
    requirement?: string | null
    controlReference?: string | null
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RemediationTaskUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: VendorUpdateOneRequiredWithoutRemediationsNestedInput
  }

  export type RemediationTaskUncheckedUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemediationTaskUncheckedUpdateManyWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    type?: EnumRemediationTypeFieldUpdateOperationsInput | $Enums.RemediationType
    priority?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    controlReference?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use VendorCountOutputTypeDefaultArgs instead
     */
    export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionnaireTemplateCountOutputTypeDefaultArgs instead
     */
    export type QuestionnaireTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionnaireTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractCountOutputTypeDefaultArgs instead
     */
    export type ContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentCountOutputTypeDefaultArgs instead
     */
    export type IncidentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDefaultArgs instead
     */
    export type VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentDefaultArgs instead
     */
    export type AssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionnaireTemplateDefaultArgs instead
     */
    export type QuestionnaireTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionnaireTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionnaireResponseDefaultArgs instead
     */
    export type QuestionnaireResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionnaireResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDefaultArgs instead
     */
    export type ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractAmendmentDefaultArgs instead
     */
    export type ContractAmendmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractAmendmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractRenewalDefaultArgs instead
     */
    export type ContractRenewalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractRenewalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificationDefaultArgs instead
     */
    export type CertificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentDefaultArgs instead
     */
    export type IncidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RemediationTaskDefaultArgs instead
     */
    export type RemediationTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RemediationTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorAuditLogDefaultArgs instead
     */
    export type VendorAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorAuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskScoringCriteriaDefaultArgs instead
     */
    export type RiskScoringCriteriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskScoringCriteriaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}