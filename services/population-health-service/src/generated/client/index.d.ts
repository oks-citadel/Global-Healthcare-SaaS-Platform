
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Population
 * 
 */
export type Population = $Result.DefaultSelection<Prisma.$PopulationPayload>
/**
 * Model PopulationMember
 * 
 */
export type PopulationMember = $Result.DefaultSelection<Prisma.$PopulationMemberPayload>
/**
 * Model Cohort
 * 
 */
export type Cohort = $Result.DefaultSelection<Prisma.$CohortPayload>
/**
 * Model CohortMember
 * 
 */
export type CohortMember = $Result.DefaultSelection<Prisma.$CohortMemberPayload>
/**
 * Model QualityMeasure
 * 
 */
export type QualityMeasure = $Result.DefaultSelection<Prisma.$QualityMeasurePayload>
/**
 * Model PopulationQualityMeasure
 * 
 */
export type PopulationQualityMeasure = $Result.DefaultSelection<Prisma.$PopulationQualityMeasurePayload>
/**
 * Model PatientQualityMeasure
 * 
 */
export type PatientQualityMeasure = $Result.DefaultSelection<Prisma.$PatientQualityMeasurePayload>
/**
 * Model RiskScore
 * 
 */
export type RiskScore = $Result.DefaultSelection<Prisma.$RiskScorePayload>
/**
 * Model CareGap
 * 
 */
export type CareGap = $Result.DefaultSelection<Prisma.$CareGapPayload>
/**
 * Model SdohFactor
 * 
 */
export type SdohFactor = $Result.DefaultSelection<Prisma.$SdohFactorPayload>
/**
 * Model DiseaseRegistry
 * 
 */
export type DiseaseRegistry = $Result.DefaultSelection<Prisma.$DiseaseRegistryPayload>
/**
 * Model HealthEquityMetric
 * 
 */
export type HealthEquityMetric = $Result.DefaultSelection<Prisma.$HealthEquityMetricPayload>
/**
 * Model AnalyticsReport
 * 
 */
export type AnalyticsReport = $Result.DefaultSelection<Prisma.$AnalyticsReportPayload>
/**
 * Model PredictiveModel
 * 
 */
export type PredictiveModel = $Result.DefaultSelection<Prisma.$PredictiveModelPayload>
/**
 * Model AnalyticsAuditLog
 * 
 */
export type AnalyticsAuditLog = $Result.DefaultSelection<Prisma.$AnalyticsAuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DefinitionType: {
  geographic: 'geographic',
  demographic: 'demographic',
  condition_based: 'condition_based',
  payer_based: 'payer_based',
  provider_panel: 'provider_panel',
  custom: 'custom'
};

export type DefinitionType = (typeof DefinitionType)[keyof typeof DefinitionType]


export const PopulationStatus: {
  active: 'active',
  inactive: 'inactive',
  archived: 'archived'
};

export type PopulationStatus = (typeof PopulationStatus)[keyof typeof PopulationStatus]


export const MemberStatus: {
  active: 'active',
  inactive: 'inactive',
  deceased: 'deceased',
  transferred: 'transferred'
};

export type MemberStatus = (typeof MemberStatus)[keyof typeof MemberStatus]


export const RiskTier: {
  low: 'low',
  moderate: 'moderate',
  high: 'high',
  very_high: 'very_high',
  critical: 'critical'
};

export type RiskTier = (typeof RiskTier)[keyof typeof RiskTier]


export const CohortType: {
  risk_stratification: 'risk_stratification',
  disease_registry: 'disease_registry',
  care_management: 'care_management',
  quality_improvement: 'quality_improvement',
  research: 'research',
  custom: 'custom'
};

export type CohortType = (typeof CohortType)[keyof typeof CohortType]


export const MeasureType: {
  process: 'process',
  outcome: 'outcome',
  structure: 'structure',
  patient_experience: 'patient_experience',
  intermediate_outcome: 'intermediate_outcome',
  composite: 'composite'
};

export type MeasureType = (typeof MeasureType)[keyof typeof MeasureType]


export const MeasureCategory: {
  hedis: 'hedis',
  cms_stars: 'cms_stars',
  mips: 'mips',
  pcmh: 'pcmh',
  aco: 'aco',
  state_medicaid: 'state_medicaid',
  commercial: 'commercial',
  custom: 'custom'
};

export type MeasureCategory = (typeof MeasureCategory)[keyof typeof MeasureCategory]


export const ComplianceStatus: {
  pending: 'pending',
  compliant: 'compliant',
  non_compliant: 'non_compliant',
  excluded: 'excluded',
  not_applicable: 'not_applicable'
};

export type ComplianceStatus = (typeof ComplianceStatus)[keyof typeof ComplianceStatus]


export const ScoreType: {
  hcc_raf: 'hcc_raf',
  cdps: 'cdps',
  hospitalization_risk: 'hospitalization_risk',
  ed_utilization: 'ed_utilization',
  readmission_risk: 'readmission_risk',
  mortality_risk: 'mortality_risk',
  cost_prediction: 'cost_prediction',
  composite: 'composite',
  custom: 'custom'
};

export type ScoreType = (typeof ScoreType)[keyof typeof ScoreType]


export const GapType: {
  preventive_care: 'preventive_care',
  chronic_disease_management: 'chronic_disease_management',
  medication_adherence: 'medication_adherence',
  screening: 'screening',
  immunization: 'immunization',
  follow_up: 'follow_up',
  lab_test: 'lab_test',
  specialist_referral: 'specialist_referral',
  wellness_visit: 'wellness_visit',
  other: 'other'
};

export type GapType = (typeof GapType)[keyof typeof GapType]


export const GapPriority: {
  low: 'low',
  medium: 'medium',
  high: 'high',
  urgent: 'urgent'
};

export type GapPriority = (typeof GapPriority)[keyof typeof GapPriority]


export const GapStatus: {
  open: 'open',
  in_progress: 'in_progress',
  scheduled: 'scheduled',
  resolved: 'resolved',
  closed: 'closed',
  patient_declined: 'patient_declined'
};

export type GapStatus = (typeof GapStatus)[keyof typeof GapStatus]


export const SdohCategory: {
  food_insecurity: 'food_insecurity',
  housing_instability: 'housing_instability',
  transportation: 'transportation',
  utilities: 'utilities',
  interpersonal_safety: 'interpersonal_safety',
  education: 'education',
  employment: 'employment',
  financial_strain: 'financial_strain',
  social_isolation: 'social_isolation',
  health_literacy: 'health_literacy',
  stress: 'stress',
  other: 'other'
};

export type SdohCategory = (typeof SdohCategory)[keyof typeof SdohCategory]


export const SdohSeverity: {
  none: 'none',
  mild: 'mild',
  moderate: 'moderate',
  severe: 'severe'
};

export type SdohSeverity = (typeof SdohSeverity)[keyof typeof SdohSeverity]


export const TrendDirection: {
  increasing: 'increasing',
  stable: 'stable',
  decreasing: 'decreasing'
};

export type TrendDirection = (typeof TrendDirection)[keyof typeof TrendDirection]


export const EquityMeasureType: {
  access_to_care: 'access_to_care',
  quality_of_care: 'quality_of_care',
  health_outcomes: 'health_outcomes',
  patient_experience: 'patient_experience',
  utilization: 'utilization',
  cost: 'cost'
};

export type EquityMeasureType = (typeof EquityMeasureType)[keyof typeof EquityMeasureType]


export const ReportType: {
  population_dashboard: 'population_dashboard',
  quality_scorecard: 'quality_scorecard',
  risk_stratification: 'risk_stratification',
  care_gap_analysis: 'care_gap_analysis',
  sdoh_assessment: 'sdoh_assessment',
  disease_surveillance: 'disease_surveillance',
  health_equity: 'health_equity',
  trend_analysis: 'trend_analysis',
  predictive_model: 'predictive_model',
  custom: 'custom'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const PredictiveModelType: {
  hospitalization: 'hospitalization',
  readmission: 'readmission',
  ed_visit: 'ed_visit',
  mortality: 'mortality',
  disease_progression: 'disease_progression',
  cost: 'cost',
  medication_adherence: 'medication_adherence',
  care_gap_closure: 'care_gap_closure',
  custom: 'custom'
};

export type PredictiveModelType = (typeof PredictiveModelType)[keyof typeof PredictiveModelType]

}

export type DefinitionType = $Enums.DefinitionType

export const DefinitionType: typeof $Enums.DefinitionType

export type PopulationStatus = $Enums.PopulationStatus

export const PopulationStatus: typeof $Enums.PopulationStatus

export type MemberStatus = $Enums.MemberStatus

export const MemberStatus: typeof $Enums.MemberStatus

export type RiskTier = $Enums.RiskTier

export const RiskTier: typeof $Enums.RiskTier

export type CohortType = $Enums.CohortType

export const CohortType: typeof $Enums.CohortType

export type MeasureType = $Enums.MeasureType

export const MeasureType: typeof $Enums.MeasureType

export type MeasureCategory = $Enums.MeasureCategory

export const MeasureCategory: typeof $Enums.MeasureCategory

export type ComplianceStatus = $Enums.ComplianceStatus

export const ComplianceStatus: typeof $Enums.ComplianceStatus

export type ScoreType = $Enums.ScoreType

export const ScoreType: typeof $Enums.ScoreType

export type GapType = $Enums.GapType

export const GapType: typeof $Enums.GapType

export type GapPriority = $Enums.GapPriority

export const GapPriority: typeof $Enums.GapPriority

export type GapStatus = $Enums.GapStatus

export const GapStatus: typeof $Enums.GapStatus

export type SdohCategory = $Enums.SdohCategory

export const SdohCategory: typeof $Enums.SdohCategory

export type SdohSeverity = $Enums.SdohSeverity

export const SdohSeverity: typeof $Enums.SdohSeverity

export type TrendDirection = $Enums.TrendDirection

export const TrendDirection: typeof $Enums.TrendDirection

export type EquityMeasureType = $Enums.EquityMeasureType

export const EquityMeasureType: typeof $Enums.EquityMeasureType

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type PredictiveModelType = $Enums.PredictiveModelType

export const PredictiveModelType: typeof $Enums.PredictiveModelType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Populations
 * const populations = await prisma.population.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Populations
   * const populations = await prisma.population.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.population`: Exposes CRUD operations for the **Population** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Populations
    * const populations = await prisma.population.findMany()
    * ```
    */
  get population(): Prisma.PopulationDelegate<ExtArgs>;

  /**
   * `prisma.populationMember`: Exposes CRUD operations for the **PopulationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PopulationMembers
    * const populationMembers = await prisma.populationMember.findMany()
    * ```
    */
  get populationMember(): Prisma.PopulationMemberDelegate<ExtArgs>;

  /**
   * `prisma.cohort`: Exposes CRUD operations for the **Cohort** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cohorts
    * const cohorts = await prisma.cohort.findMany()
    * ```
    */
  get cohort(): Prisma.CohortDelegate<ExtArgs>;

  /**
   * `prisma.cohortMember`: Exposes CRUD operations for the **CohortMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CohortMembers
    * const cohortMembers = await prisma.cohortMember.findMany()
    * ```
    */
  get cohortMember(): Prisma.CohortMemberDelegate<ExtArgs>;

  /**
   * `prisma.qualityMeasure`: Exposes CRUD operations for the **QualityMeasure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QualityMeasures
    * const qualityMeasures = await prisma.qualityMeasure.findMany()
    * ```
    */
  get qualityMeasure(): Prisma.QualityMeasureDelegate<ExtArgs>;

  /**
   * `prisma.populationQualityMeasure`: Exposes CRUD operations for the **PopulationQualityMeasure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PopulationQualityMeasures
    * const populationQualityMeasures = await prisma.populationQualityMeasure.findMany()
    * ```
    */
  get populationQualityMeasure(): Prisma.PopulationQualityMeasureDelegate<ExtArgs>;

  /**
   * `prisma.patientQualityMeasure`: Exposes CRUD operations for the **PatientQualityMeasure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientQualityMeasures
    * const patientQualityMeasures = await prisma.patientQualityMeasure.findMany()
    * ```
    */
  get patientQualityMeasure(): Prisma.PatientQualityMeasureDelegate<ExtArgs>;

  /**
   * `prisma.riskScore`: Exposes CRUD operations for the **RiskScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskScores
    * const riskScores = await prisma.riskScore.findMany()
    * ```
    */
  get riskScore(): Prisma.RiskScoreDelegate<ExtArgs>;

  /**
   * `prisma.careGap`: Exposes CRUD operations for the **CareGap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareGaps
    * const careGaps = await prisma.careGap.findMany()
    * ```
    */
  get careGap(): Prisma.CareGapDelegate<ExtArgs>;

  /**
   * `prisma.sdohFactor`: Exposes CRUD operations for the **SdohFactor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SdohFactors
    * const sdohFactors = await prisma.sdohFactor.findMany()
    * ```
    */
  get sdohFactor(): Prisma.SdohFactorDelegate<ExtArgs>;

  /**
   * `prisma.diseaseRegistry`: Exposes CRUD operations for the **DiseaseRegistry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiseaseRegistries
    * const diseaseRegistries = await prisma.diseaseRegistry.findMany()
    * ```
    */
  get diseaseRegistry(): Prisma.DiseaseRegistryDelegate<ExtArgs>;

  /**
   * `prisma.healthEquityMetric`: Exposes CRUD operations for the **HealthEquityMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthEquityMetrics
    * const healthEquityMetrics = await prisma.healthEquityMetric.findMany()
    * ```
    */
  get healthEquityMetric(): Prisma.HealthEquityMetricDelegate<ExtArgs>;

  /**
   * `prisma.analyticsReport`: Exposes CRUD operations for the **AnalyticsReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsReports
    * const analyticsReports = await prisma.analyticsReport.findMany()
    * ```
    */
  get analyticsReport(): Prisma.AnalyticsReportDelegate<ExtArgs>;

  /**
   * `prisma.predictiveModel`: Exposes CRUD operations for the **PredictiveModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PredictiveModels
    * const predictiveModels = await prisma.predictiveModel.findMany()
    * ```
    */
  get predictiveModel(): Prisma.PredictiveModelDelegate<ExtArgs>;

  /**
   * `prisma.analyticsAuditLog`: Exposes CRUD operations for the **AnalyticsAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsAuditLogs
    * const analyticsAuditLogs = await prisma.analyticsAuditLog.findMany()
    * ```
    */
  get analyticsAuditLog(): Prisma.AnalyticsAuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Population: 'Population',
    PopulationMember: 'PopulationMember',
    Cohort: 'Cohort',
    CohortMember: 'CohortMember',
    QualityMeasure: 'QualityMeasure',
    PopulationQualityMeasure: 'PopulationQualityMeasure',
    PatientQualityMeasure: 'PatientQualityMeasure',
    RiskScore: 'RiskScore',
    CareGap: 'CareGap',
    SdohFactor: 'SdohFactor',
    DiseaseRegistry: 'DiseaseRegistry',
    HealthEquityMetric: 'HealthEquityMetric',
    AnalyticsReport: 'AnalyticsReport',
    PredictiveModel: 'PredictiveModel',
    AnalyticsAuditLog: 'AnalyticsAuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "population" | "populationMember" | "cohort" | "cohortMember" | "qualityMeasure" | "populationQualityMeasure" | "patientQualityMeasure" | "riskScore" | "careGap" | "sdohFactor" | "diseaseRegistry" | "healthEquityMetric" | "analyticsReport" | "predictiveModel" | "analyticsAuditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Population: {
        payload: Prisma.$PopulationPayload<ExtArgs>
        fields: Prisma.PopulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PopulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PopulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>
          }
          findFirst: {
            args: Prisma.PopulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PopulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>
          }
          findMany: {
            args: Prisma.PopulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>[]
          }
          create: {
            args: Prisma.PopulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>
          }
          createMany: {
            args: Prisma.PopulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PopulationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>[]
          }
          delete: {
            args: Prisma.PopulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>
          }
          update: {
            args: Prisma.PopulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>
          }
          deleteMany: {
            args: Prisma.PopulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PopulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PopulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationPayload>
          }
          aggregate: {
            args: Prisma.PopulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePopulation>
          }
          groupBy: {
            args: Prisma.PopulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PopulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PopulationCountArgs<ExtArgs>
            result: $Utils.Optional<PopulationCountAggregateOutputType> | number
          }
        }
      }
      PopulationMember: {
        payload: Prisma.$PopulationMemberPayload<ExtArgs>
        fields: Prisma.PopulationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PopulationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PopulationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>
          }
          findFirst: {
            args: Prisma.PopulationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PopulationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>
          }
          findMany: {
            args: Prisma.PopulationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>[]
          }
          create: {
            args: Prisma.PopulationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>
          }
          createMany: {
            args: Prisma.PopulationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PopulationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>[]
          }
          delete: {
            args: Prisma.PopulationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>
          }
          update: {
            args: Prisma.PopulationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>
          }
          deleteMany: {
            args: Prisma.PopulationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PopulationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PopulationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationMemberPayload>
          }
          aggregate: {
            args: Prisma.PopulationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePopulationMember>
          }
          groupBy: {
            args: Prisma.PopulationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<PopulationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.PopulationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<PopulationMemberCountAggregateOutputType> | number
          }
        }
      }
      Cohort: {
        payload: Prisma.$CohortPayload<ExtArgs>
        fields: Prisma.CohortFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CohortFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CohortFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>
          }
          findFirst: {
            args: Prisma.CohortFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CohortFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>
          }
          findMany: {
            args: Prisma.CohortFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>[]
          }
          create: {
            args: Prisma.CohortCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>
          }
          createMany: {
            args: Prisma.CohortCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CohortCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>[]
          }
          delete: {
            args: Prisma.CohortDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>
          }
          update: {
            args: Prisma.CohortUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>
          }
          deleteMany: {
            args: Prisma.CohortDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CohortUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CohortUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortPayload>
          }
          aggregate: {
            args: Prisma.CohortAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCohort>
          }
          groupBy: {
            args: Prisma.CohortGroupByArgs<ExtArgs>
            result: $Utils.Optional<CohortGroupByOutputType>[]
          }
          count: {
            args: Prisma.CohortCountArgs<ExtArgs>
            result: $Utils.Optional<CohortCountAggregateOutputType> | number
          }
        }
      }
      CohortMember: {
        payload: Prisma.$CohortMemberPayload<ExtArgs>
        fields: Prisma.CohortMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CohortMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CohortMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>
          }
          findFirst: {
            args: Prisma.CohortMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CohortMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>
          }
          findMany: {
            args: Prisma.CohortMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>[]
          }
          create: {
            args: Prisma.CohortMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>
          }
          createMany: {
            args: Prisma.CohortMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CohortMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>[]
          }
          delete: {
            args: Prisma.CohortMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>
          }
          update: {
            args: Prisma.CohortMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>
          }
          deleteMany: {
            args: Prisma.CohortMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CohortMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CohortMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CohortMemberPayload>
          }
          aggregate: {
            args: Prisma.CohortMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCohortMember>
          }
          groupBy: {
            args: Prisma.CohortMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CohortMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CohortMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CohortMemberCountAggregateOutputType> | number
          }
        }
      }
      QualityMeasure: {
        payload: Prisma.$QualityMeasurePayload<ExtArgs>
        fields: Prisma.QualityMeasureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QualityMeasureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QualityMeasureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>
          }
          findFirst: {
            args: Prisma.QualityMeasureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QualityMeasureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>
          }
          findMany: {
            args: Prisma.QualityMeasureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>[]
          }
          create: {
            args: Prisma.QualityMeasureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>
          }
          createMany: {
            args: Prisma.QualityMeasureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QualityMeasureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>[]
          }
          delete: {
            args: Prisma.QualityMeasureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>
          }
          update: {
            args: Prisma.QualityMeasureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>
          }
          deleteMany: {
            args: Prisma.QualityMeasureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QualityMeasureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QualityMeasureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityMeasurePayload>
          }
          aggregate: {
            args: Prisma.QualityMeasureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualityMeasure>
          }
          groupBy: {
            args: Prisma.QualityMeasureGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualityMeasureGroupByOutputType>[]
          }
          count: {
            args: Prisma.QualityMeasureCountArgs<ExtArgs>
            result: $Utils.Optional<QualityMeasureCountAggregateOutputType> | number
          }
        }
      }
      PopulationQualityMeasure: {
        payload: Prisma.$PopulationQualityMeasurePayload<ExtArgs>
        fields: Prisma.PopulationQualityMeasureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PopulationQualityMeasureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PopulationQualityMeasureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>
          }
          findFirst: {
            args: Prisma.PopulationQualityMeasureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PopulationQualityMeasureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>
          }
          findMany: {
            args: Prisma.PopulationQualityMeasureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>[]
          }
          create: {
            args: Prisma.PopulationQualityMeasureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>
          }
          createMany: {
            args: Prisma.PopulationQualityMeasureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PopulationQualityMeasureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>[]
          }
          delete: {
            args: Prisma.PopulationQualityMeasureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>
          }
          update: {
            args: Prisma.PopulationQualityMeasureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>
          }
          deleteMany: {
            args: Prisma.PopulationQualityMeasureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PopulationQualityMeasureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PopulationQualityMeasureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PopulationQualityMeasurePayload>
          }
          aggregate: {
            args: Prisma.PopulationQualityMeasureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePopulationQualityMeasure>
          }
          groupBy: {
            args: Prisma.PopulationQualityMeasureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PopulationQualityMeasureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PopulationQualityMeasureCountArgs<ExtArgs>
            result: $Utils.Optional<PopulationQualityMeasureCountAggregateOutputType> | number
          }
        }
      }
      PatientQualityMeasure: {
        payload: Prisma.$PatientQualityMeasurePayload<ExtArgs>
        fields: Prisma.PatientQualityMeasureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientQualityMeasureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientQualityMeasureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>
          }
          findFirst: {
            args: Prisma.PatientQualityMeasureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientQualityMeasureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>
          }
          findMany: {
            args: Prisma.PatientQualityMeasureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>[]
          }
          create: {
            args: Prisma.PatientQualityMeasureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>
          }
          createMany: {
            args: Prisma.PatientQualityMeasureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientQualityMeasureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>[]
          }
          delete: {
            args: Prisma.PatientQualityMeasureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>
          }
          update: {
            args: Prisma.PatientQualityMeasureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>
          }
          deleteMany: {
            args: Prisma.PatientQualityMeasureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientQualityMeasureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientQualityMeasureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientQualityMeasurePayload>
          }
          aggregate: {
            args: Prisma.PatientQualityMeasureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientQualityMeasure>
          }
          groupBy: {
            args: Prisma.PatientQualityMeasureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientQualityMeasureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientQualityMeasureCountArgs<ExtArgs>
            result: $Utils.Optional<PatientQualityMeasureCountAggregateOutputType> | number
          }
        }
      }
      RiskScore: {
        payload: Prisma.$RiskScorePayload<ExtArgs>
        fields: Prisma.RiskScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>
          }
          findFirst: {
            args: Prisma.RiskScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>
          }
          findMany: {
            args: Prisma.RiskScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>[]
          }
          create: {
            args: Prisma.RiskScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>
          }
          createMany: {
            args: Prisma.RiskScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>[]
          }
          delete: {
            args: Prisma.RiskScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>
          }
          update: {
            args: Prisma.RiskScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>
          }
          deleteMany: {
            args: Prisma.RiskScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskScorePayload>
          }
          aggregate: {
            args: Prisma.RiskScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskScore>
          }
          groupBy: {
            args: Prisma.RiskScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskScoreCountArgs<ExtArgs>
            result: $Utils.Optional<RiskScoreCountAggregateOutputType> | number
          }
        }
      }
      CareGap: {
        payload: Prisma.$CareGapPayload<ExtArgs>
        fields: Prisma.CareGapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareGapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareGapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>
          }
          findFirst: {
            args: Prisma.CareGapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareGapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>
          }
          findMany: {
            args: Prisma.CareGapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>[]
          }
          create: {
            args: Prisma.CareGapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>
          }
          createMany: {
            args: Prisma.CareGapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CareGapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>[]
          }
          delete: {
            args: Prisma.CareGapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>
          }
          update: {
            args: Prisma.CareGapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>
          }
          deleteMany: {
            args: Prisma.CareGapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareGapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CareGapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareGapPayload>
          }
          aggregate: {
            args: Prisma.CareGapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareGap>
          }
          groupBy: {
            args: Prisma.CareGapGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareGapGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareGapCountArgs<ExtArgs>
            result: $Utils.Optional<CareGapCountAggregateOutputType> | number
          }
        }
      }
      SdohFactor: {
        payload: Prisma.$SdohFactorPayload<ExtArgs>
        fields: Prisma.SdohFactorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SdohFactorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SdohFactorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>
          }
          findFirst: {
            args: Prisma.SdohFactorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SdohFactorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>
          }
          findMany: {
            args: Prisma.SdohFactorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>[]
          }
          create: {
            args: Prisma.SdohFactorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>
          }
          createMany: {
            args: Prisma.SdohFactorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SdohFactorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>[]
          }
          delete: {
            args: Prisma.SdohFactorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>
          }
          update: {
            args: Prisma.SdohFactorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>
          }
          deleteMany: {
            args: Prisma.SdohFactorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SdohFactorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SdohFactorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdohFactorPayload>
          }
          aggregate: {
            args: Prisma.SdohFactorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSdohFactor>
          }
          groupBy: {
            args: Prisma.SdohFactorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SdohFactorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SdohFactorCountArgs<ExtArgs>
            result: $Utils.Optional<SdohFactorCountAggregateOutputType> | number
          }
        }
      }
      DiseaseRegistry: {
        payload: Prisma.$DiseaseRegistryPayload<ExtArgs>
        fields: Prisma.DiseaseRegistryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiseaseRegistryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiseaseRegistryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>
          }
          findFirst: {
            args: Prisma.DiseaseRegistryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiseaseRegistryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>
          }
          findMany: {
            args: Prisma.DiseaseRegistryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>[]
          }
          create: {
            args: Prisma.DiseaseRegistryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>
          }
          createMany: {
            args: Prisma.DiseaseRegistryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiseaseRegistryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>[]
          }
          delete: {
            args: Prisma.DiseaseRegistryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>
          }
          update: {
            args: Prisma.DiseaseRegistryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>
          }
          deleteMany: {
            args: Prisma.DiseaseRegistryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiseaseRegistryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiseaseRegistryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiseaseRegistryPayload>
          }
          aggregate: {
            args: Prisma.DiseaseRegistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiseaseRegistry>
          }
          groupBy: {
            args: Prisma.DiseaseRegistryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiseaseRegistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiseaseRegistryCountArgs<ExtArgs>
            result: $Utils.Optional<DiseaseRegistryCountAggregateOutputType> | number
          }
        }
      }
      HealthEquityMetric: {
        payload: Prisma.$HealthEquityMetricPayload<ExtArgs>
        fields: Prisma.HealthEquityMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthEquityMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthEquityMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>
          }
          findFirst: {
            args: Prisma.HealthEquityMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthEquityMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>
          }
          findMany: {
            args: Prisma.HealthEquityMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>[]
          }
          create: {
            args: Prisma.HealthEquityMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>
          }
          createMany: {
            args: Prisma.HealthEquityMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthEquityMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>[]
          }
          delete: {
            args: Prisma.HealthEquityMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>
          }
          update: {
            args: Prisma.HealthEquityMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>
          }
          deleteMany: {
            args: Prisma.HealthEquityMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthEquityMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthEquityMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEquityMetricPayload>
          }
          aggregate: {
            args: Prisma.HealthEquityMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthEquityMetric>
          }
          groupBy: {
            args: Prisma.HealthEquityMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthEquityMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthEquityMetricCountArgs<ExtArgs>
            result: $Utils.Optional<HealthEquityMetricCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsReport: {
        payload: Prisma.$AnalyticsReportPayload<ExtArgs>
        fields: Prisma.AnalyticsReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findMany: {
            args: Prisma.AnalyticsReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          create: {
            args: Prisma.AnalyticsReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          createMany: {
            args: Prisma.AnalyticsReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          update: {
            args: Prisma.AnalyticsReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsReport>
          }
          groupBy: {
            args: Prisma.AnalyticsReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsReportCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportCountAggregateOutputType> | number
          }
        }
      }
      PredictiveModel: {
        payload: Prisma.$PredictiveModelPayload<ExtArgs>
        fields: Prisma.PredictiveModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PredictiveModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PredictiveModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>
          }
          findFirst: {
            args: Prisma.PredictiveModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PredictiveModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>
          }
          findMany: {
            args: Prisma.PredictiveModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>[]
          }
          create: {
            args: Prisma.PredictiveModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>
          }
          createMany: {
            args: Prisma.PredictiveModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PredictiveModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>[]
          }
          delete: {
            args: Prisma.PredictiveModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>
          }
          update: {
            args: Prisma.PredictiveModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>
          }
          deleteMany: {
            args: Prisma.PredictiveModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PredictiveModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PredictiveModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictiveModelPayload>
          }
          aggregate: {
            args: Prisma.PredictiveModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePredictiveModel>
          }
          groupBy: {
            args: Prisma.PredictiveModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PredictiveModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PredictiveModelCountArgs<ExtArgs>
            result: $Utils.Optional<PredictiveModelCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsAuditLog: {
        payload: Prisma.$AnalyticsAuditLogPayload<ExtArgs>
        fields: Prisma.AnalyticsAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>
          }
          findMany: {
            args: Prisma.AnalyticsAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>[]
          }
          create: {
            args: Prisma.AnalyticsAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>
          }
          createMany: {
            args: Prisma.AnalyticsAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>
          }
          update: {
            args: Prisma.AnalyticsAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsAuditLog>
          }
          groupBy: {
            args: Prisma.AnalyticsAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsAuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PopulationCountOutputType
   */

  export type PopulationCountOutputType = {
    cohorts: number
    qualityMeasures: number
    analytics: number
    sdohFactors: number
  }

  export type PopulationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cohorts?: boolean | PopulationCountOutputTypeCountCohortsArgs
    qualityMeasures?: boolean | PopulationCountOutputTypeCountQualityMeasuresArgs
    analytics?: boolean | PopulationCountOutputTypeCountAnalyticsArgs
    sdohFactors?: boolean | PopulationCountOutputTypeCountSdohFactorsArgs
  }

  // Custom InputTypes
  /**
   * PopulationCountOutputType without action
   */
  export type PopulationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationCountOutputType
     */
    select?: PopulationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PopulationCountOutputType without action
   */
  export type PopulationCountOutputTypeCountCohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CohortWhereInput
  }

  /**
   * PopulationCountOutputType without action
   */
  export type PopulationCountOutputTypeCountQualityMeasuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopulationQualityMeasureWhereInput
  }

  /**
   * PopulationCountOutputType without action
   */
  export type PopulationCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsReportWhereInput
  }

  /**
   * PopulationCountOutputType without action
   */
  export type PopulationCountOutputTypeCountSdohFactorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SdohFactorWhereInput
  }


  /**
   * Count Type CohortCountOutputType
   */

  export type CohortCountOutputType = {
    careGaps: number
  }

  export type CohortCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careGaps?: boolean | CohortCountOutputTypeCountCareGapsArgs
  }

  // Custom InputTypes
  /**
   * CohortCountOutputType without action
   */
  export type CohortCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortCountOutputType
     */
    select?: CohortCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CohortCountOutputType without action
   */
  export type CohortCountOutputTypeCountCareGapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareGapWhereInput
  }


  /**
   * Count Type QualityMeasureCountOutputType
   */

  export type QualityMeasureCountOutputType = {
    populationMeasures: number
    patientMeasures: number
  }

  export type QualityMeasureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    populationMeasures?: boolean | QualityMeasureCountOutputTypeCountPopulationMeasuresArgs
    patientMeasures?: boolean | QualityMeasureCountOutputTypeCountPatientMeasuresArgs
  }

  // Custom InputTypes
  /**
   * QualityMeasureCountOutputType without action
   */
  export type QualityMeasureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasureCountOutputType
     */
    select?: QualityMeasureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QualityMeasureCountOutputType without action
   */
  export type QualityMeasureCountOutputTypeCountPopulationMeasuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopulationQualityMeasureWhereInput
  }

  /**
   * QualityMeasureCountOutputType without action
   */
  export type QualityMeasureCountOutputTypeCountPatientMeasuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientQualityMeasureWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Population
   */

  export type AggregatePopulation = {
    _count: PopulationCountAggregateOutputType | null
    _avg: PopulationAvgAggregateOutputType | null
    _sum: PopulationSumAggregateOutputType | null
    _min: PopulationMinAggregateOutputType | null
    _max: PopulationMaxAggregateOutputType | null
  }

  export type PopulationAvgAggregateOutputType = {
    memberCount: number | null
  }

  export type PopulationSumAggregateOutputType = {
    memberCount: number | null
  }

  export type PopulationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    organizationId: string | null
    definitionType: $Enums.DefinitionType | null
    memberCount: number | null
    status: $Enums.PopulationStatus | null
    fhirGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type PopulationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    organizationId: string | null
    definitionType: $Enums.DefinitionType | null
    memberCount: number | null
    status: $Enums.PopulationStatus | null
    fhirGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type PopulationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    organizationId: number
    definitionType: number
    criteria: number
    memberCount: number
    status: number
    fhirGroupId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type PopulationAvgAggregateInputType = {
    memberCount?: true
  }

  export type PopulationSumAggregateInputType = {
    memberCount?: true
  }

  export type PopulationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    organizationId?: true
    definitionType?: true
    memberCount?: true
    status?: true
    fhirGroupId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type PopulationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    organizationId?: true
    definitionType?: true
    memberCount?: true
    status?: true
    fhirGroupId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type PopulationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    organizationId?: true
    definitionType?: true
    criteria?: true
    memberCount?: true
    status?: true
    fhirGroupId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type PopulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Population to aggregate.
     */
    where?: PopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Populations to fetch.
     */
    orderBy?: PopulationOrderByWithRelationInput | PopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Populations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Populations
    **/
    _count?: true | PopulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PopulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PopulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PopulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PopulationMaxAggregateInputType
  }

  export type GetPopulationAggregateType<T extends PopulationAggregateArgs> = {
        [P in keyof T & keyof AggregatePopulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePopulation[P]>
      : GetScalarType<T[P], AggregatePopulation[P]>
  }




  export type PopulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopulationWhereInput
    orderBy?: PopulationOrderByWithAggregationInput | PopulationOrderByWithAggregationInput[]
    by: PopulationScalarFieldEnum[] | PopulationScalarFieldEnum
    having?: PopulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PopulationCountAggregateInputType | true
    _avg?: PopulationAvgAggregateInputType
    _sum?: PopulationSumAggregateInputType
    _min?: PopulationMinAggregateInputType
    _max?: PopulationMaxAggregateInputType
  }

  export type PopulationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    organizationId: string
    definitionType: $Enums.DefinitionType
    criteria: JsonValue
    memberCount: number
    status: $Enums.PopulationStatus
    fhirGroupId: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: PopulationCountAggregateOutputType | null
    _avg: PopulationAvgAggregateOutputType | null
    _sum: PopulationSumAggregateOutputType | null
    _min: PopulationMinAggregateOutputType | null
    _max: PopulationMaxAggregateOutputType | null
  }

  type GetPopulationGroupByPayload<T extends PopulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PopulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PopulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PopulationGroupByOutputType[P]>
            : GetScalarType<T[P], PopulationGroupByOutputType[P]>
        }
      >
    >


  export type PopulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    organizationId?: boolean
    definitionType?: boolean
    criteria?: boolean
    memberCount?: boolean
    status?: boolean
    fhirGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    cohorts?: boolean | Population$cohortsArgs<ExtArgs>
    qualityMeasures?: boolean | Population$qualityMeasuresArgs<ExtArgs>
    analytics?: boolean | Population$analyticsArgs<ExtArgs>
    sdohFactors?: boolean | Population$sdohFactorsArgs<ExtArgs>
    _count?: boolean | PopulationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["population"]>

  export type PopulationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    organizationId?: boolean
    definitionType?: boolean
    criteria?: boolean
    memberCount?: boolean
    status?: boolean
    fhirGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["population"]>

  export type PopulationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    organizationId?: boolean
    definitionType?: boolean
    criteria?: boolean
    memberCount?: boolean
    status?: boolean
    fhirGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type PopulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cohorts?: boolean | Population$cohortsArgs<ExtArgs>
    qualityMeasures?: boolean | Population$qualityMeasuresArgs<ExtArgs>
    analytics?: boolean | Population$analyticsArgs<ExtArgs>
    sdohFactors?: boolean | Population$sdohFactorsArgs<ExtArgs>
    _count?: boolean | PopulationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PopulationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PopulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Population"
    objects: {
      cohorts: Prisma.$CohortPayload<ExtArgs>[]
      qualityMeasures: Prisma.$PopulationQualityMeasurePayload<ExtArgs>[]
      analytics: Prisma.$AnalyticsReportPayload<ExtArgs>[]
      sdohFactors: Prisma.$SdohFactorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      organizationId: string
      definitionType: $Enums.DefinitionType
      criteria: Prisma.JsonValue
      memberCount: number
      status: $Enums.PopulationStatus
      fhirGroupId: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["population"]>
    composites: {}
  }

  type PopulationGetPayload<S extends boolean | null | undefined | PopulationDefaultArgs> = $Result.GetResult<Prisma.$PopulationPayload, S>

  type PopulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PopulationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PopulationCountAggregateInputType | true
    }

  export interface PopulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Population'], meta: { name: 'Population' } }
    /**
     * Find zero or one Population that matches the filter.
     * @param {PopulationFindUniqueArgs} args - Arguments to find a Population
     * @example
     * // Get one Population
     * const population = await prisma.population.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PopulationFindUniqueArgs>(args: SelectSubset<T, PopulationFindUniqueArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Population that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PopulationFindUniqueOrThrowArgs} args - Arguments to find a Population
     * @example
     * // Get one Population
     * const population = await prisma.population.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PopulationFindUniqueOrThrowArgs>(args: SelectSubset<T, PopulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Population that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationFindFirstArgs} args - Arguments to find a Population
     * @example
     * // Get one Population
     * const population = await prisma.population.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PopulationFindFirstArgs>(args?: SelectSubset<T, PopulationFindFirstArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Population that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationFindFirstOrThrowArgs} args - Arguments to find a Population
     * @example
     * // Get one Population
     * const population = await prisma.population.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PopulationFindFirstOrThrowArgs>(args?: SelectSubset<T, PopulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Populations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Populations
     * const populations = await prisma.population.findMany()
     * 
     * // Get first 10 Populations
     * const populations = await prisma.population.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const populationWithIdOnly = await prisma.population.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PopulationFindManyArgs>(args?: SelectSubset<T, PopulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Population.
     * @param {PopulationCreateArgs} args - Arguments to create a Population.
     * @example
     * // Create one Population
     * const Population = await prisma.population.create({
     *   data: {
     *     // ... data to create a Population
     *   }
     * })
     * 
     */
    create<T extends PopulationCreateArgs>(args: SelectSubset<T, PopulationCreateArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Populations.
     * @param {PopulationCreateManyArgs} args - Arguments to create many Populations.
     * @example
     * // Create many Populations
     * const population = await prisma.population.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PopulationCreateManyArgs>(args?: SelectSubset<T, PopulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Populations and returns the data saved in the database.
     * @param {PopulationCreateManyAndReturnArgs} args - Arguments to create many Populations.
     * @example
     * // Create many Populations
     * const population = await prisma.population.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Populations and only return the `id`
     * const populationWithIdOnly = await prisma.population.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PopulationCreateManyAndReturnArgs>(args?: SelectSubset<T, PopulationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Population.
     * @param {PopulationDeleteArgs} args - Arguments to delete one Population.
     * @example
     * // Delete one Population
     * const Population = await prisma.population.delete({
     *   where: {
     *     // ... filter to delete one Population
     *   }
     * })
     * 
     */
    delete<T extends PopulationDeleteArgs>(args: SelectSubset<T, PopulationDeleteArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Population.
     * @param {PopulationUpdateArgs} args - Arguments to update one Population.
     * @example
     * // Update one Population
     * const population = await prisma.population.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PopulationUpdateArgs>(args: SelectSubset<T, PopulationUpdateArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Populations.
     * @param {PopulationDeleteManyArgs} args - Arguments to filter Populations to delete.
     * @example
     * // Delete a few Populations
     * const { count } = await prisma.population.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PopulationDeleteManyArgs>(args?: SelectSubset<T, PopulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Populations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Populations
     * const population = await prisma.population.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PopulationUpdateManyArgs>(args: SelectSubset<T, PopulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Population.
     * @param {PopulationUpsertArgs} args - Arguments to update or create a Population.
     * @example
     * // Update or create a Population
     * const population = await prisma.population.upsert({
     *   create: {
     *     // ... data to create a Population
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Population we want to update
     *   }
     * })
     */
    upsert<T extends PopulationUpsertArgs>(args: SelectSubset<T, PopulationUpsertArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Populations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationCountArgs} args - Arguments to filter Populations to count.
     * @example
     * // Count the number of Populations
     * const count = await prisma.population.count({
     *   where: {
     *     // ... the filter for the Populations we want to count
     *   }
     * })
    **/
    count<T extends PopulationCountArgs>(
      args?: Subset<T, PopulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PopulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Population.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PopulationAggregateArgs>(args: Subset<T, PopulationAggregateArgs>): Prisma.PrismaPromise<GetPopulationAggregateType<T>>

    /**
     * Group by Population.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PopulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PopulationGroupByArgs['orderBy'] }
        : { orderBy?: PopulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PopulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Population model
   */
  readonly fields: PopulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Population.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PopulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cohorts<T extends Population$cohortsArgs<ExtArgs> = {}>(args?: Subset<T, Population$cohortsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "findMany"> | Null>
    qualityMeasures<T extends Population$qualityMeasuresArgs<ExtArgs> = {}>(args?: Subset<T, Population$qualityMeasuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends Population$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Population$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findMany"> | Null>
    sdohFactors<T extends Population$sdohFactorsArgs<ExtArgs> = {}>(args?: Subset<T, Population$sdohFactorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Population model
   */ 
  interface PopulationFieldRefs {
    readonly id: FieldRef<"Population", 'String'>
    readonly name: FieldRef<"Population", 'String'>
    readonly description: FieldRef<"Population", 'String'>
    readonly organizationId: FieldRef<"Population", 'String'>
    readonly definitionType: FieldRef<"Population", 'DefinitionType'>
    readonly criteria: FieldRef<"Population", 'Json'>
    readonly memberCount: FieldRef<"Population", 'Int'>
    readonly status: FieldRef<"Population", 'PopulationStatus'>
    readonly fhirGroupId: FieldRef<"Population", 'String'>
    readonly createdAt: FieldRef<"Population", 'DateTime'>
    readonly updatedAt: FieldRef<"Population", 'DateTime'>
    readonly createdBy: FieldRef<"Population", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Population findUnique
   */
  export type PopulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * Filter, which Population to fetch.
     */
    where: PopulationWhereUniqueInput
  }

  /**
   * Population findUniqueOrThrow
   */
  export type PopulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * Filter, which Population to fetch.
     */
    where: PopulationWhereUniqueInput
  }

  /**
   * Population findFirst
   */
  export type PopulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * Filter, which Population to fetch.
     */
    where?: PopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Populations to fetch.
     */
    orderBy?: PopulationOrderByWithRelationInput | PopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Populations.
     */
    cursor?: PopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Populations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Populations.
     */
    distinct?: PopulationScalarFieldEnum | PopulationScalarFieldEnum[]
  }

  /**
   * Population findFirstOrThrow
   */
  export type PopulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * Filter, which Population to fetch.
     */
    where?: PopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Populations to fetch.
     */
    orderBy?: PopulationOrderByWithRelationInput | PopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Populations.
     */
    cursor?: PopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Populations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Populations.
     */
    distinct?: PopulationScalarFieldEnum | PopulationScalarFieldEnum[]
  }

  /**
   * Population findMany
   */
  export type PopulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * Filter, which Populations to fetch.
     */
    where?: PopulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Populations to fetch.
     */
    orderBy?: PopulationOrderByWithRelationInput | PopulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Populations.
     */
    cursor?: PopulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Populations.
     */
    skip?: number
    distinct?: PopulationScalarFieldEnum | PopulationScalarFieldEnum[]
  }

  /**
   * Population create
   */
  export type PopulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * The data needed to create a Population.
     */
    data: XOR<PopulationCreateInput, PopulationUncheckedCreateInput>
  }

  /**
   * Population createMany
   */
  export type PopulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Populations.
     */
    data: PopulationCreateManyInput | PopulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Population createManyAndReturn
   */
  export type PopulationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Populations.
     */
    data: PopulationCreateManyInput | PopulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Population update
   */
  export type PopulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * The data needed to update a Population.
     */
    data: XOR<PopulationUpdateInput, PopulationUncheckedUpdateInput>
    /**
     * Choose, which Population to update.
     */
    where: PopulationWhereUniqueInput
  }

  /**
   * Population updateMany
   */
  export type PopulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Populations.
     */
    data: XOR<PopulationUpdateManyMutationInput, PopulationUncheckedUpdateManyInput>
    /**
     * Filter which Populations to update
     */
    where?: PopulationWhereInput
  }

  /**
   * Population upsert
   */
  export type PopulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * The filter to search for the Population to update in case it exists.
     */
    where: PopulationWhereUniqueInput
    /**
     * In case the Population found by the `where` argument doesn't exist, create a new Population with this data.
     */
    create: XOR<PopulationCreateInput, PopulationUncheckedCreateInput>
    /**
     * In case the Population was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PopulationUpdateInput, PopulationUncheckedUpdateInput>
  }

  /**
   * Population delete
   */
  export type PopulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    /**
     * Filter which Population to delete.
     */
    where: PopulationWhereUniqueInput
  }

  /**
   * Population deleteMany
   */
  export type PopulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Populations to delete
     */
    where?: PopulationWhereInput
  }

  /**
   * Population.cohorts
   */
  export type Population$cohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    where?: CohortWhereInput
    orderBy?: CohortOrderByWithRelationInput | CohortOrderByWithRelationInput[]
    cursor?: CohortWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CohortScalarFieldEnum | CohortScalarFieldEnum[]
  }

  /**
   * Population.qualityMeasures
   */
  export type Population$qualityMeasuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    where?: PopulationQualityMeasureWhereInput
    orderBy?: PopulationQualityMeasureOrderByWithRelationInput | PopulationQualityMeasureOrderByWithRelationInput[]
    cursor?: PopulationQualityMeasureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PopulationQualityMeasureScalarFieldEnum | PopulationQualityMeasureScalarFieldEnum[]
  }

  /**
   * Population.analytics
   */
  export type Population$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    where?: AnalyticsReportWhereInput
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    cursor?: AnalyticsReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * Population.sdohFactors
   */
  export type Population$sdohFactorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    where?: SdohFactorWhereInput
    orderBy?: SdohFactorOrderByWithRelationInput | SdohFactorOrderByWithRelationInput[]
    cursor?: SdohFactorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SdohFactorScalarFieldEnum | SdohFactorScalarFieldEnum[]
  }

  /**
   * Population without action
   */
  export type PopulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
  }


  /**
   * Model PopulationMember
   */

  export type AggregatePopulationMember = {
    _count: PopulationMemberCountAggregateOutputType | null
    _avg: PopulationMemberAvgAggregateOutputType | null
    _sum: PopulationMemberSumAggregateOutputType | null
    _min: PopulationMemberMinAggregateOutputType | null
    _max: PopulationMemberMaxAggregateOutputType | null
  }

  export type PopulationMemberAvgAggregateOutputType = {
    currentRiskScore: number | null
  }

  export type PopulationMemberSumAggregateOutputType = {
    currentRiskScore: number | null
  }

  export type PopulationMemberMinAggregateOutputType = {
    id: string | null
    populationId: string | null
    patientId: string | null
    fhirPatientRef: string | null
    enrolledAt: Date | null
    disenrolledAt: Date | null
    status: $Enums.MemberStatus | null
    currentRiskScore: number | null
    riskTier: $Enums.RiskTier | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PopulationMemberMaxAggregateOutputType = {
    id: string | null
    populationId: string | null
    patientId: string | null
    fhirPatientRef: string | null
    enrolledAt: Date | null
    disenrolledAt: Date | null
    status: $Enums.MemberStatus | null
    currentRiskScore: number | null
    riskTier: $Enums.RiskTier | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PopulationMemberCountAggregateOutputType = {
    id: number
    populationId: number
    patientId: number
    fhirPatientRef: number
    enrolledAt: number
    disenrolledAt: number
    status: number
    currentRiskScore: number
    riskTier: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PopulationMemberAvgAggregateInputType = {
    currentRiskScore?: true
  }

  export type PopulationMemberSumAggregateInputType = {
    currentRiskScore?: true
  }

  export type PopulationMemberMinAggregateInputType = {
    id?: true
    populationId?: true
    patientId?: true
    fhirPatientRef?: true
    enrolledAt?: true
    disenrolledAt?: true
    status?: true
    currentRiskScore?: true
    riskTier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PopulationMemberMaxAggregateInputType = {
    id?: true
    populationId?: true
    patientId?: true
    fhirPatientRef?: true
    enrolledAt?: true
    disenrolledAt?: true
    status?: true
    currentRiskScore?: true
    riskTier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PopulationMemberCountAggregateInputType = {
    id?: true
    populationId?: true
    patientId?: true
    fhirPatientRef?: true
    enrolledAt?: true
    disenrolledAt?: true
    status?: true
    currentRiskScore?: true
    riskTier?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PopulationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PopulationMember to aggregate.
     */
    where?: PopulationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationMembers to fetch.
     */
    orderBy?: PopulationMemberOrderByWithRelationInput | PopulationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PopulationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PopulationMembers
    **/
    _count?: true | PopulationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PopulationMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PopulationMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PopulationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PopulationMemberMaxAggregateInputType
  }

  export type GetPopulationMemberAggregateType<T extends PopulationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregatePopulationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePopulationMember[P]>
      : GetScalarType<T[P], AggregatePopulationMember[P]>
  }




  export type PopulationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopulationMemberWhereInput
    orderBy?: PopulationMemberOrderByWithAggregationInput | PopulationMemberOrderByWithAggregationInput[]
    by: PopulationMemberScalarFieldEnum[] | PopulationMemberScalarFieldEnum
    having?: PopulationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PopulationMemberCountAggregateInputType | true
    _avg?: PopulationMemberAvgAggregateInputType
    _sum?: PopulationMemberSumAggregateInputType
    _min?: PopulationMemberMinAggregateInputType
    _max?: PopulationMemberMaxAggregateInputType
  }

  export type PopulationMemberGroupByOutputType = {
    id: string
    populationId: string
    patientId: string
    fhirPatientRef: string | null
    enrolledAt: Date
    disenrolledAt: Date | null
    status: $Enums.MemberStatus
    currentRiskScore: number | null
    riskTier: $Enums.RiskTier | null
    createdAt: Date
    updatedAt: Date
    _count: PopulationMemberCountAggregateOutputType | null
    _avg: PopulationMemberAvgAggregateOutputType | null
    _sum: PopulationMemberSumAggregateOutputType | null
    _min: PopulationMemberMinAggregateOutputType | null
    _max: PopulationMemberMaxAggregateOutputType | null
  }

  type GetPopulationMemberGroupByPayload<T extends PopulationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PopulationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PopulationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PopulationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], PopulationMemberGroupByOutputType[P]>
        }
      >
    >


  export type PopulationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    enrolledAt?: boolean
    disenrolledAt?: boolean
    status?: boolean
    currentRiskScore?: boolean
    riskTier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["populationMember"]>

  export type PopulationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    enrolledAt?: boolean
    disenrolledAt?: boolean
    status?: boolean
    currentRiskScore?: boolean
    riskTier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["populationMember"]>

  export type PopulationMemberSelectScalar = {
    id?: boolean
    populationId?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    enrolledAt?: boolean
    disenrolledAt?: boolean
    status?: boolean
    currentRiskScore?: boolean
    riskTier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PopulationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PopulationMember"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      populationId: string
      patientId: string
      fhirPatientRef: string | null
      enrolledAt: Date
      disenrolledAt: Date | null
      status: $Enums.MemberStatus
      currentRiskScore: number | null
      riskTier: $Enums.RiskTier | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["populationMember"]>
    composites: {}
  }

  type PopulationMemberGetPayload<S extends boolean | null | undefined | PopulationMemberDefaultArgs> = $Result.GetResult<Prisma.$PopulationMemberPayload, S>

  type PopulationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PopulationMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PopulationMemberCountAggregateInputType | true
    }

  export interface PopulationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PopulationMember'], meta: { name: 'PopulationMember' } }
    /**
     * Find zero or one PopulationMember that matches the filter.
     * @param {PopulationMemberFindUniqueArgs} args - Arguments to find a PopulationMember
     * @example
     * // Get one PopulationMember
     * const populationMember = await prisma.populationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PopulationMemberFindUniqueArgs>(args: SelectSubset<T, PopulationMemberFindUniqueArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PopulationMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PopulationMemberFindUniqueOrThrowArgs} args - Arguments to find a PopulationMember
     * @example
     * // Get one PopulationMember
     * const populationMember = await prisma.populationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PopulationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, PopulationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PopulationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationMemberFindFirstArgs} args - Arguments to find a PopulationMember
     * @example
     * // Get one PopulationMember
     * const populationMember = await prisma.populationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PopulationMemberFindFirstArgs>(args?: SelectSubset<T, PopulationMemberFindFirstArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PopulationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationMemberFindFirstOrThrowArgs} args - Arguments to find a PopulationMember
     * @example
     * // Get one PopulationMember
     * const populationMember = await prisma.populationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PopulationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, PopulationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PopulationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PopulationMembers
     * const populationMembers = await prisma.populationMember.findMany()
     * 
     * // Get first 10 PopulationMembers
     * const populationMembers = await prisma.populationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const populationMemberWithIdOnly = await prisma.populationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PopulationMemberFindManyArgs>(args?: SelectSubset<T, PopulationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PopulationMember.
     * @param {PopulationMemberCreateArgs} args - Arguments to create a PopulationMember.
     * @example
     * // Create one PopulationMember
     * const PopulationMember = await prisma.populationMember.create({
     *   data: {
     *     // ... data to create a PopulationMember
     *   }
     * })
     * 
     */
    create<T extends PopulationMemberCreateArgs>(args: SelectSubset<T, PopulationMemberCreateArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PopulationMembers.
     * @param {PopulationMemberCreateManyArgs} args - Arguments to create many PopulationMembers.
     * @example
     * // Create many PopulationMembers
     * const populationMember = await prisma.populationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PopulationMemberCreateManyArgs>(args?: SelectSubset<T, PopulationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PopulationMembers and returns the data saved in the database.
     * @param {PopulationMemberCreateManyAndReturnArgs} args - Arguments to create many PopulationMembers.
     * @example
     * // Create many PopulationMembers
     * const populationMember = await prisma.populationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PopulationMembers and only return the `id`
     * const populationMemberWithIdOnly = await prisma.populationMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PopulationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, PopulationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PopulationMember.
     * @param {PopulationMemberDeleteArgs} args - Arguments to delete one PopulationMember.
     * @example
     * // Delete one PopulationMember
     * const PopulationMember = await prisma.populationMember.delete({
     *   where: {
     *     // ... filter to delete one PopulationMember
     *   }
     * })
     * 
     */
    delete<T extends PopulationMemberDeleteArgs>(args: SelectSubset<T, PopulationMemberDeleteArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PopulationMember.
     * @param {PopulationMemberUpdateArgs} args - Arguments to update one PopulationMember.
     * @example
     * // Update one PopulationMember
     * const populationMember = await prisma.populationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PopulationMemberUpdateArgs>(args: SelectSubset<T, PopulationMemberUpdateArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PopulationMembers.
     * @param {PopulationMemberDeleteManyArgs} args - Arguments to filter PopulationMembers to delete.
     * @example
     * // Delete a few PopulationMembers
     * const { count } = await prisma.populationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PopulationMemberDeleteManyArgs>(args?: SelectSubset<T, PopulationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PopulationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PopulationMembers
     * const populationMember = await prisma.populationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PopulationMemberUpdateManyArgs>(args: SelectSubset<T, PopulationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PopulationMember.
     * @param {PopulationMemberUpsertArgs} args - Arguments to update or create a PopulationMember.
     * @example
     * // Update or create a PopulationMember
     * const populationMember = await prisma.populationMember.upsert({
     *   create: {
     *     // ... data to create a PopulationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PopulationMember we want to update
     *   }
     * })
     */
    upsert<T extends PopulationMemberUpsertArgs>(args: SelectSubset<T, PopulationMemberUpsertArgs<ExtArgs>>): Prisma__PopulationMemberClient<$Result.GetResult<Prisma.$PopulationMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PopulationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationMemberCountArgs} args - Arguments to filter PopulationMembers to count.
     * @example
     * // Count the number of PopulationMembers
     * const count = await prisma.populationMember.count({
     *   where: {
     *     // ... the filter for the PopulationMembers we want to count
     *   }
     * })
    **/
    count<T extends PopulationMemberCountArgs>(
      args?: Subset<T, PopulationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PopulationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PopulationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PopulationMemberAggregateArgs>(args: Subset<T, PopulationMemberAggregateArgs>): Prisma.PrismaPromise<GetPopulationMemberAggregateType<T>>

    /**
     * Group by PopulationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PopulationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PopulationMemberGroupByArgs['orderBy'] }
        : { orderBy?: PopulationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PopulationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopulationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PopulationMember model
   */
  readonly fields: PopulationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PopulationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PopulationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PopulationMember model
   */ 
  interface PopulationMemberFieldRefs {
    readonly id: FieldRef<"PopulationMember", 'String'>
    readonly populationId: FieldRef<"PopulationMember", 'String'>
    readonly patientId: FieldRef<"PopulationMember", 'String'>
    readonly fhirPatientRef: FieldRef<"PopulationMember", 'String'>
    readonly enrolledAt: FieldRef<"PopulationMember", 'DateTime'>
    readonly disenrolledAt: FieldRef<"PopulationMember", 'DateTime'>
    readonly status: FieldRef<"PopulationMember", 'MemberStatus'>
    readonly currentRiskScore: FieldRef<"PopulationMember", 'Float'>
    readonly riskTier: FieldRef<"PopulationMember", 'RiskTier'>
    readonly createdAt: FieldRef<"PopulationMember", 'DateTime'>
    readonly updatedAt: FieldRef<"PopulationMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PopulationMember findUnique
   */
  export type PopulationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * Filter, which PopulationMember to fetch.
     */
    where: PopulationMemberWhereUniqueInput
  }

  /**
   * PopulationMember findUniqueOrThrow
   */
  export type PopulationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * Filter, which PopulationMember to fetch.
     */
    where: PopulationMemberWhereUniqueInput
  }

  /**
   * PopulationMember findFirst
   */
  export type PopulationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * Filter, which PopulationMember to fetch.
     */
    where?: PopulationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationMembers to fetch.
     */
    orderBy?: PopulationMemberOrderByWithRelationInput | PopulationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PopulationMembers.
     */
    cursor?: PopulationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PopulationMembers.
     */
    distinct?: PopulationMemberScalarFieldEnum | PopulationMemberScalarFieldEnum[]
  }

  /**
   * PopulationMember findFirstOrThrow
   */
  export type PopulationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * Filter, which PopulationMember to fetch.
     */
    where?: PopulationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationMembers to fetch.
     */
    orderBy?: PopulationMemberOrderByWithRelationInput | PopulationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PopulationMembers.
     */
    cursor?: PopulationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PopulationMembers.
     */
    distinct?: PopulationMemberScalarFieldEnum | PopulationMemberScalarFieldEnum[]
  }

  /**
   * PopulationMember findMany
   */
  export type PopulationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * Filter, which PopulationMembers to fetch.
     */
    where?: PopulationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationMembers to fetch.
     */
    orderBy?: PopulationMemberOrderByWithRelationInput | PopulationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PopulationMembers.
     */
    cursor?: PopulationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationMembers.
     */
    skip?: number
    distinct?: PopulationMemberScalarFieldEnum | PopulationMemberScalarFieldEnum[]
  }

  /**
   * PopulationMember create
   */
  export type PopulationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * The data needed to create a PopulationMember.
     */
    data: XOR<PopulationMemberCreateInput, PopulationMemberUncheckedCreateInput>
  }

  /**
   * PopulationMember createMany
   */
  export type PopulationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PopulationMembers.
     */
    data: PopulationMemberCreateManyInput | PopulationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PopulationMember createManyAndReturn
   */
  export type PopulationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PopulationMembers.
     */
    data: PopulationMemberCreateManyInput | PopulationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PopulationMember update
   */
  export type PopulationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * The data needed to update a PopulationMember.
     */
    data: XOR<PopulationMemberUpdateInput, PopulationMemberUncheckedUpdateInput>
    /**
     * Choose, which PopulationMember to update.
     */
    where: PopulationMemberWhereUniqueInput
  }

  /**
   * PopulationMember updateMany
   */
  export type PopulationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PopulationMembers.
     */
    data: XOR<PopulationMemberUpdateManyMutationInput, PopulationMemberUncheckedUpdateManyInput>
    /**
     * Filter which PopulationMembers to update
     */
    where?: PopulationMemberWhereInput
  }

  /**
   * PopulationMember upsert
   */
  export type PopulationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * The filter to search for the PopulationMember to update in case it exists.
     */
    where: PopulationMemberWhereUniqueInput
    /**
     * In case the PopulationMember found by the `where` argument doesn't exist, create a new PopulationMember with this data.
     */
    create: XOR<PopulationMemberCreateInput, PopulationMemberUncheckedCreateInput>
    /**
     * In case the PopulationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PopulationMemberUpdateInput, PopulationMemberUncheckedUpdateInput>
  }

  /**
   * PopulationMember delete
   */
  export type PopulationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
    /**
     * Filter which PopulationMember to delete.
     */
    where: PopulationMemberWhereUniqueInput
  }

  /**
   * PopulationMember deleteMany
   */
  export type PopulationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PopulationMembers to delete
     */
    where?: PopulationMemberWhereInput
  }

  /**
   * PopulationMember without action
   */
  export type PopulationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationMember
     */
    select?: PopulationMemberSelect<ExtArgs> | null
  }


  /**
   * Model Cohort
   */

  export type AggregateCohort = {
    _count: CohortCountAggregateOutputType | null
    _avg: CohortAvgAggregateOutputType | null
    _sum: CohortSumAggregateOutputType | null
    _min: CohortMinAggregateOutputType | null
    _max: CohortMaxAggregateOutputType | null
  }

  export type CohortAvgAggregateOutputType = {
    memberCount: number | null
    interventionPriority: number | null
  }

  export type CohortSumAggregateOutputType = {
    memberCount: number | null
    interventionPriority: number | null
  }

  export type CohortMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    populationId: string | null
    cohortType: $Enums.CohortType | null
    memberCount: number | null
    fhirGroupId: string | null
    riskLevel: $Enums.RiskTier | null
    interventionPriority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type CohortMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    populationId: string | null
    cohortType: $Enums.CohortType | null
    memberCount: number | null
    fhirGroupId: string | null
    riskLevel: $Enums.RiskTier | null
    interventionPriority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type CohortCountAggregateOutputType = {
    id: number
    name: number
    description: number
    populationId: number
    cohortType: number
    criteria: number
    memberCount: number
    fhirGroupId: number
    riskLevel: number
    interventionPriority: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type CohortAvgAggregateInputType = {
    memberCount?: true
    interventionPriority?: true
  }

  export type CohortSumAggregateInputType = {
    memberCount?: true
    interventionPriority?: true
  }

  export type CohortMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    populationId?: true
    cohortType?: true
    memberCount?: true
    fhirGroupId?: true
    riskLevel?: true
    interventionPriority?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type CohortMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    populationId?: true
    cohortType?: true
    memberCount?: true
    fhirGroupId?: true
    riskLevel?: true
    interventionPriority?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type CohortCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    populationId?: true
    cohortType?: true
    criteria?: true
    memberCount?: true
    fhirGroupId?: true
    riskLevel?: true
    interventionPriority?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type CohortAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cohort to aggregate.
     */
    where?: CohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortOrderByWithRelationInput | CohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cohorts
    **/
    _count?: true | CohortCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CohortAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CohortSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CohortMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CohortMaxAggregateInputType
  }

  export type GetCohortAggregateType<T extends CohortAggregateArgs> = {
        [P in keyof T & keyof AggregateCohort]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCohort[P]>
      : GetScalarType<T[P], AggregateCohort[P]>
  }




  export type CohortGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CohortWhereInput
    orderBy?: CohortOrderByWithAggregationInput | CohortOrderByWithAggregationInput[]
    by: CohortScalarFieldEnum[] | CohortScalarFieldEnum
    having?: CohortScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CohortCountAggregateInputType | true
    _avg?: CohortAvgAggregateInputType
    _sum?: CohortSumAggregateInputType
    _min?: CohortMinAggregateInputType
    _max?: CohortMaxAggregateInputType
  }

  export type CohortGroupByOutputType = {
    id: string
    name: string
    description: string | null
    populationId: string
    cohortType: $Enums.CohortType
    criteria: JsonValue
    memberCount: number
    fhirGroupId: string | null
    riskLevel: $Enums.RiskTier | null
    interventionPriority: number | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: CohortCountAggregateOutputType | null
    _avg: CohortAvgAggregateOutputType | null
    _sum: CohortSumAggregateOutputType | null
    _min: CohortMinAggregateOutputType | null
    _max: CohortMaxAggregateOutputType | null
  }

  type GetCohortGroupByPayload<T extends CohortGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CohortGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CohortGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CohortGroupByOutputType[P]>
            : GetScalarType<T[P], CohortGroupByOutputType[P]>
        }
      >
    >


  export type CohortSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    populationId?: boolean
    cohortType?: boolean
    criteria?: boolean
    memberCount?: boolean
    fhirGroupId?: boolean
    riskLevel?: boolean
    interventionPriority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    population?: boolean | PopulationDefaultArgs<ExtArgs>
    careGaps?: boolean | Cohort$careGapsArgs<ExtArgs>
    _count?: boolean | CohortCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cohort"]>

  export type CohortSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    populationId?: boolean
    cohortType?: boolean
    criteria?: boolean
    memberCount?: boolean
    fhirGroupId?: boolean
    riskLevel?: boolean
    interventionPriority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    population?: boolean | PopulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cohort"]>

  export type CohortSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    populationId?: boolean
    cohortType?: boolean
    criteria?: boolean
    memberCount?: boolean
    fhirGroupId?: boolean
    riskLevel?: boolean
    interventionPriority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type CohortInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | PopulationDefaultArgs<ExtArgs>
    careGaps?: boolean | Cohort$careGapsArgs<ExtArgs>
    _count?: boolean | CohortCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CohortIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | PopulationDefaultArgs<ExtArgs>
  }

  export type $CohortPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cohort"
    objects: {
      population: Prisma.$PopulationPayload<ExtArgs>
      careGaps: Prisma.$CareGapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      populationId: string
      cohortType: $Enums.CohortType
      criteria: Prisma.JsonValue
      memberCount: number
      fhirGroupId: string | null
      riskLevel: $Enums.RiskTier | null
      interventionPriority: number | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["cohort"]>
    composites: {}
  }

  type CohortGetPayload<S extends boolean | null | undefined | CohortDefaultArgs> = $Result.GetResult<Prisma.$CohortPayload, S>

  type CohortCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CohortFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CohortCountAggregateInputType | true
    }

  export interface CohortDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cohort'], meta: { name: 'Cohort' } }
    /**
     * Find zero or one Cohort that matches the filter.
     * @param {CohortFindUniqueArgs} args - Arguments to find a Cohort
     * @example
     * // Get one Cohort
     * const cohort = await prisma.cohort.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CohortFindUniqueArgs>(args: SelectSubset<T, CohortFindUniqueArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cohort that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CohortFindUniqueOrThrowArgs} args - Arguments to find a Cohort
     * @example
     * // Get one Cohort
     * const cohort = await prisma.cohort.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CohortFindUniqueOrThrowArgs>(args: SelectSubset<T, CohortFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cohort that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortFindFirstArgs} args - Arguments to find a Cohort
     * @example
     * // Get one Cohort
     * const cohort = await prisma.cohort.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CohortFindFirstArgs>(args?: SelectSubset<T, CohortFindFirstArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cohort that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortFindFirstOrThrowArgs} args - Arguments to find a Cohort
     * @example
     * // Get one Cohort
     * const cohort = await prisma.cohort.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CohortFindFirstOrThrowArgs>(args?: SelectSubset<T, CohortFindFirstOrThrowArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cohorts
     * const cohorts = await prisma.cohort.findMany()
     * 
     * // Get first 10 Cohorts
     * const cohorts = await prisma.cohort.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cohortWithIdOnly = await prisma.cohort.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CohortFindManyArgs>(args?: SelectSubset<T, CohortFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cohort.
     * @param {CohortCreateArgs} args - Arguments to create a Cohort.
     * @example
     * // Create one Cohort
     * const Cohort = await prisma.cohort.create({
     *   data: {
     *     // ... data to create a Cohort
     *   }
     * })
     * 
     */
    create<T extends CohortCreateArgs>(args: SelectSubset<T, CohortCreateArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cohorts.
     * @param {CohortCreateManyArgs} args - Arguments to create many Cohorts.
     * @example
     * // Create many Cohorts
     * const cohort = await prisma.cohort.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CohortCreateManyArgs>(args?: SelectSubset<T, CohortCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cohorts and returns the data saved in the database.
     * @param {CohortCreateManyAndReturnArgs} args - Arguments to create many Cohorts.
     * @example
     * // Create many Cohorts
     * const cohort = await prisma.cohort.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cohorts and only return the `id`
     * const cohortWithIdOnly = await prisma.cohort.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CohortCreateManyAndReturnArgs>(args?: SelectSubset<T, CohortCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cohort.
     * @param {CohortDeleteArgs} args - Arguments to delete one Cohort.
     * @example
     * // Delete one Cohort
     * const Cohort = await prisma.cohort.delete({
     *   where: {
     *     // ... filter to delete one Cohort
     *   }
     * })
     * 
     */
    delete<T extends CohortDeleteArgs>(args: SelectSubset<T, CohortDeleteArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cohort.
     * @param {CohortUpdateArgs} args - Arguments to update one Cohort.
     * @example
     * // Update one Cohort
     * const cohort = await prisma.cohort.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CohortUpdateArgs>(args: SelectSubset<T, CohortUpdateArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cohorts.
     * @param {CohortDeleteManyArgs} args - Arguments to filter Cohorts to delete.
     * @example
     * // Delete a few Cohorts
     * const { count } = await prisma.cohort.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CohortDeleteManyArgs>(args?: SelectSubset<T, CohortDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cohorts
     * const cohort = await prisma.cohort.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CohortUpdateManyArgs>(args: SelectSubset<T, CohortUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cohort.
     * @param {CohortUpsertArgs} args - Arguments to update or create a Cohort.
     * @example
     * // Update or create a Cohort
     * const cohort = await prisma.cohort.upsert({
     *   create: {
     *     // ... data to create a Cohort
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cohort we want to update
     *   }
     * })
     */
    upsert<T extends CohortUpsertArgs>(args: SelectSubset<T, CohortUpsertArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortCountArgs} args - Arguments to filter Cohorts to count.
     * @example
     * // Count the number of Cohorts
     * const count = await prisma.cohort.count({
     *   where: {
     *     // ... the filter for the Cohorts we want to count
     *   }
     * })
    **/
    count<T extends CohortCountArgs>(
      args?: Subset<T, CohortCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CohortCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cohort.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CohortAggregateArgs>(args: Subset<T, CohortAggregateArgs>): Prisma.PrismaPromise<GetCohortAggregateType<T>>

    /**
     * Group by Cohort.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CohortGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CohortGroupByArgs['orderBy'] }
        : { orderBy?: CohortGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CohortGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCohortGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cohort model
   */
  readonly fields: CohortFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cohort.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CohortClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    population<T extends PopulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PopulationDefaultArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    careGaps<T extends Cohort$careGapsArgs<ExtArgs> = {}>(args?: Subset<T, Cohort$careGapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cohort model
   */ 
  interface CohortFieldRefs {
    readonly id: FieldRef<"Cohort", 'String'>
    readonly name: FieldRef<"Cohort", 'String'>
    readonly description: FieldRef<"Cohort", 'String'>
    readonly populationId: FieldRef<"Cohort", 'String'>
    readonly cohortType: FieldRef<"Cohort", 'CohortType'>
    readonly criteria: FieldRef<"Cohort", 'Json'>
    readonly memberCount: FieldRef<"Cohort", 'Int'>
    readonly fhirGroupId: FieldRef<"Cohort", 'String'>
    readonly riskLevel: FieldRef<"Cohort", 'RiskTier'>
    readonly interventionPriority: FieldRef<"Cohort", 'Int'>
    readonly createdAt: FieldRef<"Cohort", 'DateTime'>
    readonly updatedAt: FieldRef<"Cohort", 'DateTime'>
    readonly createdBy: FieldRef<"Cohort", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cohort findUnique
   */
  export type CohortFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * Filter, which Cohort to fetch.
     */
    where: CohortWhereUniqueInput
  }

  /**
   * Cohort findUniqueOrThrow
   */
  export type CohortFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * Filter, which Cohort to fetch.
     */
    where: CohortWhereUniqueInput
  }

  /**
   * Cohort findFirst
   */
  export type CohortFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * Filter, which Cohort to fetch.
     */
    where?: CohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortOrderByWithRelationInput | CohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cohorts.
     */
    cursor?: CohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cohorts.
     */
    distinct?: CohortScalarFieldEnum | CohortScalarFieldEnum[]
  }

  /**
   * Cohort findFirstOrThrow
   */
  export type CohortFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * Filter, which Cohort to fetch.
     */
    where?: CohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortOrderByWithRelationInput | CohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cohorts.
     */
    cursor?: CohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cohorts.
     */
    distinct?: CohortScalarFieldEnum | CohortScalarFieldEnum[]
  }

  /**
   * Cohort findMany
   */
  export type CohortFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where?: CohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortOrderByWithRelationInput | CohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cohorts.
     */
    cursor?: CohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    distinct?: CohortScalarFieldEnum | CohortScalarFieldEnum[]
  }

  /**
   * Cohort create
   */
  export type CohortCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * The data needed to create a Cohort.
     */
    data: XOR<CohortCreateInput, CohortUncheckedCreateInput>
  }

  /**
   * Cohort createMany
   */
  export type CohortCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cohorts.
     */
    data: CohortCreateManyInput | CohortCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cohort createManyAndReturn
   */
  export type CohortCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cohorts.
     */
    data: CohortCreateManyInput | CohortCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cohort update
   */
  export type CohortUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * The data needed to update a Cohort.
     */
    data: XOR<CohortUpdateInput, CohortUncheckedUpdateInput>
    /**
     * Choose, which Cohort to update.
     */
    where: CohortWhereUniqueInput
  }

  /**
   * Cohort updateMany
   */
  export type CohortUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cohorts.
     */
    data: XOR<CohortUpdateManyMutationInput, CohortUncheckedUpdateManyInput>
    /**
     * Filter which Cohorts to update
     */
    where?: CohortWhereInput
  }

  /**
   * Cohort upsert
   */
  export type CohortUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * The filter to search for the Cohort to update in case it exists.
     */
    where: CohortWhereUniqueInput
    /**
     * In case the Cohort found by the `where` argument doesn't exist, create a new Cohort with this data.
     */
    create: XOR<CohortCreateInput, CohortUncheckedCreateInput>
    /**
     * In case the Cohort was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CohortUpdateInput, CohortUncheckedUpdateInput>
  }

  /**
   * Cohort delete
   */
  export type CohortDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    /**
     * Filter which Cohort to delete.
     */
    where: CohortWhereUniqueInput
  }

  /**
   * Cohort deleteMany
   */
  export type CohortDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cohorts to delete
     */
    where?: CohortWhereInput
  }

  /**
   * Cohort.careGaps
   */
  export type Cohort$careGapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    where?: CareGapWhereInput
    orderBy?: CareGapOrderByWithRelationInput | CareGapOrderByWithRelationInput[]
    cursor?: CareGapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareGapScalarFieldEnum | CareGapScalarFieldEnum[]
  }

  /**
   * Cohort without action
   */
  export type CohortDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
  }


  /**
   * Model CohortMember
   */

  export type AggregateCohortMember = {
    _count: CohortMemberCountAggregateOutputType | null
    _avg: CohortMemberAvgAggregateOutputType | null
    _sum: CohortMemberSumAggregateOutputType | null
    _min: CohortMemberMinAggregateOutputType | null
    _max: CohortMemberMaxAggregateOutputType | null
  }

  export type CohortMemberAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type CohortMemberSumAggregateOutputType = {
    riskScore: number | null
  }

  export type CohortMemberMinAggregateOutputType = {
    id: string | null
    cohortId: string | null
    patientId: string | null
    fhirPatientRef: string | null
    assignedAt: Date | null
    removedAt: Date | null
    status: $Enums.MemberStatus | null
    riskScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CohortMemberMaxAggregateOutputType = {
    id: string | null
    cohortId: string | null
    patientId: string | null
    fhirPatientRef: string | null
    assignedAt: Date | null
    removedAt: Date | null
    status: $Enums.MemberStatus | null
    riskScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CohortMemberCountAggregateOutputType = {
    id: number
    cohortId: number
    patientId: number
    fhirPatientRef: number
    assignedAt: number
    removedAt: number
    status: number
    riskScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CohortMemberAvgAggregateInputType = {
    riskScore?: true
  }

  export type CohortMemberSumAggregateInputType = {
    riskScore?: true
  }

  export type CohortMemberMinAggregateInputType = {
    id?: true
    cohortId?: true
    patientId?: true
    fhirPatientRef?: true
    assignedAt?: true
    removedAt?: true
    status?: true
    riskScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CohortMemberMaxAggregateInputType = {
    id?: true
    cohortId?: true
    patientId?: true
    fhirPatientRef?: true
    assignedAt?: true
    removedAt?: true
    status?: true
    riskScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CohortMemberCountAggregateInputType = {
    id?: true
    cohortId?: true
    patientId?: true
    fhirPatientRef?: true
    assignedAt?: true
    removedAt?: true
    status?: true
    riskScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CohortMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CohortMember to aggregate.
     */
    where?: CohortMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortMembers to fetch.
     */
    orderBy?: CohortMemberOrderByWithRelationInput | CohortMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CohortMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CohortMembers
    **/
    _count?: true | CohortMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CohortMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CohortMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CohortMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CohortMemberMaxAggregateInputType
  }

  export type GetCohortMemberAggregateType<T extends CohortMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCohortMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCohortMember[P]>
      : GetScalarType<T[P], AggregateCohortMember[P]>
  }




  export type CohortMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CohortMemberWhereInput
    orderBy?: CohortMemberOrderByWithAggregationInput | CohortMemberOrderByWithAggregationInput[]
    by: CohortMemberScalarFieldEnum[] | CohortMemberScalarFieldEnum
    having?: CohortMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CohortMemberCountAggregateInputType | true
    _avg?: CohortMemberAvgAggregateInputType
    _sum?: CohortMemberSumAggregateInputType
    _min?: CohortMemberMinAggregateInputType
    _max?: CohortMemberMaxAggregateInputType
  }

  export type CohortMemberGroupByOutputType = {
    id: string
    cohortId: string
    patientId: string
    fhirPatientRef: string | null
    assignedAt: Date
    removedAt: Date | null
    status: $Enums.MemberStatus
    riskScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: CohortMemberCountAggregateOutputType | null
    _avg: CohortMemberAvgAggregateOutputType | null
    _sum: CohortMemberSumAggregateOutputType | null
    _min: CohortMemberMinAggregateOutputType | null
    _max: CohortMemberMaxAggregateOutputType | null
  }

  type GetCohortMemberGroupByPayload<T extends CohortMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CohortMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CohortMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CohortMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CohortMemberGroupByOutputType[P]>
        }
      >
    >


  export type CohortMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cohortId?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    assignedAt?: boolean
    removedAt?: boolean
    status?: boolean
    riskScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cohortMember"]>

  export type CohortMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cohortId?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    assignedAt?: boolean
    removedAt?: boolean
    status?: boolean
    riskScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cohortMember"]>

  export type CohortMemberSelectScalar = {
    id?: boolean
    cohortId?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    assignedAt?: boolean
    removedAt?: boolean
    status?: boolean
    riskScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CohortMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CohortMember"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cohortId: string
      patientId: string
      fhirPatientRef: string | null
      assignedAt: Date
      removedAt: Date | null
      status: $Enums.MemberStatus
      riskScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cohortMember"]>
    composites: {}
  }

  type CohortMemberGetPayload<S extends boolean | null | undefined | CohortMemberDefaultArgs> = $Result.GetResult<Prisma.$CohortMemberPayload, S>

  type CohortMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CohortMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CohortMemberCountAggregateInputType | true
    }

  export interface CohortMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CohortMember'], meta: { name: 'CohortMember' } }
    /**
     * Find zero or one CohortMember that matches the filter.
     * @param {CohortMemberFindUniqueArgs} args - Arguments to find a CohortMember
     * @example
     * // Get one CohortMember
     * const cohortMember = await prisma.cohortMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CohortMemberFindUniqueArgs>(args: SelectSubset<T, CohortMemberFindUniqueArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CohortMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CohortMemberFindUniqueOrThrowArgs} args - Arguments to find a CohortMember
     * @example
     * // Get one CohortMember
     * const cohortMember = await prisma.cohortMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CohortMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CohortMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CohortMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortMemberFindFirstArgs} args - Arguments to find a CohortMember
     * @example
     * // Get one CohortMember
     * const cohortMember = await prisma.cohortMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CohortMemberFindFirstArgs>(args?: SelectSubset<T, CohortMemberFindFirstArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CohortMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortMemberFindFirstOrThrowArgs} args - Arguments to find a CohortMember
     * @example
     * // Get one CohortMember
     * const cohortMember = await prisma.cohortMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CohortMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CohortMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CohortMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CohortMembers
     * const cohortMembers = await prisma.cohortMember.findMany()
     * 
     * // Get first 10 CohortMembers
     * const cohortMembers = await prisma.cohortMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cohortMemberWithIdOnly = await prisma.cohortMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CohortMemberFindManyArgs>(args?: SelectSubset<T, CohortMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CohortMember.
     * @param {CohortMemberCreateArgs} args - Arguments to create a CohortMember.
     * @example
     * // Create one CohortMember
     * const CohortMember = await prisma.cohortMember.create({
     *   data: {
     *     // ... data to create a CohortMember
     *   }
     * })
     * 
     */
    create<T extends CohortMemberCreateArgs>(args: SelectSubset<T, CohortMemberCreateArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CohortMembers.
     * @param {CohortMemberCreateManyArgs} args - Arguments to create many CohortMembers.
     * @example
     * // Create many CohortMembers
     * const cohortMember = await prisma.cohortMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CohortMemberCreateManyArgs>(args?: SelectSubset<T, CohortMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CohortMembers and returns the data saved in the database.
     * @param {CohortMemberCreateManyAndReturnArgs} args - Arguments to create many CohortMembers.
     * @example
     * // Create many CohortMembers
     * const cohortMember = await prisma.cohortMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CohortMembers and only return the `id`
     * const cohortMemberWithIdOnly = await prisma.cohortMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CohortMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CohortMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CohortMember.
     * @param {CohortMemberDeleteArgs} args - Arguments to delete one CohortMember.
     * @example
     * // Delete one CohortMember
     * const CohortMember = await prisma.cohortMember.delete({
     *   where: {
     *     // ... filter to delete one CohortMember
     *   }
     * })
     * 
     */
    delete<T extends CohortMemberDeleteArgs>(args: SelectSubset<T, CohortMemberDeleteArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CohortMember.
     * @param {CohortMemberUpdateArgs} args - Arguments to update one CohortMember.
     * @example
     * // Update one CohortMember
     * const cohortMember = await prisma.cohortMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CohortMemberUpdateArgs>(args: SelectSubset<T, CohortMemberUpdateArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CohortMembers.
     * @param {CohortMemberDeleteManyArgs} args - Arguments to filter CohortMembers to delete.
     * @example
     * // Delete a few CohortMembers
     * const { count } = await prisma.cohortMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CohortMemberDeleteManyArgs>(args?: SelectSubset<T, CohortMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CohortMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CohortMembers
     * const cohortMember = await prisma.cohortMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CohortMemberUpdateManyArgs>(args: SelectSubset<T, CohortMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CohortMember.
     * @param {CohortMemberUpsertArgs} args - Arguments to update or create a CohortMember.
     * @example
     * // Update or create a CohortMember
     * const cohortMember = await prisma.cohortMember.upsert({
     *   create: {
     *     // ... data to create a CohortMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CohortMember we want to update
     *   }
     * })
     */
    upsert<T extends CohortMemberUpsertArgs>(args: SelectSubset<T, CohortMemberUpsertArgs<ExtArgs>>): Prisma__CohortMemberClient<$Result.GetResult<Prisma.$CohortMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CohortMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortMemberCountArgs} args - Arguments to filter CohortMembers to count.
     * @example
     * // Count the number of CohortMembers
     * const count = await prisma.cohortMember.count({
     *   where: {
     *     // ... the filter for the CohortMembers we want to count
     *   }
     * })
    **/
    count<T extends CohortMemberCountArgs>(
      args?: Subset<T, CohortMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CohortMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CohortMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CohortMemberAggregateArgs>(args: Subset<T, CohortMemberAggregateArgs>): Prisma.PrismaPromise<GetCohortMemberAggregateType<T>>

    /**
     * Group by CohortMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CohortMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CohortMemberGroupByArgs['orderBy'] }
        : { orderBy?: CohortMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CohortMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCohortMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CohortMember model
   */
  readonly fields: CohortMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CohortMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CohortMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CohortMember model
   */ 
  interface CohortMemberFieldRefs {
    readonly id: FieldRef<"CohortMember", 'String'>
    readonly cohortId: FieldRef<"CohortMember", 'String'>
    readonly patientId: FieldRef<"CohortMember", 'String'>
    readonly fhirPatientRef: FieldRef<"CohortMember", 'String'>
    readonly assignedAt: FieldRef<"CohortMember", 'DateTime'>
    readonly removedAt: FieldRef<"CohortMember", 'DateTime'>
    readonly status: FieldRef<"CohortMember", 'MemberStatus'>
    readonly riskScore: FieldRef<"CohortMember", 'Float'>
    readonly createdAt: FieldRef<"CohortMember", 'DateTime'>
    readonly updatedAt: FieldRef<"CohortMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CohortMember findUnique
   */
  export type CohortMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * Filter, which CohortMember to fetch.
     */
    where: CohortMemberWhereUniqueInput
  }

  /**
   * CohortMember findUniqueOrThrow
   */
  export type CohortMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * Filter, which CohortMember to fetch.
     */
    where: CohortMemberWhereUniqueInput
  }

  /**
   * CohortMember findFirst
   */
  export type CohortMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * Filter, which CohortMember to fetch.
     */
    where?: CohortMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortMembers to fetch.
     */
    orderBy?: CohortMemberOrderByWithRelationInput | CohortMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CohortMembers.
     */
    cursor?: CohortMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CohortMembers.
     */
    distinct?: CohortMemberScalarFieldEnum | CohortMemberScalarFieldEnum[]
  }

  /**
   * CohortMember findFirstOrThrow
   */
  export type CohortMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * Filter, which CohortMember to fetch.
     */
    where?: CohortMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortMembers to fetch.
     */
    orderBy?: CohortMemberOrderByWithRelationInput | CohortMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CohortMembers.
     */
    cursor?: CohortMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CohortMembers.
     */
    distinct?: CohortMemberScalarFieldEnum | CohortMemberScalarFieldEnum[]
  }

  /**
   * CohortMember findMany
   */
  export type CohortMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * Filter, which CohortMembers to fetch.
     */
    where?: CohortMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CohortMembers to fetch.
     */
    orderBy?: CohortMemberOrderByWithRelationInput | CohortMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CohortMembers.
     */
    cursor?: CohortMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CohortMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CohortMembers.
     */
    skip?: number
    distinct?: CohortMemberScalarFieldEnum | CohortMemberScalarFieldEnum[]
  }

  /**
   * CohortMember create
   */
  export type CohortMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * The data needed to create a CohortMember.
     */
    data: XOR<CohortMemberCreateInput, CohortMemberUncheckedCreateInput>
  }

  /**
   * CohortMember createMany
   */
  export type CohortMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CohortMembers.
     */
    data: CohortMemberCreateManyInput | CohortMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CohortMember createManyAndReturn
   */
  export type CohortMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CohortMembers.
     */
    data: CohortMemberCreateManyInput | CohortMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CohortMember update
   */
  export type CohortMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * The data needed to update a CohortMember.
     */
    data: XOR<CohortMemberUpdateInput, CohortMemberUncheckedUpdateInput>
    /**
     * Choose, which CohortMember to update.
     */
    where: CohortMemberWhereUniqueInput
  }

  /**
   * CohortMember updateMany
   */
  export type CohortMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CohortMembers.
     */
    data: XOR<CohortMemberUpdateManyMutationInput, CohortMemberUncheckedUpdateManyInput>
    /**
     * Filter which CohortMembers to update
     */
    where?: CohortMemberWhereInput
  }

  /**
   * CohortMember upsert
   */
  export type CohortMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * The filter to search for the CohortMember to update in case it exists.
     */
    where: CohortMemberWhereUniqueInput
    /**
     * In case the CohortMember found by the `where` argument doesn't exist, create a new CohortMember with this data.
     */
    create: XOR<CohortMemberCreateInput, CohortMemberUncheckedCreateInput>
    /**
     * In case the CohortMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CohortMemberUpdateInput, CohortMemberUncheckedUpdateInput>
  }

  /**
   * CohortMember delete
   */
  export type CohortMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
    /**
     * Filter which CohortMember to delete.
     */
    where: CohortMemberWhereUniqueInput
  }

  /**
   * CohortMember deleteMany
   */
  export type CohortMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CohortMembers to delete
     */
    where?: CohortMemberWhereInput
  }

  /**
   * CohortMember without action
   */
  export type CohortMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortMember
     */
    select?: CohortMemberSelect<ExtArgs> | null
  }


  /**
   * Model QualityMeasure
   */

  export type AggregateQualityMeasure = {
    _count: QualityMeasureCountAggregateOutputType | null
    _avg: QualityMeasureAvgAggregateOutputType | null
    _sum: QualityMeasureSumAggregateOutputType | null
    _min: QualityMeasureMinAggregateOutputType | null
    _max: QualityMeasureMaxAggregateOutputType | null
  }

  export type QualityMeasureAvgAggregateOutputType = {
    targetRate: number | null
    reportingYear: number | null
  }

  export type QualityMeasureSumAggregateOutputType = {
    targetRate: number | null
    reportingYear: number | null
  }

  export type QualityMeasureMinAggregateOutputType = {
    id: string | null
    measureId: string | null
    name: string | null
    description: string | null
    measureType: $Enums.MeasureType | null
    category: $Enums.MeasureCategory | null
    steward: string | null
    domain: string | null
    fhirMeasureId: string | null
    fhirVersion: string | null
    targetRate: number | null
    measurePeriodStart: Date | null
    measurePeriodEnd: Date | null
    reportingYear: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualityMeasureMaxAggregateOutputType = {
    id: string | null
    measureId: string | null
    name: string | null
    description: string | null
    measureType: $Enums.MeasureType | null
    category: $Enums.MeasureCategory | null
    steward: string | null
    domain: string | null
    fhirMeasureId: string | null
    fhirVersion: string | null
    targetRate: number | null
    measurePeriodStart: Date | null
    measurePeriodEnd: Date | null
    reportingYear: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualityMeasureCountAggregateOutputType = {
    id: number
    measureId: number
    name: number
    description: number
    measureType: number
    category: number
    steward: number
    domain: number
    fhirMeasureId: number
    fhirVersion: number
    numeratorCriteria: number
    denominatorCriteria: number
    exclusionCriteria: number
    targetRate: number
    measurePeriodStart: number
    measurePeriodEnd: number
    reportingYear: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QualityMeasureAvgAggregateInputType = {
    targetRate?: true
    reportingYear?: true
  }

  export type QualityMeasureSumAggregateInputType = {
    targetRate?: true
    reportingYear?: true
  }

  export type QualityMeasureMinAggregateInputType = {
    id?: true
    measureId?: true
    name?: true
    description?: true
    measureType?: true
    category?: true
    steward?: true
    domain?: true
    fhirMeasureId?: true
    fhirVersion?: true
    targetRate?: true
    measurePeriodStart?: true
    measurePeriodEnd?: true
    reportingYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualityMeasureMaxAggregateInputType = {
    id?: true
    measureId?: true
    name?: true
    description?: true
    measureType?: true
    category?: true
    steward?: true
    domain?: true
    fhirMeasureId?: true
    fhirVersion?: true
    targetRate?: true
    measurePeriodStart?: true
    measurePeriodEnd?: true
    reportingYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualityMeasureCountAggregateInputType = {
    id?: true
    measureId?: true
    name?: true
    description?: true
    measureType?: true
    category?: true
    steward?: true
    domain?: true
    fhirMeasureId?: true
    fhirVersion?: true
    numeratorCriteria?: true
    denominatorCriteria?: true
    exclusionCriteria?: true
    targetRate?: true
    measurePeriodStart?: true
    measurePeriodEnd?: true
    reportingYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QualityMeasureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityMeasure to aggregate.
     */
    where?: QualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityMeasures to fetch.
     */
    orderBy?: QualityMeasureOrderByWithRelationInput | QualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QualityMeasures
    **/
    _count?: true | QualityMeasureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualityMeasureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualityMeasureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualityMeasureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualityMeasureMaxAggregateInputType
  }

  export type GetQualityMeasureAggregateType<T extends QualityMeasureAggregateArgs> = {
        [P in keyof T & keyof AggregateQualityMeasure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualityMeasure[P]>
      : GetScalarType<T[P], AggregateQualityMeasure[P]>
  }




  export type QualityMeasureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityMeasureWhereInput
    orderBy?: QualityMeasureOrderByWithAggregationInput | QualityMeasureOrderByWithAggregationInput[]
    by: QualityMeasureScalarFieldEnum[] | QualityMeasureScalarFieldEnum
    having?: QualityMeasureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualityMeasureCountAggregateInputType | true
    _avg?: QualityMeasureAvgAggregateInputType
    _sum?: QualityMeasureSumAggregateInputType
    _min?: QualityMeasureMinAggregateInputType
    _max?: QualityMeasureMaxAggregateInputType
  }

  export type QualityMeasureGroupByOutputType = {
    id: string
    measureId: string
    name: string
    description: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward: string | null
    domain: string | null
    fhirMeasureId: string | null
    fhirVersion: string | null
    numeratorCriteria: JsonValue | null
    denominatorCriteria: JsonValue | null
    exclusionCriteria: JsonValue | null
    targetRate: number | null
    measurePeriodStart: Date | null
    measurePeriodEnd: Date | null
    reportingYear: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: QualityMeasureCountAggregateOutputType | null
    _avg: QualityMeasureAvgAggregateOutputType | null
    _sum: QualityMeasureSumAggregateOutputType | null
    _min: QualityMeasureMinAggregateOutputType | null
    _max: QualityMeasureMaxAggregateOutputType | null
  }

  type GetQualityMeasureGroupByPayload<T extends QualityMeasureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualityMeasureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualityMeasureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualityMeasureGroupByOutputType[P]>
            : GetScalarType<T[P], QualityMeasureGroupByOutputType[P]>
        }
      >
    >


  export type QualityMeasureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    measureId?: boolean
    name?: boolean
    description?: boolean
    measureType?: boolean
    category?: boolean
    steward?: boolean
    domain?: boolean
    fhirMeasureId?: boolean
    fhirVersion?: boolean
    numeratorCriteria?: boolean
    denominatorCriteria?: boolean
    exclusionCriteria?: boolean
    targetRate?: boolean
    measurePeriodStart?: boolean
    measurePeriodEnd?: boolean
    reportingYear?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    populationMeasures?: boolean | QualityMeasure$populationMeasuresArgs<ExtArgs>
    patientMeasures?: boolean | QualityMeasure$patientMeasuresArgs<ExtArgs>
    _count?: boolean | QualityMeasureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualityMeasure"]>

  export type QualityMeasureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    measureId?: boolean
    name?: boolean
    description?: boolean
    measureType?: boolean
    category?: boolean
    steward?: boolean
    domain?: boolean
    fhirMeasureId?: boolean
    fhirVersion?: boolean
    numeratorCriteria?: boolean
    denominatorCriteria?: boolean
    exclusionCriteria?: boolean
    targetRate?: boolean
    measurePeriodStart?: boolean
    measurePeriodEnd?: boolean
    reportingYear?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["qualityMeasure"]>

  export type QualityMeasureSelectScalar = {
    id?: boolean
    measureId?: boolean
    name?: boolean
    description?: boolean
    measureType?: boolean
    category?: boolean
    steward?: boolean
    domain?: boolean
    fhirMeasureId?: boolean
    fhirVersion?: boolean
    numeratorCriteria?: boolean
    denominatorCriteria?: boolean
    exclusionCriteria?: boolean
    targetRate?: boolean
    measurePeriodStart?: boolean
    measurePeriodEnd?: boolean
    reportingYear?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QualityMeasureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    populationMeasures?: boolean | QualityMeasure$populationMeasuresArgs<ExtArgs>
    patientMeasures?: boolean | QualityMeasure$patientMeasuresArgs<ExtArgs>
    _count?: boolean | QualityMeasureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QualityMeasureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QualityMeasurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QualityMeasure"
    objects: {
      populationMeasures: Prisma.$PopulationQualityMeasurePayload<ExtArgs>[]
      patientMeasures: Prisma.$PatientQualityMeasurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      measureId: string
      name: string
      description: string | null
      measureType: $Enums.MeasureType
      category: $Enums.MeasureCategory
      steward: string | null
      domain: string | null
      fhirMeasureId: string | null
      fhirVersion: string | null
      numeratorCriteria: Prisma.JsonValue | null
      denominatorCriteria: Prisma.JsonValue | null
      exclusionCriteria: Prisma.JsonValue | null
      targetRate: number | null
      measurePeriodStart: Date | null
      measurePeriodEnd: Date | null
      reportingYear: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qualityMeasure"]>
    composites: {}
  }

  type QualityMeasureGetPayload<S extends boolean | null | undefined | QualityMeasureDefaultArgs> = $Result.GetResult<Prisma.$QualityMeasurePayload, S>

  type QualityMeasureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QualityMeasureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QualityMeasureCountAggregateInputType | true
    }

  export interface QualityMeasureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QualityMeasure'], meta: { name: 'QualityMeasure' } }
    /**
     * Find zero or one QualityMeasure that matches the filter.
     * @param {QualityMeasureFindUniqueArgs} args - Arguments to find a QualityMeasure
     * @example
     * // Get one QualityMeasure
     * const qualityMeasure = await prisma.qualityMeasure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QualityMeasureFindUniqueArgs>(args: SelectSubset<T, QualityMeasureFindUniqueArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QualityMeasure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QualityMeasureFindUniqueOrThrowArgs} args - Arguments to find a QualityMeasure
     * @example
     * // Get one QualityMeasure
     * const qualityMeasure = await prisma.qualityMeasure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QualityMeasureFindUniqueOrThrowArgs>(args: SelectSubset<T, QualityMeasureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QualityMeasure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityMeasureFindFirstArgs} args - Arguments to find a QualityMeasure
     * @example
     * // Get one QualityMeasure
     * const qualityMeasure = await prisma.qualityMeasure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QualityMeasureFindFirstArgs>(args?: SelectSubset<T, QualityMeasureFindFirstArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QualityMeasure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityMeasureFindFirstOrThrowArgs} args - Arguments to find a QualityMeasure
     * @example
     * // Get one QualityMeasure
     * const qualityMeasure = await prisma.qualityMeasure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QualityMeasureFindFirstOrThrowArgs>(args?: SelectSubset<T, QualityMeasureFindFirstOrThrowArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QualityMeasures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityMeasureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QualityMeasures
     * const qualityMeasures = await prisma.qualityMeasure.findMany()
     * 
     * // Get first 10 QualityMeasures
     * const qualityMeasures = await prisma.qualityMeasure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qualityMeasureWithIdOnly = await prisma.qualityMeasure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QualityMeasureFindManyArgs>(args?: SelectSubset<T, QualityMeasureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QualityMeasure.
     * @param {QualityMeasureCreateArgs} args - Arguments to create a QualityMeasure.
     * @example
     * // Create one QualityMeasure
     * const QualityMeasure = await prisma.qualityMeasure.create({
     *   data: {
     *     // ... data to create a QualityMeasure
     *   }
     * })
     * 
     */
    create<T extends QualityMeasureCreateArgs>(args: SelectSubset<T, QualityMeasureCreateArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QualityMeasures.
     * @param {QualityMeasureCreateManyArgs} args - Arguments to create many QualityMeasures.
     * @example
     * // Create many QualityMeasures
     * const qualityMeasure = await prisma.qualityMeasure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QualityMeasureCreateManyArgs>(args?: SelectSubset<T, QualityMeasureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QualityMeasures and returns the data saved in the database.
     * @param {QualityMeasureCreateManyAndReturnArgs} args - Arguments to create many QualityMeasures.
     * @example
     * // Create many QualityMeasures
     * const qualityMeasure = await prisma.qualityMeasure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QualityMeasures and only return the `id`
     * const qualityMeasureWithIdOnly = await prisma.qualityMeasure.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QualityMeasureCreateManyAndReturnArgs>(args?: SelectSubset<T, QualityMeasureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QualityMeasure.
     * @param {QualityMeasureDeleteArgs} args - Arguments to delete one QualityMeasure.
     * @example
     * // Delete one QualityMeasure
     * const QualityMeasure = await prisma.qualityMeasure.delete({
     *   where: {
     *     // ... filter to delete one QualityMeasure
     *   }
     * })
     * 
     */
    delete<T extends QualityMeasureDeleteArgs>(args: SelectSubset<T, QualityMeasureDeleteArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QualityMeasure.
     * @param {QualityMeasureUpdateArgs} args - Arguments to update one QualityMeasure.
     * @example
     * // Update one QualityMeasure
     * const qualityMeasure = await prisma.qualityMeasure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QualityMeasureUpdateArgs>(args: SelectSubset<T, QualityMeasureUpdateArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QualityMeasures.
     * @param {QualityMeasureDeleteManyArgs} args - Arguments to filter QualityMeasures to delete.
     * @example
     * // Delete a few QualityMeasures
     * const { count } = await prisma.qualityMeasure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QualityMeasureDeleteManyArgs>(args?: SelectSubset<T, QualityMeasureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityMeasureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QualityMeasures
     * const qualityMeasure = await prisma.qualityMeasure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QualityMeasureUpdateManyArgs>(args: SelectSubset<T, QualityMeasureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QualityMeasure.
     * @param {QualityMeasureUpsertArgs} args - Arguments to update or create a QualityMeasure.
     * @example
     * // Update or create a QualityMeasure
     * const qualityMeasure = await prisma.qualityMeasure.upsert({
     *   create: {
     *     // ... data to create a QualityMeasure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QualityMeasure we want to update
     *   }
     * })
     */
    upsert<T extends QualityMeasureUpsertArgs>(args: SelectSubset<T, QualityMeasureUpsertArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QualityMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityMeasureCountArgs} args - Arguments to filter QualityMeasures to count.
     * @example
     * // Count the number of QualityMeasures
     * const count = await prisma.qualityMeasure.count({
     *   where: {
     *     // ... the filter for the QualityMeasures we want to count
     *   }
     * })
    **/
    count<T extends QualityMeasureCountArgs>(
      args?: Subset<T, QualityMeasureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualityMeasureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QualityMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityMeasureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualityMeasureAggregateArgs>(args: Subset<T, QualityMeasureAggregateArgs>): Prisma.PrismaPromise<GetQualityMeasureAggregateType<T>>

    /**
     * Group by QualityMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityMeasureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualityMeasureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualityMeasureGroupByArgs['orderBy'] }
        : { orderBy?: QualityMeasureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualityMeasureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualityMeasureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QualityMeasure model
   */
  readonly fields: QualityMeasureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QualityMeasure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QualityMeasureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    populationMeasures<T extends QualityMeasure$populationMeasuresArgs<ExtArgs> = {}>(args?: Subset<T, QualityMeasure$populationMeasuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "findMany"> | Null>
    patientMeasures<T extends QualityMeasure$patientMeasuresArgs<ExtArgs> = {}>(args?: Subset<T, QualityMeasure$patientMeasuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QualityMeasure model
   */ 
  interface QualityMeasureFieldRefs {
    readonly id: FieldRef<"QualityMeasure", 'String'>
    readonly measureId: FieldRef<"QualityMeasure", 'String'>
    readonly name: FieldRef<"QualityMeasure", 'String'>
    readonly description: FieldRef<"QualityMeasure", 'String'>
    readonly measureType: FieldRef<"QualityMeasure", 'MeasureType'>
    readonly category: FieldRef<"QualityMeasure", 'MeasureCategory'>
    readonly steward: FieldRef<"QualityMeasure", 'String'>
    readonly domain: FieldRef<"QualityMeasure", 'String'>
    readonly fhirMeasureId: FieldRef<"QualityMeasure", 'String'>
    readonly fhirVersion: FieldRef<"QualityMeasure", 'String'>
    readonly numeratorCriteria: FieldRef<"QualityMeasure", 'Json'>
    readonly denominatorCriteria: FieldRef<"QualityMeasure", 'Json'>
    readonly exclusionCriteria: FieldRef<"QualityMeasure", 'Json'>
    readonly targetRate: FieldRef<"QualityMeasure", 'Float'>
    readonly measurePeriodStart: FieldRef<"QualityMeasure", 'DateTime'>
    readonly measurePeriodEnd: FieldRef<"QualityMeasure", 'DateTime'>
    readonly reportingYear: FieldRef<"QualityMeasure", 'Int'>
    readonly isActive: FieldRef<"QualityMeasure", 'Boolean'>
    readonly createdAt: FieldRef<"QualityMeasure", 'DateTime'>
    readonly updatedAt: FieldRef<"QualityMeasure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QualityMeasure findUnique
   */
  export type QualityMeasureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which QualityMeasure to fetch.
     */
    where: QualityMeasureWhereUniqueInput
  }

  /**
   * QualityMeasure findUniqueOrThrow
   */
  export type QualityMeasureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which QualityMeasure to fetch.
     */
    where: QualityMeasureWhereUniqueInput
  }

  /**
   * QualityMeasure findFirst
   */
  export type QualityMeasureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which QualityMeasure to fetch.
     */
    where?: QualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityMeasures to fetch.
     */
    orderBy?: QualityMeasureOrderByWithRelationInput | QualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityMeasures.
     */
    cursor?: QualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityMeasures.
     */
    distinct?: QualityMeasureScalarFieldEnum | QualityMeasureScalarFieldEnum[]
  }

  /**
   * QualityMeasure findFirstOrThrow
   */
  export type QualityMeasureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which QualityMeasure to fetch.
     */
    where?: QualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityMeasures to fetch.
     */
    orderBy?: QualityMeasureOrderByWithRelationInput | QualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityMeasures.
     */
    cursor?: QualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityMeasures.
     */
    distinct?: QualityMeasureScalarFieldEnum | QualityMeasureScalarFieldEnum[]
  }

  /**
   * QualityMeasure findMany
   */
  export type QualityMeasureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which QualityMeasures to fetch.
     */
    where?: QualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityMeasures to fetch.
     */
    orderBy?: QualityMeasureOrderByWithRelationInput | QualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QualityMeasures.
     */
    cursor?: QualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityMeasures.
     */
    skip?: number
    distinct?: QualityMeasureScalarFieldEnum | QualityMeasureScalarFieldEnum[]
  }

  /**
   * QualityMeasure create
   */
  export type QualityMeasureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * The data needed to create a QualityMeasure.
     */
    data: XOR<QualityMeasureCreateInput, QualityMeasureUncheckedCreateInput>
  }

  /**
   * QualityMeasure createMany
   */
  export type QualityMeasureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QualityMeasures.
     */
    data: QualityMeasureCreateManyInput | QualityMeasureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualityMeasure createManyAndReturn
   */
  export type QualityMeasureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QualityMeasures.
     */
    data: QualityMeasureCreateManyInput | QualityMeasureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualityMeasure update
   */
  export type QualityMeasureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * The data needed to update a QualityMeasure.
     */
    data: XOR<QualityMeasureUpdateInput, QualityMeasureUncheckedUpdateInput>
    /**
     * Choose, which QualityMeasure to update.
     */
    where: QualityMeasureWhereUniqueInput
  }

  /**
   * QualityMeasure updateMany
   */
  export type QualityMeasureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QualityMeasures.
     */
    data: XOR<QualityMeasureUpdateManyMutationInput, QualityMeasureUncheckedUpdateManyInput>
    /**
     * Filter which QualityMeasures to update
     */
    where?: QualityMeasureWhereInput
  }

  /**
   * QualityMeasure upsert
   */
  export type QualityMeasureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * The filter to search for the QualityMeasure to update in case it exists.
     */
    where: QualityMeasureWhereUniqueInput
    /**
     * In case the QualityMeasure found by the `where` argument doesn't exist, create a new QualityMeasure with this data.
     */
    create: XOR<QualityMeasureCreateInput, QualityMeasureUncheckedCreateInput>
    /**
     * In case the QualityMeasure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QualityMeasureUpdateInput, QualityMeasureUncheckedUpdateInput>
  }

  /**
   * QualityMeasure delete
   */
  export type QualityMeasureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
    /**
     * Filter which QualityMeasure to delete.
     */
    where: QualityMeasureWhereUniqueInput
  }

  /**
   * QualityMeasure deleteMany
   */
  export type QualityMeasureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityMeasures to delete
     */
    where?: QualityMeasureWhereInput
  }

  /**
   * QualityMeasure.populationMeasures
   */
  export type QualityMeasure$populationMeasuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    where?: PopulationQualityMeasureWhereInput
    orderBy?: PopulationQualityMeasureOrderByWithRelationInput | PopulationQualityMeasureOrderByWithRelationInput[]
    cursor?: PopulationQualityMeasureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PopulationQualityMeasureScalarFieldEnum | PopulationQualityMeasureScalarFieldEnum[]
  }

  /**
   * QualityMeasure.patientMeasures
   */
  export type QualityMeasure$patientMeasuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    where?: PatientQualityMeasureWhereInput
    orderBy?: PatientQualityMeasureOrderByWithRelationInput | PatientQualityMeasureOrderByWithRelationInput[]
    cursor?: PatientQualityMeasureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientQualityMeasureScalarFieldEnum | PatientQualityMeasureScalarFieldEnum[]
  }

  /**
   * QualityMeasure without action
   */
  export type QualityMeasureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityMeasure
     */
    select?: QualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityMeasureInclude<ExtArgs> | null
  }


  /**
   * Model PopulationQualityMeasure
   */

  export type AggregatePopulationQualityMeasure = {
    _count: PopulationQualityMeasureCountAggregateOutputType | null
    _avg: PopulationQualityMeasureAvgAggregateOutputType | null
    _sum: PopulationQualityMeasureSumAggregateOutputType | null
    _min: PopulationQualityMeasureMinAggregateOutputType | null
    _max: PopulationQualityMeasureMaxAggregateOutputType | null
  }

  export type PopulationQualityMeasureAvgAggregateOutputType = {
    numerator: number | null
    denominator: number | null
    exclusions: number | null
    performanceRate: number | null
    benchmarkRate: number | null
    benchmarkPercentile: number | null
    starRating: number | null
  }

  export type PopulationQualityMeasureSumAggregateOutputType = {
    numerator: number | null
    denominator: number | null
    exclusions: number | null
    performanceRate: number | null
    benchmarkRate: number | null
    benchmarkPercentile: number | null
    starRating: number | null
  }

  export type PopulationQualityMeasureMinAggregateOutputType = {
    id: string | null
    populationId: string | null
    qualityMeasureId: string | null
    numerator: number | null
    denominator: number | null
    exclusions: number | null
    performanceRate: number | null
    benchmarkRate: number | null
    benchmarkPercentile: number | null
    starRating: number | null
    measurePeriod: string | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PopulationQualityMeasureMaxAggregateOutputType = {
    id: string | null
    populationId: string | null
    qualityMeasureId: string | null
    numerator: number | null
    denominator: number | null
    exclusions: number | null
    performanceRate: number | null
    benchmarkRate: number | null
    benchmarkPercentile: number | null
    starRating: number | null
    measurePeriod: string | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PopulationQualityMeasureCountAggregateOutputType = {
    id: number
    populationId: number
    qualityMeasureId: number
    numerator: number
    denominator: number
    exclusions: number
    performanceRate: number
    benchmarkRate: number
    benchmarkPercentile: number
    starRating: number
    measurePeriod: number
    calculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PopulationQualityMeasureAvgAggregateInputType = {
    numerator?: true
    denominator?: true
    exclusions?: true
    performanceRate?: true
    benchmarkRate?: true
    benchmarkPercentile?: true
    starRating?: true
  }

  export type PopulationQualityMeasureSumAggregateInputType = {
    numerator?: true
    denominator?: true
    exclusions?: true
    performanceRate?: true
    benchmarkRate?: true
    benchmarkPercentile?: true
    starRating?: true
  }

  export type PopulationQualityMeasureMinAggregateInputType = {
    id?: true
    populationId?: true
    qualityMeasureId?: true
    numerator?: true
    denominator?: true
    exclusions?: true
    performanceRate?: true
    benchmarkRate?: true
    benchmarkPercentile?: true
    starRating?: true
    measurePeriod?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PopulationQualityMeasureMaxAggregateInputType = {
    id?: true
    populationId?: true
    qualityMeasureId?: true
    numerator?: true
    denominator?: true
    exclusions?: true
    performanceRate?: true
    benchmarkRate?: true
    benchmarkPercentile?: true
    starRating?: true
    measurePeriod?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PopulationQualityMeasureCountAggregateInputType = {
    id?: true
    populationId?: true
    qualityMeasureId?: true
    numerator?: true
    denominator?: true
    exclusions?: true
    performanceRate?: true
    benchmarkRate?: true
    benchmarkPercentile?: true
    starRating?: true
    measurePeriod?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PopulationQualityMeasureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PopulationQualityMeasure to aggregate.
     */
    where?: PopulationQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationQualityMeasures to fetch.
     */
    orderBy?: PopulationQualityMeasureOrderByWithRelationInput | PopulationQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PopulationQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationQualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PopulationQualityMeasures
    **/
    _count?: true | PopulationQualityMeasureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PopulationQualityMeasureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PopulationQualityMeasureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PopulationQualityMeasureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PopulationQualityMeasureMaxAggregateInputType
  }

  export type GetPopulationQualityMeasureAggregateType<T extends PopulationQualityMeasureAggregateArgs> = {
        [P in keyof T & keyof AggregatePopulationQualityMeasure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePopulationQualityMeasure[P]>
      : GetScalarType<T[P], AggregatePopulationQualityMeasure[P]>
  }




  export type PopulationQualityMeasureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PopulationQualityMeasureWhereInput
    orderBy?: PopulationQualityMeasureOrderByWithAggregationInput | PopulationQualityMeasureOrderByWithAggregationInput[]
    by: PopulationQualityMeasureScalarFieldEnum[] | PopulationQualityMeasureScalarFieldEnum
    having?: PopulationQualityMeasureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PopulationQualityMeasureCountAggregateInputType | true
    _avg?: PopulationQualityMeasureAvgAggregateInputType
    _sum?: PopulationQualityMeasureSumAggregateInputType
    _min?: PopulationQualityMeasureMinAggregateInputType
    _max?: PopulationQualityMeasureMaxAggregateInputType
  }

  export type PopulationQualityMeasureGroupByOutputType = {
    id: string
    populationId: string
    qualityMeasureId: string
    numerator: number
    denominator: number
    exclusions: number
    performanceRate: number | null
    benchmarkRate: number | null
    benchmarkPercentile: number | null
    starRating: number | null
    measurePeriod: string
    calculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: PopulationQualityMeasureCountAggregateOutputType | null
    _avg: PopulationQualityMeasureAvgAggregateOutputType | null
    _sum: PopulationQualityMeasureSumAggregateOutputType | null
    _min: PopulationQualityMeasureMinAggregateOutputType | null
    _max: PopulationQualityMeasureMaxAggregateOutputType | null
  }

  type GetPopulationQualityMeasureGroupByPayload<T extends PopulationQualityMeasureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PopulationQualityMeasureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PopulationQualityMeasureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PopulationQualityMeasureGroupByOutputType[P]>
            : GetScalarType<T[P], PopulationQualityMeasureGroupByOutputType[P]>
        }
      >
    >


  export type PopulationQualityMeasureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    qualityMeasureId?: boolean
    numerator?: boolean
    denominator?: boolean
    exclusions?: boolean
    performanceRate?: boolean
    benchmarkRate?: boolean
    benchmarkPercentile?: boolean
    starRating?: boolean
    measurePeriod?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    population?: boolean | PopulationDefaultArgs<ExtArgs>
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["populationQualityMeasure"]>

  export type PopulationQualityMeasureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    qualityMeasureId?: boolean
    numerator?: boolean
    denominator?: boolean
    exclusions?: boolean
    performanceRate?: boolean
    benchmarkRate?: boolean
    benchmarkPercentile?: boolean
    starRating?: boolean
    measurePeriod?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    population?: boolean | PopulationDefaultArgs<ExtArgs>
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["populationQualityMeasure"]>

  export type PopulationQualityMeasureSelectScalar = {
    id?: boolean
    populationId?: boolean
    qualityMeasureId?: boolean
    numerator?: boolean
    denominator?: boolean
    exclusions?: boolean
    performanceRate?: boolean
    benchmarkRate?: boolean
    benchmarkPercentile?: boolean
    starRating?: boolean
    measurePeriod?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PopulationQualityMeasureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | PopulationDefaultArgs<ExtArgs>
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }
  export type PopulationQualityMeasureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | PopulationDefaultArgs<ExtArgs>
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }

  export type $PopulationQualityMeasurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PopulationQualityMeasure"
    objects: {
      population: Prisma.$PopulationPayload<ExtArgs>
      qualityMeasure: Prisma.$QualityMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      populationId: string
      qualityMeasureId: string
      numerator: number
      denominator: number
      exclusions: number
      performanceRate: number | null
      benchmarkRate: number | null
      benchmarkPercentile: number | null
      starRating: number | null
      measurePeriod: string
      calculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["populationQualityMeasure"]>
    composites: {}
  }

  type PopulationQualityMeasureGetPayload<S extends boolean | null | undefined | PopulationQualityMeasureDefaultArgs> = $Result.GetResult<Prisma.$PopulationQualityMeasurePayload, S>

  type PopulationQualityMeasureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PopulationQualityMeasureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PopulationQualityMeasureCountAggregateInputType | true
    }

  export interface PopulationQualityMeasureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PopulationQualityMeasure'], meta: { name: 'PopulationQualityMeasure' } }
    /**
     * Find zero or one PopulationQualityMeasure that matches the filter.
     * @param {PopulationQualityMeasureFindUniqueArgs} args - Arguments to find a PopulationQualityMeasure
     * @example
     * // Get one PopulationQualityMeasure
     * const populationQualityMeasure = await prisma.populationQualityMeasure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PopulationQualityMeasureFindUniqueArgs>(args: SelectSubset<T, PopulationQualityMeasureFindUniqueArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PopulationQualityMeasure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PopulationQualityMeasureFindUniqueOrThrowArgs} args - Arguments to find a PopulationQualityMeasure
     * @example
     * // Get one PopulationQualityMeasure
     * const populationQualityMeasure = await prisma.populationQualityMeasure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PopulationQualityMeasureFindUniqueOrThrowArgs>(args: SelectSubset<T, PopulationQualityMeasureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PopulationQualityMeasure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationQualityMeasureFindFirstArgs} args - Arguments to find a PopulationQualityMeasure
     * @example
     * // Get one PopulationQualityMeasure
     * const populationQualityMeasure = await prisma.populationQualityMeasure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PopulationQualityMeasureFindFirstArgs>(args?: SelectSubset<T, PopulationQualityMeasureFindFirstArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PopulationQualityMeasure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationQualityMeasureFindFirstOrThrowArgs} args - Arguments to find a PopulationQualityMeasure
     * @example
     * // Get one PopulationQualityMeasure
     * const populationQualityMeasure = await prisma.populationQualityMeasure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PopulationQualityMeasureFindFirstOrThrowArgs>(args?: SelectSubset<T, PopulationQualityMeasureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PopulationQualityMeasures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationQualityMeasureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PopulationQualityMeasures
     * const populationQualityMeasures = await prisma.populationQualityMeasure.findMany()
     * 
     * // Get first 10 PopulationQualityMeasures
     * const populationQualityMeasures = await prisma.populationQualityMeasure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const populationQualityMeasureWithIdOnly = await prisma.populationQualityMeasure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PopulationQualityMeasureFindManyArgs>(args?: SelectSubset<T, PopulationQualityMeasureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PopulationQualityMeasure.
     * @param {PopulationQualityMeasureCreateArgs} args - Arguments to create a PopulationQualityMeasure.
     * @example
     * // Create one PopulationQualityMeasure
     * const PopulationQualityMeasure = await prisma.populationQualityMeasure.create({
     *   data: {
     *     // ... data to create a PopulationQualityMeasure
     *   }
     * })
     * 
     */
    create<T extends PopulationQualityMeasureCreateArgs>(args: SelectSubset<T, PopulationQualityMeasureCreateArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PopulationQualityMeasures.
     * @param {PopulationQualityMeasureCreateManyArgs} args - Arguments to create many PopulationQualityMeasures.
     * @example
     * // Create many PopulationQualityMeasures
     * const populationQualityMeasure = await prisma.populationQualityMeasure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PopulationQualityMeasureCreateManyArgs>(args?: SelectSubset<T, PopulationQualityMeasureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PopulationQualityMeasures and returns the data saved in the database.
     * @param {PopulationQualityMeasureCreateManyAndReturnArgs} args - Arguments to create many PopulationQualityMeasures.
     * @example
     * // Create many PopulationQualityMeasures
     * const populationQualityMeasure = await prisma.populationQualityMeasure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PopulationQualityMeasures and only return the `id`
     * const populationQualityMeasureWithIdOnly = await prisma.populationQualityMeasure.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PopulationQualityMeasureCreateManyAndReturnArgs>(args?: SelectSubset<T, PopulationQualityMeasureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PopulationQualityMeasure.
     * @param {PopulationQualityMeasureDeleteArgs} args - Arguments to delete one PopulationQualityMeasure.
     * @example
     * // Delete one PopulationQualityMeasure
     * const PopulationQualityMeasure = await prisma.populationQualityMeasure.delete({
     *   where: {
     *     // ... filter to delete one PopulationQualityMeasure
     *   }
     * })
     * 
     */
    delete<T extends PopulationQualityMeasureDeleteArgs>(args: SelectSubset<T, PopulationQualityMeasureDeleteArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PopulationQualityMeasure.
     * @param {PopulationQualityMeasureUpdateArgs} args - Arguments to update one PopulationQualityMeasure.
     * @example
     * // Update one PopulationQualityMeasure
     * const populationQualityMeasure = await prisma.populationQualityMeasure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PopulationQualityMeasureUpdateArgs>(args: SelectSubset<T, PopulationQualityMeasureUpdateArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PopulationQualityMeasures.
     * @param {PopulationQualityMeasureDeleteManyArgs} args - Arguments to filter PopulationQualityMeasures to delete.
     * @example
     * // Delete a few PopulationQualityMeasures
     * const { count } = await prisma.populationQualityMeasure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PopulationQualityMeasureDeleteManyArgs>(args?: SelectSubset<T, PopulationQualityMeasureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PopulationQualityMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationQualityMeasureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PopulationQualityMeasures
     * const populationQualityMeasure = await prisma.populationQualityMeasure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PopulationQualityMeasureUpdateManyArgs>(args: SelectSubset<T, PopulationQualityMeasureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PopulationQualityMeasure.
     * @param {PopulationQualityMeasureUpsertArgs} args - Arguments to update or create a PopulationQualityMeasure.
     * @example
     * // Update or create a PopulationQualityMeasure
     * const populationQualityMeasure = await prisma.populationQualityMeasure.upsert({
     *   create: {
     *     // ... data to create a PopulationQualityMeasure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PopulationQualityMeasure we want to update
     *   }
     * })
     */
    upsert<T extends PopulationQualityMeasureUpsertArgs>(args: SelectSubset<T, PopulationQualityMeasureUpsertArgs<ExtArgs>>): Prisma__PopulationQualityMeasureClient<$Result.GetResult<Prisma.$PopulationQualityMeasurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PopulationQualityMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationQualityMeasureCountArgs} args - Arguments to filter PopulationQualityMeasures to count.
     * @example
     * // Count the number of PopulationQualityMeasures
     * const count = await prisma.populationQualityMeasure.count({
     *   where: {
     *     // ... the filter for the PopulationQualityMeasures we want to count
     *   }
     * })
    **/
    count<T extends PopulationQualityMeasureCountArgs>(
      args?: Subset<T, PopulationQualityMeasureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PopulationQualityMeasureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PopulationQualityMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationQualityMeasureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PopulationQualityMeasureAggregateArgs>(args: Subset<T, PopulationQualityMeasureAggregateArgs>): Prisma.PrismaPromise<GetPopulationQualityMeasureAggregateType<T>>

    /**
     * Group by PopulationQualityMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopulationQualityMeasureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PopulationQualityMeasureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PopulationQualityMeasureGroupByArgs['orderBy'] }
        : { orderBy?: PopulationQualityMeasureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PopulationQualityMeasureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopulationQualityMeasureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PopulationQualityMeasure model
   */
  readonly fields: PopulationQualityMeasureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PopulationQualityMeasure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PopulationQualityMeasureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    population<T extends PopulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PopulationDefaultArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    qualityMeasure<T extends QualityMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QualityMeasureDefaultArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PopulationQualityMeasure model
   */ 
  interface PopulationQualityMeasureFieldRefs {
    readonly id: FieldRef<"PopulationQualityMeasure", 'String'>
    readonly populationId: FieldRef<"PopulationQualityMeasure", 'String'>
    readonly qualityMeasureId: FieldRef<"PopulationQualityMeasure", 'String'>
    readonly numerator: FieldRef<"PopulationQualityMeasure", 'Int'>
    readonly denominator: FieldRef<"PopulationQualityMeasure", 'Int'>
    readonly exclusions: FieldRef<"PopulationQualityMeasure", 'Int'>
    readonly performanceRate: FieldRef<"PopulationQualityMeasure", 'Float'>
    readonly benchmarkRate: FieldRef<"PopulationQualityMeasure", 'Float'>
    readonly benchmarkPercentile: FieldRef<"PopulationQualityMeasure", 'Int'>
    readonly starRating: FieldRef<"PopulationQualityMeasure", 'Int'>
    readonly measurePeriod: FieldRef<"PopulationQualityMeasure", 'String'>
    readonly calculatedAt: FieldRef<"PopulationQualityMeasure", 'DateTime'>
    readonly createdAt: FieldRef<"PopulationQualityMeasure", 'DateTime'>
    readonly updatedAt: FieldRef<"PopulationQualityMeasure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PopulationQualityMeasure findUnique
   */
  export type PopulationQualityMeasureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PopulationQualityMeasure to fetch.
     */
    where: PopulationQualityMeasureWhereUniqueInput
  }

  /**
   * PopulationQualityMeasure findUniqueOrThrow
   */
  export type PopulationQualityMeasureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PopulationQualityMeasure to fetch.
     */
    where: PopulationQualityMeasureWhereUniqueInput
  }

  /**
   * PopulationQualityMeasure findFirst
   */
  export type PopulationQualityMeasureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PopulationQualityMeasure to fetch.
     */
    where?: PopulationQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationQualityMeasures to fetch.
     */
    orderBy?: PopulationQualityMeasureOrderByWithRelationInput | PopulationQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PopulationQualityMeasures.
     */
    cursor?: PopulationQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationQualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PopulationQualityMeasures.
     */
    distinct?: PopulationQualityMeasureScalarFieldEnum | PopulationQualityMeasureScalarFieldEnum[]
  }

  /**
   * PopulationQualityMeasure findFirstOrThrow
   */
  export type PopulationQualityMeasureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PopulationQualityMeasure to fetch.
     */
    where?: PopulationQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationQualityMeasures to fetch.
     */
    orderBy?: PopulationQualityMeasureOrderByWithRelationInput | PopulationQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PopulationQualityMeasures.
     */
    cursor?: PopulationQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationQualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PopulationQualityMeasures.
     */
    distinct?: PopulationQualityMeasureScalarFieldEnum | PopulationQualityMeasureScalarFieldEnum[]
  }

  /**
   * PopulationQualityMeasure findMany
   */
  export type PopulationQualityMeasureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PopulationQualityMeasures to fetch.
     */
    where?: PopulationQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PopulationQualityMeasures to fetch.
     */
    orderBy?: PopulationQualityMeasureOrderByWithRelationInput | PopulationQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PopulationQualityMeasures.
     */
    cursor?: PopulationQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PopulationQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PopulationQualityMeasures.
     */
    skip?: number
    distinct?: PopulationQualityMeasureScalarFieldEnum | PopulationQualityMeasureScalarFieldEnum[]
  }

  /**
   * PopulationQualityMeasure create
   */
  export type PopulationQualityMeasureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * The data needed to create a PopulationQualityMeasure.
     */
    data: XOR<PopulationQualityMeasureCreateInput, PopulationQualityMeasureUncheckedCreateInput>
  }

  /**
   * PopulationQualityMeasure createMany
   */
  export type PopulationQualityMeasureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PopulationQualityMeasures.
     */
    data: PopulationQualityMeasureCreateManyInput | PopulationQualityMeasureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PopulationQualityMeasure createManyAndReturn
   */
  export type PopulationQualityMeasureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PopulationQualityMeasures.
     */
    data: PopulationQualityMeasureCreateManyInput | PopulationQualityMeasureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PopulationQualityMeasure update
   */
  export type PopulationQualityMeasureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * The data needed to update a PopulationQualityMeasure.
     */
    data: XOR<PopulationQualityMeasureUpdateInput, PopulationQualityMeasureUncheckedUpdateInput>
    /**
     * Choose, which PopulationQualityMeasure to update.
     */
    where: PopulationQualityMeasureWhereUniqueInput
  }

  /**
   * PopulationQualityMeasure updateMany
   */
  export type PopulationQualityMeasureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PopulationQualityMeasures.
     */
    data: XOR<PopulationQualityMeasureUpdateManyMutationInput, PopulationQualityMeasureUncheckedUpdateManyInput>
    /**
     * Filter which PopulationQualityMeasures to update
     */
    where?: PopulationQualityMeasureWhereInput
  }

  /**
   * PopulationQualityMeasure upsert
   */
  export type PopulationQualityMeasureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * The filter to search for the PopulationQualityMeasure to update in case it exists.
     */
    where: PopulationQualityMeasureWhereUniqueInput
    /**
     * In case the PopulationQualityMeasure found by the `where` argument doesn't exist, create a new PopulationQualityMeasure with this data.
     */
    create: XOR<PopulationQualityMeasureCreateInput, PopulationQualityMeasureUncheckedCreateInput>
    /**
     * In case the PopulationQualityMeasure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PopulationQualityMeasureUpdateInput, PopulationQualityMeasureUncheckedUpdateInput>
  }

  /**
   * PopulationQualityMeasure delete
   */
  export type PopulationQualityMeasureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter which PopulationQualityMeasure to delete.
     */
    where: PopulationQualityMeasureWhereUniqueInput
  }

  /**
   * PopulationQualityMeasure deleteMany
   */
  export type PopulationQualityMeasureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PopulationQualityMeasures to delete
     */
    where?: PopulationQualityMeasureWhereInput
  }

  /**
   * PopulationQualityMeasure without action
   */
  export type PopulationQualityMeasureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PopulationQualityMeasure
     */
    select?: PopulationQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationQualityMeasureInclude<ExtArgs> | null
  }


  /**
   * Model PatientQualityMeasure
   */

  export type AggregatePatientQualityMeasure = {
    _count: PatientQualityMeasureCountAggregateOutputType | null
    _min: PatientQualityMeasureMinAggregateOutputType | null
    _max: PatientQualityMeasureMaxAggregateOutputType | null
  }

  export type PatientQualityMeasureMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    fhirPatientRef: string | null
    qualityMeasureId: string | null
    inDenominator: boolean | null
    inNumerator: boolean | null
    isExcluded: boolean | null
    exclusionReason: string | null
    status: $Enums.ComplianceStatus | null
    dueDate: Date | null
    completedDate: Date | null
    evidenceRef: string | null
    notes: string | null
    measurePeriod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientQualityMeasureMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    fhirPatientRef: string | null
    qualityMeasureId: string | null
    inDenominator: boolean | null
    inNumerator: boolean | null
    isExcluded: boolean | null
    exclusionReason: string | null
    status: $Enums.ComplianceStatus | null
    dueDate: Date | null
    completedDate: Date | null
    evidenceRef: string | null
    notes: string | null
    measurePeriod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientQualityMeasureCountAggregateOutputType = {
    id: number
    patientId: number
    fhirPatientRef: number
    qualityMeasureId: number
    inDenominator: number
    inNumerator: number
    isExcluded: number
    exclusionReason: number
    status: number
    dueDate: number
    completedDate: number
    evidenceRef: number
    notes: number
    measurePeriod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientQualityMeasureMinAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    qualityMeasureId?: true
    inDenominator?: true
    inNumerator?: true
    isExcluded?: true
    exclusionReason?: true
    status?: true
    dueDate?: true
    completedDate?: true
    evidenceRef?: true
    notes?: true
    measurePeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientQualityMeasureMaxAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    qualityMeasureId?: true
    inDenominator?: true
    inNumerator?: true
    isExcluded?: true
    exclusionReason?: true
    status?: true
    dueDate?: true
    completedDate?: true
    evidenceRef?: true
    notes?: true
    measurePeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientQualityMeasureCountAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    qualityMeasureId?: true
    inDenominator?: true
    inNumerator?: true
    isExcluded?: true
    exclusionReason?: true
    status?: true
    dueDate?: true
    completedDate?: true
    evidenceRef?: true
    notes?: true
    measurePeriod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientQualityMeasureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientQualityMeasure to aggregate.
     */
    where?: PatientQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientQualityMeasures to fetch.
     */
    orderBy?: PatientQualityMeasureOrderByWithRelationInput | PatientQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientQualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientQualityMeasures
    **/
    _count?: true | PatientQualityMeasureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientQualityMeasureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientQualityMeasureMaxAggregateInputType
  }

  export type GetPatientQualityMeasureAggregateType<T extends PatientQualityMeasureAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientQualityMeasure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientQualityMeasure[P]>
      : GetScalarType<T[P], AggregatePatientQualityMeasure[P]>
  }




  export type PatientQualityMeasureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientQualityMeasureWhereInput
    orderBy?: PatientQualityMeasureOrderByWithAggregationInput | PatientQualityMeasureOrderByWithAggregationInput[]
    by: PatientQualityMeasureScalarFieldEnum[] | PatientQualityMeasureScalarFieldEnum
    having?: PatientQualityMeasureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientQualityMeasureCountAggregateInputType | true
    _min?: PatientQualityMeasureMinAggregateInputType
    _max?: PatientQualityMeasureMaxAggregateInputType
  }

  export type PatientQualityMeasureGroupByOutputType = {
    id: string
    patientId: string
    fhirPatientRef: string | null
    qualityMeasureId: string
    inDenominator: boolean
    inNumerator: boolean
    isExcluded: boolean
    exclusionReason: string | null
    status: $Enums.ComplianceStatus
    dueDate: Date | null
    completedDate: Date | null
    evidenceRef: string | null
    notes: string | null
    measurePeriod: string
    createdAt: Date
    updatedAt: Date
    _count: PatientQualityMeasureCountAggregateOutputType | null
    _min: PatientQualityMeasureMinAggregateOutputType | null
    _max: PatientQualityMeasureMaxAggregateOutputType | null
  }

  type GetPatientQualityMeasureGroupByPayload<T extends PatientQualityMeasureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientQualityMeasureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientQualityMeasureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientQualityMeasureGroupByOutputType[P]>
            : GetScalarType<T[P], PatientQualityMeasureGroupByOutputType[P]>
        }
      >
    >


  export type PatientQualityMeasureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    qualityMeasureId?: boolean
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    evidenceRef?: boolean
    notes?: boolean
    measurePeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientQualityMeasure"]>

  export type PatientQualityMeasureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    qualityMeasureId?: boolean
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    evidenceRef?: boolean
    notes?: boolean
    measurePeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientQualityMeasure"]>

  export type PatientQualityMeasureSelectScalar = {
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    qualityMeasureId?: boolean
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    evidenceRef?: boolean
    notes?: boolean
    measurePeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientQualityMeasureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }
  export type PatientQualityMeasureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualityMeasure?: boolean | QualityMeasureDefaultArgs<ExtArgs>
  }

  export type $PatientQualityMeasurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientQualityMeasure"
    objects: {
      qualityMeasure: Prisma.$QualityMeasurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      fhirPatientRef: string | null
      qualityMeasureId: string
      inDenominator: boolean
      inNumerator: boolean
      isExcluded: boolean
      exclusionReason: string | null
      status: $Enums.ComplianceStatus
      dueDate: Date | null
      completedDate: Date | null
      evidenceRef: string | null
      notes: string | null
      measurePeriod: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patientQualityMeasure"]>
    composites: {}
  }

  type PatientQualityMeasureGetPayload<S extends boolean | null | undefined | PatientQualityMeasureDefaultArgs> = $Result.GetResult<Prisma.$PatientQualityMeasurePayload, S>

  type PatientQualityMeasureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientQualityMeasureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientQualityMeasureCountAggregateInputType | true
    }

  export interface PatientQualityMeasureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientQualityMeasure'], meta: { name: 'PatientQualityMeasure' } }
    /**
     * Find zero or one PatientQualityMeasure that matches the filter.
     * @param {PatientQualityMeasureFindUniqueArgs} args - Arguments to find a PatientQualityMeasure
     * @example
     * // Get one PatientQualityMeasure
     * const patientQualityMeasure = await prisma.patientQualityMeasure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientQualityMeasureFindUniqueArgs>(args: SelectSubset<T, PatientQualityMeasureFindUniqueArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientQualityMeasure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientQualityMeasureFindUniqueOrThrowArgs} args - Arguments to find a PatientQualityMeasure
     * @example
     * // Get one PatientQualityMeasure
     * const patientQualityMeasure = await prisma.patientQualityMeasure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientQualityMeasureFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientQualityMeasureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientQualityMeasure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientQualityMeasureFindFirstArgs} args - Arguments to find a PatientQualityMeasure
     * @example
     * // Get one PatientQualityMeasure
     * const patientQualityMeasure = await prisma.patientQualityMeasure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientQualityMeasureFindFirstArgs>(args?: SelectSubset<T, PatientQualityMeasureFindFirstArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientQualityMeasure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientQualityMeasureFindFirstOrThrowArgs} args - Arguments to find a PatientQualityMeasure
     * @example
     * // Get one PatientQualityMeasure
     * const patientQualityMeasure = await prisma.patientQualityMeasure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientQualityMeasureFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientQualityMeasureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientQualityMeasures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientQualityMeasureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientQualityMeasures
     * const patientQualityMeasures = await prisma.patientQualityMeasure.findMany()
     * 
     * // Get first 10 PatientQualityMeasures
     * const patientQualityMeasures = await prisma.patientQualityMeasure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientQualityMeasureWithIdOnly = await prisma.patientQualityMeasure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientQualityMeasureFindManyArgs>(args?: SelectSubset<T, PatientQualityMeasureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientQualityMeasure.
     * @param {PatientQualityMeasureCreateArgs} args - Arguments to create a PatientQualityMeasure.
     * @example
     * // Create one PatientQualityMeasure
     * const PatientQualityMeasure = await prisma.patientQualityMeasure.create({
     *   data: {
     *     // ... data to create a PatientQualityMeasure
     *   }
     * })
     * 
     */
    create<T extends PatientQualityMeasureCreateArgs>(args: SelectSubset<T, PatientQualityMeasureCreateArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientQualityMeasures.
     * @param {PatientQualityMeasureCreateManyArgs} args - Arguments to create many PatientQualityMeasures.
     * @example
     * // Create many PatientQualityMeasures
     * const patientQualityMeasure = await prisma.patientQualityMeasure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientQualityMeasureCreateManyArgs>(args?: SelectSubset<T, PatientQualityMeasureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientQualityMeasures and returns the data saved in the database.
     * @param {PatientQualityMeasureCreateManyAndReturnArgs} args - Arguments to create many PatientQualityMeasures.
     * @example
     * // Create many PatientQualityMeasures
     * const patientQualityMeasure = await prisma.patientQualityMeasure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientQualityMeasures and only return the `id`
     * const patientQualityMeasureWithIdOnly = await prisma.patientQualityMeasure.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientQualityMeasureCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientQualityMeasureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientQualityMeasure.
     * @param {PatientQualityMeasureDeleteArgs} args - Arguments to delete one PatientQualityMeasure.
     * @example
     * // Delete one PatientQualityMeasure
     * const PatientQualityMeasure = await prisma.patientQualityMeasure.delete({
     *   where: {
     *     // ... filter to delete one PatientQualityMeasure
     *   }
     * })
     * 
     */
    delete<T extends PatientQualityMeasureDeleteArgs>(args: SelectSubset<T, PatientQualityMeasureDeleteArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientQualityMeasure.
     * @param {PatientQualityMeasureUpdateArgs} args - Arguments to update one PatientQualityMeasure.
     * @example
     * // Update one PatientQualityMeasure
     * const patientQualityMeasure = await prisma.patientQualityMeasure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientQualityMeasureUpdateArgs>(args: SelectSubset<T, PatientQualityMeasureUpdateArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientQualityMeasures.
     * @param {PatientQualityMeasureDeleteManyArgs} args - Arguments to filter PatientQualityMeasures to delete.
     * @example
     * // Delete a few PatientQualityMeasures
     * const { count } = await prisma.patientQualityMeasure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientQualityMeasureDeleteManyArgs>(args?: SelectSubset<T, PatientQualityMeasureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientQualityMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientQualityMeasureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientQualityMeasures
     * const patientQualityMeasure = await prisma.patientQualityMeasure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientQualityMeasureUpdateManyArgs>(args: SelectSubset<T, PatientQualityMeasureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientQualityMeasure.
     * @param {PatientQualityMeasureUpsertArgs} args - Arguments to update or create a PatientQualityMeasure.
     * @example
     * // Update or create a PatientQualityMeasure
     * const patientQualityMeasure = await prisma.patientQualityMeasure.upsert({
     *   create: {
     *     // ... data to create a PatientQualityMeasure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientQualityMeasure we want to update
     *   }
     * })
     */
    upsert<T extends PatientQualityMeasureUpsertArgs>(args: SelectSubset<T, PatientQualityMeasureUpsertArgs<ExtArgs>>): Prisma__PatientQualityMeasureClient<$Result.GetResult<Prisma.$PatientQualityMeasurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientQualityMeasures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientQualityMeasureCountArgs} args - Arguments to filter PatientQualityMeasures to count.
     * @example
     * // Count the number of PatientQualityMeasures
     * const count = await prisma.patientQualityMeasure.count({
     *   where: {
     *     // ... the filter for the PatientQualityMeasures we want to count
     *   }
     * })
    **/
    count<T extends PatientQualityMeasureCountArgs>(
      args?: Subset<T, PatientQualityMeasureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientQualityMeasureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientQualityMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientQualityMeasureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientQualityMeasureAggregateArgs>(args: Subset<T, PatientQualityMeasureAggregateArgs>): Prisma.PrismaPromise<GetPatientQualityMeasureAggregateType<T>>

    /**
     * Group by PatientQualityMeasure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientQualityMeasureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientQualityMeasureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientQualityMeasureGroupByArgs['orderBy'] }
        : { orderBy?: PatientQualityMeasureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientQualityMeasureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientQualityMeasureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientQualityMeasure model
   */
  readonly fields: PatientQualityMeasureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientQualityMeasure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientQualityMeasureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qualityMeasure<T extends QualityMeasureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QualityMeasureDefaultArgs<ExtArgs>>): Prisma__QualityMeasureClient<$Result.GetResult<Prisma.$QualityMeasurePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientQualityMeasure model
   */ 
  interface PatientQualityMeasureFieldRefs {
    readonly id: FieldRef<"PatientQualityMeasure", 'String'>
    readonly patientId: FieldRef<"PatientQualityMeasure", 'String'>
    readonly fhirPatientRef: FieldRef<"PatientQualityMeasure", 'String'>
    readonly qualityMeasureId: FieldRef<"PatientQualityMeasure", 'String'>
    readonly inDenominator: FieldRef<"PatientQualityMeasure", 'Boolean'>
    readonly inNumerator: FieldRef<"PatientQualityMeasure", 'Boolean'>
    readonly isExcluded: FieldRef<"PatientQualityMeasure", 'Boolean'>
    readonly exclusionReason: FieldRef<"PatientQualityMeasure", 'String'>
    readonly status: FieldRef<"PatientQualityMeasure", 'ComplianceStatus'>
    readonly dueDate: FieldRef<"PatientQualityMeasure", 'DateTime'>
    readonly completedDate: FieldRef<"PatientQualityMeasure", 'DateTime'>
    readonly evidenceRef: FieldRef<"PatientQualityMeasure", 'String'>
    readonly notes: FieldRef<"PatientQualityMeasure", 'String'>
    readonly measurePeriod: FieldRef<"PatientQualityMeasure", 'String'>
    readonly createdAt: FieldRef<"PatientQualityMeasure", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientQualityMeasure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientQualityMeasure findUnique
   */
  export type PatientQualityMeasureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PatientQualityMeasure to fetch.
     */
    where: PatientQualityMeasureWhereUniqueInput
  }

  /**
   * PatientQualityMeasure findUniqueOrThrow
   */
  export type PatientQualityMeasureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PatientQualityMeasure to fetch.
     */
    where: PatientQualityMeasureWhereUniqueInput
  }

  /**
   * PatientQualityMeasure findFirst
   */
  export type PatientQualityMeasureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PatientQualityMeasure to fetch.
     */
    where?: PatientQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientQualityMeasures to fetch.
     */
    orderBy?: PatientQualityMeasureOrderByWithRelationInput | PatientQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientQualityMeasures.
     */
    cursor?: PatientQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientQualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientQualityMeasures.
     */
    distinct?: PatientQualityMeasureScalarFieldEnum | PatientQualityMeasureScalarFieldEnum[]
  }

  /**
   * PatientQualityMeasure findFirstOrThrow
   */
  export type PatientQualityMeasureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PatientQualityMeasure to fetch.
     */
    where?: PatientQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientQualityMeasures to fetch.
     */
    orderBy?: PatientQualityMeasureOrderByWithRelationInput | PatientQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientQualityMeasures.
     */
    cursor?: PatientQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientQualityMeasures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientQualityMeasures.
     */
    distinct?: PatientQualityMeasureScalarFieldEnum | PatientQualityMeasureScalarFieldEnum[]
  }

  /**
   * PatientQualityMeasure findMany
   */
  export type PatientQualityMeasureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter, which PatientQualityMeasures to fetch.
     */
    where?: PatientQualityMeasureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientQualityMeasures to fetch.
     */
    orderBy?: PatientQualityMeasureOrderByWithRelationInput | PatientQualityMeasureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientQualityMeasures.
     */
    cursor?: PatientQualityMeasureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientQualityMeasures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientQualityMeasures.
     */
    skip?: number
    distinct?: PatientQualityMeasureScalarFieldEnum | PatientQualityMeasureScalarFieldEnum[]
  }

  /**
   * PatientQualityMeasure create
   */
  export type PatientQualityMeasureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientQualityMeasure.
     */
    data: XOR<PatientQualityMeasureCreateInput, PatientQualityMeasureUncheckedCreateInput>
  }

  /**
   * PatientQualityMeasure createMany
   */
  export type PatientQualityMeasureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientQualityMeasures.
     */
    data: PatientQualityMeasureCreateManyInput | PatientQualityMeasureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientQualityMeasure createManyAndReturn
   */
  export type PatientQualityMeasureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientQualityMeasures.
     */
    data: PatientQualityMeasureCreateManyInput | PatientQualityMeasureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientQualityMeasure update
   */
  export type PatientQualityMeasureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientQualityMeasure.
     */
    data: XOR<PatientQualityMeasureUpdateInput, PatientQualityMeasureUncheckedUpdateInput>
    /**
     * Choose, which PatientQualityMeasure to update.
     */
    where: PatientQualityMeasureWhereUniqueInput
  }

  /**
   * PatientQualityMeasure updateMany
   */
  export type PatientQualityMeasureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientQualityMeasures.
     */
    data: XOR<PatientQualityMeasureUpdateManyMutationInput, PatientQualityMeasureUncheckedUpdateManyInput>
    /**
     * Filter which PatientQualityMeasures to update
     */
    where?: PatientQualityMeasureWhereInput
  }

  /**
   * PatientQualityMeasure upsert
   */
  export type PatientQualityMeasureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientQualityMeasure to update in case it exists.
     */
    where: PatientQualityMeasureWhereUniqueInput
    /**
     * In case the PatientQualityMeasure found by the `where` argument doesn't exist, create a new PatientQualityMeasure with this data.
     */
    create: XOR<PatientQualityMeasureCreateInput, PatientQualityMeasureUncheckedCreateInput>
    /**
     * In case the PatientQualityMeasure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientQualityMeasureUpdateInput, PatientQualityMeasureUncheckedUpdateInput>
  }

  /**
   * PatientQualityMeasure delete
   */
  export type PatientQualityMeasureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
    /**
     * Filter which PatientQualityMeasure to delete.
     */
    where: PatientQualityMeasureWhereUniqueInput
  }

  /**
   * PatientQualityMeasure deleteMany
   */
  export type PatientQualityMeasureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientQualityMeasures to delete
     */
    where?: PatientQualityMeasureWhereInput
  }

  /**
   * PatientQualityMeasure without action
   */
  export type PatientQualityMeasureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientQualityMeasure
     */
    select?: PatientQualityMeasureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientQualityMeasureInclude<ExtArgs> | null
  }


  /**
   * Model RiskScore
   */

  export type AggregateRiskScore = {
    _count: RiskScoreCountAggregateOutputType | null
    _avg: RiskScoreAvgAggregateOutputType | null
    _sum: RiskScoreSumAggregateOutputType | null
    _min: RiskScoreMinAggregateOutputType | null
    _max: RiskScoreMaxAggregateOutputType | null
  }

  export type RiskScoreAvgAggregateOutputType = {
    rawScore: number | null
    normalizedScore: number | null
    percentile: number | null
    predictedCost: number | null
  }

  export type RiskScoreSumAggregateOutputType = {
    rawScore: number | null
    normalizedScore: number | null
    percentile: number | null
    predictedCost: number | null
  }

  export type RiskScoreMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    fhirPatientRef: string | null
    modelName: string | null
    modelVersion: string | null
    scoreType: $Enums.ScoreType | null
    rawScore: number | null
    normalizedScore: number | null
    percentile: number | null
    riskTier: $Enums.RiskTier | null
    predictedCost: number | null
    effectiveDate: Date | null
    expirationDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskScoreMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    fhirPatientRef: string | null
    modelName: string | null
    modelVersion: string | null
    scoreType: $Enums.ScoreType | null
    rawScore: number | null
    normalizedScore: number | null
    percentile: number | null
    riskTier: $Enums.RiskTier | null
    predictedCost: number | null
    effectiveDate: Date | null
    expirationDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskScoreCountAggregateOutputType = {
    id: number
    patientId: number
    fhirPatientRef: number
    modelName: number
    modelVersion: number
    scoreType: number
    rawScore: number
    normalizedScore: number
    percentile: number
    riskTier: number
    riskFactors: number
    clinicalFactors: number
    socialFactors: number
    predictedCost: number
    predictedEvents: number
    effectiveDate: number
    expirationDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskScoreAvgAggregateInputType = {
    rawScore?: true
    normalizedScore?: true
    percentile?: true
    predictedCost?: true
  }

  export type RiskScoreSumAggregateInputType = {
    rawScore?: true
    normalizedScore?: true
    percentile?: true
    predictedCost?: true
  }

  export type RiskScoreMinAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    modelName?: true
    modelVersion?: true
    scoreType?: true
    rawScore?: true
    normalizedScore?: true
    percentile?: true
    riskTier?: true
    predictedCost?: true
    effectiveDate?: true
    expirationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskScoreMaxAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    modelName?: true
    modelVersion?: true
    scoreType?: true
    rawScore?: true
    normalizedScore?: true
    percentile?: true
    riskTier?: true
    predictedCost?: true
    effectiveDate?: true
    expirationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskScoreCountAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    modelName?: true
    modelVersion?: true
    scoreType?: true
    rawScore?: true
    normalizedScore?: true
    percentile?: true
    riskTier?: true
    riskFactors?: true
    clinicalFactors?: true
    socialFactors?: true
    predictedCost?: true
    predictedEvents?: true
    effectiveDate?: true
    expirationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskScore to aggregate.
     */
    where?: RiskScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScores to fetch.
     */
    orderBy?: RiskScoreOrderByWithRelationInput | RiskScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskScores
    **/
    _count?: true | RiskScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskScoreMaxAggregateInputType
  }

  export type GetRiskScoreAggregateType<T extends RiskScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskScore[P]>
      : GetScalarType<T[P], AggregateRiskScore[P]>
  }




  export type RiskScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskScoreWhereInput
    orderBy?: RiskScoreOrderByWithAggregationInput | RiskScoreOrderByWithAggregationInput[]
    by: RiskScoreScalarFieldEnum[] | RiskScoreScalarFieldEnum
    having?: RiskScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskScoreCountAggregateInputType | true
    _avg?: RiskScoreAvgAggregateInputType
    _sum?: RiskScoreSumAggregateInputType
    _min?: RiskScoreMinAggregateInputType
    _max?: RiskScoreMaxAggregateInputType
  }

  export type RiskScoreGroupByOutputType = {
    id: string
    patientId: string
    fhirPatientRef: string | null
    modelName: string
    modelVersion: string | null
    scoreType: $Enums.ScoreType
    rawScore: number
    normalizedScore: number | null
    percentile: number | null
    riskTier: $Enums.RiskTier
    riskFactors: JsonValue | null
    clinicalFactors: JsonValue | null
    socialFactors: JsonValue | null
    predictedCost: number | null
    predictedEvents: JsonValue | null
    effectiveDate: Date
    expirationDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RiskScoreCountAggregateOutputType | null
    _avg: RiskScoreAvgAggregateOutputType | null
    _sum: RiskScoreSumAggregateOutputType | null
    _min: RiskScoreMinAggregateOutputType | null
    _max: RiskScoreMaxAggregateOutputType | null
  }

  type GetRiskScoreGroupByPayload<T extends RiskScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskScoreGroupByOutputType[P]>
            : GetScalarType<T[P], RiskScoreGroupByOutputType[P]>
        }
      >
    >


  export type RiskScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    modelName?: boolean
    modelVersion?: boolean
    scoreType?: boolean
    rawScore?: boolean
    normalizedScore?: boolean
    percentile?: boolean
    riskTier?: boolean
    riskFactors?: boolean
    clinicalFactors?: boolean
    socialFactors?: boolean
    predictedCost?: boolean
    predictedEvents?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["riskScore"]>

  export type RiskScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    modelName?: boolean
    modelVersion?: boolean
    scoreType?: boolean
    rawScore?: boolean
    normalizedScore?: boolean
    percentile?: boolean
    riskTier?: boolean
    riskFactors?: boolean
    clinicalFactors?: boolean
    socialFactors?: boolean
    predictedCost?: boolean
    predictedEvents?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["riskScore"]>

  export type RiskScoreSelectScalar = {
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    modelName?: boolean
    modelVersion?: boolean
    scoreType?: boolean
    rawScore?: boolean
    normalizedScore?: boolean
    percentile?: boolean
    riskTier?: boolean
    riskFactors?: boolean
    clinicalFactors?: boolean
    socialFactors?: boolean
    predictedCost?: boolean
    predictedEvents?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RiskScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskScore"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      fhirPatientRef: string | null
      modelName: string
      modelVersion: string | null
      scoreType: $Enums.ScoreType
      rawScore: number
      normalizedScore: number | null
      percentile: number | null
      riskTier: $Enums.RiskTier
      riskFactors: Prisma.JsonValue | null
      clinicalFactors: Prisma.JsonValue | null
      socialFactors: Prisma.JsonValue | null
      predictedCost: number | null
      predictedEvents: Prisma.JsonValue | null
      effectiveDate: Date
      expirationDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskScore"]>
    composites: {}
  }

  type RiskScoreGetPayload<S extends boolean | null | undefined | RiskScoreDefaultArgs> = $Result.GetResult<Prisma.$RiskScorePayload, S>

  type RiskScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskScoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskScoreCountAggregateInputType | true
    }

  export interface RiskScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskScore'], meta: { name: 'RiskScore' } }
    /**
     * Find zero or one RiskScore that matches the filter.
     * @param {RiskScoreFindUniqueArgs} args - Arguments to find a RiskScore
     * @example
     * // Get one RiskScore
     * const riskScore = await prisma.riskScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskScoreFindUniqueArgs>(args: SelectSubset<T, RiskScoreFindUniqueArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskScore that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskScoreFindUniqueOrThrowArgs} args - Arguments to find a RiskScore
     * @example
     * // Get one RiskScore
     * const riskScore = await prisma.riskScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoreFindFirstArgs} args - Arguments to find a RiskScore
     * @example
     * // Get one RiskScore
     * const riskScore = await prisma.riskScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskScoreFindFirstArgs>(args?: SelectSubset<T, RiskScoreFindFirstArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoreFindFirstOrThrowArgs} args - Arguments to find a RiskScore
     * @example
     * // Get one RiskScore
     * const riskScore = await prisma.riskScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskScores
     * const riskScores = await prisma.riskScore.findMany()
     * 
     * // Get first 10 RiskScores
     * const riskScores = await prisma.riskScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskScoreWithIdOnly = await prisma.riskScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskScoreFindManyArgs>(args?: SelectSubset<T, RiskScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskScore.
     * @param {RiskScoreCreateArgs} args - Arguments to create a RiskScore.
     * @example
     * // Create one RiskScore
     * const RiskScore = await prisma.riskScore.create({
     *   data: {
     *     // ... data to create a RiskScore
     *   }
     * })
     * 
     */
    create<T extends RiskScoreCreateArgs>(args: SelectSubset<T, RiskScoreCreateArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskScores.
     * @param {RiskScoreCreateManyArgs} args - Arguments to create many RiskScores.
     * @example
     * // Create many RiskScores
     * const riskScore = await prisma.riskScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskScoreCreateManyArgs>(args?: SelectSubset<T, RiskScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskScores and returns the data saved in the database.
     * @param {RiskScoreCreateManyAndReturnArgs} args - Arguments to create many RiskScores.
     * @example
     * // Create many RiskScores
     * const riskScore = await prisma.riskScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskScores and only return the `id`
     * const riskScoreWithIdOnly = await prisma.riskScore.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskScore.
     * @param {RiskScoreDeleteArgs} args - Arguments to delete one RiskScore.
     * @example
     * // Delete one RiskScore
     * const RiskScore = await prisma.riskScore.delete({
     *   where: {
     *     // ... filter to delete one RiskScore
     *   }
     * })
     * 
     */
    delete<T extends RiskScoreDeleteArgs>(args: SelectSubset<T, RiskScoreDeleteArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskScore.
     * @param {RiskScoreUpdateArgs} args - Arguments to update one RiskScore.
     * @example
     * // Update one RiskScore
     * const riskScore = await prisma.riskScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskScoreUpdateArgs>(args: SelectSubset<T, RiskScoreUpdateArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskScores.
     * @param {RiskScoreDeleteManyArgs} args - Arguments to filter RiskScores to delete.
     * @example
     * // Delete a few RiskScores
     * const { count } = await prisma.riskScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskScoreDeleteManyArgs>(args?: SelectSubset<T, RiskScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskScores
     * const riskScore = await prisma.riskScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskScoreUpdateManyArgs>(args: SelectSubset<T, RiskScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskScore.
     * @param {RiskScoreUpsertArgs} args - Arguments to update or create a RiskScore.
     * @example
     * // Update or create a RiskScore
     * const riskScore = await prisma.riskScore.upsert({
     *   create: {
     *     // ... data to create a RiskScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskScore we want to update
     *   }
     * })
     */
    upsert<T extends RiskScoreUpsertArgs>(args: SelectSubset<T, RiskScoreUpsertArgs<ExtArgs>>): Prisma__RiskScoreClient<$Result.GetResult<Prisma.$RiskScorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoreCountArgs} args - Arguments to filter RiskScores to count.
     * @example
     * // Count the number of RiskScores
     * const count = await prisma.riskScore.count({
     *   where: {
     *     // ... the filter for the RiskScores we want to count
     *   }
     * })
    **/
    count<T extends RiskScoreCountArgs>(
      args?: Subset<T, RiskScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskScoreAggregateArgs>(args: Subset<T, RiskScoreAggregateArgs>): Prisma.PrismaPromise<GetRiskScoreAggregateType<T>>

    /**
     * Group by RiskScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskScoreGroupByArgs['orderBy'] }
        : { orderBy?: RiskScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskScore model
   */
  readonly fields: RiskScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskScore model
   */ 
  interface RiskScoreFieldRefs {
    readonly id: FieldRef<"RiskScore", 'String'>
    readonly patientId: FieldRef<"RiskScore", 'String'>
    readonly fhirPatientRef: FieldRef<"RiskScore", 'String'>
    readonly modelName: FieldRef<"RiskScore", 'String'>
    readonly modelVersion: FieldRef<"RiskScore", 'String'>
    readonly scoreType: FieldRef<"RiskScore", 'ScoreType'>
    readonly rawScore: FieldRef<"RiskScore", 'Float'>
    readonly normalizedScore: FieldRef<"RiskScore", 'Float'>
    readonly percentile: FieldRef<"RiskScore", 'Int'>
    readonly riskTier: FieldRef<"RiskScore", 'RiskTier'>
    readonly riskFactors: FieldRef<"RiskScore", 'Json'>
    readonly clinicalFactors: FieldRef<"RiskScore", 'Json'>
    readonly socialFactors: FieldRef<"RiskScore", 'Json'>
    readonly predictedCost: FieldRef<"RiskScore", 'Float'>
    readonly predictedEvents: FieldRef<"RiskScore", 'Json'>
    readonly effectiveDate: FieldRef<"RiskScore", 'DateTime'>
    readonly expirationDate: FieldRef<"RiskScore", 'DateTime'>
    readonly isActive: FieldRef<"RiskScore", 'Boolean'>
    readonly createdAt: FieldRef<"RiskScore", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskScore findUnique
   */
  export type RiskScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * Filter, which RiskScore to fetch.
     */
    where: RiskScoreWhereUniqueInput
  }

  /**
   * RiskScore findUniqueOrThrow
   */
  export type RiskScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * Filter, which RiskScore to fetch.
     */
    where: RiskScoreWhereUniqueInput
  }

  /**
   * RiskScore findFirst
   */
  export type RiskScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * Filter, which RiskScore to fetch.
     */
    where?: RiskScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScores to fetch.
     */
    orderBy?: RiskScoreOrderByWithRelationInput | RiskScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskScores.
     */
    cursor?: RiskScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskScores.
     */
    distinct?: RiskScoreScalarFieldEnum | RiskScoreScalarFieldEnum[]
  }

  /**
   * RiskScore findFirstOrThrow
   */
  export type RiskScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * Filter, which RiskScore to fetch.
     */
    where?: RiskScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScores to fetch.
     */
    orderBy?: RiskScoreOrderByWithRelationInput | RiskScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskScores.
     */
    cursor?: RiskScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskScores.
     */
    distinct?: RiskScoreScalarFieldEnum | RiskScoreScalarFieldEnum[]
  }

  /**
   * RiskScore findMany
   */
  export type RiskScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * Filter, which RiskScores to fetch.
     */
    where?: RiskScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskScores to fetch.
     */
    orderBy?: RiskScoreOrderByWithRelationInput | RiskScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskScores.
     */
    cursor?: RiskScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskScores.
     */
    skip?: number
    distinct?: RiskScoreScalarFieldEnum | RiskScoreScalarFieldEnum[]
  }

  /**
   * RiskScore create
   */
  export type RiskScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * The data needed to create a RiskScore.
     */
    data: XOR<RiskScoreCreateInput, RiskScoreUncheckedCreateInput>
  }

  /**
   * RiskScore createMany
   */
  export type RiskScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskScores.
     */
    data: RiskScoreCreateManyInput | RiskScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskScore createManyAndReturn
   */
  export type RiskScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskScores.
     */
    data: RiskScoreCreateManyInput | RiskScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskScore update
   */
  export type RiskScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * The data needed to update a RiskScore.
     */
    data: XOR<RiskScoreUpdateInput, RiskScoreUncheckedUpdateInput>
    /**
     * Choose, which RiskScore to update.
     */
    where: RiskScoreWhereUniqueInput
  }

  /**
   * RiskScore updateMany
   */
  export type RiskScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskScores.
     */
    data: XOR<RiskScoreUpdateManyMutationInput, RiskScoreUncheckedUpdateManyInput>
    /**
     * Filter which RiskScores to update
     */
    where?: RiskScoreWhereInput
  }

  /**
   * RiskScore upsert
   */
  export type RiskScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * The filter to search for the RiskScore to update in case it exists.
     */
    where: RiskScoreWhereUniqueInput
    /**
     * In case the RiskScore found by the `where` argument doesn't exist, create a new RiskScore with this data.
     */
    create: XOR<RiskScoreCreateInput, RiskScoreUncheckedCreateInput>
    /**
     * In case the RiskScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskScoreUpdateInput, RiskScoreUncheckedUpdateInput>
  }

  /**
   * RiskScore delete
   */
  export type RiskScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
    /**
     * Filter which RiskScore to delete.
     */
    where: RiskScoreWhereUniqueInput
  }

  /**
   * RiskScore deleteMany
   */
  export type RiskScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskScores to delete
     */
    where?: RiskScoreWhereInput
  }

  /**
   * RiskScore without action
   */
  export type RiskScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskScore
     */
    select?: RiskScoreSelect<ExtArgs> | null
  }


  /**
   * Model CareGap
   */

  export type AggregateCareGap = {
    _count: CareGapCountAggregateOutputType | null
    _min: CareGapMinAggregateOutputType | null
    _max: CareGapMaxAggregateOutputType | null
  }

  export type CareGapMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    fhirPatientRef: string | null
    cohortId: string | null
    gapType: $Enums.GapType | null
    title: string | null
    description: string | null
    priority: $Enums.GapPriority | null
    qualityMeasureId: string | null
    recommendedAction: string | null
    actionDueDate: Date | null
    status: $Enums.GapStatus | null
    identifiedAt: Date | null
    resolvedAt: Date | null
    resolvedBy: string | null
    resolutionNotes: string | null
    fhirConditionRef: string | null
    fhirProcedureRef: string | null
    fhirMedicationRef: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareGapMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    fhirPatientRef: string | null
    cohortId: string | null
    gapType: $Enums.GapType | null
    title: string | null
    description: string | null
    priority: $Enums.GapPriority | null
    qualityMeasureId: string | null
    recommendedAction: string | null
    actionDueDate: Date | null
    status: $Enums.GapStatus | null
    identifiedAt: Date | null
    resolvedAt: Date | null
    resolvedBy: string | null
    resolutionNotes: string | null
    fhirConditionRef: string | null
    fhirProcedureRef: string | null
    fhirMedicationRef: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareGapCountAggregateOutputType = {
    id: number
    patientId: number
    fhirPatientRef: number
    cohortId: number
    gapType: number
    title: number
    description: number
    priority: number
    qualityMeasureId: number
    recommendedAction: number
    actionDueDate: number
    status: number
    identifiedAt: number
    resolvedAt: number
    resolvedBy: number
    resolutionNotes: number
    fhirConditionRef: number
    fhirProcedureRef: number
    fhirMedicationRef: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CareGapMinAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    cohortId?: true
    gapType?: true
    title?: true
    description?: true
    priority?: true
    qualityMeasureId?: true
    recommendedAction?: true
    actionDueDate?: true
    status?: true
    identifiedAt?: true
    resolvedAt?: true
    resolvedBy?: true
    resolutionNotes?: true
    fhirConditionRef?: true
    fhirProcedureRef?: true
    fhirMedicationRef?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareGapMaxAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    cohortId?: true
    gapType?: true
    title?: true
    description?: true
    priority?: true
    qualityMeasureId?: true
    recommendedAction?: true
    actionDueDate?: true
    status?: true
    identifiedAt?: true
    resolvedAt?: true
    resolvedBy?: true
    resolutionNotes?: true
    fhirConditionRef?: true
    fhirProcedureRef?: true
    fhirMedicationRef?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareGapCountAggregateInputType = {
    id?: true
    patientId?: true
    fhirPatientRef?: true
    cohortId?: true
    gapType?: true
    title?: true
    description?: true
    priority?: true
    qualityMeasureId?: true
    recommendedAction?: true
    actionDueDate?: true
    status?: true
    identifiedAt?: true
    resolvedAt?: true
    resolvedBy?: true
    resolutionNotes?: true
    fhirConditionRef?: true
    fhirProcedureRef?: true
    fhirMedicationRef?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CareGapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareGap to aggregate.
     */
    where?: CareGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareGaps to fetch.
     */
    orderBy?: CareGapOrderByWithRelationInput | CareGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareGaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CareGaps
    **/
    _count?: true | CareGapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareGapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareGapMaxAggregateInputType
  }

  export type GetCareGapAggregateType<T extends CareGapAggregateArgs> = {
        [P in keyof T & keyof AggregateCareGap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareGap[P]>
      : GetScalarType<T[P], AggregateCareGap[P]>
  }




  export type CareGapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareGapWhereInput
    orderBy?: CareGapOrderByWithAggregationInput | CareGapOrderByWithAggregationInput[]
    by: CareGapScalarFieldEnum[] | CareGapScalarFieldEnum
    having?: CareGapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareGapCountAggregateInputType | true
    _min?: CareGapMinAggregateInputType
    _max?: CareGapMaxAggregateInputType
  }

  export type CareGapGroupByOutputType = {
    id: string
    patientId: string
    fhirPatientRef: string | null
    cohortId: string | null
    gapType: $Enums.GapType
    title: string
    description: string | null
    priority: $Enums.GapPriority
    qualityMeasureId: string | null
    recommendedAction: string | null
    actionDueDate: Date | null
    status: $Enums.GapStatus
    identifiedAt: Date
    resolvedAt: Date | null
    resolvedBy: string | null
    resolutionNotes: string | null
    fhirConditionRef: string | null
    fhirProcedureRef: string | null
    fhirMedicationRef: string | null
    createdAt: Date
    updatedAt: Date
    _count: CareGapCountAggregateOutputType | null
    _min: CareGapMinAggregateOutputType | null
    _max: CareGapMaxAggregateOutputType | null
  }

  type GetCareGapGroupByPayload<T extends CareGapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareGapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareGapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareGapGroupByOutputType[P]>
            : GetScalarType<T[P], CareGapGroupByOutputType[P]>
        }
      >
    >


  export type CareGapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    cohortId?: boolean
    gapType?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    qualityMeasureId?: boolean
    recommendedAction?: boolean
    actionDueDate?: boolean
    status?: boolean
    identifiedAt?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    resolutionNotes?: boolean
    fhirConditionRef?: boolean
    fhirProcedureRef?: boolean
    fhirMedicationRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cohort?: boolean | CareGap$cohortArgs<ExtArgs>
  }, ExtArgs["result"]["careGap"]>

  export type CareGapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    cohortId?: boolean
    gapType?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    qualityMeasureId?: boolean
    recommendedAction?: boolean
    actionDueDate?: boolean
    status?: boolean
    identifiedAt?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    resolutionNotes?: boolean
    fhirConditionRef?: boolean
    fhirProcedureRef?: boolean
    fhirMedicationRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cohort?: boolean | CareGap$cohortArgs<ExtArgs>
  }, ExtArgs["result"]["careGap"]>

  export type CareGapSelectScalar = {
    id?: boolean
    patientId?: boolean
    fhirPatientRef?: boolean
    cohortId?: boolean
    gapType?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    qualityMeasureId?: boolean
    recommendedAction?: boolean
    actionDueDate?: boolean
    status?: boolean
    identifiedAt?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    resolutionNotes?: boolean
    fhirConditionRef?: boolean
    fhirProcedureRef?: boolean
    fhirMedicationRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CareGapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cohort?: boolean | CareGap$cohortArgs<ExtArgs>
  }
  export type CareGapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cohort?: boolean | CareGap$cohortArgs<ExtArgs>
  }

  export type $CareGapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CareGap"
    objects: {
      cohort: Prisma.$CohortPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      fhirPatientRef: string | null
      cohortId: string | null
      gapType: $Enums.GapType
      title: string
      description: string | null
      priority: $Enums.GapPriority
      qualityMeasureId: string | null
      recommendedAction: string | null
      actionDueDate: Date | null
      status: $Enums.GapStatus
      identifiedAt: Date
      resolvedAt: Date | null
      resolvedBy: string | null
      resolutionNotes: string | null
      fhirConditionRef: string | null
      fhirProcedureRef: string | null
      fhirMedicationRef: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["careGap"]>
    composites: {}
  }

  type CareGapGetPayload<S extends boolean | null | undefined | CareGapDefaultArgs> = $Result.GetResult<Prisma.$CareGapPayload, S>

  type CareGapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CareGapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CareGapCountAggregateInputType | true
    }

  export interface CareGapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CareGap'], meta: { name: 'CareGap' } }
    /**
     * Find zero or one CareGap that matches the filter.
     * @param {CareGapFindUniqueArgs} args - Arguments to find a CareGap
     * @example
     * // Get one CareGap
     * const careGap = await prisma.careGap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareGapFindUniqueArgs>(args: SelectSubset<T, CareGapFindUniqueArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CareGap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CareGapFindUniqueOrThrowArgs} args - Arguments to find a CareGap
     * @example
     * // Get one CareGap
     * const careGap = await prisma.careGap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareGapFindUniqueOrThrowArgs>(args: SelectSubset<T, CareGapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CareGap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareGapFindFirstArgs} args - Arguments to find a CareGap
     * @example
     * // Get one CareGap
     * const careGap = await prisma.careGap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareGapFindFirstArgs>(args?: SelectSubset<T, CareGapFindFirstArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CareGap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareGapFindFirstOrThrowArgs} args - Arguments to find a CareGap
     * @example
     * // Get one CareGap
     * const careGap = await prisma.careGap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareGapFindFirstOrThrowArgs>(args?: SelectSubset<T, CareGapFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CareGaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareGapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareGaps
     * const careGaps = await prisma.careGap.findMany()
     * 
     * // Get first 10 CareGaps
     * const careGaps = await prisma.careGap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careGapWithIdOnly = await prisma.careGap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareGapFindManyArgs>(args?: SelectSubset<T, CareGapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CareGap.
     * @param {CareGapCreateArgs} args - Arguments to create a CareGap.
     * @example
     * // Create one CareGap
     * const CareGap = await prisma.careGap.create({
     *   data: {
     *     // ... data to create a CareGap
     *   }
     * })
     * 
     */
    create<T extends CareGapCreateArgs>(args: SelectSubset<T, CareGapCreateArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CareGaps.
     * @param {CareGapCreateManyArgs} args - Arguments to create many CareGaps.
     * @example
     * // Create many CareGaps
     * const careGap = await prisma.careGap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareGapCreateManyArgs>(args?: SelectSubset<T, CareGapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CareGaps and returns the data saved in the database.
     * @param {CareGapCreateManyAndReturnArgs} args - Arguments to create many CareGaps.
     * @example
     * // Create many CareGaps
     * const careGap = await prisma.careGap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CareGaps and only return the `id`
     * const careGapWithIdOnly = await prisma.careGap.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CareGapCreateManyAndReturnArgs>(args?: SelectSubset<T, CareGapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CareGap.
     * @param {CareGapDeleteArgs} args - Arguments to delete one CareGap.
     * @example
     * // Delete one CareGap
     * const CareGap = await prisma.careGap.delete({
     *   where: {
     *     // ... filter to delete one CareGap
     *   }
     * })
     * 
     */
    delete<T extends CareGapDeleteArgs>(args: SelectSubset<T, CareGapDeleteArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CareGap.
     * @param {CareGapUpdateArgs} args - Arguments to update one CareGap.
     * @example
     * // Update one CareGap
     * const careGap = await prisma.careGap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareGapUpdateArgs>(args: SelectSubset<T, CareGapUpdateArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CareGaps.
     * @param {CareGapDeleteManyArgs} args - Arguments to filter CareGaps to delete.
     * @example
     * // Delete a few CareGaps
     * const { count } = await prisma.careGap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareGapDeleteManyArgs>(args?: SelectSubset<T, CareGapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareGaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareGapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareGaps
     * const careGap = await prisma.careGap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareGapUpdateManyArgs>(args: SelectSubset<T, CareGapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CareGap.
     * @param {CareGapUpsertArgs} args - Arguments to update or create a CareGap.
     * @example
     * // Update or create a CareGap
     * const careGap = await prisma.careGap.upsert({
     *   create: {
     *     // ... data to create a CareGap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareGap we want to update
     *   }
     * })
     */
    upsert<T extends CareGapUpsertArgs>(args: SelectSubset<T, CareGapUpsertArgs<ExtArgs>>): Prisma__CareGapClient<$Result.GetResult<Prisma.$CareGapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CareGaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareGapCountArgs} args - Arguments to filter CareGaps to count.
     * @example
     * // Count the number of CareGaps
     * const count = await prisma.careGap.count({
     *   where: {
     *     // ... the filter for the CareGaps we want to count
     *   }
     * })
    **/
    count<T extends CareGapCountArgs>(
      args?: Subset<T, CareGapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareGapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareGap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareGapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareGapAggregateArgs>(args: Subset<T, CareGapAggregateArgs>): Prisma.PrismaPromise<GetCareGapAggregateType<T>>

    /**
     * Group by CareGap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareGapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareGapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareGapGroupByArgs['orderBy'] }
        : { orderBy?: CareGapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareGapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareGapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CareGap model
   */
  readonly fields: CareGapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CareGap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareGapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cohort<T extends CareGap$cohortArgs<ExtArgs> = {}>(args?: Subset<T, CareGap$cohortArgs<ExtArgs>>): Prisma__CohortClient<$Result.GetResult<Prisma.$CohortPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CareGap model
   */ 
  interface CareGapFieldRefs {
    readonly id: FieldRef<"CareGap", 'String'>
    readonly patientId: FieldRef<"CareGap", 'String'>
    readonly fhirPatientRef: FieldRef<"CareGap", 'String'>
    readonly cohortId: FieldRef<"CareGap", 'String'>
    readonly gapType: FieldRef<"CareGap", 'GapType'>
    readonly title: FieldRef<"CareGap", 'String'>
    readonly description: FieldRef<"CareGap", 'String'>
    readonly priority: FieldRef<"CareGap", 'GapPriority'>
    readonly qualityMeasureId: FieldRef<"CareGap", 'String'>
    readonly recommendedAction: FieldRef<"CareGap", 'String'>
    readonly actionDueDate: FieldRef<"CareGap", 'DateTime'>
    readonly status: FieldRef<"CareGap", 'GapStatus'>
    readonly identifiedAt: FieldRef<"CareGap", 'DateTime'>
    readonly resolvedAt: FieldRef<"CareGap", 'DateTime'>
    readonly resolvedBy: FieldRef<"CareGap", 'String'>
    readonly resolutionNotes: FieldRef<"CareGap", 'String'>
    readonly fhirConditionRef: FieldRef<"CareGap", 'String'>
    readonly fhirProcedureRef: FieldRef<"CareGap", 'String'>
    readonly fhirMedicationRef: FieldRef<"CareGap", 'String'>
    readonly createdAt: FieldRef<"CareGap", 'DateTime'>
    readonly updatedAt: FieldRef<"CareGap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CareGap findUnique
   */
  export type CareGapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * Filter, which CareGap to fetch.
     */
    where: CareGapWhereUniqueInput
  }

  /**
   * CareGap findUniqueOrThrow
   */
  export type CareGapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * Filter, which CareGap to fetch.
     */
    where: CareGapWhereUniqueInput
  }

  /**
   * CareGap findFirst
   */
  export type CareGapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * Filter, which CareGap to fetch.
     */
    where?: CareGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareGaps to fetch.
     */
    orderBy?: CareGapOrderByWithRelationInput | CareGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareGaps.
     */
    cursor?: CareGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareGaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareGaps.
     */
    distinct?: CareGapScalarFieldEnum | CareGapScalarFieldEnum[]
  }

  /**
   * CareGap findFirstOrThrow
   */
  export type CareGapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * Filter, which CareGap to fetch.
     */
    where?: CareGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareGaps to fetch.
     */
    orderBy?: CareGapOrderByWithRelationInput | CareGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareGaps.
     */
    cursor?: CareGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareGaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareGaps.
     */
    distinct?: CareGapScalarFieldEnum | CareGapScalarFieldEnum[]
  }

  /**
   * CareGap findMany
   */
  export type CareGapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * Filter, which CareGaps to fetch.
     */
    where?: CareGapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareGaps to fetch.
     */
    orderBy?: CareGapOrderByWithRelationInput | CareGapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CareGaps.
     */
    cursor?: CareGapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareGaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareGaps.
     */
    skip?: number
    distinct?: CareGapScalarFieldEnum | CareGapScalarFieldEnum[]
  }

  /**
   * CareGap create
   */
  export type CareGapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * The data needed to create a CareGap.
     */
    data: XOR<CareGapCreateInput, CareGapUncheckedCreateInput>
  }

  /**
   * CareGap createMany
   */
  export type CareGapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CareGaps.
     */
    data: CareGapCreateManyInput | CareGapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CareGap createManyAndReturn
   */
  export type CareGapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CareGaps.
     */
    data: CareGapCreateManyInput | CareGapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CareGap update
   */
  export type CareGapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * The data needed to update a CareGap.
     */
    data: XOR<CareGapUpdateInput, CareGapUncheckedUpdateInput>
    /**
     * Choose, which CareGap to update.
     */
    where: CareGapWhereUniqueInput
  }

  /**
   * CareGap updateMany
   */
  export type CareGapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CareGaps.
     */
    data: XOR<CareGapUpdateManyMutationInput, CareGapUncheckedUpdateManyInput>
    /**
     * Filter which CareGaps to update
     */
    where?: CareGapWhereInput
  }

  /**
   * CareGap upsert
   */
  export type CareGapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * The filter to search for the CareGap to update in case it exists.
     */
    where: CareGapWhereUniqueInput
    /**
     * In case the CareGap found by the `where` argument doesn't exist, create a new CareGap with this data.
     */
    create: XOR<CareGapCreateInput, CareGapUncheckedCreateInput>
    /**
     * In case the CareGap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareGapUpdateInput, CareGapUncheckedUpdateInput>
  }

  /**
   * CareGap delete
   */
  export type CareGapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
    /**
     * Filter which CareGap to delete.
     */
    where: CareGapWhereUniqueInput
  }

  /**
   * CareGap deleteMany
   */
  export type CareGapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareGaps to delete
     */
    where?: CareGapWhereInput
  }

  /**
   * CareGap.cohort
   */
  export type CareGap$cohortArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohort
     */
    select?: CohortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CohortInclude<ExtArgs> | null
    where?: CohortWhereInput
  }

  /**
   * CareGap without action
   */
  export type CareGapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareGap
     */
    select?: CareGapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareGapInclude<ExtArgs> | null
  }


  /**
   * Model SdohFactor
   */

  export type AggregateSdohFactor = {
    _count: SdohFactorCountAggregateOutputType | null
    _avg: SdohFactorAvgAggregateOutputType | null
    _sum: SdohFactorSumAggregateOutputType | null
    _min: SdohFactorMinAggregateOutputType | null
    _max: SdohFactorMaxAggregateOutputType | null
  }

  export type SdohFactorAvgAggregateOutputType = {
    screeningScore: number | null
  }

  export type SdohFactorSumAggregateOutputType = {
    screeningScore: number | null
  }

  export type SdohFactorMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    populationId: string | null
    fhirPatientRef: string | null
    category: $Enums.SdohCategory | null
    factor: string | null
    value: string | null
    severity: $Enums.SdohSeverity | null
    assessmentDate: Date | null
    assessmentTool: string | null
    screeningScore: number | null
    isPositiveScreen: boolean | null
    interventionNeeded: boolean | null
    interventionType: string | null
    interventionStatus: string | null
    referralMade: boolean | null
    referralDetails: string | null
    fhirObservationRef: string | null
    fhirConditionRef: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SdohFactorMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    populationId: string | null
    fhirPatientRef: string | null
    category: $Enums.SdohCategory | null
    factor: string | null
    value: string | null
    severity: $Enums.SdohSeverity | null
    assessmentDate: Date | null
    assessmentTool: string | null
    screeningScore: number | null
    isPositiveScreen: boolean | null
    interventionNeeded: boolean | null
    interventionType: string | null
    interventionStatus: string | null
    referralMade: boolean | null
    referralDetails: string | null
    fhirObservationRef: string | null
    fhirConditionRef: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SdohFactorCountAggregateOutputType = {
    id: number
    patientId: number
    populationId: number
    fhirPatientRef: number
    category: number
    factor: number
    value: number
    severity: number
    assessmentDate: number
    assessmentTool: number
    screeningScore: number
    isPositiveScreen: number
    interventionNeeded: number
    interventionType: number
    interventionStatus: number
    referralMade: number
    referralDetails: number
    fhirObservationRef: number
    fhirConditionRef: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SdohFactorAvgAggregateInputType = {
    screeningScore?: true
  }

  export type SdohFactorSumAggregateInputType = {
    screeningScore?: true
  }

  export type SdohFactorMinAggregateInputType = {
    id?: true
    patientId?: true
    populationId?: true
    fhirPatientRef?: true
    category?: true
    factor?: true
    value?: true
    severity?: true
    assessmentDate?: true
    assessmentTool?: true
    screeningScore?: true
    isPositiveScreen?: true
    interventionNeeded?: true
    interventionType?: true
    interventionStatus?: true
    referralMade?: true
    referralDetails?: true
    fhirObservationRef?: true
    fhirConditionRef?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SdohFactorMaxAggregateInputType = {
    id?: true
    patientId?: true
    populationId?: true
    fhirPatientRef?: true
    category?: true
    factor?: true
    value?: true
    severity?: true
    assessmentDate?: true
    assessmentTool?: true
    screeningScore?: true
    isPositiveScreen?: true
    interventionNeeded?: true
    interventionType?: true
    interventionStatus?: true
    referralMade?: true
    referralDetails?: true
    fhirObservationRef?: true
    fhirConditionRef?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SdohFactorCountAggregateInputType = {
    id?: true
    patientId?: true
    populationId?: true
    fhirPatientRef?: true
    category?: true
    factor?: true
    value?: true
    severity?: true
    assessmentDate?: true
    assessmentTool?: true
    screeningScore?: true
    isPositiveScreen?: true
    interventionNeeded?: true
    interventionType?: true
    interventionStatus?: true
    referralMade?: true
    referralDetails?: true
    fhirObservationRef?: true
    fhirConditionRef?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SdohFactorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SdohFactor to aggregate.
     */
    where?: SdohFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdohFactors to fetch.
     */
    orderBy?: SdohFactorOrderByWithRelationInput | SdohFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SdohFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdohFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdohFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SdohFactors
    **/
    _count?: true | SdohFactorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SdohFactorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SdohFactorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SdohFactorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SdohFactorMaxAggregateInputType
  }

  export type GetSdohFactorAggregateType<T extends SdohFactorAggregateArgs> = {
        [P in keyof T & keyof AggregateSdohFactor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSdohFactor[P]>
      : GetScalarType<T[P], AggregateSdohFactor[P]>
  }




  export type SdohFactorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SdohFactorWhereInput
    orderBy?: SdohFactorOrderByWithAggregationInput | SdohFactorOrderByWithAggregationInput[]
    by: SdohFactorScalarFieldEnum[] | SdohFactorScalarFieldEnum
    having?: SdohFactorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SdohFactorCountAggregateInputType | true
    _avg?: SdohFactorAvgAggregateInputType
    _sum?: SdohFactorSumAggregateInputType
    _min?: SdohFactorMinAggregateInputType
    _max?: SdohFactorMaxAggregateInputType
  }

  export type SdohFactorGroupByOutputType = {
    id: string
    patientId: string | null
    populationId: string | null
    fhirPatientRef: string | null
    category: $Enums.SdohCategory
    factor: string
    value: string | null
    severity: $Enums.SdohSeverity | null
    assessmentDate: Date
    assessmentTool: string | null
    screeningScore: number | null
    isPositiveScreen: boolean
    interventionNeeded: boolean
    interventionType: string | null
    interventionStatus: string | null
    referralMade: boolean
    referralDetails: string | null
    fhirObservationRef: string | null
    fhirConditionRef: string | null
    createdAt: Date
    updatedAt: Date
    _count: SdohFactorCountAggregateOutputType | null
    _avg: SdohFactorAvgAggregateOutputType | null
    _sum: SdohFactorSumAggregateOutputType | null
    _min: SdohFactorMinAggregateOutputType | null
    _max: SdohFactorMaxAggregateOutputType | null
  }

  type GetSdohFactorGroupByPayload<T extends SdohFactorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SdohFactorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SdohFactorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SdohFactorGroupByOutputType[P]>
            : GetScalarType<T[P], SdohFactorGroupByOutputType[P]>
        }
      >
    >


  export type SdohFactorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    populationId?: boolean
    fhirPatientRef?: boolean
    category?: boolean
    factor?: boolean
    value?: boolean
    severity?: boolean
    assessmentDate?: boolean
    assessmentTool?: boolean
    screeningScore?: boolean
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: boolean
    interventionStatus?: boolean
    referralMade?: boolean
    referralDetails?: boolean
    fhirObservationRef?: boolean
    fhirConditionRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    population?: boolean | SdohFactor$populationArgs<ExtArgs>
  }, ExtArgs["result"]["sdohFactor"]>

  export type SdohFactorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    populationId?: boolean
    fhirPatientRef?: boolean
    category?: boolean
    factor?: boolean
    value?: boolean
    severity?: boolean
    assessmentDate?: boolean
    assessmentTool?: boolean
    screeningScore?: boolean
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: boolean
    interventionStatus?: boolean
    referralMade?: boolean
    referralDetails?: boolean
    fhirObservationRef?: boolean
    fhirConditionRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    population?: boolean | SdohFactor$populationArgs<ExtArgs>
  }, ExtArgs["result"]["sdohFactor"]>

  export type SdohFactorSelectScalar = {
    id?: boolean
    patientId?: boolean
    populationId?: boolean
    fhirPatientRef?: boolean
    category?: boolean
    factor?: boolean
    value?: boolean
    severity?: boolean
    assessmentDate?: boolean
    assessmentTool?: boolean
    screeningScore?: boolean
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: boolean
    interventionStatus?: boolean
    referralMade?: boolean
    referralDetails?: boolean
    fhirObservationRef?: boolean
    fhirConditionRef?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SdohFactorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | SdohFactor$populationArgs<ExtArgs>
  }
  export type SdohFactorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | SdohFactor$populationArgs<ExtArgs>
  }

  export type $SdohFactorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SdohFactor"
    objects: {
      population: Prisma.$PopulationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      populationId: string | null
      fhirPatientRef: string | null
      category: $Enums.SdohCategory
      factor: string
      value: string | null
      severity: $Enums.SdohSeverity | null
      assessmentDate: Date
      assessmentTool: string | null
      screeningScore: number | null
      isPositiveScreen: boolean
      interventionNeeded: boolean
      interventionType: string | null
      interventionStatus: string | null
      referralMade: boolean
      referralDetails: string | null
      fhirObservationRef: string | null
      fhirConditionRef: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sdohFactor"]>
    composites: {}
  }

  type SdohFactorGetPayload<S extends boolean | null | undefined | SdohFactorDefaultArgs> = $Result.GetResult<Prisma.$SdohFactorPayload, S>

  type SdohFactorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SdohFactorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SdohFactorCountAggregateInputType | true
    }

  export interface SdohFactorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SdohFactor'], meta: { name: 'SdohFactor' } }
    /**
     * Find zero or one SdohFactor that matches the filter.
     * @param {SdohFactorFindUniqueArgs} args - Arguments to find a SdohFactor
     * @example
     * // Get one SdohFactor
     * const sdohFactor = await prisma.sdohFactor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SdohFactorFindUniqueArgs>(args: SelectSubset<T, SdohFactorFindUniqueArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SdohFactor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SdohFactorFindUniqueOrThrowArgs} args - Arguments to find a SdohFactor
     * @example
     * // Get one SdohFactor
     * const sdohFactor = await prisma.sdohFactor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SdohFactorFindUniqueOrThrowArgs>(args: SelectSubset<T, SdohFactorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SdohFactor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdohFactorFindFirstArgs} args - Arguments to find a SdohFactor
     * @example
     * // Get one SdohFactor
     * const sdohFactor = await prisma.sdohFactor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SdohFactorFindFirstArgs>(args?: SelectSubset<T, SdohFactorFindFirstArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SdohFactor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdohFactorFindFirstOrThrowArgs} args - Arguments to find a SdohFactor
     * @example
     * // Get one SdohFactor
     * const sdohFactor = await prisma.sdohFactor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SdohFactorFindFirstOrThrowArgs>(args?: SelectSubset<T, SdohFactorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SdohFactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdohFactorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SdohFactors
     * const sdohFactors = await prisma.sdohFactor.findMany()
     * 
     * // Get first 10 SdohFactors
     * const sdohFactors = await prisma.sdohFactor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sdohFactorWithIdOnly = await prisma.sdohFactor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SdohFactorFindManyArgs>(args?: SelectSubset<T, SdohFactorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SdohFactor.
     * @param {SdohFactorCreateArgs} args - Arguments to create a SdohFactor.
     * @example
     * // Create one SdohFactor
     * const SdohFactor = await prisma.sdohFactor.create({
     *   data: {
     *     // ... data to create a SdohFactor
     *   }
     * })
     * 
     */
    create<T extends SdohFactorCreateArgs>(args: SelectSubset<T, SdohFactorCreateArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SdohFactors.
     * @param {SdohFactorCreateManyArgs} args - Arguments to create many SdohFactors.
     * @example
     * // Create many SdohFactors
     * const sdohFactor = await prisma.sdohFactor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SdohFactorCreateManyArgs>(args?: SelectSubset<T, SdohFactorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SdohFactors and returns the data saved in the database.
     * @param {SdohFactorCreateManyAndReturnArgs} args - Arguments to create many SdohFactors.
     * @example
     * // Create many SdohFactors
     * const sdohFactor = await prisma.sdohFactor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SdohFactors and only return the `id`
     * const sdohFactorWithIdOnly = await prisma.sdohFactor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SdohFactorCreateManyAndReturnArgs>(args?: SelectSubset<T, SdohFactorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SdohFactor.
     * @param {SdohFactorDeleteArgs} args - Arguments to delete one SdohFactor.
     * @example
     * // Delete one SdohFactor
     * const SdohFactor = await prisma.sdohFactor.delete({
     *   where: {
     *     // ... filter to delete one SdohFactor
     *   }
     * })
     * 
     */
    delete<T extends SdohFactorDeleteArgs>(args: SelectSubset<T, SdohFactorDeleteArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SdohFactor.
     * @param {SdohFactorUpdateArgs} args - Arguments to update one SdohFactor.
     * @example
     * // Update one SdohFactor
     * const sdohFactor = await prisma.sdohFactor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SdohFactorUpdateArgs>(args: SelectSubset<T, SdohFactorUpdateArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SdohFactors.
     * @param {SdohFactorDeleteManyArgs} args - Arguments to filter SdohFactors to delete.
     * @example
     * // Delete a few SdohFactors
     * const { count } = await prisma.sdohFactor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SdohFactorDeleteManyArgs>(args?: SelectSubset<T, SdohFactorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SdohFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdohFactorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SdohFactors
     * const sdohFactor = await prisma.sdohFactor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SdohFactorUpdateManyArgs>(args: SelectSubset<T, SdohFactorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SdohFactor.
     * @param {SdohFactorUpsertArgs} args - Arguments to update or create a SdohFactor.
     * @example
     * // Update or create a SdohFactor
     * const sdohFactor = await prisma.sdohFactor.upsert({
     *   create: {
     *     // ... data to create a SdohFactor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SdohFactor we want to update
     *   }
     * })
     */
    upsert<T extends SdohFactorUpsertArgs>(args: SelectSubset<T, SdohFactorUpsertArgs<ExtArgs>>): Prisma__SdohFactorClient<$Result.GetResult<Prisma.$SdohFactorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SdohFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdohFactorCountArgs} args - Arguments to filter SdohFactors to count.
     * @example
     * // Count the number of SdohFactors
     * const count = await prisma.sdohFactor.count({
     *   where: {
     *     // ... the filter for the SdohFactors we want to count
     *   }
     * })
    **/
    count<T extends SdohFactorCountArgs>(
      args?: Subset<T, SdohFactorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SdohFactorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SdohFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdohFactorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SdohFactorAggregateArgs>(args: Subset<T, SdohFactorAggregateArgs>): Prisma.PrismaPromise<GetSdohFactorAggregateType<T>>

    /**
     * Group by SdohFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdohFactorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SdohFactorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SdohFactorGroupByArgs['orderBy'] }
        : { orderBy?: SdohFactorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SdohFactorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSdohFactorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SdohFactor model
   */
  readonly fields: SdohFactorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SdohFactor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SdohFactorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    population<T extends SdohFactor$populationArgs<ExtArgs> = {}>(args?: Subset<T, SdohFactor$populationArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SdohFactor model
   */ 
  interface SdohFactorFieldRefs {
    readonly id: FieldRef<"SdohFactor", 'String'>
    readonly patientId: FieldRef<"SdohFactor", 'String'>
    readonly populationId: FieldRef<"SdohFactor", 'String'>
    readonly fhirPatientRef: FieldRef<"SdohFactor", 'String'>
    readonly category: FieldRef<"SdohFactor", 'SdohCategory'>
    readonly factor: FieldRef<"SdohFactor", 'String'>
    readonly value: FieldRef<"SdohFactor", 'String'>
    readonly severity: FieldRef<"SdohFactor", 'SdohSeverity'>
    readonly assessmentDate: FieldRef<"SdohFactor", 'DateTime'>
    readonly assessmentTool: FieldRef<"SdohFactor", 'String'>
    readonly screeningScore: FieldRef<"SdohFactor", 'Float'>
    readonly isPositiveScreen: FieldRef<"SdohFactor", 'Boolean'>
    readonly interventionNeeded: FieldRef<"SdohFactor", 'Boolean'>
    readonly interventionType: FieldRef<"SdohFactor", 'String'>
    readonly interventionStatus: FieldRef<"SdohFactor", 'String'>
    readonly referralMade: FieldRef<"SdohFactor", 'Boolean'>
    readonly referralDetails: FieldRef<"SdohFactor", 'String'>
    readonly fhirObservationRef: FieldRef<"SdohFactor", 'String'>
    readonly fhirConditionRef: FieldRef<"SdohFactor", 'String'>
    readonly createdAt: FieldRef<"SdohFactor", 'DateTime'>
    readonly updatedAt: FieldRef<"SdohFactor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SdohFactor findUnique
   */
  export type SdohFactorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * Filter, which SdohFactor to fetch.
     */
    where: SdohFactorWhereUniqueInput
  }

  /**
   * SdohFactor findUniqueOrThrow
   */
  export type SdohFactorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * Filter, which SdohFactor to fetch.
     */
    where: SdohFactorWhereUniqueInput
  }

  /**
   * SdohFactor findFirst
   */
  export type SdohFactorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * Filter, which SdohFactor to fetch.
     */
    where?: SdohFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdohFactors to fetch.
     */
    orderBy?: SdohFactorOrderByWithRelationInput | SdohFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SdohFactors.
     */
    cursor?: SdohFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdohFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdohFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SdohFactors.
     */
    distinct?: SdohFactorScalarFieldEnum | SdohFactorScalarFieldEnum[]
  }

  /**
   * SdohFactor findFirstOrThrow
   */
  export type SdohFactorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * Filter, which SdohFactor to fetch.
     */
    where?: SdohFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdohFactors to fetch.
     */
    orderBy?: SdohFactorOrderByWithRelationInput | SdohFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SdohFactors.
     */
    cursor?: SdohFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdohFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdohFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SdohFactors.
     */
    distinct?: SdohFactorScalarFieldEnum | SdohFactorScalarFieldEnum[]
  }

  /**
   * SdohFactor findMany
   */
  export type SdohFactorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * Filter, which SdohFactors to fetch.
     */
    where?: SdohFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdohFactors to fetch.
     */
    orderBy?: SdohFactorOrderByWithRelationInput | SdohFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SdohFactors.
     */
    cursor?: SdohFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdohFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdohFactors.
     */
    skip?: number
    distinct?: SdohFactorScalarFieldEnum | SdohFactorScalarFieldEnum[]
  }

  /**
   * SdohFactor create
   */
  export type SdohFactorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * The data needed to create a SdohFactor.
     */
    data: XOR<SdohFactorCreateInput, SdohFactorUncheckedCreateInput>
  }

  /**
   * SdohFactor createMany
   */
  export type SdohFactorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SdohFactors.
     */
    data: SdohFactorCreateManyInput | SdohFactorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SdohFactor createManyAndReturn
   */
  export type SdohFactorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SdohFactors.
     */
    data: SdohFactorCreateManyInput | SdohFactorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SdohFactor update
   */
  export type SdohFactorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * The data needed to update a SdohFactor.
     */
    data: XOR<SdohFactorUpdateInput, SdohFactorUncheckedUpdateInput>
    /**
     * Choose, which SdohFactor to update.
     */
    where: SdohFactorWhereUniqueInput
  }

  /**
   * SdohFactor updateMany
   */
  export type SdohFactorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SdohFactors.
     */
    data: XOR<SdohFactorUpdateManyMutationInput, SdohFactorUncheckedUpdateManyInput>
    /**
     * Filter which SdohFactors to update
     */
    where?: SdohFactorWhereInput
  }

  /**
   * SdohFactor upsert
   */
  export type SdohFactorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * The filter to search for the SdohFactor to update in case it exists.
     */
    where: SdohFactorWhereUniqueInput
    /**
     * In case the SdohFactor found by the `where` argument doesn't exist, create a new SdohFactor with this data.
     */
    create: XOR<SdohFactorCreateInput, SdohFactorUncheckedCreateInput>
    /**
     * In case the SdohFactor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SdohFactorUpdateInput, SdohFactorUncheckedUpdateInput>
  }

  /**
   * SdohFactor delete
   */
  export type SdohFactorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
    /**
     * Filter which SdohFactor to delete.
     */
    where: SdohFactorWhereUniqueInput
  }

  /**
   * SdohFactor deleteMany
   */
  export type SdohFactorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SdohFactors to delete
     */
    where?: SdohFactorWhereInput
  }

  /**
   * SdohFactor.population
   */
  export type SdohFactor$populationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    where?: PopulationWhereInput
  }

  /**
   * SdohFactor without action
   */
  export type SdohFactorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdohFactor
     */
    select?: SdohFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdohFactorInclude<ExtArgs> | null
  }


  /**
   * Model DiseaseRegistry
   */

  export type AggregateDiseaseRegistry = {
    _count: DiseaseRegistryCountAggregateOutputType | null
    _avg: DiseaseRegistryAvgAggregateOutputType | null
    _sum: DiseaseRegistrySumAggregateOutputType | null
    _min: DiseaseRegistryMinAggregateOutputType | null
    _max: DiseaseRegistryMaxAggregateOutputType | null
  }

  export type DiseaseRegistryAvgAggregateOutputType = {
    prevalenceCount: number | null
    prevalenceRate: number | null
    incidenceCount: number | null
    incidenceRate: number | null
    previousPeriodPrevalence: number | null
  }

  export type DiseaseRegistrySumAggregateOutputType = {
    prevalenceCount: number | null
    prevalenceRate: number | null
    incidenceCount: number | null
    incidenceRate: number | null
    previousPeriodPrevalence: number | null
  }

  export type DiseaseRegistryMinAggregateOutputType = {
    id: string | null
    conditionCode: string | null
    conditionName: string | null
    populationId: string | null
    prevalenceCount: number | null
    prevalenceRate: number | null
    incidenceCount: number | null
    incidenceRate: number | null
    periodStart: Date | null
    periodEnd: Date | null
    previousPeriodPrevalence: number | null
    trendDirection: $Enums.TrendDirection | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiseaseRegistryMaxAggregateOutputType = {
    id: string | null
    conditionCode: string | null
    conditionName: string | null
    populationId: string | null
    prevalenceCount: number | null
    prevalenceRate: number | null
    incidenceCount: number | null
    incidenceRate: number | null
    periodStart: Date | null
    periodEnd: Date | null
    previousPeriodPrevalence: number | null
    trendDirection: $Enums.TrendDirection | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiseaseRegistryCountAggregateOutputType = {
    id: number
    conditionCode: number
    conditionName: number
    populationId: number
    prevalenceCount: number
    prevalenceRate: number
    incidenceCount: number
    incidenceRate: number
    periodStart: number
    periodEnd: number
    ageDistribution: number
    genderDistribution: number
    raceDistribution: number
    previousPeriodPrevalence: number
    trendDirection: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiseaseRegistryAvgAggregateInputType = {
    prevalenceCount?: true
    prevalenceRate?: true
    incidenceCount?: true
    incidenceRate?: true
    previousPeriodPrevalence?: true
  }

  export type DiseaseRegistrySumAggregateInputType = {
    prevalenceCount?: true
    prevalenceRate?: true
    incidenceCount?: true
    incidenceRate?: true
    previousPeriodPrevalence?: true
  }

  export type DiseaseRegistryMinAggregateInputType = {
    id?: true
    conditionCode?: true
    conditionName?: true
    populationId?: true
    prevalenceCount?: true
    prevalenceRate?: true
    incidenceCount?: true
    incidenceRate?: true
    periodStart?: true
    periodEnd?: true
    previousPeriodPrevalence?: true
    trendDirection?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiseaseRegistryMaxAggregateInputType = {
    id?: true
    conditionCode?: true
    conditionName?: true
    populationId?: true
    prevalenceCount?: true
    prevalenceRate?: true
    incidenceCount?: true
    incidenceRate?: true
    periodStart?: true
    periodEnd?: true
    previousPeriodPrevalence?: true
    trendDirection?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiseaseRegistryCountAggregateInputType = {
    id?: true
    conditionCode?: true
    conditionName?: true
    populationId?: true
    prevalenceCount?: true
    prevalenceRate?: true
    incidenceCount?: true
    incidenceRate?: true
    periodStart?: true
    periodEnd?: true
    ageDistribution?: true
    genderDistribution?: true
    raceDistribution?: true
    previousPeriodPrevalence?: true
    trendDirection?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiseaseRegistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiseaseRegistry to aggregate.
     */
    where?: DiseaseRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiseaseRegistries to fetch.
     */
    orderBy?: DiseaseRegistryOrderByWithRelationInput | DiseaseRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiseaseRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiseaseRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiseaseRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiseaseRegistries
    **/
    _count?: true | DiseaseRegistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiseaseRegistryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiseaseRegistrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiseaseRegistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiseaseRegistryMaxAggregateInputType
  }

  export type GetDiseaseRegistryAggregateType<T extends DiseaseRegistryAggregateArgs> = {
        [P in keyof T & keyof AggregateDiseaseRegistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiseaseRegistry[P]>
      : GetScalarType<T[P], AggregateDiseaseRegistry[P]>
  }




  export type DiseaseRegistryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiseaseRegistryWhereInput
    orderBy?: DiseaseRegistryOrderByWithAggregationInput | DiseaseRegistryOrderByWithAggregationInput[]
    by: DiseaseRegistryScalarFieldEnum[] | DiseaseRegistryScalarFieldEnum
    having?: DiseaseRegistryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiseaseRegistryCountAggregateInputType | true
    _avg?: DiseaseRegistryAvgAggregateInputType
    _sum?: DiseaseRegistrySumAggregateInputType
    _min?: DiseaseRegistryMinAggregateInputType
    _max?: DiseaseRegistryMaxAggregateInputType
  }

  export type DiseaseRegistryGroupByOutputType = {
    id: string
    conditionCode: string
    conditionName: string
    populationId: string | null
    prevalenceCount: number
    prevalenceRate: number | null
    incidenceCount: number
    incidenceRate: number | null
    periodStart: Date
    periodEnd: Date
    ageDistribution: JsonValue | null
    genderDistribution: JsonValue | null
    raceDistribution: JsonValue | null
    previousPeriodPrevalence: number | null
    trendDirection: $Enums.TrendDirection | null
    createdAt: Date
    updatedAt: Date
    _count: DiseaseRegistryCountAggregateOutputType | null
    _avg: DiseaseRegistryAvgAggregateOutputType | null
    _sum: DiseaseRegistrySumAggregateOutputType | null
    _min: DiseaseRegistryMinAggregateOutputType | null
    _max: DiseaseRegistryMaxAggregateOutputType | null
  }

  type GetDiseaseRegistryGroupByPayload<T extends DiseaseRegistryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiseaseRegistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiseaseRegistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiseaseRegistryGroupByOutputType[P]>
            : GetScalarType<T[P], DiseaseRegistryGroupByOutputType[P]>
        }
      >
    >


  export type DiseaseRegistrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionCode?: boolean
    conditionName?: boolean
    populationId?: boolean
    prevalenceCount?: boolean
    prevalenceRate?: boolean
    incidenceCount?: boolean
    incidenceRate?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    ageDistribution?: boolean
    genderDistribution?: boolean
    raceDistribution?: boolean
    previousPeriodPrevalence?: boolean
    trendDirection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["diseaseRegistry"]>

  export type DiseaseRegistrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conditionCode?: boolean
    conditionName?: boolean
    populationId?: boolean
    prevalenceCount?: boolean
    prevalenceRate?: boolean
    incidenceCount?: boolean
    incidenceRate?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    ageDistribution?: boolean
    genderDistribution?: boolean
    raceDistribution?: boolean
    previousPeriodPrevalence?: boolean
    trendDirection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["diseaseRegistry"]>

  export type DiseaseRegistrySelectScalar = {
    id?: boolean
    conditionCode?: boolean
    conditionName?: boolean
    populationId?: boolean
    prevalenceCount?: boolean
    prevalenceRate?: boolean
    incidenceCount?: boolean
    incidenceRate?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    ageDistribution?: boolean
    genderDistribution?: boolean
    raceDistribution?: boolean
    previousPeriodPrevalence?: boolean
    trendDirection?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DiseaseRegistryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiseaseRegistry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conditionCode: string
      conditionName: string
      populationId: string | null
      prevalenceCount: number
      prevalenceRate: number | null
      incidenceCount: number
      incidenceRate: number | null
      periodStart: Date
      periodEnd: Date
      ageDistribution: Prisma.JsonValue | null
      genderDistribution: Prisma.JsonValue | null
      raceDistribution: Prisma.JsonValue | null
      previousPeriodPrevalence: number | null
      trendDirection: $Enums.TrendDirection | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["diseaseRegistry"]>
    composites: {}
  }

  type DiseaseRegistryGetPayload<S extends boolean | null | undefined | DiseaseRegistryDefaultArgs> = $Result.GetResult<Prisma.$DiseaseRegistryPayload, S>

  type DiseaseRegistryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiseaseRegistryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiseaseRegistryCountAggregateInputType | true
    }

  export interface DiseaseRegistryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiseaseRegistry'], meta: { name: 'DiseaseRegistry' } }
    /**
     * Find zero or one DiseaseRegistry that matches the filter.
     * @param {DiseaseRegistryFindUniqueArgs} args - Arguments to find a DiseaseRegistry
     * @example
     * // Get one DiseaseRegistry
     * const diseaseRegistry = await prisma.diseaseRegistry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiseaseRegistryFindUniqueArgs>(args: SelectSubset<T, DiseaseRegistryFindUniqueArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DiseaseRegistry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiseaseRegistryFindUniqueOrThrowArgs} args - Arguments to find a DiseaseRegistry
     * @example
     * // Get one DiseaseRegistry
     * const diseaseRegistry = await prisma.diseaseRegistry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiseaseRegistryFindUniqueOrThrowArgs>(args: SelectSubset<T, DiseaseRegistryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DiseaseRegistry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseRegistryFindFirstArgs} args - Arguments to find a DiseaseRegistry
     * @example
     * // Get one DiseaseRegistry
     * const diseaseRegistry = await prisma.diseaseRegistry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiseaseRegistryFindFirstArgs>(args?: SelectSubset<T, DiseaseRegistryFindFirstArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DiseaseRegistry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseRegistryFindFirstOrThrowArgs} args - Arguments to find a DiseaseRegistry
     * @example
     * // Get one DiseaseRegistry
     * const diseaseRegistry = await prisma.diseaseRegistry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiseaseRegistryFindFirstOrThrowArgs>(args?: SelectSubset<T, DiseaseRegistryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DiseaseRegistries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseRegistryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiseaseRegistries
     * const diseaseRegistries = await prisma.diseaseRegistry.findMany()
     * 
     * // Get first 10 DiseaseRegistries
     * const diseaseRegistries = await prisma.diseaseRegistry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diseaseRegistryWithIdOnly = await prisma.diseaseRegistry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiseaseRegistryFindManyArgs>(args?: SelectSubset<T, DiseaseRegistryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DiseaseRegistry.
     * @param {DiseaseRegistryCreateArgs} args - Arguments to create a DiseaseRegistry.
     * @example
     * // Create one DiseaseRegistry
     * const DiseaseRegistry = await prisma.diseaseRegistry.create({
     *   data: {
     *     // ... data to create a DiseaseRegistry
     *   }
     * })
     * 
     */
    create<T extends DiseaseRegistryCreateArgs>(args: SelectSubset<T, DiseaseRegistryCreateArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DiseaseRegistries.
     * @param {DiseaseRegistryCreateManyArgs} args - Arguments to create many DiseaseRegistries.
     * @example
     * // Create many DiseaseRegistries
     * const diseaseRegistry = await prisma.diseaseRegistry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiseaseRegistryCreateManyArgs>(args?: SelectSubset<T, DiseaseRegistryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiseaseRegistries and returns the data saved in the database.
     * @param {DiseaseRegistryCreateManyAndReturnArgs} args - Arguments to create many DiseaseRegistries.
     * @example
     * // Create many DiseaseRegistries
     * const diseaseRegistry = await prisma.diseaseRegistry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiseaseRegistries and only return the `id`
     * const diseaseRegistryWithIdOnly = await prisma.diseaseRegistry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiseaseRegistryCreateManyAndReturnArgs>(args?: SelectSubset<T, DiseaseRegistryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DiseaseRegistry.
     * @param {DiseaseRegistryDeleteArgs} args - Arguments to delete one DiseaseRegistry.
     * @example
     * // Delete one DiseaseRegistry
     * const DiseaseRegistry = await prisma.diseaseRegistry.delete({
     *   where: {
     *     // ... filter to delete one DiseaseRegistry
     *   }
     * })
     * 
     */
    delete<T extends DiseaseRegistryDeleteArgs>(args: SelectSubset<T, DiseaseRegistryDeleteArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DiseaseRegistry.
     * @param {DiseaseRegistryUpdateArgs} args - Arguments to update one DiseaseRegistry.
     * @example
     * // Update one DiseaseRegistry
     * const diseaseRegistry = await prisma.diseaseRegistry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiseaseRegistryUpdateArgs>(args: SelectSubset<T, DiseaseRegistryUpdateArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DiseaseRegistries.
     * @param {DiseaseRegistryDeleteManyArgs} args - Arguments to filter DiseaseRegistries to delete.
     * @example
     * // Delete a few DiseaseRegistries
     * const { count } = await prisma.diseaseRegistry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiseaseRegistryDeleteManyArgs>(args?: SelectSubset<T, DiseaseRegistryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiseaseRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseRegistryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiseaseRegistries
     * const diseaseRegistry = await prisma.diseaseRegistry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiseaseRegistryUpdateManyArgs>(args: SelectSubset<T, DiseaseRegistryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiseaseRegistry.
     * @param {DiseaseRegistryUpsertArgs} args - Arguments to update or create a DiseaseRegistry.
     * @example
     * // Update or create a DiseaseRegistry
     * const diseaseRegistry = await prisma.diseaseRegistry.upsert({
     *   create: {
     *     // ... data to create a DiseaseRegistry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiseaseRegistry we want to update
     *   }
     * })
     */
    upsert<T extends DiseaseRegistryUpsertArgs>(args: SelectSubset<T, DiseaseRegistryUpsertArgs<ExtArgs>>): Prisma__DiseaseRegistryClient<$Result.GetResult<Prisma.$DiseaseRegistryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DiseaseRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseRegistryCountArgs} args - Arguments to filter DiseaseRegistries to count.
     * @example
     * // Count the number of DiseaseRegistries
     * const count = await prisma.diseaseRegistry.count({
     *   where: {
     *     // ... the filter for the DiseaseRegistries we want to count
     *   }
     * })
    **/
    count<T extends DiseaseRegistryCountArgs>(
      args?: Subset<T, DiseaseRegistryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiseaseRegistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiseaseRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseRegistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiseaseRegistryAggregateArgs>(args: Subset<T, DiseaseRegistryAggregateArgs>): Prisma.PrismaPromise<GetDiseaseRegistryAggregateType<T>>

    /**
     * Group by DiseaseRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseRegistryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiseaseRegistryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiseaseRegistryGroupByArgs['orderBy'] }
        : { orderBy?: DiseaseRegistryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiseaseRegistryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiseaseRegistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiseaseRegistry model
   */
  readonly fields: DiseaseRegistryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiseaseRegistry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiseaseRegistryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiseaseRegistry model
   */ 
  interface DiseaseRegistryFieldRefs {
    readonly id: FieldRef<"DiseaseRegistry", 'String'>
    readonly conditionCode: FieldRef<"DiseaseRegistry", 'String'>
    readonly conditionName: FieldRef<"DiseaseRegistry", 'String'>
    readonly populationId: FieldRef<"DiseaseRegistry", 'String'>
    readonly prevalenceCount: FieldRef<"DiseaseRegistry", 'Int'>
    readonly prevalenceRate: FieldRef<"DiseaseRegistry", 'Float'>
    readonly incidenceCount: FieldRef<"DiseaseRegistry", 'Int'>
    readonly incidenceRate: FieldRef<"DiseaseRegistry", 'Float'>
    readonly periodStart: FieldRef<"DiseaseRegistry", 'DateTime'>
    readonly periodEnd: FieldRef<"DiseaseRegistry", 'DateTime'>
    readonly ageDistribution: FieldRef<"DiseaseRegistry", 'Json'>
    readonly genderDistribution: FieldRef<"DiseaseRegistry", 'Json'>
    readonly raceDistribution: FieldRef<"DiseaseRegistry", 'Json'>
    readonly previousPeriodPrevalence: FieldRef<"DiseaseRegistry", 'Float'>
    readonly trendDirection: FieldRef<"DiseaseRegistry", 'TrendDirection'>
    readonly createdAt: FieldRef<"DiseaseRegistry", 'DateTime'>
    readonly updatedAt: FieldRef<"DiseaseRegistry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiseaseRegistry findUnique
   */
  export type DiseaseRegistryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * Filter, which DiseaseRegistry to fetch.
     */
    where: DiseaseRegistryWhereUniqueInput
  }

  /**
   * DiseaseRegistry findUniqueOrThrow
   */
  export type DiseaseRegistryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * Filter, which DiseaseRegistry to fetch.
     */
    where: DiseaseRegistryWhereUniqueInput
  }

  /**
   * DiseaseRegistry findFirst
   */
  export type DiseaseRegistryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * Filter, which DiseaseRegistry to fetch.
     */
    where?: DiseaseRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiseaseRegistries to fetch.
     */
    orderBy?: DiseaseRegistryOrderByWithRelationInput | DiseaseRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiseaseRegistries.
     */
    cursor?: DiseaseRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiseaseRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiseaseRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiseaseRegistries.
     */
    distinct?: DiseaseRegistryScalarFieldEnum | DiseaseRegistryScalarFieldEnum[]
  }

  /**
   * DiseaseRegistry findFirstOrThrow
   */
  export type DiseaseRegistryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * Filter, which DiseaseRegistry to fetch.
     */
    where?: DiseaseRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiseaseRegistries to fetch.
     */
    orderBy?: DiseaseRegistryOrderByWithRelationInput | DiseaseRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiseaseRegistries.
     */
    cursor?: DiseaseRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiseaseRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiseaseRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiseaseRegistries.
     */
    distinct?: DiseaseRegistryScalarFieldEnum | DiseaseRegistryScalarFieldEnum[]
  }

  /**
   * DiseaseRegistry findMany
   */
  export type DiseaseRegistryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * Filter, which DiseaseRegistries to fetch.
     */
    where?: DiseaseRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiseaseRegistries to fetch.
     */
    orderBy?: DiseaseRegistryOrderByWithRelationInput | DiseaseRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiseaseRegistries.
     */
    cursor?: DiseaseRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiseaseRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiseaseRegistries.
     */
    skip?: number
    distinct?: DiseaseRegistryScalarFieldEnum | DiseaseRegistryScalarFieldEnum[]
  }

  /**
   * DiseaseRegistry create
   */
  export type DiseaseRegistryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * The data needed to create a DiseaseRegistry.
     */
    data: XOR<DiseaseRegistryCreateInput, DiseaseRegistryUncheckedCreateInput>
  }

  /**
   * DiseaseRegistry createMany
   */
  export type DiseaseRegistryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiseaseRegistries.
     */
    data: DiseaseRegistryCreateManyInput | DiseaseRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiseaseRegistry createManyAndReturn
   */
  export type DiseaseRegistryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DiseaseRegistries.
     */
    data: DiseaseRegistryCreateManyInput | DiseaseRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiseaseRegistry update
   */
  export type DiseaseRegistryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * The data needed to update a DiseaseRegistry.
     */
    data: XOR<DiseaseRegistryUpdateInput, DiseaseRegistryUncheckedUpdateInput>
    /**
     * Choose, which DiseaseRegistry to update.
     */
    where: DiseaseRegistryWhereUniqueInput
  }

  /**
   * DiseaseRegistry updateMany
   */
  export type DiseaseRegistryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiseaseRegistries.
     */
    data: XOR<DiseaseRegistryUpdateManyMutationInput, DiseaseRegistryUncheckedUpdateManyInput>
    /**
     * Filter which DiseaseRegistries to update
     */
    where?: DiseaseRegistryWhereInput
  }

  /**
   * DiseaseRegistry upsert
   */
  export type DiseaseRegistryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * The filter to search for the DiseaseRegistry to update in case it exists.
     */
    where: DiseaseRegistryWhereUniqueInput
    /**
     * In case the DiseaseRegistry found by the `where` argument doesn't exist, create a new DiseaseRegistry with this data.
     */
    create: XOR<DiseaseRegistryCreateInput, DiseaseRegistryUncheckedCreateInput>
    /**
     * In case the DiseaseRegistry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiseaseRegistryUpdateInput, DiseaseRegistryUncheckedUpdateInput>
  }

  /**
   * DiseaseRegistry delete
   */
  export type DiseaseRegistryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
    /**
     * Filter which DiseaseRegistry to delete.
     */
    where: DiseaseRegistryWhereUniqueInput
  }

  /**
   * DiseaseRegistry deleteMany
   */
  export type DiseaseRegistryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiseaseRegistries to delete
     */
    where?: DiseaseRegistryWhereInput
  }

  /**
   * DiseaseRegistry without action
   */
  export type DiseaseRegistryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseRegistry
     */
    select?: DiseaseRegistrySelect<ExtArgs> | null
  }


  /**
   * Model HealthEquityMetric
   */

  export type AggregateHealthEquityMetric = {
    _count: HealthEquityMetricCountAggregateOutputType | null
    _avg: HealthEquityMetricAvgAggregateOutputType | null
    _sum: HealthEquityMetricSumAggregateOutputType | null
    _min: HealthEquityMetricMinAggregateOutputType | null
    _max: HealthEquityMetricMaxAggregateOutputType | null
  }

  export type HealthEquityMetricAvgAggregateOutputType = {
    metricValue: number | null
    referenceValue: number | null
    disparityIndex: number | null
    pValue: number | null
    sampleSize: number | null
  }

  export type HealthEquityMetricSumAggregateOutputType = {
    metricValue: number | null
    referenceValue: number | null
    disparityIndex: number | null
    pValue: number | null
    sampleSize: number | null
  }

  export type HealthEquityMetricMinAggregateOutputType = {
    id: string | null
    populationId: string | null
    measureType: $Enums.EquityMeasureType | null
    stratificationDimension: string | null
    stratificationValue: string | null
    metricName: string | null
    metricValue: number | null
    referenceValue: number | null
    disparityIndex: number | null
    pValue: number | null
    sampleSize: number | null
    measurePeriod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthEquityMetricMaxAggregateOutputType = {
    id: string | null
    populationId: string | null
    measureType: $Enums.EquityMeasureType | null
    stratificationDimension: string | null
    stratificationValue: string | null
    metricName: string | null
    metricValue: number | null
    referenceValue: number | null
    disparityIndex: number | null
    pValue: number | null
    sampleSize: number | null
    measurePeriod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthEquityMetricCountAggregateOutputType = {
    id: number
    populationId: number
    measureType: number
    stratificationDimension: number
    stratificationValue: number
    metricName: number
    metricValue: number
    referenceValue: number
    disparityIndex: number
    confidenceInterval: number
    pValue: number
    sampleSize: number
    measurePeriod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthEquityMetricAvgAggregateInputType = {
    metricValue?: true
    referenceValue?: true
    disparityIndex?: true
    pValue?: true
    sampleSize?: true
  }

  export type HealthEquityMetricSumAggregateInputType = {
    metricValue?: true
    referenceValue?: true
    disparityIndex?: true
    pValue?: true
    sampleSize?: true
  }

  export type HealthEquityMetricMinAggregateInputType = {
    id?: true
    populationId?: true
    measureType?: true
    stratificationDimension?: true
    stratificationValue?: true
    metricName?: true
    metricValue?: true
    referenceValue?: true
    disparityIndex?: true
    pValue?: true
    sampleSize?: true
    measurePeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthEquityMetricMaxAggregateInputType = {
    id?: true
    populationId?: true
    measureType?: true
    stratificationDimension?: true
    stratificationValue?: true
    metricName?: true
    metricValue?: true
    referenceValue?: true
    disparityIndex?: true
    pValue?: true
    sampleSize?: true
    measurePeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthEquityMetricCountAggregateInputType = {
    id?: true
    populationId?: true
    measureType?: true
    stratificationDimension?: true
    stratificationValue?: true
    metricName?: true
    metricValue?: true
    referenceValue?: true
    disparityIndex?: true
    confidenceInterval?: true
    pValue?: true
    sampleSize?: true
    measurePeriod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthEquityMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthEquityMetric to aggregate.
     */
    where?: HealthEquityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEquityMetrics to fetch.
     */
    orderBy?: HealthEquityMetricOrderByWithRelationInput | HealthEquityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthEquityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEquityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEquityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthEquityMetrics
    **/
    _count?: true | HealthEquityMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthEquityMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthEquityMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthEquityMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthEquityMetricMaxAggregateInputType
  }

  export type GetHealthEquityMetricAggregateType<T extends HealthEquityMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthEquityMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthEquityMetric[P]>
      : GetScalarType<T[P], AggregateHealthEquityMetric[P]>
  }




  export type HealthEquityMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthEquityMetricWhereInput
    orderBy?: HealthEquityMetricOrderByWithAggregationInput | HealthEquityMetricOrderByWithAggregationInput[]
    by: HealthEquityMetricScalarFieldEnum[] | HealthEquityMetricScalarFieldEnum
    having?: HealthEquityMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthEquityMetricCountAggregateInputType | true
    _avg?: HealthEquityMetricAvgAggregateInputType
    _sum?: HealthEquityMetricSumAggregateInputType
    _min?: HealthEquityMetricMinAggregateInputType
    _max?: HealthEquityMetricMaxAggregateInputType
  }

  export type HealthEquityMetricGroupByOutputType = {
    id: string
    populationId: string | null
    measureType: $Enums.EquityMeasureType
    stratificationDimension: string
    stratificationValue: string
    metricName: string
    metricValue: number
    referenceValue: number | null
    disparityIndex: number | null
    confidenceInterval: JsonValue | null
    pValue: number | null
    sampleSize: number | null
    measurePeriod: string
    createdAt: Date
    updatedAt: Date
    _count: HealthEquityMetricCountAggregateOutputType | null
    _avg: HealthEquityMetricAvgAggregateOutputType | null
    _sum: HealthEquityMetricSumAggregateOutputType | null
    _min: HealthEquityMetricMinAggregateOutputType | null
    _max: HealthEquityMetricMaxAggregateOutputType | null
  }

  type GetHealthEquityMetricGroupByPayload<T extends HealthEquityMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthEquityMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthEquityMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthEquityMetricGroupByOutputType[P]>
            : GetScalarType<T[P], HealthEquityMetricGroupByOutputType[P]>
        }
      >
    >


  export type HealthEquityMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    measureType?: boolean
    stratificationDimension?: boolean
    stratificationValue?: boolean
    metricName?: boolean
    metricValue?: boolean
    referenceValue?: boolean
    disparityIndex?: boolean
    confidenceInterval?: boolean
    pValue?: boolean
    sampleSize?: boolean
    measurePeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["healthEquityMetric"]>

  export type HealthEquityMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    measureType?: boolean
    stratificationDimension?: boolean
    stratificationValue?: boolean
    metricName?: boolean
    metricValue?: boolean
    referenceValue?: boolean
    disparityIndex?: boolean
    confidenceInterval?: boolean
    pValue?: boolean
    sampleSize?: boolean
    measurePeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["healthEquityMetric"]>

  export type HealthEquityMetricSelectScalar = {
    id?: boolean
    populationId?: boolean
    measureType?: boolean
    stratificationDimension?: boolean
    stratificationValue?: boolean
    metricName?: boolean
    metricValue?: boolean
    referenceValue?: boolean
    disparityIndex?: boolean
    confidenceInterval?: boolean
    pValue?: boolean
    sampleSize?: boolean
    measurePeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $HealthEquityMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthEquityMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      populationId: string | null
      measureType: $Enums.EquityMeasureType
      stratificationDimension: string
      stratificationValue: string
      metricName: string
      metricValue: number
      referenceValue: number | null
      disparityIndex: number | null
      confidenceInterval: Prisma.JsonValue | null
      pValue: number | null
      sampleSize: number | null
      measurePeriod: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthEquityMetric"]>
    composites: {}
  }

  type HealthEquityMetricGetPayload<S extends boolean | null | undefined | HealthEquityMetricDefaultArgs> = $Result.GetResult<Prisma.$HealthEquityMetricPayload, S>

  type HealthEquityMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthEquityMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthEquityMetricCountAggregateInputType | true
    }

  export interface HealthEquityMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthEquityMetric'], meta: { name: 'HealthEquityMetric' } }
    /**
     * Find zero or one HealthEquityMetric that matches the filter.
     * @param {HealthEquityMetricFindUniqueArgs} args - Arguments to find a HealthEquityMetric
     * @example
     * // Get one HealthEquityMetric
     * const healthEquityMetric = await prisma.healthEquityMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthEquityMetricFindUniqueArgs>(args: SelectSubset<T, HealthEquityMetricFindUniqueArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthEquityMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthEquityMetricFindUniqueOrThrowArgs} args - Arguments to find a HealthEquityMetric
     * @example
     * // Get one HealthEquityMetric
     * const healthEquityMetric = await prisma.healthEquityMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthEquityMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthEquityMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthEquityMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEquityMetricFindFirstArgs} args - Arguments to find a HealthEquityMetric
     * @example
     * // Get one HealthEquityMetric
     * const healthEquityMetric = await prisma.healthEquityMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthEquityMetricFindFirstArgs>(args?: SelectSubset<T, HealthEquityMetricFindFirstArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthEquityMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEquityMetricFindFirstOrThrowArgs} args - Arguments to find a HealthEquityMetric
     * @example
     * // Get one HealthEquityMetric
     * const healthEquityMetric = await prisma.healthEquityMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthEquityMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthEquityMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthEquityMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEquityMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthEquityMetrics
     * const healthEquityMetrics = await prisma.healthEquityMetric.findMany()
     * 
     * // Get first 10 HealthEquityMetrics
     * const healthEquityMetrics = await prisma.healthEquityMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthEquityMetricWithIdOnly = await prisma.healthEquityMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthEquityMetricFindManyArgs>(args?: SelectSubset<T, HealthEquityMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthEquityMetric.
     * @param {HealthEquityMetricCreateArgs} args - Arguments to create a HealthEquityMetric.
     * @example
     * // Create one HealthEquityMetric
     * const HealthEquityMetric = await prisma.healthEquityMetric.create({
     *   data: {
     *     // ... data to create a HealthEquityMetric
     *   }
     * })
     * 
     */
    create<T extends HealthEquityMetricCreateArgs>(args: SelectSubset<T, HealthEquityMetricCreateArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthEquityMetrics.
     * @param {HealthEquityMetricCreateManyArgs} args - Arguments to create many HealthEquityMetrics.
     * @example
     * // Create many HealthEquityMetrics
     * const healthEquityMetric = await prisma.healthEquityMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthEquityMetricCreateManyArgs>(args?: SelectSubset<T, HealthEquityMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthEquityMetrics and returns the data saved in the database.
     * @param {HealthEquityMetricCreateManyAndReturnArgs} args - Arguments to create many HealthEquityMetrics.
     * @example
     * // Create many HealthEquityMetrics
     * const healthEquityMetric = await prisma.healthEquityMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthEquityMetrics and only return the `id`
     * const healthEquityMetricWithIdOnly = await prisma.healthEquityMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthEquityMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthEquityMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthEquityMetric.
     * @param {HealthEquityMetricDeleteArgs} args - Arguments to delete one HealthEquityMetric.
     * @example
     * // Delete one HealthEquityMetric
     * const HealthEquityMetric = await prisma.healthEquityMetric.delete({
     *   where: {
     *     // ... filter to delete one HealthEquityMetric
     *   }
     * })
     * 
     */
    delete<T extends HealthEquityMetricDeleteArgs>(args: SelectSubset<T, HealthEquityMetricDeleteArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthEquityMetric.
     * @param {HealthEquityMetricUpdateArgs} args - Arguments to update one HealthEquityMetric.
     * @example
     * // Update one HealthEquityMetric
     * const healthEquityMetric = await prisma.healthEquityMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthEquityMetricUpdateArgs>(args: SelectSubset<T, HealthEquityMetricUpdateArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthEquityMetrics.
     * @param {HealthEquityMetricDeleteManyArgs} args - Arguments to filter HealthEquityMetrics to delete.
     * @example
     * // Delete a few HealthEquityMetrics
     * const { count } = await prisma.healthEquityMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthEquityMetricDeleteManyArgs>(args?: SelectSubset<T, HealthEquityMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthEquityMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEquityMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthEquityMetrics
     * const healthEquityMetric = await prisma.healthEquityMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthEquityMetricUpdateManyArgs>(args: SelectSubset<T, HealthEquityMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthEquityMetric.
     * @param {HealthEquityMetricUpsertArgs} args - Arguments to update or create a HealthEquityMetric.
     * @example
     * // Update or create a HealthEquityMetric
     * const healthEquityMetric = await prisma.healthEquityMetric.upsert({
     *   create: {
     *     // ... data to create a HealthEquityMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthEquityMetric we want to update
     *   }
     * })
     */
    upsert<T extends HealthEquityMetricUpsertArgs>(args: SelectSubset<T, HealthEquityMetricUpsertArgs<ExtArgs>>): Prisma__HealthEquityMetricClient<$Result.GetResult<Prisma.$HealthEquityMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthEquityMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEquityMetricCountArgs} args - Arguments to filter HealthEquityMetrics to count.
     * @example
     * // Count the number of HealthEquityMetrics
     * const count = await prisma.healthEquityMetric.count({
     *   where: {
     *     // ... the filter for the HealthEquityMetrics we want to count
     *   }
     * })
    **/
    count<T extends HealthEquityMetricCountArgs>(
      args?: Subset<T, HealthEquityMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthEquityMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthEquityMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEquityMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthEquityMetricAggregateArgs>(args: Subset<T, HealthEquityMetricAggregateArgs>): Prisma.PrismaPromise<GetHealthEquityMetricAggregateType<T>>

    /**
     * Group by HealthEquityMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEquityMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthEquityMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthEquityMetricGroupByArgs['orderBy'] }
        : { orderBy?: HealthEquityMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthEquityMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthEquityMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthEquityMetric model
   */
  readonly fields: HealthEquityMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthEquityMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthEquityMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthEquityMetric model
   */ 
  interface HealthEquityMetricFieldRefs {
    readonly id: FieldRef<"HealthEquityMetric", 'String'>
    readonly populationId: FieldRef<"HealthEquityMetric", 'String'>
    readonly measureType: FieldRef<"HealthEquityMetric", 'EquityMeasureType'>
    readonly stratificationDimension: FieldRef<"HealthEquityMetric", 'String'>
    readonly stratificationValue: FieldRef<"HealthEquityMetric", 'String'>
    readonly metricName: FieldRef<"HealthEquityMetric", 'String'>
    readonly metricValue: FieldRef<"HealthEquityMetric", 'Float'>
    readonly referenceValue: FieldRef<"HealthEquityMetric", 'Float'>
    readonly disparityIndex: FieldRef<"HealthEquityMetric", 'Float'>
    readonly confidenceInterval: FieldRef<"HealthEquityMetric", 'Json'>
    readonly pValue: FieldRef<"HealthEquityMetric", 'Float'>
    readonly sampleSize: FieldRef<"HealthEquityMetric", 'Int'>
    readonly measurePeriod: FieldRef<"HealthEquityMetric", 'String'>
    readonly createdAt: FieldRef<"HealthEquityMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthEquityMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthEquityMetric findUnique
   */
  export type HealthEquityMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * Filter, which HealthEquityMetric to fetch.
     */
    where: HealthEquityMetricWhereUniqueInput
  }

  /**
   * HealthEquityMetric findUniqueOrThrow
   */
  export type HealthEquityMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * Filter, which HealthEquityMetric to fetch.
     */
    where: HealthEquityMetricWhereUniqueInput
  }

  /**
   * HealthEquityMetric findFirst
   */
  export type HealthEquityMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * Filter, which HealthEquityMetric to fetch.
     */
    where?: HealthEquityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEquityMetrics to fetch.
     */
    orderBy?: HealthEquityMetricOrderByWithRelationInput | HealthEquityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthEquityMetrics.
     */
    cursor?: HealthEquityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEquityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEquityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthEquityMetrics.
     */
    distinct?: HealthEquityMetricScalarFieldEnum | HealthEquityMetricScalarFieldEnum[]
  }

  /**
   * HealthEquityMetric findFirstOrThrow
   */
  export type HealthEquityMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * Filter, which HealthEquityMetric to fetch.
     */
    where?: HealthEquityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEquityMetrics to fetch.
     */
    orderBy?: HealthEquityMetricOrderByWithRelationInput | HealthEquityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthEquityMetrics.
     */
    cursor?: HealthEquityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEquityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEquityMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthEquityMetrics.
     */
    distinct?: HealthEquityMetricScalarFieldEnum | HealthEquityMetricScalarFieldEnum[]
  }

  /**
   * HealthEquityMetric findMany
   */
  export type HealthEquityMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * Filter, which HealthEquityMetrics to fetch.
     */
    where?: HealthEquityMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEquityMetrics to fetch.
     */
    orderBy?: HealthEquityMetricOrderByWithRelationInput | HealthEquityMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthEquityMetrics.
     */
    cursor?: HealthEquityMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEquityMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEquityMetrics.
     */
    skip?: number
    distinct?: HealthEquityMetricScalarFieldEnum | HealthEquityMetricScalarFieldEnum[]
  }

  /**
   * HealthEquityMetric create
   */
  export type HealthEquityMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a HealthEquityMetric.
     */
    data: XOR<HealthEquityMetricCreateInput, HealthEquityMetricUncheckedCreateInput>
  }

  /**
   * HealthEquityMetric createMany
   */
  export type HealthEquityMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthEquityMetrics.
     */
    data: HealthEquityMetricCreateManyInput | HealthEquityMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthEquityMetric createManyAndReturn
   */
  export type HealthEquityMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthEquityMetrics.
     */
    data: HealthEquityMetricCreateManyInput | HealthEquityMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthEquityMetric update
   */
  export type HealthEquityMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a HealthEquityMetric.
     */
    data: XOR<HealthEquityMetricUpdateInput, HealthEquityMetricUncheckedUpdateInput>
    /**
     * Choose, which HealthEquityMetric to update.
     */
    where: HealthEquityMetricWhereUniqueInput
  }

  /**
   * HealthEquityMetric updateMany
   */
  export type HealthEquityMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthEquityMetrics.
     */
    data: XOR<HealthEquityMetricUpdateManyMutationInput, HealthEquityMetricUncheckedUpdateManyInput>
    /**
     * Filter which HealthEquityMetrics to update
     */
    where?: HealthEquityMetricWhereInput
  }

  /**
   * HealthEquityMetric upsert
   */
  export type HealthEquityMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the HealthEquityMetric to update in case it exists.
     */
    where: HealthEquityMetricWhereUniqueInput
    /**
     * In case the HealthEquityMetric found by the `where` argument doesn't exist, create a new HealthEquityMetric with this data.
     */
    create: XOR<HealthEquityMetricCreateInput, HealthEquityMetricUncheckedCreateInput>
    /**
     * In case the HealthEquityMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthEquityMetricUpdateInput, HealthEquityMetricUncheckedUpdateInput>
  }

  /**
   * HealthEquityMetric delete
   */
  export type HealthEquityMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
    /**
     * Filter which HealthEquityMetric to delete.
     */
    where: HealthEquityMetricWhereUniqueInput
  }

  /**
   * HealthEquityMetric deleteMany
   */
  export type HealthEquityMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthEquityMetrics to delete
     */
    where?: HealthEquityMetricWhereInput
  }

  /**
   * HealthEquityMetric without action
   */
  export type HealthEquityMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEquityMetric
     */
    select?: HealthEquityMetricSelect<ExtArgs> | null
  }


  /**
   * Model AnalyticsReport
   */

  export type AggregateAnalyticsReport = {
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  export type AnalyticsReportMinAggregateOutputType = {
    id: string | null
    populationId: string | null
    reportType: $Enums.ReportType | null
    title: string | null
    description: string | null
    generatedAt: Date | null
    generatedBy: string | null
    periodStart: Date | null
    periodEnd: Date | null
    lastExportedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsReportMaxAggregateOutputType = {
    id: string | null
    populationId: string | null
    reportType: $Enums.ReportType | null
    title: string | null
    description: string | null
    generatedAt: Date | null
    generatedBy: string | null
    periodStart: Date | null
    periodEnd: Date | null
    lastExportedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsReportCountAggregateOutputType = {
    id: number
    populationId: number
    reportType: number
    title: number
    description: number
    parameters: number
    data: number
    visualizations: number
    generatedAt: number
    generatedBy: number
    periodStart: number
    periodEnd: number
    exportFormats: number
    lastExportedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsReportMinAggregateInputType = {
    id?: true
    populationId?: true
    reportType?: true
    title?: true
    description?: true
    generatedAt?: true
    generatedBy?: true
    periodStart?: true
    periodEnd?: true
    lastExportedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsReportMaxAggregateInputType = {
    id?: true
    populationId?: true
    reportType?: true
    title?: true
    description?: true
    generatedAt?: true
    generatedBy?: true
    periodStart?: true
    periodEnd?: true
    lastExportedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsReportCountAggregateInputType = {
    id?: true
    populationId?: true
    reportType?: true
    title?: true
    description?: true
    parameters?: true
    data?: true
    visualizations?: true
    generatedAt?: true
    generatedBy?: true
    periodStart?: true
    periodEnd?: true
    exportFormats?: true
    lastExportedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReport to aggregate.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsReports
    **/
    _count?: true | AnalyticsReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type GetAnalyticsReportAggregateType<T extends AnalyticsReportAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsReport[P]>
      : GetScalarType<T[P], AggregateAnalyticsReport[P]>
  }




  export type AnalyticsReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsReportWhereInput
    orderBy?: AnalyticsReportOrderByWithAggregationInput | AnalyticsReportOrderByWithAggregationInput[]
    by: AnalyticsReportScalarFieldEnum[] | AnalyticsReportScalarFieldEnum
    having?: AnalyticsReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsReportCountAggregateInputType | true
    _min?: AnalyticsReportMinAggregateInputType
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type AnalyticsReportGroupByOutputType = {
    id: string
    populationId: string | null
    reportType: $Enums.ReportType
    title: string
    description: string | null
    parameters: JsonValue | null
    data: JsonValue
    visualizations: JsonValue | null
    generatedAt: Date
    generatedBy: string | null
    periodStart: Date | null
    periodEnd: Date | null
    exportFormats: JsonValue | null
    lastExportedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  type GetAnalyticsReportGroupByPayload<T extends AnalyticsReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    reportType?: boolean
    title?: boolean
    description?: boolean
    parameters?: boolean
    data?: boolean
    visualizations?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    exportFormats?: boolean
    lastExportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    population?: boolean | AnalyticsReport$populationArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsReport"]>

  export type AnalyticsReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    populationId?: boolean
    reportType?: boolean
    title?: boolean
    description?: boolean
    parameters?: boolean
    data?: boolean
    visualizations?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    exportFormats?: boolean
    lastExportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    population?: boolean | AnalyticsReport$populationArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsReport"]>

  export type AnalyticsReportSelectScalar = {
    id?: boolean
    populationId?: boolean
    reportType?: boolean
    title?: boolean
    description?: boolean
    parameters?: boolean
    data?: boolean
    visualizations?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    exportFormats?: boolean
    lastExportedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | AnalyticsReport$populationArgs<ExtArgs>
  }
  export type AnalyticsReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    population?: boolean | AnalyticsReport$populationArgs<ExtArgs>
  }

  export type $AnalyticsReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsReport"
    objects: {
      population: Prisma.$PopulationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      populationId: string | null
      reportType: $Enums.ReportType
      title: string
      description: string | null
      parameters: Prisma.JsonValue | null
      data: Prisma.JsonValue
      visualizations: Prisma.JsonValue | null
      generatedAt: Date
      generatedBy: string | null
      periodStart: Date | null
      periodEnd: Date | null
      exportFormats: Prisma.JsonValue | null
      lastExportedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsReport"]>
    composites: {}
  }

  type AnalyticsReportGetPayload<S extends boolean | null | undefined | AnalyticsReportDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsReportPayload, S>

  type AnalyticsReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsReportCountAggregateInputType | true
    }

  export interface AnalyticsReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsReport'], meta: { name: 'AnalyticsReport' } }
    /**
     * Find zero or one AnalyticsReport that matches the filter.
     * @param {AnalyticsReportFindUniqueArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsReportFindUniqueArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnalyticsReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsReportFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsReportFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnalyticsReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsReportFindFirstArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnalyticsReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsReportFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnalyticsReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany()
     * 
     * // Get first 10 AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsReportFindManyArgs>(args?: SelectSubset<T, AnalyticsReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnalyticsReport.
     * @param {AnalyticsReportCreateArgs} args - Arguments to create a AnalyticsReport.
     * @example
     * // Create one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.create({
     *   data: {
     *     // ... data to create a AnalyticsReport
     *   }
     * })
     * 
     */
    create<T extends AnalyticsReportCreateArgs>(args: SelectSubset<T, AnalyticsReportCreateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnalyticsReports.
     * @param {AnalyticsReportCreateManyArgs} args - Arguments to create many AnalyticsReports.
     * @example
     * // Create many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsReportCreateManyArgs>(args?: SelectSubset<T, AnalyticsReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsReports and returns the data saved in the database.
     * @param {AnalyticsReportCreateManyAndReturnArgs} args - Arguments to create many AnalyticsReports.
     * @example
     * // Create many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsReports and only return the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsReportCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnalyticsReport.
     * @param {AnalyticsReportDeleteArgs} args - Arguments to delete one AnalyticsReport.
     * @example
     * // Delete one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsReport
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsReportDeleteArgs>(args: SelectSubset<T, AnalyticsReportDeleteArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnalyticsReport.
     * @param {AnalyticsReportUpdateArgs} args - Arguments to update one AnalyticsReport.
     * @example
     * // Update one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsReportUpdateArgs>(args: SelectSubset<T, AnalyticsReportUpdateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnalyticsReports.
     * @param {AnalyticsReportDeleteManyArgs} args - Arguments to filter AnalyticsReports to delete.
     * @example
     * // Delete a few AnalyticsReports
     * const { count } = await prisma.analyticsReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsReportDeleteManyArgs>(args?: SelectSubset<T, AnalyticsReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsReportUpdateManyArgs>(args: SelectSubset<T, AnalyticsReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsReport.
     * @param {AnalyticsReportUpsertArgs} args - Arguments to update or create a AnalyticsReport.
     * @example
     * // Update or create a AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.upsert({
     *   create: {
     *     // ... data to create a AnalyticsReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsReport we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsReportUpsertArgs>(args: SelectSubset<T, AnalyticsReportUpsertArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportCountArgs} args - Arguments to filter AnalyticsReports to count.
     * @example
     * // Count the number of AnalyticsReports
     * const count = await prisma.analyticsReport.count({
     *   where: {
     *     // ... the filter for the AnalyticsReports we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsReportCountArgs>(
      args?: Subset<T, AnalyticsReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsReportAggregateArgs>(args: Subset<T, AnalyticsReportAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsReportAggregateType<T>>

    /**
     * Group by AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsReportGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsReport model
   */
  readonly fields: AnalyticsReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    population<T extends AnalyticsReport$populationArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticsReport$populationArgs<ExtArgs>>): Prisma__PopulationClient<$Result.GetResult<Prisma.$PopulationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsReport model
   */ 
  interface AnalyticsReportFieldRefs {
    readonly id: FieldRef<"AnalyticsReport", 'String'>
    readonly populationId: FieldRef<"AnalyticsReport", 'String'>
    readonly reportType: FieldRef<"AnalyticsReport", 'ReportType'>
    readonly title: FieldRef<"AnalyticsReport", 'String'>
    readonly description: FieldRef<"AnalyticsReport", 'String'>
    readonly parameters: FieldRef<"AnalyticsReport", 'Json'>
    readonly data: FieldRef<"AnalyticsReport", 'Json'>
    readonly visualizations: FieldRef<"AnalyticsReport", 'Json'>
    readonly generatedAt: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly generatedBy: FieldRef<"AnalyticsReport", 'String'>
    readonly periodStart: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly periodEnd: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly exportFormats: FieldRef<"AnalyticsReport", 'Json'>
    readonly lastExportedAt: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsReport findUnique
   */
  export type AnalyticsReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findUniqueOrThrow
   */
  export type AnalyticsReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findFirst
   */
  export type AnalyticsReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findFirstOrThrow
   */
  export type AnalyticsReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findMany
   */
  export type AnalyticsReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReports to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport create
   */
  export type AnalyticsReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsReport.
     */
    data: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
  }

  /**
   * AnalyticsReport createMany
   */
  export type AnalyticsReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsReports.
     */
    data: AnalyticsReportCreateManyInput | AnalyticsReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsReport createManyAndReturn
   */
  export type AnalyticsReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnalyticsReports.
     */
    data: AnalyticsReportCreateManyInput | AnalyticsReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsReport update
   */
  export type AnalyticsReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsReport.
     */
    data: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsReport to update.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport updateMany
   */
  export type AnalyticsReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsReports.
     */
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsReports to update
     */
    where?: AnalyticsReportWhereInput
  }

  /**
   * AnalyticsReport upsert
   */
  export type AnalyticsReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsReport to update in case it exists.
     */
    where: AnalyticsReportWhereUniqueInput
    /**
     * In case the AnalyticsReport found by the `where` argument doesn't exist, create a new AnalyticsReport with this data.
     */
    create: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
    /**
     * In case the AnalyticsReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
  }

  /**
   * AnalyticsReport delete
   */
  export type AnalyticsReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsReport to delete.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport deleteMany
   */
  export type AnalyticsReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReports to delete
     */
    where?: AnalyticsReportWhereInput
  }

  /**
   * AnalyticsReport.population
   */
  export type AnalyticsReport$populationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Population
     */
    select?: PopulationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PopulationInclude<ExtArgs> | null
    where?: PopulationWhereInput
  }

  /**
   * AnalyticsReport without action
   */
  export type AnalyticsReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
  }


  /**
   * Model PredictiveModel
   */

  export type AggregatePredictiveModel = {
    _count: PredictiveModelCountAggregateOutputType | null
    _avg: PredictiveModelAvgAggregateOutputType | null
    _sum: PredictiveModelSumAggregateOutputType | null
    _min: PredictiveModelMinAggregateOutputType | null
    _max: PredictiveModelMaxAggregateOutputType | null
  }

  export type PredictiveModelAvgAggregateOutputType = {
    accuracy: number | null
    auc: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    trainingSampleSize: number | null
  }

  export type PredictiveModelSumAggregateOutputType = {
    accuracy: number | null
    auc: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    trainingSampleSize: number | null
  }

  export type PredictiveModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    modelType: $Enums.PredictiveModelType | null
    algorithm: string | null
    accuracy: number | null
    auc: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    version: string | null
    isActive: boolean | null
    trainedAt: Date | null
    trainingSampleSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PredictiveModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    modelType: $Enums.PredictiveModelType | null
    algorithm: string | null
    accuracy: number | null
    auc: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    version: string | null
    isActive: boolean | null
    trainedAt: Date | null
    trainingSampleSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PredictiveModelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    modelType: number
    algorithm: number
    features: number
    hyperparameters: number
    accuracy: number
    auc: number
    precision: number
    recall: number
    f1Score: number
    version: number
    isActive: number
    trainedAt: number
    trainingSampleSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PredictiveModelAvgAggregateInputType = {
    accuracy?: true
    auc?: true
    precision?: true
    recall?: true
    f1Score?: true
    trainingSampleSize?: true
  }

  export type PredictiveModelSumAggregateInputType = {
    accuracy?: true
    auc?: true
    precision?: true
    recall?: true
    f1Score?: true
    trainingSampleSize?: true
  }

  export type PredictiveModelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    modelType?: true
    algorithm?: true
    accuracy?: true
    auc?: true
    precision?: true
    recall?: true
    f1Score?: true
    version?: true
    isActive?: true
    trainedAt?: true
    trainingSampleSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PredictiveModelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    modelType?: true
    algorithm?: true
    accuracy?: true
    auc?: true
    precision?: true
    recall?: true
    f1Score?: true
    version?: true
    isActive?: true
    trainedAt?: true
    trainingSampleSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PredictiveModelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    modelType?: true
    algorithm?: true
    features?: true
    hyperparameters?: true
    accuracy?: true
    auc?: true
    precision?: true
    recall?: true
    f1Score?: true
    version?: true
    isActive?: true
    trainedAt?: true
    trainingSampleSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PredictiveModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictiveModel to aggregate.
     */
    where?: PredictiveModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictiveModels to fetch.
     */
    orderBy?: PredictiveModelOrderByWithRelationInput | PredictiveModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PredictiveModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictiveModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictiveModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PredictiveModels
    **/
    _count?: true | PredictiveModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PredictiveModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PredictiveModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PredictiveModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PredictiveModelMaxAggregateInputType
  }

  export type GetPredictiveModelAggregateType<T extends PredictiveModelAggregateArgs> = {
        [P in keyof T & keyof AggregatePredictiveModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePredictiveModel[P]>
      : GetScalarType<T[P], AggregatePredictiveModel[P]>
  }




  export type PredictiveModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictiveModelWhereInput
    orderBy?: PredictiveModelOrderByWithAggregationInput | PredictiveModelOrderByWithAggregationInput[]
    by: PredictiveModelScalarFieldEnum[] | PredictiveModelScalarFieldEnum
    having?: PredictiveModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PredictiveModelCountAggregateInputType | true
    _avg?: PredictiveModelAvgAggregateInputType
    _sum?: PredictiveModelSumAggregateInputType
    _min?: PredictiveModelMinAggregateInputType
    _max?: PredictiveModelMaxAggregateInputType
  }

  export type PredictiveModelGroupByOutputType = {
    id: string
    name: string
    description: string | null
    modelType: $Enums.PredictiveModelType
    algorithm: string
    features: JsonValue
    hyperparameters: JsonValue | null
    accuracy: number | null
    auc: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    version: string
    isActive: boolean
    trainedAt: Date | null
    trainingSampleSize: number | null
    createdAt: Date
    updatedAt: Date
    _count: PredictiveModelCountAggregateOutputType | null
    _avg: PredictiveModelAvgAggregateOutputType | null
    _sum: PredictiveModelSumAggregateOutputType | null
    _min: PredictiveModelMinAggregateOutputType | null
    _max: PredictiveModelMaxAggregateOutputType | null
  }

  type GetPredictiveModelGroupByPayload<T extends PredictiveModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PredictiveModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PredictiveModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PredictiveModelGroupByOutputType[P]>
            : GetScalarType<T[P], PredictiveModelGroupByOutputType[P]>
        }
      >
    >


  export type PredictiveModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    modelType?: boolean
    algorithm?: boolean
    features?: boolean
    hyperparameters?: boolean
    accuracy?: boolean
    auc?: boolean
    precision?: boolean
    recall?: boolean
    f1Score?: boolean
    version?: boolean
    isActive?: boolean
    trainedAt?: boolean
    trainingSampleSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["predictiveModel"]>

  export type PredictiveModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    modelType?: boolean
    algorithm?: boolean
    features?: boolean
    hyperparameters?: boolean
    accuracy?: boolean
    auc?: boolean
    precision?: boolean
    recall?: boolean
    f1Score?: boolean
    version?: boolean
    isActive?: boolean
    trainedAt?: boolean
    trainingSampleSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["predictiveModel"]>

  export type PredictiveModelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    modelType?: boolean
    algorithm?: boolean
    features?: boolean
    hyperparameters?: boolean
    accuracy?: boolean
    auc?: boolean
    precision?: boolean
    recall?: boolean
    f1Score?: boolean
    version?: boolean
    isActive?: boolean
    trainedAt?: boolean
    trainingSampleSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PredictiveModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PredictiveModel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      modelType: $Enums.PredictiveModelType
      algorithm: string
      features: Prisma.JsonValue
      hyperparameters: Prisma.JsonValue | null
      accuracy: number | null
      auc: number | null
      precision: number | null
      recall: number | null
      f1Score: number | null
      version: string
      isActive: boolean
      trainedAt: Date | null
      trainingSampleSize: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["predictiveModel"]>
    composites: {}
  }

  type PredictiveModelGetPayload<S extends boolean | null | undefined | PredictiveModelDefaultArgs> = $Result.GetResult<Prisma.$PredictiveModelPayload, S>

  type PredictiveModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PredictiveModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PredictiveModelCountAggregateInputType | true
    }

  export interface PredictiveModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PredictiveModel'], meta: { name: 'PredictiveModel' } }
    /**
     * Find zero or one PredictiveModel that matches the filter.
     * @param {PredictiveModelFindUniqueArgs} args - Arguments to find a PredictiveModel
     * @example
     * // Get one PredictiveModel
     * const predictiveModel = await prisma.predictiveModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PredictiveModelFindUniqueArgs>(args: SelectSubset<T, PredictiveModelFindUniqueArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PredictiveModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PredictiveModelFindUniqueOrThrowArgs} args - Arguments to find a PredictiveModel
     * @example
     * // Get one PredictiveModel
     * const predictiveModel = await prisma.predictiveModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PredictiveModelFindUniqueOrThrowArgs>(args: SelectSubset<T, PredictiveModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PredictiveModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictiveModelFindFirstArgs} args - Arguments to find a PredictiveModel
     * @example
     * // Get one PredictiveModel
     * const predictiveModel = await prisma.predictiveModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PredictiveModelFindFirstArgs>(args?: SelectSubset<T, PredictiveModelFindFirstArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PredictiveModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictiveModelFindFirstOrThrowArgs} args - Arguments to find a PredictiveModel
     * @example
     * // Get one PredictiveModel
     * const predictiveModel = await prisma.predictiveModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PredictiveModelFindFirstOrThrowArgs>(args?: SelectSubset<T, PredictiveModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PredictiveModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictiveModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PredictiveModels
     * const predictiveModels = await prisma.predictiveModel.findMany()
     * 
     * // Get first 10 PredictiveModels
     * const predictiveModels = await prisma.predictiveModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predictiveModelWithIdOnly = await prisma.predictiveModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PredictiveModelFindManyArgs>(args?: SelectSubset<T, PredictiveModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PredictiveModel.
     * @param {PredictiveModelCreateArgs} args - Arguments to create a PredictiveModel.
     * @example
     * // Create one PredictiveModel
     * const PredictiveModel = await prisma.predictiveModel.create({
     *   data: {
     *     // ... data to create a PredictiveModel
     *   }
     * })
     * 
     */
    create<T extends PredictiveModelCreateArgs>(args: SelectSubset<T, PredictiveModelCreateArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PredictiveModels.
     * @param {PredictiveModelCreateManyArgs} args - Arguments to create many PredictiveModels.
     * @example
     * // Create many PredictiveModels
     * const predictiveModel = await prisma.predictiveModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PredictiveModelCreateManyArgs>(args?: SelectSubset<T, PredictiveModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PredictiveModels and returns the data saved in the database.
     * @param {PredictiveModelCreateManyAndReturnArgs} args - Arguments to create many PredictiveModels.
     * @example
     * // Create many PredictiveModels
     * const predictiveModel = await prisma.predictiveModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PredictiveModels and only return the `id`
     * const predictiveModelWithIdOnly = await prisma.predictiveModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PredictiveModelCreateManyAndReturnArgs>(args?: SelectSubset<T, PredictiveModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PredictiveModel.
     * @param {PredictiveModelDeleteArgs} args - Arguments to delete one PredictiveModel.
     * @example
     * // Delete one PredictiveModel
     * const PredictiveModel = await prisma.predictiveModel.delete({
     *   where: {
     *     // ... filter to delete one PredictiveModel
     *   }
     * })
     * 
     */
    delete<T extends PredictiveModelDeleteArgs>(args: SelectSubset<T, PredictiveModelDeleteArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PredictiveModel.
     * @param {PredictiveModelUpdateArgs} args - Arguments to update one PredictiveModel.
     * @example
     * // Update one PredictiveModel
     * const predictiveModel = await prisma.predictiveModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PredictiveModelUpdateArgs>(args: SelectSubset<T, PredictiveModelUpdateArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PredictiveModels.
     * @param {PredictiveModelDeleteManyArgs} args - Arguments to filter PredictiveModels to delete.
     * @example
     * // Delete a few PredictiveModels
     * const { count } = await prisma.predictiveModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PredictiveModelDeleteManyArgs>(args?: SelectSubset<T, PredictiveModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PredictiveModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictiveModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PredictiveModels
     * const predictiveModel = await prisma.predictiveModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PredictiveModelUpdateManyArgs>(args: SelectSubset<T, PredictiveModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PredictiveModel.
     * @param {PredictiveModelUpsertArgs} args - Arguments to update or create a PredictiveModel.
     * @example
     * // Update or create a PredictiveModel
     * const predictiveModel = await prisma.predictiveModel.upsert({
     *   create: {
     *     // ... data to create a PredictiveModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PredictiveModel we want to update
     *   }
     * })
     */
    upsert<T extends PredictiveModelUpsertArgs>(args: SelectSubset<T, PredictiveModelUpsertArgs<ExtArgs>>): Prisma__PredictiveModelClient<$Result.GetResult<Prisma.$PredictiveModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PredictiveModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictiveModelCountArgs} args - Arguments to filter PredictiveModels to count.
     * @example
     * // Count the number of PredictiveModels
     * const count = await prisma.predictiveModel.count({
     *   where: {
     *     // ... the filter for the PredictiveModels we want to count
     *   }
     * })
    **/
    count<T extends PredictiveModelCountArgs>(
      args?: Subset<T, PredictiveModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PredictiveModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PredictiveModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictiveModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PredictiveModelAggregateArgs>(args: Subset<T, PredictiveModelAggregateArgs>): Prisma.PrismaPromise<GetPredictiveModelAggregateType<T>>

    /**
     * Group by PredictiveModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictiveModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PredictiveModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PredictiveModelGroupByArgs['orderBy'] }
        : { orderBy?: PredictiveModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PredictiveModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredictiveModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PredictiveModel model
   */
  readonly fields: PredictiveModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PredictiveModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PredictiveModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PredictiveModel model
   */ 
  interface PredictiveModelFieldRefs {
    readonly id: FieldRef<"PredictiveModel", 'String'>
    readonly name: FieldRef<"PredictiveModel", 'String'>
    readonly description: FieldRef<"PredictiveModel", 'String'>
    readonly modelType: FieldRef<"PredictiveModel", 'PredictiveModelType'>
    readonly algorithm: FieldRef<"PredictiveModel", 'String'>
    readonly features: FieldRef<"PredictiveModel", 'Json'>
    readonly hyperparameters: FieldRef<"PredictiveModel", 'Json'>
    readonly accuracy: FieldRef<"PredictiveModel", 'Float'>
    readonly auc: FieldRef<"PredictiveModel", 'Float'>
    readonly precision: FieldRef<"PredictiveModel", 'Float'>
    readonly recall: FieldRef<"PredictiveModel", 'Float'>
    readonly f1Score: FieldRef<"PredictiveModel", 'Float'>
    readonly version: FieldRef<"PredictiveModel", 'String'>
    readonly isActive: FieldRef<"PredictiveModel", 'Boolean'>
    readonly trainedAt: FieldRef<"PredictiveModel", 'DateTime'>
    readonly trainingSampleSize: FieldRef<"PredictiveModel", 'Int'>
    readonly createdAt: FieldRef<"PredictiveModel", 'DateTime'>
    readonly updatedAt: FieldRef<"PredictiveModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PredictiveModel findUnique
   */
  export type PredictiveModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * Filter, which PredictiveModel to fetch.
     */
    where: PredictiveModelWhereUniqueInput
  }

  /**
   * PredictiveModel findUniqueOrThrow
   */
  export type PredictiveModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * Filter, which PredictiveModel to fetch.
     */
    where: PredictiveModelWhereUniqueInput
  }

  /**
   * PredictiveModel findFirst
   */
  export type PredictiveModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * Filter, which PredictiveModel to fetch.
     */
    where?: PredictiveModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictiveModels to fetch.
     */
    orderBy?: PredictiveModelOrderByWithRelationInput | PredictiveModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictiveModels.
     */
    cursor?: PredictiveModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictiveModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictiveModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictiveModels.
     */
    distinct?: PredictiveModelScalarFieldEnum | PredictiveModelScalarFieldEnum[]
  }

  /**
   * PredictiveModel findFirstOrThrow
   */
  export type PredictiveModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * Filter, which PredictiveModel to fetch.
     */
    where?: PredictiveModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictiveModels to fetch.
     */
    orderBy?: PredictiveModelOrderByWithRelationInput | PredictiveModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictiveModels.
     */
    cursor?: PredictiveModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictiveModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictiveModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictiveModels.
     */
    distinct?: PredictiveModelScalarFieldEnum | PredictiveModelScalarFieldEnum[]
  }

  /**
   * PredictiveModel findMany
   */
  export type PredictiveModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * Filter, which PredictiveModels to fetch.
     */
    where?: PredictiveModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictiveModels to fetch.
     */
    orderBy?: PredictiveModelOrderByWithRelationInput | PredictiveModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PredictiveModels.
     */
    cursor?: PredictiveModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictiveModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictiveModels.
     */
    skip?: number
    distinct?: PredictiveModelScalarFieldEnum | PredictiveModelScalarFieldEnum[]
  }

  /**
   * PredictiveModel create
   */
  export type PredictiveModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * The data needed to create a PredictiveModel.
     */
    data: XOR<PredictiveModelCreateInput, PredictiveModelUncheckedCreateInput>
  }

  /**
   * PredictiveModel createMany
   */
  export type PredictiveModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PredictiveModels.
     */
    data: PredictiveModelCreateManyInput | PredictiveModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PredictiveModel createManyAndReturn
   */
  export type PredictiveModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PredictiveModels.
     */
    data: PredictiveModelCreateManyInput | PredictiveModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PredictiveModel update
   */
  export type PredictiveModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * The data needed to update a PredictiveModel.
     */
    data: XOR<PredictiveModelUpdateInput, PredictiveModelUncheckedUpdateInput>
    /**
     * Choose, which PredictiveModel to update.
     */
    where: PredictiveModelWhereUniqueInput
  }

  /**
   * PredictiveModel updateMany
   */
  export type PredictiveModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PredictiveModels.
     */
    data: XOR<PredictiveModelUpdateManyMutationInput, PredictiveModelUncheckedUpdateManyInput>
    /**
     * Filter which PredictiveModels to update
     */
    where?: PredictiveModelWhereInput
  }

  /**
   * PredictiveModel upsert
   */
  export type PredictiveModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * The filter to search for the PredictiveModel to update in case it exists.
     */
    where: PredictiveModelWhereUniqueInput
    /**
     * In case the PredictiveModel found by the `where` argument doesn't exist, create a new PredictiveModel with this data.
     */
    create: XOR<PredictiveModelCreateInput, PredictiveModelUncheckedCreateInput>
    /**
     * In case the PredictiveModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PredictiveModelUpdateInput, PredictiveModelUncheckedUpdateInput>
  }

  /**
   * PredictiveModel delete
   */
  export type PredictiveModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
    /**
     * Filter which PredictiveModel to delete.
     */
    where: PredictiveModelWhereUniqueInput
  }

  /**
   * PredictiveModel deleteMany
   */
  export type PredictiveModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictiveModels to delete
     */
    where?: PredictiveModelWhereInput
  }

  /**
   * PredictiveModel without action
   */
  export type PredictiveModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictiveModel
     */
    select?: PredictiveModelSelect<ExtArgs> | null
  }


  /**
   * Model AnalyticsAuditLog
   */

  export type AggregateAnalyticsAuditLog = {
    _count: AnalyticsAuditLogCountAggregateOutputType | null
    _min: AnalyticsAuditLogMinAggregateOutputType | null
    _max: AnalyticsAuditLogMaxAggregateOutputType | null
  }

  export type AnalyticsAuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AnalyticsAuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AnalyticsAuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resourceType: number
    resourceId: number
    ipAddress: number
    userAgent: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AnalyticsAuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AnalyticsAuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AnalyticsAuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsAuditLog to aggregate.
     */
    where?: AnalyticsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAuditLogs to fetch.
     */
    orderBy?: AnalyticsAuditLogOrderByWithRelationInput | AnalyticsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsAuditLogs
    **/
    _count?: true | AnalyticsAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsAuditLogMaxAggregateInputType
  }

  export type GetAnalyticsAuditLogAggregateType<T extends AnalyticsAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsAuditLog[P]>
      : GetScalarType<T[P], AggregateAnalyticsAuditLog[P]>
  }




  export type AnalyticsAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsAuditLogWhereInput
    orderBy?: AnalyticsAuditLogOrderByWithAggregationInput | AnalyticsAuditLogOrderByWithAggregationInput[]
    by: AnalyticsAuditLogScalarFieldEnum[] | AnalyticsAuditLogScalarFieldEnum
    having?: AnalyticsAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsAuditLogCountAggregateInputType | true
    _min?: AnalyticsAuditLogMinAggregateInputType
    _max?: AnalyticsAuditLogMaxAggregateInputType
  }

  export type AnalyticsAuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    resourceType: string
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AnalyticsAuditLogCountAggregateOutputType | null
    _min: AnalyticsAuditLogMinAggregateOutputType | null
    _max: AnalyticsAuditLogMaxAggregateOutputType | null
  }

  type GetAnalyticsAuditLogGroupByPayload<T extends AnalyticsAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsAuditLog"]>

  export type AnalyticsAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsAuditLog"]>

  export type AnalyticsAuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $AnalyticsAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resourceType: string
      resourceId: string | null
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["analyticsAuditLog"]>
    composites: {}
  }

  type AnalyticsAuditLogGetPayload<S extends boolean | null | undefined | AnalyticsAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsAuditLogPayload, S>

  type AnalyticsAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsAuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsAuditLogCountAggregateInputType | true
    }

  export interface AnalyticsAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsAuditLog'], meta: { name: 'AnalyticsAuditLog' } }
    /**
     * Find zero or one AnalyticsAuditLog that matches the filter.
     * @param {AnalyticsAuditLogFindUniqueArgs} args - Arguments to find a AnalyticsAuditLog
     * @example
     * // Get one AnalyticsAuditLog
     * const analyticsAuditLog = await prisma.analyticsAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsAuditLogFindUniqueArgs>(args: SelectSubset<T, AnalyticsAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnalyticsAuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsAuditLog
     * @example
     * // Get one AnalyticsAuditLog
     * const analyticsAuditLog = await prisma.analyticsAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnalyticsAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAuditLogFindFirstArgs} args - Arguments to find a AnalyticsAuditLog
     * @example
     * // Get one AnalyticsAuditLog
     * const analyticsAuditLog = await prisma.analyticsAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsAuditLogFindFirstArgs>(args?: SelectSubset<T, AnalyticsAuditLogFindFirstArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnalyticsAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAuditLogFindFirstOrThrowArgs} args - Arguments to find a AnalyticsAuditLog
     * @example
     * // Get one AnalyticsAuditLog
     * const analyticsAuditLog = await prisma.analyticsAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnalyticsAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsAuditLogs
     * const analyticsAuditLogs = await prisma.analyticsAuditLog.findMany()
     * 
     * // Get first 10 AnalyticsAuditLogs
     * const analyticsAuditLogs = await prisma.analyticsAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsAuditLogWithIdOnly = await prisma.analyticsAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsAuditLogFindManyArgs>(args?: SelectSubset<T, AnalyticsAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnalyticsAuditLog.
     * @param {AnalyticsAuditLogCreateArgs} args - Arguments to create a AnalyticsAuditLog.
     * @example
     * // Create one AnalyticsAuditLog
     * const AnalyticsAuditLog = await prisma.analyticsAuditLog.create({
     *   data: {
     *     // ... data to create a AnalyticsAuditLog
     *   }
     * })
     * 
     */
    create<T extends AnalyticsAuditLogCreateArgs>(args: SelectSubset<T, AnalyticsAuditLogCreateArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnalyticsAuditLogs.
     * @param {AnalyticsAuditLogCreateManyArgs} args - Arguments to create many AnalyticsAuditLogs.
     * @example
     * // Create many AnalyticsAuditLogs
     * const analyticsAuditLog = await prisma.analyticsAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsAuditLogCreateManyArgs>(args?: SelectSubset<T, AnalyticsAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsAuditLogs and returns the data saved in the database.
     * @param {AnalyticsAuditLogCreateManyAndReturnArgs} args - Arguments to create many AnalyticsAuditLogs.
     * @example
     * // Create many AnalyticsAuditLogs
     * const analyticsAuditLog = await prisma.analyticsAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsAuditLogs and only return the `id`
     * const analyticsAuditLogWithIdOnly = await prisma.analyticsAuditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnalyticsAuditLog.
     * @param {AnalyticsAuditLogDeleteArgs} args - Arguments to delete one AnalyticsAuditLog.
     * @example
     * // Delete one AnalyticsAuditLog
     * const AnalyticsAuditLog = await prisma.analyticsAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsAuditLogDeleteArgs>(args: SelectSubset<T, AnalyticsAuditLogDeleteArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnalyticsAuditLog.
     * @param {AnalyticsAuditLogUpdateArgs} args - Arguments to update one AnalyticsAuditLog.
     * @example
     * // Update one AnalyticsAuditLog
     * const analyticsAuditLog = await prisma.analyticsAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsAuditLogUpdateArgs>(args: SelectSubset<T, AnalyticsAuditLogUpdateArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnalyticsAuditLogs.
     * @param {AnalyticsAuditLogDeleteManyArgs} args - Arguments to filter AnalyticsAuditLogs to delete.
     * @example
     * // Delete a few AnalyticsAuditLogs
     * const { count } = await prisma.analyticsAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsAuditLogDeleteManyArgs>(args?: SelectSubset<T, AnalyticsAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsAuditLogs
     * const analyticsAuditLog = await prisma.analyticsAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsAuditLogUpdateManyArgs>(args: SelectSubset<T, AnalyticsAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsAuditLog.
     * @param {AnalyticsAuditLogUpsertArgs} args - Arguments to update or create a AnalyticsAuditLog.
     * @example
     * // Update or create a AnalyticsAuditLog
     * const analyticsAuditLog = await prisma.analyticsAuditLog.upsert({
     *   create: {
     *     // ... data to create a AnalyticsAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsAuditLogUpsertArgs>(args: SelectSubset<T, AnalyticsAuditLogUpsertArgs<ExtArgs>>): Prisma__AnalyticsAuditLogClient<$Result.GetResult<Prisma.$AnalyticsAuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnalyticsAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAuditLogCountArgs} args - Arguments to filter AnalyticsAuditLogs to count.
     * @example
     * // Count the number of AnalyticsAuditLogs
     * const count = await prisma.analyticsAuditLog.count({
     *   where: {
     *     // ... the filter for the AnalyticsAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsAuditLogCountArgs>(
      args?: Subset<T, AnalyticsAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAuditLogAggregateArgs>(args: Subset<T, AnalyticsAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAuditLogAggregateType<T>>

    /**
     * Group by AnalyticsAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsAuditLog model
   */
  readonly fields: AnalyticsAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsAuditLog model
   */ 
  interface AnalyticsAuditLogFieldRefs {
    readonly id: FieldRef<"AnalyticsAuditLog", 'String'>
    readonly userId: FieldRef<"AnalyticsAuditLog", 'String'>
    readonly action: FieldRef<"AnalyticsAuditLog", 'String'>
    readonly resourceType: FieldRef<"AnalyticsAuditLog", 'String'>
    readonly resourceId: FieldRef<"AnalyticsAuditLog", 'String'>
    readonly ipAddress: FieldRef<"AnalyticsAuditLog", 'String'>
    readonly userAgent: FieldRef<"AnalyticsAuditLog", 'String'>
    readonly metadata: FieldRef<"AnalyticsAuditLog", 'Json'>
    readonly createdAt: FieldRef<"AnalyticsAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsAuditLog findUnique
   */
  export type AnalyticsAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsAuditLog to fetch.
     */
    where: AnalyticsAuditLogWhereUniqueInput
  }

  /**
   * AnalyticsAuditLog findUniqueOrThrow
   */
  export type AnalyticsAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsAuditLog to fetch.
     */
    where: AnalyticsAuditLogWhereUniqueInput
  }

  /**
   * AnalyticsAuditLog findFirst
   */
  export type AnalyticsAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsAuditLog to fetch.
     */
    where?: AnalyticsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAuditLogs to fetch.
     */
    orderBy?: AnalyticsAuditLogOrderByWithRelationInput | AnalyticsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsAuditLogs.
     */
    cursor?: AnalyticsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsAuditLogs.
     */
    distinct?: AnalyticsAuditLogScalarFieldEnum | AnalyticsAuditLogScalarFieldEnum[]
  }

  /**
   * AnalyticsAuditLog findFirstOrThrow
   */
  export type AnalyticsAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsAuditLog to fetch.
     */
    where?: AnalyticsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAuditLogs to fetch.
     */
    orderBy?: AnalyticsAuditLogOrderByWithRelationInput | AnalyticsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsAuditLogs.
     */
    cursor?: AnalyticsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsAuditLogs.
     */
    distinct?: AnalyticsAuditLogScalarFieldEnum | AnalyticsAuditLogScalarFieldEnum[]
  }

  /**
   * AnalyticsAuditLog findMany
   */
  export type AnalyticsAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsAuditLogs to fetch.
     */
    where?: AnalyticsAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAuditLogs to fetch.
     */
    orderBy?: AnalyticsAuditLogOrderByWithRelationInput | AnalyticsAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsAuditLogs.
     */
    cursor?: AnalyticsAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAuditLogs.
     */
    skip?: number
    distinct?: AnalyticsAuditLogScalarFieldEnum | AnalyticsAuditLogScalarFieldEnum[]
  }

  /**
   * AnalyticsAuditLog create
   */
  export type AnalyticsAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsAuditLog.
     */
    data: XOR<AnalyticsAuditLogCreateInput, AnalyticsAuditLogUncheckedCreateInput>
  }

  /**
   * AnalyticsAuditLog createMany
   */
  export type AnalyticsAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsAuditLogs.
     */
    data: AnalyticsAuditLogCreateManyInput | AnalyticsAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsAuditLog createManyAndReturn
   */
  export type AnalyticsAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnalyticsAuditLogs.
     */
    data: AnalyticsAuditLogCreateManyInput | AnalyticsAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsAuditLog update
   */
  export type AnalyticsAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsAuditLog.
     */
    data: XOR<AnalyticsAuditLogUpdateInput, AnalyticsAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsAuditLog to update.
     */
    where: AnalyticsAuditLogWhereUniqueInput
  }

  /**
   * AnalyticsAuditLog updateMany
   */
  export type AnalyticsAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsAuditLogs.
     */
    data: XOR<AnalyticsAuditLogUpdateManyMutationInput, AnalyticsAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsAuditLogs to update
     */
    where?: AnalyticsAuditLogWhereInput
  }

  /**
   * AnalyticsAuditLog upsert
   */
  export type AnalyticsAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsAuditLog to update in case it exists.
     */
    where: AnalyticsAuditLogWhereUniqueInput
    /**
     * In case the AnalyticsAuditLog found by the `where` argument doesn't exist, create a new AnalyticsAuditLog with this data.
     */
    create: XOR<AnalyticsAuditLogCreateInput, AnalyticsAuditLogUncheckedCreateInput>
    /**
     * In case the AnalyticsAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsAuditLogUpdateInput, AnalyticsAuditLogUncheckedUpdateInput>
  }

  /**
   * AnalyticsAuditLog delete
   */
  export type AnalyticsAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
    /**
     * Filter which AnalyticsAuditLog to delete.
     */
    where: AnalyticsAuditLogWhereUniqueInput
  }

  /**
   * AnalyticsAuditLog deleteMany
   */
  export type AnalyticsAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsAuditLogs to delete
     */
    where?: AnalyticsAuditLogWhereInput
  }

  /**
   * AnalyticsAuditLog without action
   */
  export type AnalyticsAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAuditLog
     */
    select?: AnalyticsAuditLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PopulationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    organizationId: 'organizationId',
    definitionType: 'definitionType',
    criteria: 'criteria',
    memberCount: 'memberCount',
    status: 'status',
    fhirGroupId: 'fhirGroupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type PopulationScalarFieldEnum = (typeof PopulationScalarFieldEnum)[keyof typeof PopulationScalarFieldEnum]


  export const PopulationMemberScalarFieldEnum: {
    id: 'id',
    populationId: 'populationId',
    patientId: 'patientId',
    fhirPatientRef: 'fhirPatientRef',
    enrolledAt: 'enrolledAt',
    disenrolledAt: 'disenrolledAt',
    status: 'status',
    currentRiskScore: 'currentRiskScore',
    riskTier: 'riskTier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PopulationMemberScalarFieldEnum = (typeof PopulationMemberScalarFieldEnum)[keyof typeof PopulationMemberScalarFieldEnum]


  export const CohortScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    populationId: 'populationId',
    cohortType: 'cohortType',
    criteria: 'criteria',
    memberCount: 'memberCount',
    fhirGroupId: 'fhirGroupId',
    riskLevel: 'riskLevel',
    interventionPriority: 'interventionPriority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type CohortScalarFieldEnum = (typeof CohortScalarFieldEnum)[keyof typeof CohortScalarFieldEnum]


  export const CohortMemberScalarFieldEnum: {
    id: 'id',
    cohortId: 'cohortId',
    patientId: 'patientId',
    fhirPatientRef: 'fhirPatientRef',
    assignedAt: 'assignedAt',
    removedAt: 'removedAt',
    status: 'status',
    riskScore: 'riskScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CohortMemberScalarFieldEnum = (typeof CohortMemberScalarFieldEnum)[keyof typeof CohortMemberScalarFieldEnum]


  export const QualityMeasureScalarFieldEnum: {
    id: 'id',
    measureId: 'measureId',
    name: 'name',
    description: 'description',
    measureType: 'measureType',
    category: 'category',
    steward: 'steward',
    domain: 'domain',
    fhirMeasureId: 'fhirMeasureId',
    fhirVersion: 'fhirVersion',
    numeratorCriteria: 'numeratorCriteria',
    denominatorCriteria: 'denominatorCriteria',
    exclusionCriteria: 'exclusionCriteria',
    targetRate: 'targetRate',
    measurePeriodStart: 'measurePeriodStart',
    measurePeriodEnd: 'measurePeriodEnd',
    reportingYear: 'reportingYear',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QualityMeasureScalarFieldEnum = (typeof QualityMeasureScalarFieldEnum)[keyof typeof QualityMeasureScalarFieldEnum]


  export const PopulationQualityMeasureScalarFieldEnum: {
    id: 'id',
    populationId: 'populationId',
    qualityMeasureId: 'qualityMeasureId',
    numerator: 'numerator',
    denominator: 'denominator',
    exclusions: 'exclusions',
    performanceRate: 'performanceRate',
    benchmarkRate: 'benchmarkRate',
    benchmarkPercentile: 'benchmarkPercentile',
    starRating: 'starRating',
    measurePeriod: 'measurePeriod',
    calculatedAt: 'calculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PopulationQualityMeasureScalarFieldEnum = (typeof PopulationQualityMeasureScalarFieldEnum)[keyof typeof PopulationQualityMeasureScalarFieldEnum]


  export const PatientQualityMeasureScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    fhirPatientRef: 'fhirPatientRef',
    qualityMeasureId: 'qualityMeasureId',
    inDenominator: 'inDenominator',
    inNumerator: 'inNumerator',
    isExcluded: 'isExcluded',
    exclusionReason: 'exclusionReason',
    status: 'status',
    dueDate: 'dueDate',
    completedDate: 'completedDate',
    evidenceRef: 'evidenceRef',
    notes: 'notes',
    measurePeriod: 'measurePeriod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientQualityMeasureScalarFieldEnum = (typeof PatientQualityMeasureScalarFieldEnum)[keyof typeof PatientQualityMeasureScalarFieldEnum]


  export const RiskScoreScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    fhirPatientRef: 'fhirPatientRef',
    modelName: 'modelName',
    modelVersion: 'modelVersion',
    scoreType: 'scoreType',
    rawScore: 'rawScore',
    normalizedScore: 'normalizedScore',
    percentile: 'percentile',
    riskTier: 'riskTier',
    riskFactors: 'riskFactors',
    clinicalFactors: 'clinicalFactors',
    socialFactors: 'socialFactors',
    predictedCost: 'predictedCost',
    predictedEvents: 'predictedEvents',
    effectiveDate: 'effectiveDate',
    expirationDate: 'expirationDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskScoreScalarFieldEnum = (typeof RiskScoreScalarFieldEnum)[keyof typeof RiskScoreScalarFieldEnum]


  export const CareGapScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    fhirPatientRef: 'fhirPatientRef',
    cohortId: 'cohortId',
    gapType: 'gapType',
    title: 'title',
    description: 'description',
    priority: 'priority',
    qualityMeasureId: 'qualityMeasureId',
    recommendedAction: 'recommendedAction',
    actionDueDate: 'actionDueDate',
    status: 'status',
    identifiedAt: 'identifiedAt',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    resolutionNotes: 'resolutionNotes',
    fhirConditionRef: 'fhirConditionRef',
    fhirProcedureRef: 'fhirProcedureRef',
    fhirMedicationRef: 'fhirMedicationRef',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CareGapScalarFieldEnum = (typeof CareGapScalarFieldEnum)[keyof typeof CareGapScalarFieldEnum]


  export const SdohFactorScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    populationId: 'populationId',
    fhirPatientRef: 'fhirPatientRef',
    category: 'category',
    factor: 'factor',
    value: 'value',
    severity: 'severity',
    assessmentDate: 'assessmentDate',
    assessmentTool: 'assessmentTool',
    screeningScore: 'screeningScore',
    isPositiveScreen: 'isPositiveScreen',
    interventionNeeded: 'interventionNeeded',
    interventionType: 'interventionType',
    interventionStatus: 'interventionStatus',
    referralMade: 'referralMade',
    referralDetails: 'referralDetails',
    fhirObservationRef: 'fhirObservationRef',
    fhirConditionRef: 'fhirConditionRef',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SdohFactorScalarFieldEnum = (typeof SdohFactorScalarFieldEnum)[keyof typeof SdohFactorScalarFieldEnum]


  export const DiseaseRegistryScalarFieldEnum: {
    id: 'id',
    conditionCode: 'conditionCode',
    conditionName: 'conditionName',
    populationId: 'populationId',
    prevalenceCount: 'prevalenceCount',
    prevalenceRate: 'prevalenceRate',
    incidenceCount: 'incidenceCount',
    incidenceRate: 'incidenceRate',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    ageDistribution: 'ageDistribution',
    genderDistribution: 'genderDistribution',
    raceDistribution: 'raceDistribution',
    previousPeriodPrevalence: 'previousPeriodPrevalence',
    trendDirection: 'trendDirection',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiseaseRegistryScalarFieldEnum = (typeof DiseaseRegistryScalarFieldEnum)[keyof typeof DiseaseRegistryScalarFieldEnum]


  export const HealthEquityMetricScalarFieldEnum: {
    id: 'id',
    populationId: 'populationId',
    measureType: 'measureType',
    stratificationDimension: 'stratificationDimension',
    stratificationValue: 'stratificationValue',
    metricName: 'metricName',
    metricValue: 'metricValue',
    referenceValue: 'referenceValue',
    disparityIndex: 'disparityIndex',
    confidenceInterval: 'confidenceInterval',
    pValue: 'pValue',
    sampleSize: 'sampleSize',
    measurePeriod: 'measurePeriod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthEquityMetricScalarFieldEnum = (typeof HealthEquityMetricScalarFieldEnum)[keyof typeof HealthEquityMetricScalarFieldEnum]


  export const AnalyticsReportScalarFieldEnum: {
    id: 'id',
    populationId: 'populationId',
    reportType: 'reportType',
    title: 'title',
    description: 'description',
    parameters: 'parameters',
    data: 'data',
    visualizations: 'visualizations',
    generatedAt: 'generatedAt',
    generatedBy: 'generatedBy',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    exportFormats: 'exportFormats',
    lastExportedAt: 'lastExportedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsReportScalarFieldEnum = (typeof AnalyticsReportScalarFieldEnum)[keyof typeof AnalyticsReportScalarFieldEnum]


  export const PredictiveModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    modelType: 'modelType',
    algorithm: 'algorithm',
    features: 'features',
    hyperparameters: 'hyperparameters',
    accuracy: 'accuracy',
    auc: 'auc',
    precision: 'precision',
    recall: 'recall',
    f1Score: 'f1Score',
    version: 'version',
    isActive: 'isActive',
    trainedAt: 'trainedAt',
    trainingSampleSize: 'trainingSampleSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PredictiveModelScalarFieldEnum = (typeof PredictiveModelScalarFieldEnum)[keyof typeof PredictiveModelScalarFieldEnum]


  export const AnalyticsAuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AnalyticsAuditLogScalarFieldEnum = (typeof AnalyticsAuditLogScalarFieldEnum)[keyof typeof AnalyticsAuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DefinitionType'
   */
  export type EnumDefinitionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefinitionType'>
    


  /**
   * Reference to a field of type 'DefinitionType[]'
   */
  export type ListEnumDefinitionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefinitionType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PopulationStatus'
   */
  export type EnumPopulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PopulationStatus'>
    


  /**
   * Reference to a field of type 'PopulationStatus[]'
   */
  export type ListEnumPopulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PopulationStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MemberStatus'
   */
  export type EnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus'>
    


  /**
   * Reference to a field of type 'MemberStatus[]'
   */
  export type ListEnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RiskTier'
   */
  export type EnumRiskTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskTier'>
    


  /**
   * Reference to a field of type 'RiskTier[]'
   */
  export type ListEnumRiskTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskTier[]'>
    


  /**
   * Reference to a field of type 'CohortType'
   */
  export type EnumCohortTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CohortType'>
    


  /**
   * Reference to a field of type 'CohortType[]'
   */
  export type ListEnumCohortTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CohortType[]'>
    


  /**
   * Reference to a field of type 'MeasureType'
   */
  export type EnumMeasureTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasureType'>
    


  /**
   * Reference to a field of type 'MeasureType[]'
   */
  export type ListEnumMeasureTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasureType[]'>
    


  /**
   * Reference to a field of type 'MeasureCategory'
   */
  export type EnumMeasureCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasureCategory'>
    


  /**
   * Reference to a field of type 'MeasureCategory[]'
   */
  export type ListEnumMeasureCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasureCategory[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ComplianceStatus'
   */
  export type EnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus'>
    


  /**
   * Reference to a field of type 'ComplianceStatus[]'
   */
  export type ListEnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus[]'>
    


  /**
   * Reference to a field of type 'ScoreType'
   */
  export type EnumScoreTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreType'>
    


  /**
   * Reference to a field of type 'ScoreType[]'
   */
  export type ListEnumScoreTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreType[]'>
    


  /**
   * Reference to a field of type 'GapType'
   */
  export type EnumGapTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GapType'>
    


  /**
   * Reference to a field of type 'GapType[]'
   */
  export type ListEnumGapTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GapType[]'>
    


  /**
   * Reference to a field of type 'GapPriority'
   */
  export type EnumGapPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GapPriority'>
    


  /**
   * Reference to a field of type 'GapPriority[]'
   */
  export type ListEnumGapPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GapPriority[]'>
    


  /**
   * Reference to a field of type 'GapStatus'
   */
  export type EnumGapStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GapStatus'>
    


  /**
   * Reference to a field of type 'GapStatus[]'
   */
  export type ListEnumGapStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GapStatus[]'>
    


  /**
   * Reference to a field of type 'SdohCategory'
   */
  export type EnumSdohCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SdohCategory'>
    


  /**
   * Reference to a field of type 'SdohCategory[]'
   */
  export type ListEnumSdohCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SdohCategory[]'>
    


  /**
   * Reference to a field of type 'SdohSeverity'
   */
  export type EnumSdohSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SdohSeverity'>
    


  /**
   * Reference to a field of type 'SdohSeverity[]'
   */
  export type ListEnumSdohSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SdohSeverity[]'>
    


  /**
   * Reference to a field of type 'TrendDirection'
   */
  export type EnumTrendDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrendDirection'>
    


  /**
   * Reference to a field of type 'TrendDirection[]'
   */
  export type ListEnumTrendDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrendDirection[]'>
    


  /**
   * Reference to a field of type 'EquityMeasureType'
   */
  export type EnumEquityMeasureTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquityMeasureType'>
    


  /**
   * Reference to a field of type 'EquityMeasureType[]'
   */
  export type ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquityMeasureType[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'PredictiveModelType'
   */
  export type EnumPredictiveModelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PredictiveModelType'>
    


  /**
   * Reference to a field of type 'PredictiveModelType[]'
   */
  export type ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PredictiveModelType[]'>
    
  /**
   * Deep Input Types
   */


  export type PopulationWhereInput = {
    AND?: PopulationWhereInput | PopulationWhereInput[]
    OR?: PopulationWhereInput[]
    NOT?: PopulationWhereInput | PopulationWhereInput[]
    id?: StringFilter<"Population"> | string
    name?: StringFilter<"Population"> | string
    description?: StringNullableFilter<"Population"> | string | null
    organizationId?: StringFilter<"Population"> | string
    definitionType?: EnumDefinitionTypeFilter<"Population"> | $Enums.DefinitionType
    criteria?: JsonFilter<"Population">
    memberCount?: IntFilter<"Population"> | number
    status?: EnumPopulationStatusFilter<"Population"> | $Enums.PopulationStatus
    fhirGroupId?: StringNullableFilter<"Population"> | string | null
    createdAt?: DateTimeFilter<"Population"> | Date | string
    updatedAt?: DateTimeFilter<"Population"> | Date | string
    createdBy?: StringNullableFilter<"Population"> | string | null
    cohorts?: CohortListRelationFilter
    qualityMeasures?: PopulationQualityMeasureListRelationFilter
    analytics?: AnalyticsReportListRelationFilter
    sdohFactors?: SdohFactorListRelationFilter
  }

  export type PopulationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    definitionType?: SortOrder
    criteria?: SortOrder
    memberCount?: SortOrder
    status?: SortOrder
    fhirGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    cohorts?: CohortOrderByRelationAggregateInput
    qualityMeasures?: PopulationQualityMeasureOrderByRelationAggregateInput
    analytics?: AnalyticsReportOrderByRelationAggregateInput
    sdohFactors?: SdohFactorOrderByRelationAggregateInput
  }

  export type PopulationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PopulationWhereInput | PopulationWhereInput[]
    OR?: PopulationWhereInput[]
    NOT?: PopulationWhereInput | PopulationWhereInput[]
    name?: StringFilter<"Population"> | string
    description?: StringNullableFilter<"Population"> | string | null
    organizationId?: StringFilter<"Population"> | string
    definitionType?: EnumDefinitionTypeFilter<"Population"> | $Enums.DefinitionType
    criteria?: JsonFilter<"Population">
    memberCount?: IntFilter<"Population"> | number
    status?: EnumPopulationStatusFilter<"Population"> | $Enums.PopulationStatus
    fhirGroupId?: StringNullableFilter<"Population"> | string | null
    createdAt?: DateTimeFilter<"Population"> | Date | string
    updatedAt?: DateTimeFilter<"Population"> | Date | string
    createdBy?: StringNullableFilter<"Population"> | string | null
    cohorts?: CohortListRelationFilter
    qualityMeasures?: PopulationQualityMeasureListRelationFilter
    analytics?: AnalyticsReportListRelationFilter
    sdohFactors?: SdohFactorListRelationFilter
  }, "id">

  export type PopulationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    definitionType?: SortOrder
    criteria?: SortOrder
    memberCount?: SortOrder
    status?: SortOrder
    fhirGroupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: PopulationCountOrderByAggregateInput
    _avg?: PopulationAvgOrderByAggregateInput
    _max?: PopulationMaxOrderByAggregateInput
    _min?: PopulationMinOrderByAggregateInput
    _sum?: PopulationSumOrderByAggregateInput
  }

  export type PopulationScalarWhereWithAggregatesInput = {
    AND?: PopulationScalarWhereWithAggregatesInput | PopulationScalarWhereWithAggregatesInput[]
    OR?: PopulationScalarWhereWithAggregatesInput[]
    NOT?: PopulationScalarWhereWithAggregatesInput | PopulationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Population"> | string
    name?: StringWithAggregatesFilter<"Population"> | string
    description?: StringNullableWithAggregatesFilter<"Population"> | string | null
    organizationId?: StringWithAggregatesFilter<"Population"> | string
    definitionType?: EnumDefinitionTypeWithAggregatesFilter<"Population"> | $Enums.DefinitionType
    criteria?: JsonWithAggregatesFilter<"Population">
    memberCount?: IntWithAggregatesFilter<"Population"> | number
    status?: EnumPopulationStatusWithAggregatesFilter<"Population"> | $Enums.PopulationStatus
    fhirGroupId?: StringNullableWithAggregatesFilter<"Population"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Population"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Population"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Population"> | string | null
  }

  export type PopulationMemberWhereInput = {
    AND?: PopulationMemberWhereInput | PopulationMemberWhereInput[]
    OR?: PopulationMemberWhereInput[]
    NOT?: PopulationMemberWhereInput | PopulationMemberWhereInput[]
    id?: StringFilter<"PopulationMember"> | string
    populationId?: StringFilter<"PopulationMember"> | string
    patientId?: StringFilter<"PopulationMember"> | string
    fhirPatientRef?: StringNullableFilter<"PopulationMember"> | string | null
    enrolledAt?: DateTimeFilter<"PopulationMember"> | Date | string
    disenrolledAt?: DateTimeNullableFilter<"PopulationMember"> | Date | string | null
    status?: EnumMemberStatusFilter<"PopulationMember"> | $Enums.MemberStatus
    currentRiskScore?: FloatNullableFilter<"PopulationMember"> | number | null
    riskTier?: EnumRiskTierNullableFilter<"PopulationMember"> | $Enums.RiskTier | null
    createdAt?: DateTimeFilter<"PopulationMember"> | Date | string
    updatedAt?: DateTimeFilter<"PopulationMember"> | Date | string
  }

  export type PopulationMemberOrderByWithRelationInput = {
    id?: SortOrder
    populationId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    disenrolledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    currentRiskScore?: SortOrderInput | SortOrder
    riskTier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PopulationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    populationId_patientId?: PopulationMemberPopulationIdPatientIdCompoundUniqueInput
    AND?: PopulationMemberWhereInput | PopulationMemberWhereInput[]
    OR?: PopulationMemberWhereInput[]
    NOT?: PopulationMemberWhereInput | PopulationMemberWhereInput[]
    populationId?: StringFilter<"PopulationMember"> | string
    patientId?: StringFilter<"PopulationMember"> | string
    fhirPatientRef?: StringNullableFilter<"PopulationMember"> | string | null
    enrolledAt?: DateTimeFilter<"PopulationMember"> | Date | string
    disenrolledAt?: DateTimeNullableFilter<"PopulationMember"> | Date | string | null
    status?: EnumMemberStatusFilter<"PopulationMember"> | $Enums.MemberStatus
    currentRiskScore?: FloatNullableFilter<"PopulationMember"> | number | null
    riskTier?: EnumRiskTierNullableFilter<"PopulationMember"> | $Enums.RiskTier | null
    createdAt?: DateTimeFilter<"PopulationMember"> | Date | string
    updatedAt?: DateTimeFilter<"PopulationMember"> | Date | string
  }, "id" | "populationId_patientId">

  export type PopulationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    populationId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    disenrolledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    currentRiskScore?: SortOrderInput | SortOrder
    riskTier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PopulationMemberCountOrderByAggregateInput
    _avg?: PopulationMemberAvgOrderByAggregateInput
    _max?: PopulationMemberMaxOrderByAggregateInput
    _min?: PopulationMemberMinOrderByAggregateInput
    _sum?: PopulationMemberSumOrderByAggregateInput
  }

  export type PopulationMemberScalarWhereWithAggregatesInput = {
    AND?: PopulationMemberScalarWhereWithAggregatesInput | PopulationMemberScalarWhereWithAggregatesInput[]
    OR?: PopulationMemberScalarWhereWithAggregatesInput[]
    NOT?: PopulationMemberScalarWhereWithAggregatesInput | PopulationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PopulationMember"> | string
    populationId?: StringWithAggregatesFilter<"PopulationMember"> | string
    patientId?: StringWithAggregatesFilter<"PopulationMember"> | string
    fhirPatientRef?: StringNullableWithAggregatesFilter<"PopulationMember"> | string | null
    enrolledAt?: DateTimeWithAggregatesFilter<"PopulationMember"> | Date | string
    disenrolledAt?: DateTimeNullableWithAggregatesFilter<"PopulationMember"> | Date | string | null
    status?: EnumMemberStatusWithAggregatesFilter<"PopulationMember"> | $Enums.MemberStatus
    currentRiskScore?: FloatNullableWithAggregatesFilter<"PopulationMember"> | number | null
    riskTier?: EnumRiskTierNullableWithAggregatesFilter<"PopulationMember"> | $Enums.RiskTier | null
    createdAt?: DateTimeWithAggregatesFilter<"PopulationMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PopulationMember"> | Date | string
  }

  export type CohortWhereInput = {
    AND?: CohortWhereInput | CohortWhereInput[]
    OR?: CohortWhereInput[]
    NOT?: CohortWhereInput | CohortWhereInput[]
    id?: StringFilter<"Cohort"> | string
    name?: StringFilter<"Cohort"> | string
    description?: StringNullableFilter<"Cohort"> | string | null
    populationId?: StringFilter<"Cohort"> | string
    cohortType?: EnumCohortTypeFilter<"Cohort"> | $Enums.CohortType
    criteria?: JsonFilter<"Cohort">
    memberCount?: IntFilter<"Cohort"> | number
    fhirGroupId?: StringNullableFilter<"Cohort"> | string | null
    riskLevel?: EnumRiskTierNullableFilter<"Cohort"> | $Enums.RiskTier | null
    interventionPriority?: IntNullableFilter<"Cohort"> | number | null
    createdAt?: DateTimeFilter<"Cohort"> | Date | string
    updatedAt?: DateTimeFilter<"Cohort"> | Date | string
    createdBy?: StringNullableFilter<"Cohort"> | string | null
    population?: XOR<PopulationRelationFilter, PopulationWhereInput>
    careGaps?: CareGapListRelationFilter
  }

  export type CohortOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    populationId?: SortOrder
    cohortType?: SortOrder
    criteria?: SortOrder
    memberCount?: SortOrder
    fhirGroupId?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    interventionPriority?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    population?: PopulationOrderByWithRelationInput
    careGaps?: CareGapOrderByRelationAggregateInput
  }

  export type CohortWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CohortWhereInput | CohortWhereInput[]
    OR?: CohortWhereInput[]
    NOT?: CohortWhereInput | CohortWhereInput[]
    name?: StringFilter<"Cohort"> | string
    description?: StringNullableFilter<"Cohort"> | string | null
    populationId?: StringFilter<"Cohort"> | string
    cohortType?: EnumCohortTypeFilter<"Cohort"> | $Enums.CohortType
    criteria?: JsonFilter<"Cohort">
    memberCount?: IntFilter<"Cohort"> | number
    fhirGroupId?: StringNullableFilter<"Cohort"> | string | null
    riskLevel?: EnumRiskTierNullableFilter<"Cohort"> | $Enums.RiskTier | null
    interventionPriority?: IntNullableFilter<"Cohort"> | number | null
    createdAt?: DateTimeFilter<"Cohort"> | Date | string
    updatedAt?: DateTimeFilter<"Cohort"> | Date | string
    createdBy?: StringNullableFilter<"Cohort"> | string | null
    population?: XOR<PopulationRelationFilter, PopulationWhereInput>
    careGaps?: CareGapListRelationFilter
  }, "id">

  export type CohortOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    populationId?: SortOrder
    cohortType?: SortOrder
    criteria?: SortOrder
    memberCount?: SortOrder
    fhirGroupId?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    interventionPriority?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: CohortCountOrderByAggregateInput
    _avg?: CohortAvgOrderByAggregateInput
    _max?: CohortMaxOrderByAggregateInput
    _min?: CohortMinOrderByAggregateInput
    _sum?: CohortSumOrderByAggregateInput
  }

  export type CohortScalarWhereWithAggregatesInput = {
    AND?: CohortScalarWhereWithAggregatesInput | CohortScalarWhereWithAggregatesInput[]
    OR?: CohortScalarWhereWithAggregatesInput[]
    NOT?: CohortScalarWhereWithAggregatesInput | CohortScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cohort"> | string
    name?: StringWithAggregatesFilter<"Cohort"> | string
    description?: StringNullableWithAggregatesFilter<"Cohort"> | string | null
    populationId?: StringWithAggregatesFilter<"Cohort"> | string
    cohortType?: EnumCohortTypeWithAggregatesFilter<"Cohort"> | $Enums.CohortType
    criteria?: JsonWithAggregatesFilter<"Cohort">
    memberCount?: IntWithAggregatesFilter<"Cohort"> | number
    fhirGroupId?: StringNullableWithAggregatesFilter<"Cohort"> | string | null
    riskLevel?: EnumRiskTierNullableWithAggregatesFilter<"Cohort"> | $Enums.RiskTier | null
    interventionPriority?: IntNullableWithAggregatesFilter<"Cohort"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Cohort"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cohort"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Cohort"> | string | null
  }

  export type CohortMemberWhereInput = {
    AND?: CohortMemberWhereInput | CohortMemberWhereInput[]
    OR?: CohortMemberWhereInput[]
    NOT?: CohortMemberWhereInput | CohortMemberWhereInput[]
    id?: StringFilter<"CohortMember"> | string
    cohortId?: StringFilter<"CohortMember"> | string
    patientId?: StringFilter<"CohortMember"> | string
    fhirPatientRef?: StringNullableFilter<"CohortMember"> | string | null
    assignedAt?: DateTimeFilter<"CohortMember"> | Date | string
    removedAt?: DateTimeNullableFilter<"CohortMember"> | Date | string | null
    status?: EnumMemberStatusFilter<"CohortMember"> | $Enums.MemberStatus
    riskScore?: FloatNullableFilter<"CohortMember"> | number | null
    createdAt?: DateTimeFilter<"CohortMember"> | Date | string
    updatedAt?: DateTimeFilter<"CohortMember"> | Date | string
  }

  export type CohortMemberOrderByWithRelationInput = {
    id?: SortOrder
    cohortId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    riskScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cohortId_patientId?: CohortMemberCohortIdPatientIdCompoundUniqueInput
    AND?: CohortMemberWhereInput | CohortMemberWhereInput[]
    OR?: CohortMemberWhereInput[]
    NOT?: CohortMemberWhereInput | CohortMemberWhereInput[]
    cohortId?: StringFilter<"CohortMember"> | string
    patientId?: StringFilter<"CohortMember"> | string
    fhirPatientRef?: StringNullableFilter<"CohortMember"> | string | null
    assignedAt?: DateTimeFilter<"CohortMember"> | Date | string
    removedAt?: DateTimeNullableFilter<"CohortMember"> | Date | string | null
    status?: EnumMemberStatusFilter<"CohortMember"> | $Enums.MemberStatus
    riskScore?: FloatNullableFilter<"CohortMember"> | number | null
    createdAt?: DateTimeFilter<"CohortMember"> | Date | string
    updatedAt?: DateTimeFilter<"CohortMember"> | Date | string
  }, "id" | "cohortId_patientId">

  export type CohortMemberOrderByWithAggregationInput = {
    id?: SortOrder
    cohortId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    riskScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CohortMemberCountOrderByAggregateInput
    _avg?: CohortMemberAvgOrderByAggregateInput
    _max?: CohortMemberMaxOrderByAggregateInput
    _min?: CohortMemberMinOrderByAggregateInput
    _sum?: CohortMemberSumOrderByAggregateInput
  }

  export type CohortMemberScalarWhereWithAggregatesInput = {
    AND?: CohortMemberScalarWhereWithAggregatesInput | CohortMemberScalarWhereWithAggregatesInput[]
    OR?: CohortMemberScalarWhereWithAggregatesInput[]
    NOT?: CohortMemberScalarWhereWithAggregatesInput | CohortMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CohortMember"> | string
    cohortId?: StringWithAggregatesFilter<"CohortMember"> | string
    patientId?: StringWithAggregatesFilter<"CohortMember"> | string
    fhirPatientRef?: StringNullableWithAggregatesFilter<"CohortMember"> | string | null
    assignedAt?: DateTimeWithAggregatesFilter<"CohortMember"> | Date | string
    removedAt?: DateTimeNullableWithAggregatesFilter<"CohortMember"> | Date | string | null
    status?: EnumMemberStatusWithAggregatesFilter<"CohortMember"> | $Enums.MemberStatus
    riskScore?: FloatNullableWithAggregatesFilter<"CohortMember"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CohortMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CohortMember"> | Date | string
  }

  export type QualityMeasureWhereInput = {
    AND?: QualityMeasureWhereInput | QualityMeasureWhereInput[]
    OR?: QualityMeasureWhereInput[]
    NOT?: QualityMeasureWhereInput | QualityMeasureWhereInput[]
    id?: StringFilter<"QualityMeasure"> | string
    measureId?: StringFilter<"QualityMeasure"> | string
    name?: StringFilter<"QualityMeasure"> | string
    description?: StringNullableFilter<"QualityMeasure"> | string | null
    measureType?: EnumMeasureTypeFilter<"QualityMeasure"> | $Enums.MeasureType
    category?: EnumMeasureCategoryFilter<"QualityMeasure"> | $Enums.MeasureCategory
    steward?: StringNullableFilter<"QualityMeasure"> | string | null
    domain?: StringNullableFilter<"QualityMeasure"> | string | null
    fhirMeasureId?: StringNullableFilter<"QualityMeasure"> | string | null
    fhirVersion?: StringNullableFilter<"QualityMeasure"> | string | null
    numeratorCriteria?: JsonNullableFilter<"QualityMeasure">
    denominatorCriteria?: JsonNullableFilter<"QualityMeasure">
    exclusionCriteria?: JsonNullableFilter<"QualityMeasure">
    targetRate?: FloatNullableFilter<"QualityMeasure"> | number | null
    measurePeriodStart?: DateTimeNullableFilter<"QualityMeasure"> | Date | string | null
    measurePeriodEnd?: DateTimeNullableFilter<"QualityMeasure"> | Date | string | null
    reportingYear?: IntNullableFilter<"QualityMeasure"> | number | null
    isActive?: BoolFilter<"QualityMeasure"> | boolean
    createdAt?: DateTimeFilter<"QualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"QualityMeasure"> | Date | string
    populationMeasures?: PopulationQualityMeasureListRelationFilter
    patientMeasures?: PatientQualityMeasureListRelationFilter
  }

  export type QualityMeasureOrderByWithRelationInput = {
    id?: SortOrder
    measureId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    measureType?: SortOrder
    category?: SortOrder
    steward?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    fhirMeasureId?: SortOrderInput | SortOrder
    fhirVersion?: SortOrderInput | SortOrder
    numeratorCriteria?: SortOrderInput | SortOrder
    denominatorCriteria?: SortOrderInput | SortOrder
    exclusionCriteria?: SortOrderInput | SortOrder
    targetRate?: SortOrderInput | SortOrder
    measurePeriodStart?: SortOrderInput | SortOrder
    measurePeriodEnd?: SortOrderInput | SortOrder
    reportingYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    populationMeasures?: PopulationQualityMeasureOrderByRelationAggregateInput
    patientMeasures?: PatientQualityMeasureOrderByRelationAggregateInput
  }

  export type QualityMeasureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    measureId?: string
    AND?: QualityMeasureWhereInput | QualityMeasureWhereInput[]
    OR?: QualityMeasureWhereInput[]
    NOT?: QualityMeasureWhereInput | QualityMeasureWhereInput[]
    name?: StringFilter<"QualityMeasure"> | string
    description?: StringNullableFilter<"QualityMeasure"> | string | null
    measureType?: EnumMeasureTypeFilter<"QualityMeasure"> | $Enums.MeasureType
    category?: EnumMeasureCategoryFilter<"QualityMeasure"> | $Enums.MeasureCategory
    steward?: StringNullableFilter<"QualityMeasure"> | string | null
    domain?: StringNullableFilter<"QualityMeasure"> | string | null
    fhirMeasureId?: StringNullableFilter<"QualityMeasure"> | string | null
    fhirVersion?: StringNullableFilter<"QualityMeasure"> | string | null
    numeratorCriteria?: JsonNullableFilter<"QualityMeasure">
    denominatorCriteria?: JsonNullableFilter<"QualityMeasure">
    exclusionCriteria?: JsonNullableFilter<"QualityMeasure">
    targetRate?: FloatNullableFilter<"QualityMeasure"> | number | null
    measurePeriodStart?: DateTimeNullableFilter<"QualityMeasure"> | Date | string | null
    measurePeriodEnd?: DateTimeNullableFilter<"QualityMeasure"> | Date | string | null
    reportingYear?: IntNullableFilter<"QualityMeasure"> | number | null
    isActive?: BoolFilter<"QualityMeasure"> | boolean
    createdAt?: DateTimeFilter<"QualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"QualityMeasure"> | Date | string
    populationMeasures?: PopulationQualityMeasureListRelationFilter
    patientMeasures?: PatientQualityMeasureListRelationFilter
  }, "id" | "measureId">

  export type QualityMeasureOrderByWithAggregationInput = {
    id?: SortOrder
    measureId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    measureType?: SortOrder
    category?: SortOrder
    steward?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    fhirMeasureId?: SortOrderInput | SortOrder
    fhirVersion?: SortOrderInput | SortOrder
    numeratorCriteria?: SortOrderInput | SortOrder
    denominatorCriteria?: SortOrderInput | SortOrder
    exclusionCriteria?: SortOrderInput | SortOrder
    targetRate?: SortOrderInput | SortOrder
    measurePeriodStart?: SortOrderInput | SortOrder
    measurePeriodEnd?: SortOrderInput | SortOrder
    reportingYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QualityMeasureCountOrderByAggregateInput
    _avg?: QualityMeasureAvgOrderByAggregateInput
    _max?: QualityMeasureMaxOrderByAggregateInput
    _min?: QualityMeasureMinOrderByAggregateInput
    _sum?: QualityMeasureSumOrderByAggregateInput
  }

  export type QualityMeasureScalarWhereWithAggregatesInput = {
    AND?: QualityMeasureScalarWhereWithAggregatesInput | QualityMeasureScalarWhereWithAggregatesInput[]
    OR?: QualityMeasureScalarWhereWithAggregatesInput[]
    NOT?: QualityMeasureScalarWhereWithAggregatesInput | QualityMeasureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QualityMeasure"> | string
    measureId?: StringWithAggregatesFilter<"QualityMeasure"> | string
    name?: StringWithAggregatesFilter<"QualityMeasure"> | string
    description?: StringNullableWithAggregatesFilter<"QualityMeasure"> | string | null
    measureType?: EnumMeasureTypeWithAggregatesFilter<"QualityMeasure"> | $Enums.MeasureType
    category?: EnumMeasureCategoryWithAggregatesFilter<"QualityMeasure"> | $Enums.MeasureCategory
    steward?: StringNullableWithAggregatesFilter<"QualityMeasure"> | string | null
    domain?: StringNullableWithAggregatesFilter<"QualityMeasure"> | string | null
    fhirMeasureId?: StringNullableWithAggregatesFilter<"QualityMeasure"> | string | null
    fhirVersion?: StringNullableWithAggregatesFilter<"QualityMeasure"> | string | null
    numeratorCriteria?: JsonNullableWithAggregatesFilter<"QualityMeasure">
    denominatorCriteria?: JsonNullableWithAggregatesFilter<"QualityMeasure">
    exclusionCriteria?: JsonNullableWithAggregatesFilter<"QualityMeasure">
    targetRate?: FloatNullableWithAggregatesFilter<"QualityMeasure"> | number | null
    measurePeriodStart?: DateTimeNullableWithAggregatesFilter<"QualityMeasure"> | Date | string | null
    measurePeriodEnd?: DateTimeNullableWithAggregatesFilter<"QualityMeasure"> | Date | string | null
    reportingYear?: IntNullableWithAggregatesFilter<"QualityMeasure"> | number | null
    isActive?: BoolWithAggregatesFilter<"QualityMeasure"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QualityMeasure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QualityMeasure"> | Date | string
  }

  export type PopulationQualityMeasureWhereInput = {
    AND?: PopulationQualityMeasureWhereInput | PopulationQualityMeasureWhereInput[]
    OR?: PopulationQualityMeasureWhereInput[]
    NOT?: PopulationQualityMeasureWhereInput | PopulationQualityMeasureWhereInput[]
    id?: StringFilter<"PopulationQualityMeasure"> | string
    populationId?: StringFilter<"PopulationQualityMeasure"> | string
    qualityMeasureId?: StringFilter<"PopulationQualityMeasure"> | string
    numerator?: IntFilter<"PopulationQualityMeasure"> | number
    denominator?: IntFilter<"PopulationQualityMeasure"> | number
    exclusions?: IntFilter<"PopulationQualityMeasure"> | number
    performanceRate?: FloatNullableFilter<"PopulationQualityMeasure"> | number | null
    benchmarkRate?: FloatNullableFilter<"PopulationQualityMeasure"> | number | null
    benchmarkPercentile?: IntNullableFilter<"PopulationQualityMeasure"> | number | null
    starRating?: IntNullableFilter<"PopulationQualityMeasure"> | number | null
    measurePeriod?: StringFilter<"PopulationQualityMeasure"> | string
    calculatedAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    createdAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    population?: XOR<PopulationRelationFilter, PopulationWhereInput>
    qualityMeasure?: XOR<QualityMeasureRelationFilter, QualityMeasureWhereInput>
  }

  export type PopulationQualityMeasureOrderByWithRelationInput = {
    id?: SortOrder
    populationId?: SortOrder
    qualityMeasureId?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    exclusions?: SortOrder
    performanceRate?: SortOrderInput | SortOrder
    benchmarkRate?: SortOrderInput | SortOrder
    benchmarkPercentile?: SortOrderInput | SortOrder
    starRating?: SortOrderInput | SortOrder
    measurePeriod?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    population?: PopulationOrderByWithRelationInput
    qualityMeasure?: QualityMeasureOrderByWithRelationInput
  }

  export type PopulationQualityMeasureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    populationId_qualityMeasureId_measurePeriod?: PopulationQualityMeasurePopulationIdQualityMeasureIdMeasurePeriodCompoundUniqueInput
    AND?: PopulationQualityMeasureWhereInput | PopulationQualityMeasureWhereInput[]
    OR?: PopulationQualityMeasureWhereInput[]
    NOT?: PopulationQualityMeasureWhereInput | PopulationQualityMeasureWhereInput[]
    populationId?: StringFilter<"PopulationQualityMeasure"> | string
    qualityMeasureId?: StringFilter<"PopulationQualityMeasure"> | string
    numerator?: IntFilter<"PopulationQualityMeasure"> | number
    denominator?: IntFilter<"PopulationQualityMeasure"> | number
    exclusions?: IntFilter<"PopulationQualityMeasure"> | number
    performanceRate?: FloatNullableFilter<"PopulationQualityMeasure"> | number | null
    benchmarkRate?: FloatNullableFilter<"PopulationQualityMeasure"> | number | null
    benchmarkPercentile?: IntNullableFilter<"PopulationQualityMeasure"> | number | null
    starRating?: IntNullableFilter<"PopulationQualityMeasure"> | number | null
    measurePeriod?: StringFilter<"PopulationQualityMeasure"> | string
    calculatedAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    createdAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    population?: XOR<PopulationRelationFilter, PopulationWhereInput>
    qualityMeasure?: XOR<QualityMeasureRelationFilter, QualityMeasureWhereInput>
  }, "id" | "populationId_qualityMeasureId_measurePeriod">

  export type PopulationQualityMeasureOrderByWithAggregationInput = {
    id?: SortOrder
    populationId?: SortOrder
    qualityMeasureId?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    exclusions?: SortOrder
    performanceRate?: SortOrderInput | SortOrder
    benchmarkRate?: SortOrderInput | SortOrder
    benchmarkPercentile?: SortOrderInput | SortOrder
    starRating?: SortOrderInput | SortOrder
    measurePeriod?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PopulationQualityMeasureCountOrderByAggregateInput
    _avg?: PopulationQualityMeasureAvgOrderByAggregateInput
    _max?: PopulationQualityMeasureMaxOrderByAggregateInput
    _min?: PopulationQualityMeasureMinOrderByAggregateInput
    _sum?: PopulationQualityMeasureSumOrderByAggregateInput
  }

  export type PopulationQualityMeasureScalarWhereWithAggregatesInput = {
    AND?: PopulationQualityMeasureScalarWhereWithAggregatesInput | PopulationQualityMeasureScalarWhereWithAggregatesInput[]
    OR?: PopulationQualityMeasureScalarWhereWithAggregatesInput[]
    NOT?: PopulationQualityMeasureScalarWhereWithAggregatesInput | PopulationQualityMeasureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PopulationQualityMeasure"> | string
    populationId?: StringWithAggregatesFilter<"PopulationQualityMeasure"> | string
    qualityMeasureId?: StringWithAggregatesFilter<"PopulationQualityMeasure"> | string
    numerator?: IntWithAggregatesFilter<"PopulationQualityMeasure"> | number
    denominator?: IntWithAggregatesFilter<"PopulationQualityMeasure"> | number
    exclusions?: IntWithAggregatesFilter<"PopulationQualityMeasure"> | number
    performanceRate?: FloatNullableWithAggregatesFilter<"PopulationQualityMeasure"> | number | null
    benchmarkRate?: FloatNullableWithAggregatesFilter<"PopulationQualityMeasure"> | number | null
    benchmarkPercentile?: IntNullableWithAggregatesFilter<"PopulationQualityMeasure"> | number | null
    starRating?: IntNullableWithAggregatesFilter<"PopulationQualityMeasure"> | number | null
    measurePeriod?: StringWithAggregatesFilter<"PopulationQualityMeasure"> | string
    calculatedAt?: DateTimeWithAggregatesFilter<"PopulationQualityMeasure"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PopulationQualityMeasure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PopulationQualityMeasure"> | Date | string
  }

  export type PatientQualityMeasureWhereInput = {
    AND?: PatientQualityMeasureWhereInput | PatientQualityMeasureWhereInput[]
    OR?: PatientQualityMeasureWhereInput[]
    NOT?: PatientQualityMeasureWhereInput | PatientQualityMeasureWhereInput[]
    id?: StringFilter<"PatientQualityMeasure"> | string
    patientId?: StringFilter<"PatientQualityMeasure"> | string
    fhirPatientRef?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    qualityMeasureId?: StringFilter<"PatientQualityMeasure"> | string
    inDenominator?: BoolFilter<"PatientQualityMeasure"> | boolean
    inNumerator?: BoolFilter<"PatientQualityMeasure"> | boolean
    isExcluded?: BoolFilter<"PatientQualityMeasure"> | boolean
    exclusionReason?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    status?: EnumComplianceStatusFilter<"PatientQualityMeasure"> | $Enums.ComplianceStatus
    dueDate?: DateTimeNullableFilter<"PatientQualityMeasure"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"PatientQualityMeasure"> | Date | string | null
    evidenceRef?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    notes?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    measurePeriod?: StringFilter<"PatientQualityMeasure"> | string
    createdAt?: DateTimeFilter<"PatientQualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"PatientQualityMeasure"> | Date | string
    qualityMeasure?: XOR<QualityMeasureRelationFilter, QualityMeasureWhereInput>
  }

  export type PatientQualityMeasureOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    qualityMeasureId?: SortOrder
    inDenominator?: SortOrder
    inNumerator?: SortOrder
    isExcluded?: SortOrder
    exclusionReason?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    evidenceRef?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    qualityMeasure?: QualityMeasureOrderByWithRelationInput
  }

  export type PatientQualityMeasureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patientId_qualityMeasureId_measurePeriod?: PatientQualityMeasurePatientIdQualityMeasureIdMeasurePeriodCompoundUniqueInput
    AND?: PatientQualityMeasureWhereInput | PatientQualityMeasureWhereInput[]
    OR?: PatientQualityMeasureWhereInput[]
    NOT?: PatientQualityMeasureWhereInput | PatientQualityMeasureWhereInput[]
    patientId?: StringFilter<"PatientQualityMeasure"> | string
    fhirPatientRef?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    qualityMeasureId?: StringFilter<"PatientQualityMeasure"> | string
    inDenominator?: BoolFilter<"PatientQualityMeasure"> | boolean
    inNumerator?: BoolFilter<"PatientQualityMeasure"> | boolean
    isExcluded?: BoolFilter<"PatientQualityMeasure"> | boolean
    exclusionReason?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    status?: EnumComplianceStatusFilter<"PatientQualityMeasure"> | $Enums.ComplianceStatus
    dueDate?: DateTimeNullableFilter<"PatientQualityMeasure"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"PatientQualityMeasure"> | Date | string | null
    evidenceRef?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    notes?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    measurePeriod?: StringFilter<"PatientQualityMeasure"> | string
    createdAt?: DateTimeFilter<"PatientQualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"PatientQualityMeasure"> | Date | string
    qualityMeasure?: XOR<QualityMeasureRelationFilter, QualityMeasureWhereInput>
  }, "id" | "patientId_qualityMeasureId_measurePeriod">

  export type PatientQualityMeasureOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    qualityMeasureId?: SortOrder
    inDenominator?: SortOrder
    inNumerator?: SortOrder
    isExcluded?: SortOrder
    exclusionReason?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    evidenceRef?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientQualityMeasureCountOrderByAggregateInput
    _max?: PatientQualityMeasureMaxOrderByAggregateInput
    _min?: PatientQualityMeasureMinOrderByAggregateInput
  }

  export type PatientQualityMeasureScalarWhereWithAggregatesInput = {
    AND?: PatientQualityMeasureScalarWhereWithAggregatesInput | PatientQualityMeasureScalarWhereWithAggregatesInput[]
    OR?: PatientQualityMeasureScalarWhereWithAggregatesInput[]
    NOT?: PatientQualityMeasureScalarWhereWithAggregatesInput | PatientQualityMeasureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientQualityMeasure"> | string
    patientId?: StringWithAggregatesFilter<"PatientQualityMeasure"> | string
    fhirPatientRef?: StringNullableWithAggregatesFilter<"PatientQualityMeasure"> | string | null
    qualityMeasureId?: StringWithAggregatesFilter<"PatientQualityMeasure"> | string
    inDenominator?: BoolWithAggregatesFilter<"PatientQualityMeasure"> | boolean
    inNumerator?: BoolWithAggregatesFilter<"PatientQualityMeasure"> | boolean
    isExcluded?: BoolWithAggregatesFilter<"PatientQualityMeasure"> | boolean
    exclusionReason?: StringNullableWithAggregatesFilter<"PatientQualityMeasure"> | string | null
    status?: EnumComplianceStatusWithAggregatesFilter<"PatientQualityMeasure"> | $Enums.ComplianceStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"PatientQualityMeasure"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"PatientQualityMeasure"> | Date | string | null
    evidenceRef?: StringNullableWithAggregatesFilter<"PatientQualityMeasure"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PatientQualityMeasure"> | string | null
    measurePeriod?: StringWithAggregatesFilter<"PatientQualityMeasure"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PatientQualityMeasure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatientQualityMeasure"> | Date | string
  }

  export type RiskScoreWhereInput = {
    AND?: RiskScoreWhereInput | RiskScoreWhereInput[]
    OR?: RiskScoreWhereInput[]
    NOT?: RiskScoreWhereInput | RiskScoreWhereInput[]
    id?: StringFilter<"RiskScore"> | string
    patientId?: StringFilter<"RiskScore"> | string
    fhirPatientRef?: StringNullableFilter<"RiskScore"> | string | null
    modelName?: StringFilter<"RiskScore"> | string
    modelVersion?: StringNullableFilter<"RiskScore"> | string | null
    scoreType?: EnumScoreTypeFilter<"RiskScore"> | $Enums.ScoreType
    rawScore?: FloatFilter<"RiskScore"> | number
    normalizedScore?: FloatNullableFilter<"RiskScore"> | number | null
    percentile?: IntNullableFilter<"RiskScore"> | number | null
    riskTier?: EnumRiskTierFilter<"RiskScore"> | $Enums.RiskTier
    riskFactors?: JsonNullableFilter<"RiskScore">
    clinicalFactors?: JsonNullableFilter<"RiskScore">
    socialFactors?: JsonNullableFilter<"RiskScore">
    predictedCost?: FloatNullableFilter<"RiskScore"> | number | null
    predictedEvents?: JsonNullableFilter<"RiskScore">
    effectiveDate?: DateTimeFilter<"RiskScore"> | Date | string
    expirationDate?: DateTimeNullableFilter<"RiskScore"> | Date | string | null
    isActive?: BoolFilter<"RiskScore"> | boolean
    createdAt?: DateTimeFilter<"RiskScore"> | Date | string
    updatedAt?: DateTimeFilter<"RiskScore"> | Date | string
  }

  export type RiskScoreOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    scoreType?: SortOrder
    rawScore?: SortOrder
    normalizedScore?: SortOrderInput | SortOrder
    percentile?: SortOrderInput | SortOrder
    riskTier?: SortOrder
    riskFactors?: SortOrderInput | SortOrder
    clinicalFactors?: SortOrderInput | SortOrder
    socialFactors?: SortOrderInput | SortOrder
    predictedCost?: SortOrderInput | SortOrder
    predictedEvents?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskScoreWhereInput | RiskScoreWhereInput[]
    OR?: RiskScoreWhereInput[]
    NOT?: RiskScoreWhereInput | RiskScoreWhereInput[]
    patientId?: StringFilter<"RiskScore"> | string
    fhirPatientRef?: StringNullableFilter<"RiskScore"> | string | null
    modelName?: StringFilter<"RiskScore"> | string
    modelVersion?: StringNullableFilter<"RiskScore"> | string | null
    scoreType?: EnumScoreTypeFilter<"RiskScore"> | $Enums.ScoreType
    rawScore?: FloatFilter<"RiskScore"> | number
    normalizedScore?: FloatNullableFilter<"RiskScore"> | number | null
    percentile?: IntNullableFilter<"RiskScore"> | number | null
    riskTier?: EnumRiskTierFilter<"RiskScore"> | $Enums.RiskTier
    riskFactors?: JsonNullableFilter<"RiskScore">
    clinicalFactors?: JsonNullableFilter<"RiskScore">
    socialFactors?: JsonNullableFilter<"RiskScore">
    predictedCost?: FloatNullableFilter<"RiskScore"> | number | null
    predictedEvents?: JsonNullableFilter<"RiskScore">
    effectiveDate?: DateTimeFilter<"RiskScore"> | Date | string
    expirationDate?: DateTimeNullableFilter<"RiskScore"> | Date | string | null
    isActive?: BoolFilter<"RiskScore"> | boolean
    createdAt?: DateTimeFilter<"RiskScore"> | Date | string
    updatedAt?: DateTimeFilter<"RiskScore"> | Date | string
  }, "id">

  export type RiskScoreOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    scoreType?: SortOrder
    rawScore?: SortOrder
    normalizedScore?: SortOrderInput | SortOrder
    percentile?: SortOrderInput | SortOrder
    riskTier?: SortOrder
    riskFactors?: SortOrderInput | SortOrder
    clinicalFactors?: SortOrderInput | SortOrder
    socialFactors?: SortOrderInput | SortOrder
    predictedCost?: SortOrderInput | SortOrder
    predictedEvents?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskScoreCountOrderByAggregateInput
    _avg?: RiskScoreAvgOrderByAggregateInput
    _max?: RiskScoreMaxOrderByAggregateInput
    _min?: RiskScoreMinOrderByAggregateInput
    _sum?: RiskScoreSumOrderByAggregateInput
  }

  export type RiskScoreScalarWhereWithAggregatesInput = {
    AND?: RiskScoreScalarWhereWithAggregatesInput | RiskScoreScalarWhereWithAggregatesInput[]
    OR?: RiskScoreScalarWhereWithAggregatesInput[]
    NOT?: RiskScoreScalarWhereWithAggregatesInput | RiskScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskScore"> | string
    patientId?: StringWithAggregatesFilter<"RiskScore"> | string
    fhirPatientRef?: StringNullableWithAggregatesFilter<"RiskScore"> | string | null
    modelName?: StringWithAggregatesFilter<"RiskScore"> | string
    modelVersion?: StringNullableWithAggregatesFilter<"RiskScore"> | string | null
    scoreType?: EnumScoreTypeWithAggregatesFilter<"RiskScore"> | $Enums.ScoreType
    rawScore?: FloatWithAggregatesFilter<"RiskScore"> | number
    normalizedScore?: FloatNullableWithAggregatesFilter<"RiskScore"> | number | null
    percentile?: IntNullableWithAggregatesFilter<"RiskScore"> | number | null
    riskTier?: EnumRiskTierWithAggregatesFilter<"RiskScore"> | $Enums.RiskTier
    riskFactors?: JsonNullableWithAggregatesFilter<"RiskScore">
    clinicalFactors?: JsonNullableWithAggregatesFilter<"RiskScore">
    socialFactors?: JsonNullableWithAggregatesFilter<"RiskScore">
    predictedCost?: FloatNullableWithAggregatesFilter<"RiskScore"> | number | null
    predictedEvents?: JsonNullableWithAggregatesFilter<"RiskScore">
    effectiveDate?: DateTimeWithAggregatesFilter<"RiskScore"> | Date | string
    expirationDate?: DateTimeNullableWithAggregatesFilter<"RiskScore"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"RiskScore"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RiskScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskScore"> | Date | string
  }

  export type CareGapWhereInput = {
    AND?: CareGapWhereInput | CareGapWhereInput[]
    OR?: CareGapWhereInput[]
    NOT?: CareGapWhereInput | CareGapWhereInput[]
    id?: StringFilter<"CareGap"> | string
    patientId?: StringFilter<"CareGap"> | string
    fhirPatientRef?: StringNullableFilter<"CareGap"> | string | null
    cohortId?: StringNullableFilter<"CareGap"> | string | null
    gapType?: EnumGapTypeFilter<"CareGap"> | $Enums.GapType
    title?: StringFilter<"CareGap"> | string
    description?: StringNullableFilter<"CareGap"> | string | null
    priority?: EnumGapPriorityFilter<"CareGap"> | $Enums.GapPriority
    qualityMeasureId?: StringNullableFilter<"CareGap"> | string | null
    recommendedAction?: StringNullableFilter<"CareGap"> | string | null
    actionDueDate?: DateTimeNullableFilter<"CareGap"> | Date | string | null
    status?: EnumGapStatusFilter<"CareGap"> | $Enums.GapStatus
    identifiedAt?: DateTimeFilter<"CareGap"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"CareGap"> | Date | string | null
    resolvedBy?: StringNullableFilter<"CareGap"> | string | null
    resolutionNotes?: StringNullableFilter<"CareGap"> | string | null
    fhirConditionRef?: StringNullableFilter<"CareGap"> | string | null
    fhirProcedureRef?: StringNullableFilter<"CareGap"> | string | null
    fhirMedicationRef?: StringNullableFilter<"CareGap"> | string | null
    createdAt?: DateTimeFilter<"CareGap"> | Date | string
    updatedAt?: DateTimeFilter<"CareGap"> | Date | string
    cohort?: XOR<CohortNullableRelationFilter, CohortWhereInput> | null
  }

  export type CareGapOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    cohortId?: SortOrderInput | SortOrder
    gapType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    qualityMeasureId?: SortOrderInput | SortOrder
    recommendedAction?: SortOrderInput | SortOrder
    actionDueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    identifiedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolutionNotes?: SortOrderInput | SortOrder
    fhirConditionRef?: SortOrderInput | SortOrder
    fhirProcedureRef?: SortOrderInput | SortOrder
    fhirMedicationRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cohort?: CohortOrderByWithRelationInput
  }

  export type CareGapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CareGapWhereInput | CareGapWhereInput[]
    OR?: CareGapWhereInput[]
    NOT?: CareGapWhereInput | CareGapWhereInput[]
    patientId?: StringFilter<"CareGap"> | string
    fhirPatientRef?: StringNullableFilter<"CareGap"> | string | null
    cohortId?: StringNullableFilter<"CareGap"> | string | null
    gapType?: EnumGapTypeFilter<"CareGap"> | $Enums.GapType
    title?: StringFilter<"CareGap"> | string
    description?: StringNullableFilter<"CareGap"> | string | null
    priority?: EnumGapPriorityFilter<"CareGap"> | $Enums.GapPriority
    qualityMeasureId?: StringNullableFilter<"CareGap"> | string | null
    recommendedAction?: StringNullableFilter<"CareGap"> | string | null
    actionDueDate?: DateTimeNullableFilter<"CareGap"> | Date | string | null
    status?: EnumGapStatusFilter<"CareGap"> | $Enums.GapStatus
    identifiedAt?: DateTimeFilter<"CareGap"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"CareGap"> | Date | string | null
    resolvedBy?: StringNullableFilter<"CareGap"> | string | null
    resolutionNotes?: StringNullableFilter<"CareGap"> | string | null
    fhirConditionRef?: StringNullableFilter<"CareGap"> | string | null
    fhirProcedureRef?: StringNullableFilter<"CareGap"> | string | null
    fhirMedicationRef?: StringNullableFilter<"CareGap"> | string | null
    createdAt?: DateTimeFilter<"CareGap"> | Date | string
    updatedAt?: DateTimeFilter<"CareGap"> | Date | string
    cohort?: XOR<CohortNullableRelationFilter, CohortWhereInput> | null
  }, "id">

  export type CareGapOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    cohortId?: SortOrderInput | SortOrder
    gapType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    qualityMeasureId?: SortOrderInput | SortOrder
    recommendedAction?: SortOrderInput | SortOrder
    actionDueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    identifiedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolutionNotes?: SortOrderInput | SortOrder
    fhirConditionRef?: SortOrderInput | SortOrder
    fhirProcedureRef?: SortOrderInput | SortOrder
    fhirMedicationRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CareGapCountOrderByAggregateInput
    _max?: CareGapMaxOrderByAggregateInput
    _min?: CareGapMinOrderByAggregateInput
  }

  export type CareGapScalarWhereWithAggregatesInput = {
    AND?: CareGapScalarWhereWithAggregatesInput | CareGapScalarWhereWithAggregatesInput[]
    OR?: CareGapScalarWhereWithAggregatesInput[]
    NOT?: CareGapScalarWhereWithAggregatesInput | CareGapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CareGap"> | string
    patientId?: StringWithAggregatesFilter<"CareGap"> | string
    fhirPatientRef?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    cohortId?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    gapType?: EnumGapTypeWithAggregatesFilter<"CareGap"> | $Enums.GapType
    title?: StringWithAggregatesFilter<"CareGap"> | string
    description?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    priority?: EnumGapPriorityWithAggregatesFilter<"CareGap"> | $Enums.GapPriority
    qualityMeasureId?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    recommendedAction?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    actionDueDate?: DateTimeNullableWithAggregatesFilter<"CareGap"> | Date | string | null
    status?: EnumGapStatusWithAggregatesFilter<"CareGap"> | $Enums.GapStatus
    identifiedAt?: DateTimeWithAggregatesFilter<"CareGap"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"CareGap"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    resolutionNotes?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    fhirConditionRef?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    fhirProcedureRef?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    fhirMedicationRef?: StringNullableWithAggregatesFilter<"CareGap"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CareGap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CareGap"> | Date | string
  }

  export type SdohFactorWhereInput = {
    AND?: SdohFactorWhereInput | SdohFactorWhereInput[]
    OR?: SdohFactorWhereInput[]
    NOT?: SdohFactorWhereInput | SdohFactorWhereInput[]
    id?: StringFilter<"SdohFactor"> | string
    patientId?: StringNullableFilter<"SdohFactor"> | string | null
    populationId?: StringNullableFilter<"SdohFactor"> | string | null
    fhirPatientRef?: StringNullableFilter<"SdohFactor"> | string | null
    category?: EnumSdohCategoryFilter<"SdohFactor"> | $Enums.SdohCategory
    factor?: StringFilter<"SdohFactor"> | string
    value?: StringNullableFilter<"SdohFactor"> | string | null
    severity?: EnumSdohSeverityNullableFilter<"SdohFactor"> | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFilter<"SdohFactor"> | Date | string
    assessmentTool?: StringNullableFilter<"SdohFactor"> | string | null
    screeningScore?: FloatNullableFilter<"SdohFactor"> | number | null
    isPositiveScreen?: BoolFilter<"SdohFactor"> | boolean
    interventionNeeded?: BoolFilter<"SdohFactor"> | boolean
    interventionType?: StringNullableFilter<"SdohFactor"> | string | null
    interventionStatus?: StringNullableFilter<"SdohFactor"> | string | null
    referralMade?: BoolFilter<"SdohFactor"> | boolean
    referralDetails?: StringNullableFilter<"SdohFactor"> | string | null
    fhirObservationRef?: StringNullableFilter<"SdohFactor"> | string | null
    fhirConditionRef?: StringNullableFilter<"SdohFactor"> | string | null
    createdAt?: DateTimeFilter<"SdohFactor"> | Date | string
    updatedAt?: DateTimeFilter<"SdohFactor"> | Date | string
    population?: XOR<PopulationNullableRelationFilter, PopulationWhereInput> | null
  }

  export type SdohFactorOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    populationId?: SortOrderInput | SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    category?: SortOrder
    factor?: SortOrder
    value?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    assessmentDate?: SortOrder
    assessmentTool?: SortOrderInput | SortOrder
    screeningScore?: SortOrderInput | SortOrder
    isPositiveScreen?: SortOrder
    interventionNeeded?: SortOrder
    interventionType?: SortOrderInput | SortOrder
    interventionStatus?: SortOrderInput | SortOrder
    referralMade?: SortOrder
    referralDetails?: SortOrderInput | SortOrder
    fhirObservationRef?: SortOrderInput | SortOrder
    fhirConditionRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    population?: PopulationOrderByWithRelationInput
  }

  export type SdohFactorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SdohFactorWhereInput | SdohFactorWhereInput[]
    OR?: SdohFactorWhereInput[]
    NOT?: SdohFactorWhereInput | SdohFactorWhereInput[]
    patientId?: StringNullableFilter<"SdohFactor"> | string | null
    populationId?: StringNullableFilter<"SdohFactor"> | string | null
    fhirPatientRef?: StringNullableFilter<"SdohFactor"> | string | null
    category?: EnumSdohCategoryFilter<"SdohFactor"> | $Enums.SdohCategory
    factor?: StringFilter<"SdohFactor"> | string
    value?: StringNullableFilter<"SdohFactor"> | string | null
    severity?: EnumSdohSeverityNullableFilter<"SdohFactor"> | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFilter<"SdohFactor"> | Date | string
    assessmentTool?: StringNullableFilter<"SdohFactor"> | string | null
    screeningScore?: FloatNullableFilter<"SdohFactor"> | number | null
    isPositiveScreen?: BoolFilter<"SdohFactor"> | boolean
    interventionNeeded?: BoolFilter<"SdohFactor"> | boolean
    interventionType?: StringNullableFilter<"SdohFactor"> | string | null
    interventionStatus?: StringNullableFilter<"SdohFactor"> | string | null
    referralMade?: BoolFilter<"SdohFactor"> | boolean
    referralDetails?: StringNullableFilter<"SdohFactor"> | string | null
    fhirObservationRef?: StringNullableFilter<"SdohFactor"> | string | null
    fhirConditionRef?: StringNullableFilter<"SdohFactor"> | string | null
    createdAt?: DateTimeFilter<"SdohFactor"> | Date | string
    updatedAt?: DateTimeFilter<"SdohFactor"> | Date | string
    population?: XOR<PopulationNullableRelationFilter, PopulationWhereInput> | null
  }, "id">

  export type SdohFactorOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    populationId?: SortOrderInput | SortOrder
    fhirPatientRef?: SortOrderInput | SortOrder
    category?: SortOrder
    factor?: SortOrder
    value?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    assessmentDate?: SortOrder
    assessmentTool?: SortOrderInput | SortOrder
    screeningScore?: SortOrderInput | SortOrder
    isPositiveScreen?: SortOrder
    interventionNeeded?: SortOrder
    interventionType?: SortOrderInput | SortOrder
    interventionStatus?: SortOrderInput | SortOrder
    referralMade?: SortOrder
    referralDetails?: SortOrderInput | SortOrder
    fhirObservationRef?: SortOrderInput | SortOrder
    fhirConditionRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SdohFactorCountOrderByAggregateInput
    _avg?: SdohFactorAvgOrderByAggregateInput
    _max?: SdohFactorMaxOrderByAggregateInput
    _min?: SdohFactorMinOrderByAggregateInput
    _sum?: SdohFactorSumOrderByAggregateInput
  }

  export type SdohFactorScalarWhereWithAggregatesInput = {
    AND?: SdohFactorScalarWhereWithAggregatesInput | SdohFactorScalarWhereWithAggregatesInput[]
    OR?: SdohFactorScalarWhereWithAggregatesInput[]
    NOT?: SdohFactorScalarWhereWithAggregatesInput | SdohFactorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SdohFactor"> | string
    patientId?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    populationId?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    fhirPatientRef?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    category?: EnumSdohCategoryWithAggregatesFilter<"SdohFactor"> | $Enums.SdohCategory
    factor?: StringWithAggregatesFilter<"SdohFactor"> | string
    value?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    severity?: EnumSdohSeverityNullableWithAggregatesFilter<"SdohFactor"> | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeWithAggregatesFilter<"SdohFactor"> | Date | string
    assessmentTool?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    screeningScore?: FloatNullableWithAggregatesFilter<"SdohFactor"> | number | null
    isPositiveScreen?: BoolWithAggregatesFilter<"SdohFactor"> | boolean
    interventionNeeded?: BoolWithAggregatesFilter<"SdohFactor"> | boolean
    interventionType?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    interventionStatus?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    referralMade?: BoolWithAggregatesFilter<"SdohFactor"> | boolean
    referralDetails?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    fhirObservationRef?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    fhirConditionRef?: StringNullableWithAggregatesFilter<"SdohFactor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SdohFactor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SdohFactor"> | Date | string
  }

  export type DiseaseRegistryWhereInput = {
    AND?: DiseaseRegistryWhereInput | DiseaseRegistryWhereInput[]
    OR?: DiseaseRegistryWhereInput[]
    NOT?: DiseaseRegistryWhereInput | DiseaseRegistryWhereInput[]
    id?: StringFilter<"DiseaseRegistry"> | string
    conditionCode?: StringFilter<"DiseaseRegistry"> | string
    conditionName?: StringFilter<"DiseaseRegistry"> | string
    populationId?: StringNullableFilter<"DiseaseRegistry"> | string | null
    prevalenceCount?: IntFilter<"DiseaseRegistry"> | number
    prevalenceRate?: FloatNullableFilter<"DiseaseRegistry"> | number | null
    incidenceCount?: IntFilter<"DiseaseRegistry"> | number
    incidenceRate?: FloatNullableFilter<"DiseaseRegistry"> | number | null
    periodStart?: DateTimeFilter<"DiseaseRegistry"> | Date | string
    periodEnd?: DateTimeFilter<"DiseaseRegistry"> | Date | string
    ageDistribution?: JsonNullableFilter<"DiseaseRegistry">
    genderDistribution?: JsonNullableFilter<"DiseaseRegistry">
    raceDistribution?: JsonNullableFilter<"DiseaseRegistry">
    previousPeriodPrevalence?: FloatNullableFilter<"DiseaseRegistry"> | number | null
    trendDirection?: EnumTrendDirectionNullableFilter<"DiseaseRegistry"> | $Enums.TrendDirection | null
    createdAt?: DateTimeFilter<"DiseaseRegistry"> | Date | string
    updatedAt?: DateTimeFilter<"DiseaseRegistry"> | Date | string
  }

  export type DiseaseRegistryOrderByWithRelationInput = {
    id?: SortOrder
    conditionCode?: SortOrder
    conditionName?: SortOrder
    populationId?: SortOrderInput | SortOrder
    prevalenceCount?: SortOrder
    prevalenceRate?: SortOrderInput | SortOrder
    incidenceCount?: SortOrder
    incidenceRate?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    ageDistribution?: SortOrderInput | SortOrder
    genderDistribution?: SortOrderInput | SortOrder
    raceDistribution?: SortOrderInput | SortOrder
    previousPeriodPrevalence?: SortOrderInput | SortOrder
    trendDirection?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiseaseRegistryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conditionCode_populationId_periodStart?: DiseaseRegistryConditionCodePopulationIdPeriodStartCompoundUniqueInput
    AND?: DiseaseRegistryWhereInput | DiseaseRegistryWhereInput[]
    OR?: DiseaseRegistryWhereInput[]
    NOT?: DiseaseRegistryWhereInput | DiseaseRegistryWhereInput[]
    conditionCode?: StringFilter<"DiseaseRegistry"> | string
    conditionName?: StringFilter<"DiseaseRegistry"> | string
    populationId?: StringNullableFilter<"DiseaseRegistry"> | string | null
    prevalenceCount?: IntFilter<"DiseaseRegistry"> | number
    prevalenceRate?: FloatNullableFilter<"DiseaseRegistry"> | number | null
    incidenceCount?: IntFilter<"DiseaseRegistry"> | number
    incidenceRate?: FloatNullableFilter<"DiseaseRegistry"> | number | null
    periodStart?: DateTimeFilter<"DiseaseRegistry"> | Date | string
    periodEnd?: DateTimeFilter<"DiseaseRegistry"> | Date | string
    ageDistribution?: JsonNullableFilter<"DiseaseRegistry">
    genderDistribution?: JsonNullableFilter<"DiseaseRegistry">
    raceDistribution?: JsonNullableFilter<"DiseaseRegistry">
    previousPeriodPrevalence?: FloatNullableFilter<"DiseaseRegistry"> | number | null
    trendDirection?: EnumTrendDirectionNullableFilter<"DiseaseRegistry"> | $Enums.TrendDirection | null
    createdAt?: DateTimeFilter<"DiseaseRegistry"> | Date | string
    updatedAt?: DateTimeFilter<"DiseaseRegistry"> | Date | string
  }, "id" | "conditionCode_populationId_periodStart">

  export type DiseaseRegistryOrderByWithAggregationInput = {
    id?: SortOrder
    conditionCode?: SortOrder
    conditionName?: SortOrder
    populationId?: SortOrderInput | SortOrder
    prevalenceCount?: SortOrder
    prevalenceRate?: SortOrderInput | SortOrder
    incidenceCount?: SortOrder
    incidenceRate?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    ageDistribution?: SortOrderInput | SortOrder
    genderDistribution?: SortOrderInput | SortOrder
    raceDistribution?: SortOrderInput | SortOrder
    previousPeriodPrevalence?: SortOrderInput | SortOrder
    trendDirection?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiseaseRegistryCountOrderByAggregateInput
    _avg?: DiseaseRegistryAvgOrderByAggregateInput
    _max?: DiseaseRegistryMaxOrderByAggregateInput
    _min?: DiseaseRegistryMinOrderByAggregateInput
    _sum?: DiseaseRegistrySumOrderByAggregateInput
  }

  export type DiseaseRegistryScalarWhereWithAggregatesInput = {
    AND?: DiseaseRegistryScalarWhereWithAggregatesInput | DiseaseRegistryScalarWhereWithAggregatesInput[]
    OR?: DiseaseRegistryScalarWhereWithAggregatesInput[]
    NOT?: DiseaseRegistryScalarWhereWithAggregatesInput | DiseaseRegistryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiseaseRegistry"> | string
    conditionCode?: StringWithAggregatesFilter<"DiseaseRegistry"> | string
    conditionName?: StringWithAggregatesFilter<"DiseaseRegistry"> | string
    populationId?: StringNullableWithAggregatesFilter<"DiseaseRegistry"> | string | null
    prevalenceCount?: IntWithAggregatesFilter<"DiseaseRegistry"> | number
    prevalenceRate?: FloatNullableWithAggregatesFilter<"DiseaseRegistry"> | number | null
    incidenceCount?: IntWithAggregatesFilter<"DiseaseRegistry"> | number
    incidenceRate?: FloatNullableWithAggregatesFilter<"DiseaseRegistry"> | number | null
    periodStart?: DateTimeWithAggregatesFilter<"DiseaseRegistry"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"DiseaseRegistry"> | Date | string
    ageDistribution?: JsonNullableWithAggregatesFilter<"DiseaseRegistry">
    genderDistribution?: JsonNullableWithAggregatesFilter<"DiseaseRegistry">
    raceDistribution?: JsonNullableWithAggregatesFilter<"DiseaseRegistry">
    previousPeriodPrevalence?: FloatNullableWithAggregatesFilter<"DiseaseRegistry"> | number | null
    trendDirection?: EnumTrendDirectionNullableWithAggregatesFilter<"DiseaseRegistry"> | $Enums.TrendDirection | null
    createdAt?: DateTimeWithAggregatesFilter<"DiseaseRegistry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiseaseRegistry"> | Date | string
  }

  export type HealthEquityMetricWhereInput = {
    AND?: HealthEquityMetricWhereInput | HealthEquityMetricWhereInput[]
    OR?: HealthEquityMetricWhereInput[]
    NOT?: HealthEquityMetricWhereInput | HealthEquityMetricWhereInput[]
    id?: StringFilter<"HealthEquityMetric"> | string
    populationId?: StringNullableFilter<"HealthEquityMetric"> | string | null
    measureType?: EnumEquityMeasureTypeFilter<"HealthEquityMetric"> | $Enums.EquityMeasureType
    stratificationDimension?: StringFilter<"HealthEquityMetric"> | string
    stratificationValue?: StringFilter<"HealthEquityMetric"> | string
    metricName?: StringFilter<"HealthEquityMetric"> | string
    metricValue?: FloatFilter<"HealthEquityMetric"> | number
    referenceValue?: FloatNullableFilter<"HealthEquityMetric"> | number | null
    disparityIndex?: FloatNullableFilter<"HealthEquityMetric"> | number | null
    confidenceInterval?: JsonNullableFilter<"HealthEquityMetric">
    pValue?: FloatNullableFilter<"HealthEquityMetric"> | number | null
    sampleSize?: IntNullableFilter<"HealthEquityMetric"> | number | null
    measurePeriod?: StringFilter<"HealthEquityMetric"> | string
    createdAt?: DateTimeFilter<"HealthEquityMetric"> | Date | string
    updatedAt?: DateTimeFilter<"HealthEquityMetric"> | Date | string
  }

  export type HealthEquityMetricOrderByWithRelationInput = {
    id?: SortOrder
    populationId?: SortOrderInput | SortOrder
    measureType?: SortOrder
    stratificationDimension?: SortOrder
    stratificationValue?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    referenceValue?: SortOrderInput | SortOrder
    disparityIndex?: SortOrderInput | SortOrder
    confidenceInterval?: SortOrderInput | SortOrder
    pValue?: SortOrderInput | SortOrder
    sampleSize?: SortOrderInput | SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthEquityMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthEquityMetricWhereInput | HealthEquityMetricWhereInput[]
    OR?: HealthEquityMetricWhereInput[]
    NOT?: HealthEquityMetricWhereInput | HealthEquityMetricWhereInput[]
    populationId?: StringNullableFilter<"HealthEquityMetric"> | string | null
    measureType?: EnumEquityMeasureTypeFilter<"HealthEquityMetric"> | $Enums.EquityMeasureType
    stratificationDimension?: StringFilter<"HealthEquityMetric"> | string
    stratificationValue?: StringFilter<"HealthEquityMetric"> | string
    metricName?: StringFilter<"HealthEquityMetric"> | string
    metricValue?: FloatFilter<"HealthEquityMetric"> | number
    referenceValue?: FloatNullableFilter<"HealthEquityMetric"> | number | null
    disparityIndex?: FloatNullableFilter<"HealthEquityMetric"> | number | null
    confidenceInterval?: JsonNullableFilter<"HealthEquityMetric">
    pValue?: FloatNullableFilter<"HealthEquityMetric"> | number | null
    sampleSize?: IntNullableFilter<"HealthEquityMetric"> | number | null
    measurePeriod?: StringFilter<"HealthEquityMetric"> | string
    createdAt?: DateTimeFilter<"HealthEquityMetric"> | Date | string
    updatedAt?: DateTimeFilter<"HealthEquityMetric"> | Date | string
  }, "id">

  export type HealthEquityMetricOrderByWithAggregationInput = {
    id?: SortOrder
    populationId?: SortOrderInput | SortOrder
    measureType?: SortOrder
    stratificationDimension?: SortOrder
    stratificationValue?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    referenceValue?: SortOrderInput | SortOrder
    disparityIndex?: SortOrderInput | SortOrder
    confidenceInterval?: SortOrderInput | SortOrder
    pValue?: SortOrderInput | SortOrder
    sampleSize?: SortOrderInput | SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthEquityMetricCountOrderByAggregateInput
    _avg?: HealthEquityMetricAvgOrderByAggregateInput
    _max?: HealthEquityMetricMaxOrderByAggregateInput
    _min?: HealthEquityMetricMinOrderByAggregateInput
    _sum?: HealthEquityMetricSumOrderByAggregateInput
  }

  export type HealthEquityMetricScalarWhereWithAggregatesInput = {
    AND?: HealthEquityMetricScalarWhereWithAggregatesInput | HealthEquityMetricScalarWhereWithAggregatesInput[]
    OR?: HealthEquityMetricScalarWhereWithAggregatesInput[]
    NOT?: HealthEquityMetricScalarWhereWithAggregatesInput | HealthEquityMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthEquityMetric"> | string
    populationId?: StringNullableWithAggregatesFilter<"HealthEquityMetric"> | string | null
    measureType?: EnumEquityMeasureTypeWithAggregatesFilter<"HealthEquityMetric"> | $Enums.EquityMeasureType
    stratificationDimension?: StringWithAggregatesFilter<"HealthEquityMetric"> | string
    stratificationValue?: StringWithAggregatesFilter<"HealthEquityMetric"> | string
    metricName?: StringWithAggregatesFilter<"HealthEquityMetric"> | string
    metricValue?: FloatWithAggregatesFilter<"HealthEquityMetric"> | number
    referenceValue?: FloatNullableWithAggregatesFilter<"HealthEquityMetric"> | number | null
    disparityIndex?: FloatNullableWithAggregatesFilter<"HealthEquityMetric"> | number | null
    confidenceInterval?: JsonNullableWithAggregatesFilter<"HealthEquityMetric">
    pValue?: FloatNullableWithAggregatesFilter<"HealthEquityMetric"> | number | null
    sampleSize?: IntNullableWithAggregatesFilter<"HealthEquityMetric"> | number | null
    measurePeriod?: StringWithAggregatesFilter<"HealthEquityMetric"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HealthEquityMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthEquityMetric"> | Date | string
  }

  export type AnalyticsReportWhereInput = {
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    id?: StringFilter<"AnalyticsReport"> | string
    populationId?: StringNullableFilter<"AnalyticsReport"> | string | null
    reportType?: EnumReportTypeFilter<"AnalyticsReport"> | $Enums.ReportType
    title?: StringFilter<"AnalyticsReport"> | string
    description?: StringNullableFilter<"AnalyticsReport"> | string | null
    parameters?: JsonNullableFilter<"AnalyticsReport">
    data?: JsonFilter<"AnalyticsReport">
    visualizations?: JsonNullableFilter<"AnalyticsReport">
    generatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringNullableFilter<"AnalyticsReport"> | string | null
    periodStart?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    periodEnd?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    exportFormats?: JsonNullableFilter<"AnalyticsReport">
    lastExportedAt?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    population?: XOR<PopulationNullableRelationFilter, PopulationWhereInput> | null
  }

  export type AnalyticsReportOrderByWithRelationInput = {
    id?: SortOrder
    populationId?: SortOrderInput | SortOrder
    reportType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    data?: SortOrder
    visualizations?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrderInput | SortOrder
    periodStart?: SortOrderInput | SortOrder
    periodEnd?: SortOrderInput | SortOrder
    exportFormats?: SortOrderInput | SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    population?: PopulationOrderByWithRelationInput
  }

  export type AnalyticsReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    populationId?: StringNullableFilter<"AnalyticsReport"> | string | null
    reportType?: EnumReportTypeFilter<"AnalyticsReport"> | $Enums.ReportType
    title?: StringFilter<"AnalyticsReport"> | string
    description?: StringNullableFilter<"AnalyticsReport"> | string | null
    parameters?: JsonNullableFilter<"AnalyticsReport">
    data?: JsonFilter<"AnalyticsReport">
    visualizations?: JsonNullableFilter<"AnalyticsReport">
    generatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringNullableFilter<"AnalyticsReport"> | string | null
    periodStart?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    periodEnd?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    exportFormats?: JsonNullableFilter<"AnalyticsReport">
    lastExportedAt?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    population?: XOR<PopulationNullableRelationFilter, PopulationWhereInput> | null
  }, "id">

  export type AnalyticsReportOrderByWithAggregationInput = {
    id?: SortOrder
    populationId?: SortOrderInput | SortOrder
    reportType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    data?: SortOrder
    visualizations?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrderInput | SortOrder
    periodStart?: SortOrderInput | SortOrder
    periodEnd?: SortOrderInput | SortOrder
    exportFormats?: SortOrderInput | SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsReportCountOrderByAggregateInput
    _max?: AnalyticsReportMaxOrderByAggregateInput
    _min?: AnalyticsReportMinOrderByAggregateInput
  }

  export type AnalyticsReportScalarWhereWithAggregatesInput = {
    AND?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    OR?: AnalyticsReportScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    populationId?: StringNullableWithAggregatesFilter<"AnalyticsReport"> | string | null
    reportType?: EnumReportTypeWithAggregatesFilter<"AnalyticsReport"> | $Enums.ReportType
    title?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    description?: StringNullableWithAggregatesFilter<"AnalyticsReport"> | string | null
    parameters?: JsonNullableWithAggregatesFilter<"AnalyticsReport">
    data?: JsonWithAggregatesFilter<"AnalyticsReport">
    visualizations?: JsonNullableWithAggregatesFilter<"AnalyticsReport">
    generatedAt?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringNullableWithAggregatesFilter<"AnalyticsReport"> | string | null
    periodStart?: DateTimeNullableWithAggregatesFilter<"AnalyticsReport"> | Date | string | null
    periodEnd?: DateTimeNullableWithAggregatesFilter<"AnalyticsReport"> | Date | string | null
    exportFormats?: JsonNullableWithAggregatesFilter<"AnalyticsReport">
    lastExportedAt?: DateTimeNullableWithAggregatesFilter<"AnalyticsReport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
  }

  export type PredictiveModelWhereInput = {
    AND?: PredictiveModelWhereInput | PredictiveModelWhereInput[]
    OR?: PredictiveModelWhereInput[]
    NOT?: PredictiveModelWhereInput | PredictiveModelWhereInput[]
    id?: StringFilter<"PredictiveModel"> | string
    name?: StringFilter<"PredictiveModel"> | string
    description?: StringNullableFilter<"PredictiveModel"> | string | null
    modelType?: EnumPredictiveModelTypeFilter<"PredictiveModel"> | $Enums.PredictiveModelType
    algorithm?: StringFilter<"PredictiveModel"> | string
    features?: JsonFilter<"PredictiveModel">
    hyperparameters?: JsonNullableFilter<"PredictiveModel">
    accuracy?: FloatNullableFilter<"PredictiveModel"> | number | null
    auc?: FloatNullableFilter<"PredictiveModel"> | number | null
    precision?: FloatNullableFilter<"PredictiveModel"> | number | null
    recall?: FloatNullableFilter<"PredictiveModel"> | number | null
    f1Score?: FloatNullableFilter<"PredictiveModel"> | number | null
    version?: StringFilter<"PredictiveModel"> | string
    isActive?: BoolFilter<"PredictiveModel"> | boolean
    trainedAt?: DateTimeNullableFilter<"PredictiveModel"> | Date | string | null
    trainingSampleSize?: IntNullableFilter<"PredictiveModel"> | number | null
    createdAt?: DateTimeFilter<"PredictiveModel"> | Date | string
    updatedAt?: DateTimeFilter<"PredictiveModel"> | Date | string
  }

  export type PredictiveModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    modelType?: SortOrder
    algorithm?: SortOrder
    features?: SortOrder
    hyperparameters?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    auc?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    recall?: SortOrderInput | SortOrder
    f1Score?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    trainedAt?: SortOrderInput | SortOrder
    trainingSampleSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictiveModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PredictiveModelWhereInput | PredictiveModelWhereInput[]
    OR?: PredictiveModelWhereInput[]
    NOT?: PredictiveModelWhereInput | PredictiveModelWhereInput[]
    name?: StringFilter<"PredictiveModel"> | string
    description?: StringNullableFilter<"PredictiveModel"> | string | null
    modelType?: EnumPredictiveModelTypeFilter<"PredictiveModel"> | $Enums.PredictiveModelType
    algorithm?: StringFilter<"PredictiveModel"> | string
    features?: JsonFilter<"PredictiveModel">
    hyperparameters?: JsonNullableFilter<"PredictiveModel">
    accuracy?: FloatNullableFilter<"PredictiveModel"> | number | null
    auc?: FloatNullableFilter<"PredictiveModel"> | number | null
    precision?: FloatNullableFilter<"PredictiveModel"> | number | null
    recall?: FloatNullableFilter<"PredictiveModel"> | number | null
    f1Score?: FloatNullableFilter<"PredictiveModel"> | number | null
    version?: StringFilter<"PredictiveModel"> | string
    isActive?: BoolFilter<"PredictiveModel"> | boolean
    trainedAt?: DateTimeNullableFilter<"PredictiveModel"> | Date | string | null
    trainingSampleSize?: IntNullableFilter<"PredictiveModel"> | number | null
    createdAt?: DateTimeFilter<"PredictiveModel"> | Date | string
    updatedAt?: DateTimeFilter<"PredictiveModel"> | Date | string
  }, "id">

  export type PredictiveModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    modelType?: SortOrder
    algorithm?: SortOrder
    features?: SortOrder
    hyperparameters?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    auc?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    recall?: SortOrderInput | SortOrder
    f1Score?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    trainedAt?: SortOrderInput | SortOrder
    trainingSampleSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PredictiveModelCountOrderByAggregateInput
    _avg?: PredictiveModelAvgOrderByAggregateInput
    _max?: PredictiveModelMaxOrderByAggregateInput
    _min?: PredictiveModelMinOrderByAggregateInput
    _sum?: PredictiveModelSumOrderByAggregateInput
  }

  export type PredictiveModelScalarWhereWithAggregatesInput = {
    AND?: PredictiveModelScalarWhereWithAggregatesInput | PredictiveModelScalarWhereWithAggregatesInput[]
    OR?: PredictiveModelScalarWhereWithAggregatesInput[]
    NOT?: PredictiveModelScalarWhereWithAggregatesInput | PredictiveModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PredictiveModel"> | string
    name?: StringWithAggregatesFilter<"PredictiveModel"> | string
    description?: StringNullableWithAggregatesFilter<"PredictiveModel"> | string | null
    modelType?: EnumPredictiveModelTypeWithAggregatesFilter<"PredictiveModel"> | $Enums.PredictiveModelType
    algorithm?: StringWithAggregatesFilter<"PredictiveModel"> | string
    features?: JsonWithAggregatesFilter<"PredictiveModel">
    hyperparameters?: JsonNullableWithAggregatesFilter<"PredictiveModel">
    accuracy?: FloatNullableWithAggregatesFilter<"PredictiveModel"> | number | null
    auc?: FloatNullableWithAggregatesFilter<"PredictiveModel"> | number | null
    precision?: FloatNullableWithAggregatesFilter<"PredictiveModel"> | number | null
    recall?: FloatNullableWithAggregatesFilter<"PredictiveModel"> | number | null
    f1Score?: FloatNullableWithAggregatesFilter<"PredictiveModel"> | number | null
    version?: StringWithAggregatesFilter<"PredictiveModel"> | string
    isActive?: BoolWithAggregatesFilter<"PredictiveModel"> | boolean
    trainedAt?: DateTimeNullableWithAggregatesFilter<"PredictiveModel"> | Date | string | null
    trainingSampleSize?: IntNullableWithAggregatesFilter<"PredictiveModel"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PredictiveModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PredictiveModel"> | Date | string
  }

  export type AnalyticsAuditLogWhereInput = {
    AND?: AnalyticsAuditLogWhereInput | AnalyticsAuditLogWhereInput[]
    OR?: AnalyticsAuditLogWhereInput[]
    NOT?: AnalyticsAuditLogWhereInput | AnalyticsAuditLogWhereInput[]
    id?: StringFilter<"AnalyticsAuditLog"> | string
    userId?: StringFilter<"AnalyticsAuditLog"> | string
    action?: StringFilter<"AnalyticsAuditLog"> | string
    resourceType?: StringFilter<"AnalyticsAuditLog"> | string
    resourceId?: StringNullableFilter<"AnalyticsAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AnalyticsAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AnalyticsAuditLog">
    createdAt?: DateTimeFilter<"AnalyticsAuditLog"> | Date | string
  }

  export type AnalyticsAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsAuditLogWhereInput | AnalyticsAuditLogWhereInput[]
    OR?: AnalyticsAuditLogWhereInput[]
    NOT?: AnalyticsAuditLogWhereInput | AnalyticsAuditLogWhereInput[]
    userId?: StringFilter<"AnalyticsAuditLog"> | string
    action?: StringFilter<"AnalyticsAuditLog"> | string
    resourceType?: StringFilter<"AnalyticsAuditLog"> | string
    resourceId?: StringNullableFilter<"AnalyticsAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AnalyticsAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AnalyticsAuditLog">
    createdAt?: DateTimeFilter<"AnalyticsAuditLog"> | Date | string
  }, "id">

  export type AnalyticsAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsAuditLogCountOrderByAggregateInput
    _max?: AnalyticsAuditLogMaxOrderByAggregateInput
    _min?: AnalyticsAuditLogMinOrderByAggregateInput
  }

  export type AnalyticsAuditLogScalarWhereWithAggregatesInput = {
    AND?: AnalyticsAuditLogScalarWhereWithAggregatesInput | AnalyticsAuditLogScalarWhereWithAggregatesInput[]
    OR?: AnalyticsAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsAuditLogScalarWhereWithAggregatesInput | AnalyticsAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsAuditLog"> | string
    userId?: StringWithAggregatesFilter<"AnalyticsAuditLog"> | string
    action?: StringWithAggregatesFilter<"AnalyticsAuditLog"> | string
    resourceType?: StringWithAggregatesFilter<"AnalyticsAuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AnalyticsAuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AnalyticsAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AnalyticsAuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AnalyticsAuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsAuditLog"> | Date | string
  }

  export type PopulationCreateInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortCreateNestedManyWithoutPopulationInput
    qualityMeasures?: PopulationQualityMeasureCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorCreateNestedManyWithoutPopulationInput
  }

  export type PopulationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortUncheckedCreateNestedManyWithoutPopulationInput
    qualityMeasures?: PopulationQualityMeasureUncheckedCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportUncheckedCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorUncheckedCreateNestedManyWithoutPopulationInput
  }

  export type PopulationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUpdateManyWithoutPopulationNestedInput
    qualityMeasures?: PopulationQualityMeasureUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUpdateManyWithoutPopulationNestedInput
  }

  export type PopulationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUncheckedUpdateManyWithoutPopulationNestedInput
    qualityMeasures?: PopulationQualityMeasureUncheckedUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUncheckedUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUncheckedUpdateManyWithoutPopulationNestedInput
  }

  export type PopulationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type PopulationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopulationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopulationMemberCreateInput = {
    id?: string
    populationId: string
    patientId: string
    fhirPatientRef?: string | null
    enrolledAt?: Date | string
    disenrolledAt?: Date | string | null
    status?: $Enums.MemberStatus
    currentRiskScore?: number | null
    riskTier?: $Enums.RiskTier | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationMemberUncheckedCreateInput = {
    id?: string
    populationId: string
    patientId: string
    fhirPatientRef?: string | null
    enrolledAt?: Date | string
    disenrolledAt?: Date | string | null
    status?: $Enums.MemberStatus
    currentRiskScore?: number | null
    riskTier?: $Enums.RiskTier | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disenrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    currentRiskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskTier?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disenrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    currentRiskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskTier?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationMemberCreateManyInput = {
    id?: string
    populationId: string
    patientId: string
    fhirPatientRef?: string | null
    enrolledAt?: Date | string
    disenrolledAt?: Date | string | null
    status?: $Enums.MemberStatus
    currentRiskScore?: number | null
    riskTier?: $Enums.RiskTier | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disenrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    currentRiskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskTier?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disenrolledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    currentRiskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    riskTier?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortCreateInput = {
    id?: string
    name: string
    description?: string | null
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    population: PopulationCreateNestedOneWithoutCohortsInput
    careGaps?: CareGapCreateNestedManyWithoutCohortInput
  }

  export type CohortUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    populationId: string
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    careGaps?: CareGapUncheckedCreateNestedManyWithoutCohortInput
  }

  export type CohortUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    population?: PopulationUpdateOneRequiredWithoutCohortsNestedInput
    careGaps?: CareGapUpdateManyWithoutCohortNestedInput
  }

  export type CohortUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    populationId?: StringFieldUpdateOperationsInput | string
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    careGaps?: CareGapUncheckedUpdateManyWithoutCohortNestedInput
  }

  export type CohortCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    populationId: string
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type CohortUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CohortUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    populationId?: StringFieldUpdateOperationsInput | string
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CohortMemberCreateInput = {
    id?: string
    cohortId: string
    patientId: string
    fhirPatientRef?: string | null
    assignedAt?: Date | string
    removedAt?: Date | string | null
    status?: $Enums.MemberStatus
    riskScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CohortMemberUncheckedCreateInput = {
    id?: string
    cohortId: string
    patientId: string
    fhirPatientRef?: string | null
    assignedAt?: Date | string
    removedAt?: Date | string | null
    status?: $Enums.MemberStatus
    riskScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CohortMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortMemberCreateManyInput = {
    id?: string
    cohortId: string
    patientId: string
    fhirPatientRef?: string | null
    assignedAt?: Date | string
    removedAt?: Date | string | null
    status?: $Enums.MemberStatus
    riskScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CohortMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CohortMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityMeasureCreateInput = {
    id?: string
    measureId: string
    name: string
    description?: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward?: string | null
    domain?: string | null
    fhirMeasureId?: string | null
    fhirVersion?: string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: number | null
    measurePeriodStart?: Date | string | null
    measurePeriodEnd?: Date | string | null
    reportingYear?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    populationMeasures?: PopulationQualityMeasureCreateNestedManyWithoutQualityMeasureInput
    patientMeasures?: PatientQualityMeasureCreateNestedManyWithoutQualityMeasureInput
  }

  export type QualityMeasureUncheckedCreateInput = {
    id?: string
    measureId: string
    name: string
    description?: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward?: string | null
    domain?: string | null
    fhirMeasureId?: string | null
    fhirVersion?: string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: number | null
    measurePeriodStart?: Date | string | null
    measurePeriodEnd?: Date | string | null
    reportingYear?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    populationMeasures?: PopulationQualityMeasureUncheckedCreateNestedManyWithoutQualityMeasureInput
    patientMeasures?: PatientQualityMeasureUncheckedCreateNestedManyWithoutQualityMeasureInput
  }

  export type QualityMeasureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    populationMeasures?: PopulationQualityMeasureUpdateManyWithoutQualityMeasureNestedInput
    patientMeasures?: PatientQualityMeasureUpdateManyWithoutQualityMeasureNestedInput
  }

  export type QualityMeasureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    populationMeasures?: PopulationQualityMeasureUncheckedUpdateManyWithoutQualityMeasureNestedInput
    patientMeasures?: PatientQualityMeasureUncheckedUpdateManyWithoutQualityMeasureNestedInput
  }

  export type QualityMeasureCreateManyInput = {
    id?: string
    measureId: string
    name: string
    description?: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward?: string | null
    domain?: string | null
    fhirMeasureId?: string | null
    fhirVersion?: string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: number | null
    measurePeriodStart?: Date | string | null
    measurePeriodEnd?: Date | string | null
    reportingYear?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityMeasureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityMeasureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationQualityMeasureCreateInput = {
    id?: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    population: PopulationCreateNestedOneWithoutQualityMeasuresInput
    qualityMeasure: QualityMeasureCreateNestedOneWithoutPopulationMeasuresInput
  }

  export type PopulationQualityMeasureUncheckedCreateInput = {
    id?: string
    populationId: string
    qualityMeasureId: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationQualityMeasureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: PopulationUpdateOneRequiredWithoutQualityMeasuresNestedInput
    qualityMeasure?: QualityMeasureUpdateOneRequiredWithoutPopulationMeasuresNestedInput
  }

  export type PopulationQualityMeasureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    qualityMeasureId?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationQualityMeasureCreateManyInput = {
    id?: string
    populationId: string
    qualityMeasureId: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationQualityMeasureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationQualityMeasureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    qualityMeasureId?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientQualityMeasureCreateInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: string | null
    status?: $Enums.ComplianceStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    evidenceRef?: string | null
    notes?: string | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityMeasure: QualityMeasureCreateNestedOneWithoutPatientMeasuresInput
  }

  export type PatientQualityMeasureUncheckedCreateInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    qualityMeasureId: string
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: string | null
    status?: $Enums.ComplianceStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    evidenceRef?: string | null
    notes?: string | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientQualityMeasureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    inDenominator?: BoolFieldUpdateOperationsInput | boolean
    inNumerator?: BoolFieldUpdateOperationsInput | boolean
    isExcluded?: BoolFieldUpdateOperationsInput | boolean
    exclusionReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityMeasure?: QualityMeasureUpdateOneRequiredWithoutPatientMeasuresNestedInput
  }

  export type PatientQualityMeasureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    qualityMeasureId?: StringFieldUpdateOperationsInput | string
    inDenominator?: BoolFieldUpdateOperationsInput | boolean
    inNumerator?: BoolFieldUpdateOperationsInput | boolean
    isExcluded?: BoolFieldUpdateOperationsInput | boolean
    exclusionReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientQualityMeasureCreateManyInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    qualityMeasureId: string
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: string | null
    status?: $Enums.ComplianceStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    evidenceRef?: string | null
    notes?: string | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientQualityMeasureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    inDenominator?: BoolFieldUpdateOperationsInput | boolean
    inNumerator?: BoolFieldUpdateOperationsInput | boolean
    isExcluded?: BoolFieldUpdateOperationsInput | boolean
    exclusionReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientQualityMeasureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    qualityMeasureId?: StringFieldUpdateOperationsInput | string
    inDenominator?: BoolFieldUpdateOperationsInput | boolean
    inNumerator?: BoolFieldUpdateOperationsInput | boolean
    isExcluded?: BoolFieldUpdateOperationsInput | boolean
    exclusionReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoreCreateInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    modelName: string
    modelVersion?: string | null
    scoreType: $Enums.ScoreType
    rawScore: number
    normalizedScore?: number | null
    percentile?: number | null
    riskTier: $Enums.RiskTier
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    clinicalFactors?: NullableJsonNullValueInput | InputJsonValue
    socialFactors?: NullableJsonNullValueInput | InputJsonValue
    predictedCost?: number | null
    predictedEvents?: NullableJsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expirationDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskScoreUncheckedCreateInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    modelName: string
    modelVersion?: string | null
    scoreType: $Enums.ScoreType
    rawScore: number
    normalizedScore?: number | null
    percentile?: number | null
    riskTier: $Enums.RiskTier
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    clinicalFactors?: NullableJsonNullValueInput | InputJsonValue
    socialFactors?: NullableJsonNullValueInput | InputJsonValue
    predictedCost?: number | null
    predictedEvents?: NullableJsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expirationDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    rawScore?: FloatFieldUpdateOperationsInput | number
    normalizedScore?: NullableFloatFieldUpdateOperationsInput | number | null
    percentile?: NullableIntFieldUpdateOperationsInput | number | null
    riskTier?: EnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    clinicalFactors?: NullableJsonNullValueInput | InputJsonValue
    socialFactors?: NullableJsonNullValueInput | InputJsonValue
    predictedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    predictedEvents?: NullableJsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    rawScore?: FloatFieldUpdateOperationsInput | number
    normalizedScore?: NullableFloatFieldUpdateOperationsInput | number | null
    percentile?: NullableIntFieldUpdateOperationsInput | number | null
    riskTier?: EnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    clinicalFactors?: NullableJsonNullValueInput | InputJsonValue
    socialFactors?: NullableJsonNullValueInput | InputJsonValue
    predictedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    predictedEvents?: NullableJsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoreCreateManyInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    modelName: string
    modelVersion?: string | null
    scoreType: $Enums.ScoreType
    rawScore: number
    normalizedScore?: number | null
    percentile?: number | null
    riskTier: $Enums.RiskTier
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    clinicalFactors?: NullableJsonNullValueInput | InputJsonValue
    socialFactors?: NullableJsonNullValueInput | InputJsonValue
    predictedCost?: number | null
    predictedEvents?: NullableJsonNullValueInput | InputJsonValue
    effectiveDate?: Date | string
    expirationDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    rawScore?: FloatFieldUpdateOperationsInput | number
    normalizedScore?: NullableFloatFieldUpdateOperationsInput | number | null
    percentile?: NullableIntFieldUpdateOperationsInput | number | null
    riskTier?: EnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    clinicalFactors?: NullableJsonNullValueInput | InputJsonValue
    socialFactors?: NullableJsonNullValueInput | InputJsonValue
    predictedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    predictedEvents?: NullableJsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    modelName?: StringFieldUpdateOperationsInput | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    rawScore?: FloatFieldUpdateOperationsInput | number
    normalizedScore?: NullableFloatFieldUpdateOperationsInput | number | null
    percentile?: NullableIntFieldUpdateOperationsInput | number | null
    riskTier?: EnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    clinicalFactors?: NullableJsonNullValueInput | InputJsonValue
    socialFactors?: NullableJsonNullValueInput | InputJsonValue
    predictedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    predictedEvents?: NullableJsonNullValueInput | InputJsonValue
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareGapCreateInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    gapType: $Enums.GapType
    title: string
    description?: string | null
    priority?: $Enums.GapPriority
    qualityMeasureId?: string | null
    recommendedAction?: string | null
    actionDueDate?: Date | string | null
    status?: $Enums.GapStatus
    identifiedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolutionNotes?: string | null
    fhirConditionRef?: string | null
    fhirProcedureRef?: string | null
    fhirMedicationRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cohort?: CohortCreateNestedOneWithoutCareGapsInput
  }

  export type CareGapUncheckedCreateInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    cohortId?: string | null
    gapType: $Enums.GapType
    title: string
    description?: string | null
    priority?: $Enums.GapPriority
    qualityMeasureId?: string | null
    recommendedAction?: string | null
    actionDueDate?: Date | string | null
    status?: $Enums.GapStatus
    identifiedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolutionNotes?: string | null
    fhirConditionRef?: string | null
    fhirProcedureRef?: string | null
    fhirMedicationRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareGapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    gapType?: EnumGapTypeFieldUpdateOperationsInput | $Enums.GapType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumGapPriorityFieldUpdateOperationsInput | $Enums.GapPriority
    qualityMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGapStatusFieldUpdateOperationsInput | $Enums.GapStatus
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirProcedureRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMedicationRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cohort?: CohortUpdateOneWithoutCareGapsNestedInput
  }

  export type CareGapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    cohortId?: NullableStringFieldUpdateOperationsInput | string | null
    gapType?: EnumGapTypeFieldUpdateOperationsInput | $Enums.GapType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumGapPriorityFieldUpdateOperationsInput | $Enums.GapPriority
    qualityMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGapStatusFieldUpdateOperationsInput | $Enums.GapStatus
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirProcedureRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMedicationRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareGapCreateManyInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    cohortId?: string | null
    gapType: $Enums.GapType
    title: string
    description?: string | null
    priority?: $Enums.GapPriority
    qualityMeasureId?: string | null
    recommendedAction?: string | null
    actionDueDate?: Date | string | null
    status?: $Enums.GapStatus
    identifiedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolutionNotes?: string | null
    fhirConditionRef?: string | null
    fhirProcedureRef?: string | null
    fhirMedicationRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareGapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    gapType?: EnumGapTypeFieldUpdateOperationsInput | $Enums.GapType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumGapPriorityFieldUpdateOperationsInput | $Enums.GapPriority
    qualityMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGapStatusFieldUpdateOperationsInput | $Enums.GapStatus
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirProcedureRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMedicationRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareGapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    cohortId?: NullableStringFieldUpdateOperationsInput | string | null
    gapType?: EnumGapTypeFieldUpdateOperationsInput | $Enums.GapType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumGapPriorityFieldUpdateOperationsInput | $Enums.GapPriority
    qualityMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGapStatusFieldUpdateOperationsInput | $Enums.GapStatus
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirProcedureRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMedicationRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdohFactorCreateInput = {
    id?: string
    patientId?: string | null
    fhirPatientRef?: string | null
    category: $Enums.SdohCategory
    factor: string
    value?: string | null
    severity?: $Enums.SdohSeverity | null
    assessmentDate?: Date | string
    assessmentTool?: string | null
    screeningScore?: number | null
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: string | null
    interventionStatus?: string | null
    referralMade?: boolean
    referralDetails?: string | null
    fhirObservationRef?: string | null
    fhirConditionRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    population?: PopulationCreateNestedOneWithoutSdohFactorsInput
  }

  export type SdohFactorUncheckedCreateInput = {
    id?: string
    patientId?: string | null
    populationId?: string | null
    fhirPatientRef?: string | null
    category: $Enums.SdohCategory
    factor: string
    value?: string | null
    severity?: $Enums.SdohSeverity | null
    assessmentDate?: Date | string
    assessmentTool?: string | null
    screeningScore?: number | null
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: string | null
    interventionStatus?: string | null
    referralMade?: boolean
    referralDetails?: string | null
    fhirObservationRef?: string | null
    fhirConditionRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdohFactorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumSdohCategoryFieldUpdateOperationsInput | $Enums.SdohCategory
    factor?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumSdohSeverityFieldUpdateOperationsInput | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentTool?: NullableStringFieldUpdateOperationsInput | string | null
    screeningScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isPositiveScreen?: BoolFieldUpdateOperationsInput | boolean
    interventionNeeded?: BoolFieldUpdateOperationsInput | boolean
    interventionType?: NullableStringFieldUpdateOperationsInput | string | null
    interventionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referralMade?: BoolFieldUpdateOperationsInput | boolean
    referralDetails?: NullableStringFieldUpdateOperationsInput | string | null
    fhirObservationRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: PopulationUpdateOneWithoutSdohFactorsNestedInput
  }

  export type SdohFactorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumSdohCategoryFieldUpdateOperationsInput | $Enums.SdohCategory
    factor?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumSdohSeverityFieldUpdateOperationsInput | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentTool?: NullableStringFieldUpdateOperationsInput | string | null
    screeningScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isPositiveScreen?: BoolFieldUpdateOperationsInput | boolean
    interventionNeeded?: BoolFieldUpdateOperationsInput | boolean
    interventionType?: NullableStringFieldUpdateOperationsInput | string | null
    interventionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referralMade?: BoolFieldUpdateOperationsInput | boolean
    referralDetails?: NullableStringFieldUpdateOperationsInput | string | null
    fhirObservationRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdohFactorCreateManyInput = {
    id?: string
    patientId?: string | null
    populationId?: string | null
    fhirPatientRef?: string | null
    category: $Enums.SdohCategory
    factor: string
    value?: string | null
    severity?: $Enums.SdohSeverity | null
    assessmentDate?: Date | string
    assessmentTool?: string | null
    screeningScore?: number | null
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: string | null
    interventionStatus?: string | null
    referralMade?: boolean
    referralDetails?: string | null
    fhirObservationRef?: string | null
    fhirConditionRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdohFactorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumSdohCategoryFieldUpdateOperationsInput | $Enums.SdohCategory
    factor?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumSdohSeverityFieldUpdateOperationsInput | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentTool?: NullableStringFieldUpdateOperationsInput | string | null
    screeningScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isPositiveScreen?: BoolFieldUpdateOperationsInput | boolean
    interventionNeeded?: BoolFieldUpdateOperationsInput | boolean
    interventionType?: NullableStringFieldUpdateOperationsInput | string | null
    interventionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referralMade?: BoolFieldUpdateOperationsInput | boolean
    referralDetails?: NullableStringFieldUpdateOperationsInput | string | null
    fhirObservationRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdohFactorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumSdohCategoryFieldUpdateOperationsInput | $Enums.SdohCategory
    factor?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumSdohSeverityFieldUpdateOperationsInput | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentTool?: NullableStringFieldUpdateOperationsInput | string | null
    screeningScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isPositiveScreen?: BoolFieldUpdateOperationsInput | boolean
    interventionNeeded?: BoolFieldUpdateOperationsInput | boolean
    interventionType?: NullableStringFieldUpdateOperationsInput | string | null
    interventionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referralMade?: BoolFieldUpdateOperationsInput | boolean
    referralDetails?: NullableStringFieldUpdateOperationsInput | string | null
    fhirObservationRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiseaseRegistryCreateInput = {
    id?: string
    conditionCode: string
    conditionName: string
    populationId?: string | null
    prevalenceCount?: number
    prevalenceRate?: number | null
    incidenceCount?: number
    incidenceRate?: number | null
    periodStart: Date | string
    periodEnd: Date | string
    ageDistribution?: NullableJsonNullValueInput | InputJsonValue
    genderDistribution?: NullableJsonNullValueInput | InputJsonValue
    raceDistribution?: NullableJsonNullValueInput | InputJsonValue
    previousPeriodPrevalence?: number | null
    trendDirection?: $Enums.TrendDirection | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiseaseRegistryUncheckedCreateInput = {
    id?: string
    conditionCode: string
    conditionName: string
    populationId?: string | null
    prevalenceCount?: number
    prevalenceRate?: number | null
    incidenceCount?: number
    incidenceRate?: number | null
    periodStart: Date | string
    periodEnd: Date | string
    ageDistribution?: NullableJsonNullValueInput | InputJsonValue
    genderDistribution?: NullableJsonNullValueInput | InputJsonValue
    raceDistribution?: NullableJsonNullValueInput | InputJsonValue
    previousPeriodPrevalence?: number | null
    trendDirection?: $Enums.TrendDirection | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiseaseRegistryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionCode?: StringFieldUpdateOperationsInput | string
    conditionName?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    prevalenceCount?: IntFieldUpdateOperationsInput | number
    prevalenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    incidenceCount?: IntFieldUpdateOperationsInput | number
    incidenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    ageDistribution?: NullableJsonNullValueInput | InputJsonValue
    genderDistribution?: NullableJsonNullValueInput | InputJsonValue
    raceDistribution?: NullableJsonNullValueInput | InputJsonValue
    previousPeriodPrevalence?: NullableFloatFieldUpdateOperationsInput | number | null
    trendDirection?: NullableEnumTrendDirectionFieldUpdateOperationsInput | $Enums.TrendDirection | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiseaseRegistryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionCode?: StringFieldUpdateOperationsInput | string
    conditionName?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    prevalenceCount?: IntFieldUpdateOperationsInput | number
    prevalenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    incidenceCount?: IntFieldUpdateOperationsInput | number
    incidenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    ageDistribution?: NullableJsonNullValueInput | InputJsonValue
    genderDistribution?: NullableJsonNullValueInput | InputJsonValue
    raceDistribution?: NullableJsonNullValueInput | InputJsonValue
    previousPeriodPrevalence?: NullableFloatFieldUpdateOperationsInput | number | null
    trendDirection?: NullableEnumTrendDirectionFieldUpdateOperationsInput | $Enums.TrendDirection | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiseaseRegistryCreateManyInput = {
    id?: string
    conditionCode: string
    conditionName: string
    populationId?: string | null
    prevalenceCount?: number
    prevalenceRate?: number | null
    incidenceCount?: number
    incidenceRate?: number | null
    periodStart: Date | string
    periodEnd: Date | string
    ageDistribution?: NullableJsonNullValueInput | InputJsonValue
    genderDistribution?: NullableJsonNullValueInput | InputJsonValue
    raceDistribution?: NullableJsonNullValueInput | InputJsonValue
    previousPeriodPrevalence?: number | null
    trendDirection?: $Enums.TrendDirection | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiseaseRegistryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionCode?: StringFieldUpdateOperationsInput | string
    conditionName?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    prevalenceCount?: IntFieldUpdateOperationsInput | number
    prevalenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    incidenceCount?: IntFieldUpdateOperationsInput | number
    incidenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    ageDistribution?: NullableJsonNullValueInput | InputJsonValue
    genderDistribution?: NullableJsonNullValueInput | InputJsonValue
    raceDistribution?: NullableJsonNullValueInput | InputJsonValue
    previousPeriodPrevalence?: NullableFloatFieldUpdateOperationsInput | number | null
    trendDirection?: NullableEnumTrendDirectionFieldUpdateOperationsInput | $Enums.TrendDirection | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiseaseRegistryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionCode?: StringFieldUpdateOperationsInput | string
    conditionName?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    prevalenceCount?: IntFieldUpdateOperationsInput | number
    prevalenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    incidenceCount?: IntFieldUpdateOperationsInput | number
    incidenceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    ageDistribution?: NullableJsonNullValueInput | InputJsonValue
    genderDistribution?: NullableJsonNullValueInput | InputJsonValue
    raceDistribution?: NullableJsonNullValueInput | InputJsonValue
    previousPeriodPrevalence?: NullableFloatFieldUpdateOperationsInput | number | null
    trendDirection?: NullableEnumTrendDirectionFieldUpdateOperationsInput | $Enums.TrendDirection | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthEquityMetricCreateInput = {
    id?: string
    populationId?: string | null
    measureType: $Enums.EquityMeasureType
    stratificationDimension: string
    stratificationValue: string
    metricName: string
    metricValue: number
    referenceValue?: number | null
    disparityIndex?: number | null
    confidenceInterval?: NullableJsonNullValueInput | InputJsonValue
    pValue?: number | null
    sampleSize?: number | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthEquityMetricUncheckedCreateInput = {
    id?: string
    populationId?: string | null
    measureType: $Enums.EquityMeasureType
    stratificationDimension: string
    stratificationValue: string
    metricName: string
    metricValue: number
    referenceValue?: number | null
    disparityIndex?: number | null
    confidenceInterval?: NullableJsonNullValueInput | InputJsonValue
    pValue?: number | null
    sampleSize?: number | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthEquityMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumEquityMeasureTypeFieldUpdateOperationsInput | $Enums.EquityMeasureType
    stratificationDimension?: StringFieldUpdateOperationsInput | string
    stratificationValue?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    referenceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    disparityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceInterval?: NullableJsonNullValueInput | InputJsonValue
    pValue?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthEquityMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumEquityMeasureTypeFieldUpdateOperationsInput | $Enums.EquityMeasureType
    stratificationDimension?: StringFieldUpdateOperationsInput | string
    stratificationValue?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    referenceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    disparityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceInterval?: NullableJsonNullValueInput | InputJsonValue
    pValue?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthEquityMetricCreateManyInput = {
    id?: string
    populationId?: string | null
    measureType: $Enums.EquityMeasureType
    stratificationDimension: string
    stratificationValue: string
    metricName: string
    metricValue: number
    referenceValue?: number | null
    disparityIndex?: number | null
    confidenceInterval?: NullableJsonNullValueInput | InputJsonValue
    pValue?: number | null
    sampleSize?: number | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthEquityMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumEquityMeasureTypeFieldUpdateOperationsInput | $Enums.EquityMeasureType
    stratificationDimension?: StringFieldUpdateOperationsInput | string
    stratificationValue?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    referenceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    disparityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceInterval?: NullableJsonNullValueInput | InputJsonValue
    pValue?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthEquityMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumEquityMeasureTypeFieldUpdateOperationsInput | $Enums.EquityMeasureType
    stratificationDimension?: StringFieldUpdateOperationsInput | string
    stratificationValue?: StringFieldUpdateOperationsInput | string
    metricName?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    referenceValue?: NullableFloatFieldUpdateOperationsInput | number | null
    disparityIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceInterval?: NullableJsonNullValueInput | InputJsonValue
    pValue?: NullableFloatFieldUpdateOperationsInput | number | null
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportCreateInput = {
    id?: string
    reportType: $Enums.ReportType
    title: string
    description?: string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    population?: PopulationCreateNestedOneWithoutAnalyticsInput
  }

  export type AnalyticsReportUncheckedCreateInput = {
    id?: string
    populationId?: string | null
    reportType: $Enums.ReportType
    title: string
    description?: string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: PopulationUpdateOneWithoutAnalyticsNestedInput
  }

  export type AnalyticsReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportCreateManyInput = {
    id?: string
    populationId?: string | null
    reportType: $Enums.ReportType
    title: string
    description?: string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictiveModelCreateInput = {
    id?: string
    name: string
    description?: string | null
    modelType: $Enums.PredictiveModelType
    algorithm: string
    features: JsonNullValueInput | InputJsonValue
    hyperparameters?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    auc?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    version: string
    isActive?: boolean
    trainedAt?: Date | string | null
    trainingSampleSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictiveModelUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    modelType: $Enums.PredictiveModelType
    algorithm: string
    features: JsonNullValueInput | InputJsonValue
    hyperparameters?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    auc?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    version: string
    isActive?: boolean
    trainedAt?: Date | string | null
    trainingSampleSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictiveModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modelType?: EnumPredictiveModelTypeFieldUpdateOperationsInput | $Enums.PredictiveModelType
    algorithm?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    hyperparameters?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    auc?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingSampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictiveModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modelType?: EnumPredictiveModelTypeFieldUpdateOperationsInput | $Enums.PredictiveModelType
    algorithm?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    hyperparameters?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    auc?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingSampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictiveModelCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    modelType: $Enums.PredictiveModelType
    algorithm: string
    features: JsonNullValueInput | InputJsonValue
    hyperparameters?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    auc?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    version: string
    isActive?: boolean
    trainedAt?: Date | string | null
    trainingSampleSize?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictiveModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modelType?: EnumPredictiveModelTypeFieldUpdateOperationsInput | $Enums.PredictiveModelType
    algorithm?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    hyperparameters?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    auc?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingSampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictiveModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modelType?: EnumPredictiveModelTypeFieldUpdateOperationsInput | $Enums.PredictiveModelType
    algorithm?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    hyperparameters?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    auc?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingSampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAuditLogCreateInput = {
    id?: string
    userId: string
    action: string
    resourceType: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsAuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resourceType: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    resourceType: string
    resourceId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumDefinitionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DefinitionType | EnumDefinitionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDefinitionTypeFilter<$PrismaModel> | $Enums.DefinitionType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumPopulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PopulationStatus | EnumPopulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPopulationStatusFilter<$PrismaModel> | $Enums.PopulationStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CohortListRelationFilter = {
    every?: CohortWhereInput
    some?: CohortWhereInput
    none?: CohortWhereInput
  }

  export type PopulationQualityMeasureListRelationFilter = {
    every?: PopulationQualityMeasureWhereInput
    some?: PopulationQualityMeasureWhereInput
    none?: PopulationQualityMeasureWhereInput
  }

  export type AnalyticsReportListRelationFilter = {
    every?: AnalyticsReportWhereInput
    some?: AnalyticsReportWhereInput
    none?: AnalyticsReportWhereInput
  }

  export type SdohFactorListRelationFilter = {
    every?: SdohFactorWhereInput
    some?: SdohFactorWhereInput
    none?: SdohFactorWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CohortOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PopulationQualityMeasureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SdohFactorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PopulationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    definitionType?: SortOrder
    criteria?: SortOrder
    memberCount?: SortOrder
    status?: SortOrder
    fhirGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PopulationAvgOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type PopulationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    definitionType?: SortOrder
    memberCount?: SortOrder
    status?: SortOrder
    fhirGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PopulationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    definitionType?: SortOrder
    memberCount?: SortOrder
    status?: SortOrder
    fhirGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PopulationSumOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumDefinitionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefinitionType | EnumDefinitionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDefinitionTypeWithAggregatesFilter<$PrismaModel> | $Enums.DefinitionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefinitionTypeFilter<$PrismaModel>
    _max?: NestedEnumDefinitionTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPopulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PopulationStatus | EnumPopulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPopulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PopulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPopulationStatusFilter<$PrismaModel>
    _max?: NestedEnumPopulationStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumRiskTierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskTierNullableFilter<$PrismaModel> | $Enums.RiskTier | null
  }

  export type PopulationMemberPopulationIdPatientIdCompoundUniqueInput = {
    populationId: string
    patientId: string
  }

  export type PopulationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    enrolledAt?: SortOrder
    disenrolledAt?: SortOrder
    status?: SortOrder
    currentRiskScore?: SortOrder
    riskTier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PopulationMemberAvgOrderByAggregateInput = {
    currentRiskScore?: SortOrder
  }

  export type PopulationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    enrolledAt?: SortOrder
    disenrolledAt?: SortOrder
    status?: SortOrder
    currentRiskScore?: SortOrder
    riskTier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PopulationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    enrolledAt?: SortOrder
    disenrolledAt?: SortOrder
    status?: SortOrder
    currentRiskScore?: SortOrder
    riskTier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PopulationMemberSumOrderByAggregateInput = {
    currentRiskScore?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumRiskTierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskTierNullableWithAggregatesFilter<$PrismaModel> | $Enums.RiskTier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRiskTierNullableFilter<$PrismaModel>
    _max?: NestedEnumRiskTierNullableFilter<$PrismaModel>
  }

  export type EnumCohortTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CohortType | EnumCohortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCohortTypeFilter<$PrismaModel> | $Enums.CohortType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PopulationRelationFilter = {
    is?: PopulationWhereInput
    isNot?: PopulationWhereInput
  }

  export type CareGapListRelationFilter = {
    every?: CareGapWhereInput
    some?: CareGapWhereInput
    none?: CareGapWhereInput
  }

  export type CareGapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CohortCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    populationId?: SortOrder
    cohortType?: SortOrder
    criteria?: SortOrder
    memberCount?: SortOrder
    fhirGroupId?: SortOrder
    riskLevel?: SortOrder
    interventionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CohortAvgOrderByAggregateInput = {
    memberCount?: SortOrder
    interventionPriority?: SortOrder
  }

  export type CohortMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    populationId?: SortOrder
    cohortType?: SortOrder
    memberCount?: SortOrder
    fhirGroupId?: SortOrder
    riskLevel?: SortOrder
    interventionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CohortMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    populationId?: SortOrder
    cohortType?: SortOrder
    memberCount?: SortOrder
    fhirGroupId?: SortOrder
    riskLevel?: SortOrder
    interventionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CohortSumOrderByAggregateInput = {
    memberCount?: SortOrder
    interventionPriority?: SortOrder
  }

  export type EnumCohortTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CohortType | EnumCohortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCohortTypeWithAggregatesFilter<$PrismaModel> | $Enums.CohortType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCohortTypeFilter<$PrismaModel>
    _max?: NestedEnumCohortTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CohortMemberCohortIdPatientIdCompoundUniqueInput = {
    cohortId: string
    patientId: string
  }

  export type CohortMemberCountOrderByAggregateInput = {
    id?: SortOrder
    cohortId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortMemberAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type CohortMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    cohortId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortMemberMinOrderByAggregateInput = {
    id?: SortOrder
    cohortId?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrder
    status?: SortOrder
    riskScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CohortMemberSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type EnumMeasureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureType | EnumMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureTypeFilter<$PrismaModel> | $Enums.MeasureType
  }

  export type EnumMeasureCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureCategory | EnumMeasureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureCategoryFilter<$PrismaModel> | $Enums.MeasureCategory
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PatientQualityMeasureListRelationFilter = {
    every?: PatientQualityMeasureWhereInput
    some?: PatientQualityMeasureWhereInput
    none?: PatientQualityMeasureWhereInput
  }

  export type PatientQualityMeasureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QualityMeasureCountOrderByAggregateInput = {
    id?: SortOrder
    measureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    measureType?: SortOrder
    category?: SortOrder
    steward?: SortOrder
    domain?: SortOrder
    fhirMeasureId?: SortOrder
    fhirVersion?: SortOrder
    numeratorCriteria?: SortOrder
    denominatorCriteria?: SortOrder
    exclusionCriteria?: SortOrder
    targetRate?: SortOrder
    measurePeriodStart?: SortOrder
    measurePeriodEnd?: SortOrder
    reportingYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityMeasureAvgOrderByAggregateInput = {
    targetRate?: SortOrder
    reportingYear?: SortOrder
  }

  export type QualityMeasureMaxOrderByAggregateInput = {
    id?: SortOrder
    measureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    measureType?: SortOrder
    category?: SortOrder
    steward?: SortOrder
    domain?: SortOrder
    fhirMeasureId?: SortOrder
    fhirVersion?: SortOrder
    targetRate?: SortOrder
    measurePeriodStart?: SortOrder
    measurePeriodEnd?: SortOrder
    reportingYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityMeasureMinOrderByAggregateInput = {
    id?: SortOrder
    measureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    measureType?: SortOrder
    category?: SortOrder
    steward?: SortOrder
    domain?: SortOrder
    fhirMeasureId?: SortOrder
    fhirVersion?: SortOrder
    targetRate?: SortOrder
    measurePeriodStart?: SortOrder
    measurePeriodEnd?: SortOrder
    reportingYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityMeasureSumOrderByAggregateInput = {
    targetRate?: SortOrder
    reportingYear?: SortOrder
  }

  export type EnumMeasureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureType | EnumMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureTypeWithAggregatesFilter<$PrismaModel> | $Enums.MeasureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeasureTypeFilter<$PrismaModel>
    _max?: NestedEnumMeasureTypeFilter<$PrismaModel>
  }

  export type EnumMeasureCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureCategory | EnumMeasureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MeasureCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeasureCategoryFilter<$PrismaModel>
    _max?: NestedEnumMeasureCategoryFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QualityMeasureRelationFilter = {
    is?: QualityMeasureWhereInput
    isNot?: QualityMeasureWhereInput
  }

  export type PopulationQualityMeasurePopulationIdQualityMeasureIdMeasurePeriodCompoundUniqueInput = {
    populationId: string
    qualityMeasureId: string
    measurePeriod: string
  }

  export type PopulationQualityMeasureCountOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    qualityMeasureId?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    exclusions?: SortOrder
    performanceRate?: SortOrder
    benchmarkRate?: SortOrder
    benchmarkPercentile?: SortOrder
    starRating?: SortOrder
    measurePeriod?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PopulationQualityMeasureAvgOrderByAggregateInput = {
    numerator?: SortOrder
    denominator?: SortOrder
    exclusions?: SortOrder
    performanceRate?: SortOrder
    benchmarkRate?: SortOrder
    benchmarkPercentile?: SortOrder
    starRating?: SortOrder
  }

  export type PopulationQualityMeasureMaxOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    qualityMeasureId?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    exclusions?: SortOrder
    performanceRate?: SortOrder
    benchmarkRate?: SortOrder
    benchmarkPercentile?: SortOrder
    starRating?: SortOrder
    measurePeriod?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PopulationQualityMeasureMinOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    qualityMeasureId?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    exclusions?: SortOrder
    performanceRate?: SortOrder
    benchmarkRate?: SortOrder
    benchmarkPercentile?: SortOrder
    starRating?: SortOrder
    measurePeriod?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PopulationQualityMeasureSumOrderByAggregateInput = {
    numerator?: SortOrder
    denominator?: SortOrder
    exclusions?: SortOrder
    performanceRate?: SortOrder
    benchmarkRate?: SortOrder
    benchmarkPercentile?: SortOrder
    starRating?: SortOrder
  }

  export type EnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type PatientQualityMeasurePatientIdQualityMeasureIdMeasurePeriodCompoundUniqueInput = {
    patientId: string
    qualityMeasureId: string
    measurePeriod: string
  }

  export type PatientQualityMeasureCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    qualityMeasureId?: SortOrder
    inDenominator?: SortOrder
    inNumerator?: SortOrder
    isExcluded?: SortOrder
    exclusionReason?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    evidenceRef?: SortOrder
    notes?: SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientQualityMeasureMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    qualityMeasureId?: SortOrder
    inDenominator?: SortOrder
    inNumerator?: SortOrder
    isExcluded?: SortOrder
    exclusionReason?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    evidenceRef?: SortOrder
    notes?: SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientQualityMeasureMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    qualityMeasureId?: SortOrder
    inDenominator?: SortOrder
    inNumerator?: SortOrder
    isExcluded?: SortOrder
    exclusionReason?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    evidenceRef?: SortOrder
    notes?: SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type EnumScoreTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeFilter<$PrismaModel> | $Enums.ScoreType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumRiskTierFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel>
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskTierFilter<$PrismaModel> | $Enums.RiskTier
  }

  export type RiskScoreCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    scoreType?: SortOrder
    rawScore?: SortOrder
    normalizedScore?: SortOrder
    percentile?: SortOrder
    riskTier?: SortOrder
    riskFactors?: SortOrder
    clinicalFactors?: SortOrder
    socialFactors?: SortOrder
    predictedCost?: SortOrder
    predictedEvents?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoreAvgOrderByAggregateInput = {
    rawScore?: SortOrder
    normalizedScore?: SortOrder
    percentile?: SortOrder
    predictedCost?: SortOrder
  }

  export type RiskScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    scoreType?: SortOrder
    rawScore?: SortOrder
    normalizedScore?: SortOrder
    percentile?: SortOrder
    riskTier?: SortOrder
    predictedCost?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoreMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    modelName?: SortOrder
    modelVersion?: SortOrder
    scoreType?: SortOrder
    rawScore?: SortOrder
    normalizedScore?: SortOrder
    percentile?: SortOrder
    riskTier?: SortOrder
    predictedCost?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskScoreSumOrderByAggregateInput = {
    rawScore?: SortOrder
    normalizedScore?: SortOrder
    percentile?: SortOrder
    predictedCost?: SortOrder
  }

  export type EnumScoreTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoreType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreTypeFilter<$PrismaModel>
    _max?: NestedEnumScoreTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumRiskTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel>
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskTierWithAggregatesFilter<$PrismaModel> | $Enums.RiskTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskTierFilter<$PrismaModel>
    _max?: NestedEnumRiskTierFilter<$PrismaModel>
  }

  export type EnumGapTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GapType | EnumGapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGapTypeFilter<$PrismaModel> | $Enums.GapType
  }

  export type EnumGapPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.GapPriority | EnumGapPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumGapPriorityFilter<$PrismaModel> | $Enums.GapPriority
  }

  export type EnumGapStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GapStatus | EnumGapStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGapStatusFilter<$PrismaModel> | $Enums.GapStatus
  }

  export type CohortNullableRelationFilter = {
    is?: CohortWhereInput | null
    isNot?: CohortWhereInput | null
  }

  export type CareGapCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    cohortId?: SortOrder
    gapType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    qualityMeasureId?: SortOrder
    recommendedAction?: SortOrder
    actionDueDate?: SortOrder
    status?: SortOrder
    identifiedAt?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    resolutionNotes?: SortOrder
    fhirConditionRef?: SortOrder
    fhirProcedureRef?: SortOrder
    fhirMedicationRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareGapMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    cohortId?: SortOrder
    gapType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    qualityMeasureId?: SortOrder
    recommendedAction?: SortOrder
    actionDueDate?: SortOrder
    status?: SortOrder
    identifiedAt?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    resolutionNotes?: SortOrder
    fhirConditionRef?: SortOrder
    fhirProcedureRef?: SortOrder
    fhirMedicationRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareGapMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    fhirPatientRef?: SortOrder
    cohortId?: SortOrder
    gapType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    qualityMeasureId?: SortOrder
    recommendedAction?: SortOrder
    actionDueDate?: SortOrder
    status?: SortOrder
    identifiedAt?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    resolutionNotes?: SortOrder
    fhirConditionRef?: SortOrder
    fhirProcedureRef?: SortOrder
    fhirMedicationRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGapTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GapType | EnumGapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGapTypeWithAggregatesFilter<$PrismaModel> | $Enums.GapType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGapTypeFilter<$PrismaModel>
    _max?: NestedEnumGapTypeFilter<$PrismaModel>
  }

  export type EnumGapPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GapPriority | EnumGapPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumGapPriorityWithAggregatesFilter<$PrismaModel> | $Enums.GapPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGapPriorityFilter<$PrismaModel>
    _max?: NestedEnumGapPriorityFilter<$PrismaModel>
  }

  export type EnumGapStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GapStatus | EnumGapStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGapStatusWithAggregatesFilter<$PrismaModel> | $Enums.GapStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGapStatusFilter<$PrismaModel>
    _max?: NestedEnumGapStatusFilter<$PrismaModel>
  }

  export type EnumSdohCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohCategory | EnumSdohCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSdohCategoryFilter<$PrismaModel> | $Enums.SdohCategory
  }

  export type EnumSdohSeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohSeverity | EnumSdohSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSdohSeverityNullableFilter<$PrismaModel> | $Enums.SdohSeverity | null
  }

  export type PopulationNullableRelationFilter = {
    is?: PopulationWhereInput | null
    isNot?: PopulationWhereInput | null
  }

  export type SdohFactorCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    populationId?: SortOrder
    fhirPatientRef?: SortOrder
    category?: SortOrder
    factor?: SortOrder
    value?: SortOrder
    severity?: SortOrder
    assessmentDate?: SortOrder
    assessmentTool?: SortOrder
    screeningScore?: SortOrder
    isPositiveScreen?: SortOrder
    interventionNeeded?: SortOrder
    interventionType?: SortOrder
    interventionStatus?: SortOrder
    referralMade?: SortOrder
    referralDetails?: SortOrder
    fhirObservationRef?: SortOrder
    fhirConditionRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SdohFactorAvgOrderByAggregateInput = {
    screeningScore?: SortOrder
  }

  export type SdohFactorMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    populationId?: SortOrder
    fhirPatientRef?: SortOrder
    category?: SortOrder
    factor?: SortOrder
    value?: SortOrder
    severity?: SortOrder
    assessmentDate?: SortOrder
    assessmentTool?: SortOrder
    screeningScore?: SortOrder
    isPositiveScreen?: SortOrder
    interventionNeeded?: SortOrder
    interventionType?: SortOrder
    interventionStatus?: SortOrder
    referralMade?: SortOrder
    referralDetails?: SortOrder
    fhirObservationRef?: SortOrder
    fhirConditionRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SdohFactorMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    populationId?: SortOrder
    fhirPatientRef?: SortOrder
    category?: SortOrder
    factor?: SortOrder
    value?: SortOrder
    severity?: SortOrder
    assessmentDate?: SortOrder
    assessmentTool?: SortOrder
    screeningScore?: SortOrder
    isPositiveScreen?: SortOrder
    interventionNeeded?: SortOrder
    interventionType?: SortOrder
    interventionStatus?: SortOrder
    referralMade?: SortOrder
    referralDetails?: SortOrder
    fhirObservationRef?: SortOrder
    fhirConditionRef?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SdohFactorSumOrderByAggregateInput = {
    screeningScore?: SortOrder
  }

  export type EnumSdohCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohCategory | EnumSdohCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSdohCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SdohCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSdohCategoryFilter<$PrismaModel>
    _max?: NestedEnumSdohCategoryFilter<$PrismaModel>
  }

  export type EnumSdohSeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohSeverity | EnumSdohSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSdohSeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.SdohSeverity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSdohSeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumSdohSeverityNullableFilter<$PrismaModel>
  }

  export type EnumTrendDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrendDirection | EnumTrendDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrendDirectionNullableFilter<$PrismaModel> | $Enums.TrendDirection | null
  }

  export type DiseaseRegistryConditionCodePopulationIdPeriodStartCompoundUniqueInput = {
    conditionCode: string
    populationId: string
    periodStart: Date | string
  }

  export type DiseaseRegistryCountOrderByAggregateInput = {
    id?: SortOrder
    conditionCode?: SortOrder
    conditionName?: SortOrder
    populationId?: SortOrder
    prevalenceCount?: SortOrder
    prevalenceRate?: SortOrder
    incidenceCount?: SortOrder
    incidenceRate?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    ageDistribution?: SortOrder
    genderDistribution?: SortOrder
    raceDistribution?: SortOrder
    previousPeriodPrevalence?: SortOrder
    trendDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiseaseRegistryAvgOrderByAggregateInput = {
    prevalenceCount?: SortOrder
    prevalenceRate?: SortOrder
    incidenceCount?: SortOrder
    incidenceRate?: SortOrder
    previousPeriodPrevalence?: SortOrder
  }

  export type DiseaseRegistryMaxOrderByAggregateInput = {
    id?: SortOrder
    conditionCode?: SortOrder
    conditionName?: SortOrder
    populationId?: SortOrder
    prevalenceCount?: SortOrder
    prevalenceRate?: SortOrder
    incidenceCount?: SortOrder
    incidenceRate?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    previousPeriodPrevalence?: SortOrder
    trendDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiseaseRegistryMinOrderByAggregateInput = {
    id?: SortOrder
    conditionCode?: SortOrder
    conditionName?: SortOrder
    populationId?: SortOrder
    prevalenceCount?: SortOrder
    prevalenceRate?: SortOrder
    incidenceCount?: SortOrder
    incidenceRate?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    previousPeriodPrevalence?: SortOrder
    trendDirection?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiseaseRegistrySumOrderByAggregateInput = {
    prevalenceCount?: SortOrder
    prevalenceRate?: SortOrder
    incidenceCount?: SortOrder
    incidenceRate?: SortOrder
    previousPeriodPrevalence?: SortOrder
  }

  export type EnumTrendDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrendDirection | EnumTrendDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrendDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrendDirection | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrendDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumTrendDirectionNullableFilter<$PrismaModel>
  }

  export type EnumEquityMeasureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EquityMeasureType | EnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquityMeasureTypeFilter<$PrismaModel> | $Enums.EquityMeasureType
  }

  export type HealthEquityMetricCountOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    measureType?: SortOrder
    stratificationDimension?: SortOrder
    stratificationValue?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    referenceValue?: SortOrder
    disparityIndex?: SortOrder
    confidenceInterval?: SortOrder
    pValue?: SortOrder
    sampleSize?: SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthEquityMetricAvgOrderByAggregateInput = {
    metricValue?: SortOrder
    referenceValue?: SortOrder
    disparityIndex?: SortOrder
    pValue?: SortOrder
    sampleSize?: SortOrder
  }

  export type HealthEquityMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    measureType?: SortOrder
    stratificationDimension?: SortOrder
    stratificationValue?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    referenceValue?: SortOrder
    disparityIndex?: SortOrder
    pValue?: SortOrder
    sampleSize?: SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthEquityMetricMinOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    measureType?: SortOrder
    stratificationDimension?: SortOrder
    stratificationValue?: SortOrder
    metricName?: SortOrder
    metricValue?: SortOrder
    referenceValue?: SortOrder
    disparityIndex?: SortOrder
    pValue?: SortOrder
    sampleSize?: SortOrder
    measurePeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthEquityMetricSumOrderByAggregateInput = {
    metricValue?: SortOrder
    referenceValue?: SortOrder
    disparityIndex?: SortOrder
    pValue?: SortOrder
    sampleSize?: SortOrder
  }

  export type EnumEquityMeasureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquityMeasureType | EnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquityMeasureTypeWithAggregatesFilter<$PrismaModel> | $Enums.EquityMeasureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquityMeasureTypeFilter<$PrismaModel>
    _max?: NestedEnumEquityMeasureTypeFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type AnalyticsReportCountOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    parameters?: SortOrder
    data?: SortOrder
    visualizations?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    exportFormats?: SortOrder
    lastExportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsReportMaxOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    lastExportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsReportMinOrderByAggregateInput = {
    id?: SortOrder
    populationId?: SortOrder
    reportType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    lastExportedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumPredictiveModelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictiveModelType | EnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictiveModelTypeFilter<$PrismaModel> | $Enums.PredictiveModelType
  }

  export type PredictiveModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    modelType?: SortOrder
    algorithm?: SortOrder
    features?: SortOrder
    hyperparameters?: SortOrder
    accuracy?: SortOrder
    auc?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    trainedAt?: SortOrder
    trainingSampleSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictiveModelAvgOrderByAggregateInput = {
    accuracy?: SortOrder
    auc?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    trainingSampleSize?: SortOrder
  }

  export type PredictiveModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    modelType?: SortOrder
    algorithm?: SortOrder
    accuracy?: SortOrder
    auc?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    trainedAt?: SortOrder
    trainingSampleSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictiveModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    modelType?: SortOrder
    algorithm?: SortOrder
    accuracy?: SortOrder
    auc?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    trainedAt?: SortOrder
    trainingSampleSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictiveModelSumOrderByAggregateInput = {
    accuracy?: SortOrder
    auc?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    trainingSampleSize?: SortOrder
  }

  export type EnumPredictiveModelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictiveModelType | EnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictiveModelTypeWithAggregatesFilter<$PrismaModel> | $Enums.PredictiveModelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPredictiveModelTypeFilter<$PrismaModel>
    _max?: NestedEnumPredictiveModelTypeFilter<$PrismaModel>
  }

  export type AnalyticsAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type CohortCreateNestedManyWithoutPopulationInput = {
    create?: XOR<CohortCreateWithoutPopulationInput, CohortUncheckedCreateWithoutPopulationInput> | CohortCreateWithoutPopulationInput[] | CohortUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: CohortCreateOrConnectWithoutPopulationInput | CohortCreateOrConnectWithoutPopulationInput[]
    createMany?: CohortCreateManyPopulationInputEnvelope
    connect?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
  }

  export type PopulationQualityMeasureCreateNestedManyWithoutPopulationInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutPopulationInput, PopulationQualityMeasureUncheckedCreateWithoutPopulationInput> | PopulationQualityMeasureCreateWithoutPopulationInput[] | PopulationQualityMeasureUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutPopulationInput | PopulationQualityMeasureCreateOrConnectWithoutPopulationInput[]
    createMany?: PopulationQualityMeasureCreateManyPopulationInputEnvelope
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
  }

  export type AnalyticsReportCreateNestedManyWithoutPopulationInput = {
    create?: XOR<AnalyticsReportCreateWithoutPopulationInput, AnalyticsReportUncheckedCreateWithoutPopulationInput> | AnalyticsReportCreateWithoutPopulationInput[] | AnalyticsReportUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutPopulationInput | AnalyticsReportCreateOrConnectWithoutPopulationInput[]
    createMany?: AnalyticsReportCreateManyPopulationInputEnvelope
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
  }

  export type SdohFactorCreateNestedManyWithoutPopulationInput = {
    create?: XOR<SdohFactorCreateWithoutPopulationInput, SdohFactorUncheckedCreateWithoutPopulationInput> | SdohFactorCreateWithoutPopulationInput[] | SdohFactorUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: SdohFactorCreateOrConnectWithoutPopulationInput | SdohFactorCreateOrConnectWithoutPopulationInput[]
    createMany?: SdohFactorCreateManyPopulationInputEnvelope
    connect?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
  }

  export type CohortUncheckedCreateNestedManyWithoutPopulationInput = {
    create?: XOR<CohortCreateWithoutPopulationInput, CohortUncheckedCreateWithoutPopulationInput> | CohortCreateWithoutPopulationInput[] | CohortUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: CohortCreateOrConnectWithoutPopulationInput | CohortCreateOrConnectWithoutPopulationInput[]
    createMany?: CohortCreateManyPopulationInputEnvelope
    connect?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
  }

  export type PopulationQualityMeasureUncheckedCreateNestedManyWithoutPopulationInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutPopulationInput, PopulationQualityMeasureUncheckedCreateWithoutPopulationInput> | PopulationQualityMeasureCreateWithoutPopulationInput[] | PopulationQualityMeasureUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutPopulationInput | PopulationQualityMeasureCreateOrConnectWithoutPopulationInput[]
    createMany?: PopulationQualityMeasureCreateManyPopulationInputEnvelope
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
  }

  export type AnalyticsReportUncheckedCreateNestedManyWithoutPopulationInput = {
    create?: XOR<AnalyticsReportCreateWithoutPopulationInput, AnalyticsReportUncheckedCreateWithoutPopulationInput> | AnalyticsReportCreateWithoutPopulationInput[] | AnalyticsReportUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutPopulationInput | AnalyticsReportCreateOrConnectWithoutPopulationInput[]
    createMany?: AnalyticsReportCreateManyPopulationInputEnvelope
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
  }

  export type SdohFactorUncheckedCreateNestedManyWithoutPopulationInput = {
    create?: XOR<SdohFactorCreateWithoutPopulationInput, SdohFactorUncheckedCreateWithoutPopulationInput> | SdohFactorCreateWithoutPopulationInput[] | SdohFactorUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: SdohFactorCreateOrConnectWithoutPopulationInput | SdohFactorCreateOrConnectWithoutPopulationInput[]
    createMany?: SdohFactorCreateManyPopulationInputEnvelope
    connect?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumDefinitionTypeFieldUpdateOperationsInput = {
    set?: $Enums.DefinitionType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPopulationStatusFieldUpdateOperationsInput = {
    set?: $Enums.PopulationStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CohortUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<CohortCreateWithoutPopulationInput, CohortUncheckedCreateWithoutPopulationInput> | CohortCreateWithoutPopulationInput[] | CohortUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: CohortCreateOrConnectWithoutPopulationInput | CohortCreateOrConnectWithoutPopulationInput[]
    upsert?: CohortUpsertWithWhereUniqueWithoutPopulationInput | CohortUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: CohortCreateManyPopulationInputEnvelope
    set?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    disconnect?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    delete?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    connect?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    update?: CohortUpdateWithWhereUniqueWithoutPopulationInput | CohortUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: CohortUpdateManyWithWhereWithoutPopulationInput | CohortUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: CohortScalarWhereInput | CohortScalarWhereInput[]
  }

  export type PopulationQualityMeasureUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutPopulationInput, PopulationQualityMeasureUncheckedCreateWithoutPopulationInput> | PopulationQualityMeasureCreateWithoutPopulationInput[] | PopulationQualityMeasureUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutPopulationInput | PopulationQualityMeasureCreateOrConnectWithoutPopulationInput[]
    upsert?: PopulationQualityMeasureUpsertWithWhereUniqueWithoutPopulationInput | PopulationQualityMeasureUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: PopulationQualityMeasureCreateManyPopulationInputEnvelope
    set?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    disconnect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    delete?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    update?: PopulationQualityMeasureUpdateWithWhereUniqueWithoutPopulationInput | PopulationQualityMeasureUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: PopulationQualityMeasureUpdateManyWithWhereWithoutPopulationInput | PopulationQualityMeasureUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: PopulationQualityMeasureScalarWhereInput | PopulationQualityMeasureScalarWhereInput[]
  }

  export type AnalyticsReportUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<AnalyticsReportCreateWithoutPopulationInput, AnalyticsReportUncheckedCreateWithoutPopulationInput> | AnalyticsReportCreateWithoutPopulationInput[] | AnalyticsReportUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutPopulationInput | AnalyticsReportCreateOrConnectWithoutPopulationInput[]
    upsert?: AnalyticsReportUpsertWithWhereUniqueWithoutPopulationInput | AnalyticsReportUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: AnalyticsReportCreateManyPopulationInputEnvelope
    set?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    disconnect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    delete?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    update?: AnalyticsReportUpdateWithWhereUniqueWithoutPopulationInput | AnalyticsReportUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: AnalyticsReportUpdateManyWithWhereWithoutPopulationInput | AnalyticsReportUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
  }

  export type SdohFactorUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<SdohFactorCreateWithoutPopulationInput, SdohFactorUncheckedCreateWithoutPopulationInput> | SdohFactorCreateWithoutPopulationInput[] | SdohFactorUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: SdohFactorCreateOrConnectWithoutPopulationInput | SdohFactorCreateOrConnectWithoutPopulationInput[]
    upsert?: SdohFactorUpsertWithWhereUniqueWithoutPopulationInput | SdohFactorUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: SdohFactorCreateManyPopulationInputEnvelope
    set?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    disconnect?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    delete?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    connect?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    update?: SdohFactorUpdateWithWhereUniqueWithoutPopulationInput | SdohFactorUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: SdohFactorUpdateManyWithWhereWithoutPopulationInput | SdohFactorUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: SdohFactorScalarWhereInput | SdohFactorScalarWhereInput[]
  }

  export type CohortUncheckedUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<CohortCreateWithoutPopulationInput, CohortUncheckedCreateWithoutPopulationInput> | CohortCreateWithoutPopulationInput[] | CohortUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: CohortCreateOrConnectWithoutPopulationInput | CohortCreateOrConnectWithoutPopulationInput[]
    upsert?: CohortUpsertWithWhereUniqueWithoutPopulationInput | CohortUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: CohortCreateManyPopulationInputEnvelope
    set?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    disconnect?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    delete?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    connect?: CohortWhereUniqueInput | CohortWhereUniqueInput[]
    update?: CohortUpdateWithWhereUniqueWithoutPopulationInput | CohortUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: CohortUpdateManyWithWhereWithoutPopulationInput | CohortUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: CohortScalarWhereInput | CohortScalarWhereInput[]
  }

  export type PopulationQualityMeasureUncheckedUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutPopulationInput, PopulationQualityMeasureUncheckedCreateWithoutPopulationInput> | PopulationQualityMeasureCreateWithoutPopulationInput[] | PopulationQualityMeasureUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutPopulationInput | PopulationQualityMeasureCreateOrConnectWithoutPopulationInput[]
    upsert?: PopulationQualityMeasureUpsertWithWhereUniqueWithoutPopulationInput | PopulationQualityMeasureUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: PopulationQualityMeasureCreateManyPopulationInputEnvelope
    set?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    disconnect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    delete?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    update?: PopulationQualityMeasureUpdateWithWhereUniqueWithoutPopulationInput | PopulationQualityMeasureUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: PopulationQualityMeasureUpdateManyWithWhereWithoutPopulationInput | PopulationQualityMeasureUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: PopulationQualityMeasureScalarWhereInput | PopulationQualityMeasureScalarWhereInput[]
  }

  export type AnalyticsReportUncheckedUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<AnalyticsReportCreateWithoutPopulationInput, AnalyticsReportUncheckedCreateWithoutPopulationInput> | AnalyticsReportCreateWithoutPopulationInput[] | AnalyticsReportUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutPopulationInput | AnalyticsReportCreateOrConnectWithoutPopulationInput[]
    upsert?: AnalyticsReportUpsertWithWhereUniqueWithoutPopulationInput | AnalyticsReportUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: AnalyticsReportCreateManyPopulationInputEnvelope
    set?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    disconnect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    delete?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    update?: AnalyticsReportUpdateWithWhereUniqueWithoutPopulationInput | AnalyticsReportUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: AnalyticsReportUpdateManyWithWhereWithoutPopulationInput | AnalyticsReportUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
  }

  export type SdohFactorUncheckedUpdateManyWithoutPopulationNestedInput = {
    create?: XOR<SdohFactorCreateWithoutPopulationInput, SdohFactorUncheckedCreateWithoutPopulationInput> | SdohFactorCreateWithoutPopulationInput[] | SdohFactorUncheckedCreateWithoutPopulationInput[]
    connectOrCreate?: SdohFactorCreateOrConnectWithoutPopulationInput | SdohFactorCreateOrConnectWithoutPopulationInput[]
    upsert?: SdohFactorUpsertWithWhereUniqueWithoutPopulationInput | SdohFactorUpsertWithWhereUniqueWithoutPopulationInput[]
    createMany?: SdohFactorCreateManyPopulationInputEnvelope
    set?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    disconnect?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    delete?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    connect?: SdohFactorWhereUniqueInput | SdohFactorWhereUniqueInput[]
    update?: SdohFactorUpdateWithWhereUniqueWithoutPopulationInput | SdohFactorUpdateWithWhereUniqueWithoutPopulationInput[]
    updateMany?: SdohFactorUpdateManyWithWhereWithoutPopulationInput | SdohFactorUpdateManyWithWhereWithoutPopulationInput[]
    deleteMany?: SdohFactorScalarWhereInput | SdohFactorScalarWhereInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.MemberStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumRiskTierFieldUpdateOperationsInput = {
    set?: $Enums.RiskTier | null
  }

  export type PopulationCreateNestedOneWithoutCohortsInput = {
    create?: XOR<PopulationCreateWithoutCohortsInput, PopulationUncheckedCreateWithoutCohortsInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutCohortsInput
    connect?: PopulationWhereUniqueInput
  }

  export type CareGapCreateNestedManyWithoutCohortInput = {
    create?: XOR<CareGapCreateWithoutCohortInput, CareGapUncheckedCreateWithoutCohortInput> | CareGapCreateWithoutCohortInput[] | CareGapUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: CareGapCreateOrConnectWithoutCohortInput | CareGapCreateOrConnectWithoutCohortInput[]
    createMany?: CareGapCreateManyCohortInputEnvelope
    connect?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
  }

  export type CareGapUncheckedCreateNestedManyWithoutCohortInput = {
    create?: XOR<CareGapCreateWithoutCohortInput, CareGapUncheckedCreateWithoutCohortInput> | CareGapCreateWithoutCohortInput[] | CareGapUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: CareGapCreateOrConnectWithoutCohortInput | CareGapCreateOrConnectWithoutCohortInput[]
    createMany?: CareGapCreateManyCohortInputEnvelope
    connect?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
  }

  export type EnumCohortTypeFieldUpdateOperationsInput = {
    set?: $Enums.CohortType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PopulationUpdateOneRequiredWithoutCohortsNestedInput = {
    create?: XOR<PopulationCreateWithoutCohortsInput, PopulationUncheckedCreateWithoutCohortsInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutCohortsInput
    upsert?: PopulationUpsertWithoutCohortsInput
    connect?: PopulationWhereUniqueInput
    update?: XOR<XOR<PopulationUpdateToOneWithWhereWithoutCohortsInput, PopulationUpdateWithoutCohortsInput>, PopulationUncheckedUpdateWithoutCohortsInput>
  }

  export type CareGapUpdateManyWithoutCohortNestedInput = {
    create?: XOR<CareGapCreateWithoutCohortInput, CareGapUncheckedCreateWithoutCohortInput> | CareGapCreateWithoutCohortInput[] | CareGapUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: CareGapCreateOrConnectWithoutCohortInput | CareGapCreateOrConnectWithoutCohortInput[]
    upsert?: CareGapUpsertWithWhereUniqueWithoutCohortInput | CareGapUpsertWithWhereUniqueWithoutCohortInput[]
    createMany?: CareGapCreateManyCohortInputEnvelope
    set?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    disconnect?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    delete?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    connect?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    update?: CareGapUpdateWithWhereUniqueWithoutCohortInput | CareGapUpdateWithWhereUniqueWithoutCohortInput[]
    updateMany?: CareGapUpdateManyWithWhereWithoutCohortInput | CareGapUpdateManyWithWhereWithoutCohortInput[]
    deleteMany?: CareGapScalarWhereInput | CareGapScalarWhereInput[]
  }

  export type CareGapUncheckedUpdateManyWithoutCohortNestedInput = {
    create?: XOR<CareGapCreateWithoutCohortInput, CareGapUncheckedCreateWithoutCohortInput> | CareGapCreateWithoutCohortInput[] | CareGapUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: CareGapCreateOrConnectWithoutCohortInput | CareGapCreateOrConnectWithoutCohortInput[]
    upsert?: CareGapUpsertWithWhereUniqueWithoutCohortInput | CareGapUpsertWithWhereUniqueWithoutCohortInput[]
    createMany?: CareGapCreateManyCohortInputEnvelope
    set?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    disconnect?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    delete?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    connect?: CareGapWhereUniqueInput | CareGapWhereUniqueInput[]
    update?: CareGapUpdateWithWhereUniqueWithoutCohortInput | CareGapUpdateWithWhereUniqueWithoutCohortInput[]
    updateMany?: CareGapUpdateManyWithWhereWithoutCohortInput | CareGapUpdateManyWithWhereWithoutCohortInput[]
    deleteMany?: CareGapScalarWhereInput | CareGapScalarWhereInput[]
  }

  export type PopulationQualityMeasureCreateNestedManyWithoutQualityMeasureInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PopulationQualityMeasureCreateWithoutQualityMeasureInput[] | PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    createMany?: PopulationQualityMeasureCreateManyQualityMeasureInputEnvelope
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
  }

  export type PatientQualityMeasureCreateNestedManyWithoutQualityMeasureInput = {
    create?: XOR<PatientQualityMeasureCreateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PatientQualityMeasureCreateWithoutQualityMeasureInput[] | PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    createMany?: PatientQualityMeasureCreateManyQualityMeasureInputEnvelope
    connect?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
  }

  export type PopulationQualityMeasureUncheckedCreateNestedManyWithoutQualityMeasureInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PopulationQualityMeasureCreateWithoutQualityMeasureInput[] | PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    createMany?: PopulationQualityMeasureCreateManyQualityMeasureInputEnvelope
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
  }

  export type PatientQualityMeasureUncheckedCreateNestedManyWithoutQualityMeasureInput = {
    create?: XOR<PatientQualityMeasureCreateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PatientQualityMeasureCreateWithoutQualityMeasureInput[] | PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    createMany?: PatientQualityMeasureCreateManyQualityMeasureInputEnvelope
    connect?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
  }

  export type EnumMeasureTypeFieldUpdateOperationsInput = {
    set?: $Enums.MeasureType
  }

  export type EnumMeasureCategoryFieldUpdateOperationsInput = {
    set?: $Enums.MeasureCategory
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PopulationQualityMeasureUpdateManyWithoutQualityMeasureNestedInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PopulationQualityMeasureCreateWithoutQualityMeasureInput[] | PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    upsert?: PopulationQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput | PopulationQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput[]
    createMany?: PopulationQualityMeasureCreateManyQualityMeasureInputEnvelope
    set?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    disconnect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    delete?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    update?: PopulationQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput | PopulationQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput[]
    updateMany?: PopulationQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput | PopulationQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput[]
    deleteMany?: PopulationQualityMeasureScalarWhereInput | PopulationQualityMeasureScalarWhereInput[]
  }

  export type PatientQualityMeasureUpdateManyWithoutQualityMeasureNestedInput = {
    create?: XOR<PatientQualityMeasureCreateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PatientQualityMeasureCreateWithoutQualityMeasureInput[] | PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    upsert?: PatientQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput | PatientQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput[]
    createMany?: PatientQualityMeasureCreateManyQualityMeasureInputEnvelope
    set?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    disconnect?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    delete?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    connect?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    update?: PatientQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput | PatientQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput[]
    updateMany?: PatientQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput | PatientQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput[]
    deleteMany?: PatientQualityMeasureScalarWhereInput | PatientQualityMeasureScalarWhereInput[]
  }

  export type PopulationQualityMeasureUncheckedUpdateManyWithoutQualityMeasureNestedInput = {
    create?: XOR<PopulationQualityMeasureCreateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PopulationQualityMeasureCreateWithoutQualityMeasureInput[] | PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    upsert?: PopulationQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput | PopulationQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput[]
    createMany?: PopulationQualityMeasureCreateManyQualityMeasureInputEnvelope
    set?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    disconnect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    delete?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    connect?: PopulationQualityMeasureWhereUniqueInput | PopulationQualityMeasureWhereUniqueInput[]
    update?: PopulationQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput | PopulationQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput[]
    updateMany?: PopulationQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput | PopulationQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput[]
    deleteMany?: PopulationQualityMeasureScalarWhereInput | PopulationQualityMeasureScalarWhereInput[]
  }

  export type PatientQualityMeasureUncheckedUpdateManyWithoutQualityMeasureNestedInput = {
    create?: XOR<PatientQualityMeasureCreateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput> | PatientQualityMeasureCreateWithoutQualityMeasureInput[] | PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput[]
    connectOrCreate?: PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput | PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput[]
    upsert?: PatientQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput | PatientQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput[]
    createMany?: PatientQualityMeasureCreateManyQualityMeasureInputEnvelope
    set?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    disconnect?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    delete?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    connect?: PatientQualityMeasureWhereUniqueInput | PatientQualityMeasureWhereUniqueInput[]
    update?: PatientQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput | PatientQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput[]
    updateMany?: PatientQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput | PatientQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput[]
    deleteMany?: PatientQualityMeasureScalarWhereInput | PatientQualityMeasureScalarWhereInput[]
  }

  export type PopulationCreateNestedOneWithoutQualityMeasuresInput = {
    create?: XOR<PopulationCreateWithoutQualityMeasuresInput, PopulationUncheckedCreateWithoutQualityMeasuresInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutQualityMeasuresInput
    connect?: PopulationWhereUniqueInput
  }

  export type QualityMeasureCreateNestedOneWithoutPopulationMeasuresInput = {
    create?: XOR<QualityMeasureCreateWithoutPopulationMeasuresInput, QualityMeasureUncheckedCreateWithoutPopulationMeasuresInput>
    connectOrCreate?: QualityMeasureCreateOrConnectWithoutPopulationMeasuresInput
    connect?: QualityMeasureWhereUniqueInput
  }

  export type PopulationUpdateOneRequiredWithoutQualityMeasuresNestedInput = {
    create?: XOR<PopulationCreateWithoutQualityMeasuresInput, PopulationUncheckedCreateWithoutQualityMeasuresInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutQualityMeasuresInput
    upsert?: PopulationUpsertWithoutQualityMeasuresInput
    connect?: PopulationWhereUniqueInput
    update?: XOR<XOR<PopulationUpdateToOneWithWhereWithoutQualityMeasuresInput, PopulationUpdateWithoutQualityMeasuresInput>, PopulationUncheckedUpdateWithoutQualityMeasuresInput>
  }

  export type QualityMeasureUpdateOneRequiredWithoutPopulationMeasuresNestedInput = {
    create?: XOR<QualityMeasureCreateWithoutPopulationMeasuresInput, QualityMeasureUncheckedCreateWithoutPopulationMeasuresInput>
    connectOrCreate?: QualityMeasureCreateOrConnectWithoutPopulationMeasuresInput
    upsert?: QualityMeasureUpsertWithoutPopulationMeasuresInput
    connect?: QualityMeasureWhereUniqueInput
    update?: XOR<XOR<QualityMeasureUpdateToOneWithWhereWithoutPopulationMeasuresInput, QualityMeasureUpdateWithoutPopulationMeasuresInput>, QualityMeasureUncheckedUpdateWithoutPopulationMeasuresInput>
  }

  export type QualityMeasureCreateNestedOneWithoutPatientMeasuresInput = {
    create?: XOR<QualityMeasureCreateWithoutPatientMeasuresInput, QualityMeasureUncheckedCreateWithoutPatientMeasuresInput>
    connectOrCreate?: QualityMeasureCreateOrConnectWithoutPatientMeasuresInput
    connect?: QualityMeasureWhereUniqueInput
  }

  export type EnumComplianceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplianceStatus
  }

  export type QualityMeasureUpdateOneRequiredWithoutPatientMeasuresNestedInput = {
    create?: XOR<QualityMeasureCreateWithoutPatientMeasuresInput, QualityMeasureUncheckedCreateWithoutPatientMeasuresInput>
    connectOrCreate?: QualityMeasureCreateOrConnectWithoutPatientMeasuresInput
    upsert?: QualityMeasureUpsertWithoutPatientMeasuresInput
    connect?: QualityMeasureWhereUniqueInput
    update?: XOR<XOR<QualityMeasureUpdateToOneWithWhereWithoutPatientMeasuresInput, QualityMeasureUpdateWithoutPatientMeasuresInput>, QualityMeasureUncheckedUpdateWithoutPatientMeasuresInput>
  }

  export type EnumScoreTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScoreType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRiskTierFieldUpdateOperationsInput = {
    set?: $Enums.RiskTier
  }

  export type CohortCreateNestedOneWithoutCareGapsInput = {
    create?: XOR<CohortCreateWithoutCareGapsInput, CohortUncheckedCreateWithoutCareGapsInput>
    connectOrCreate?: CohortCreateOrConnectWithoutCareGapsInput
    connect?: CohortWhereUniqueInput
  }

  export type EnumGapTypeFieldUpdateOperationsInput = {
    set?: $Enums.GapType
  }

  export type EnumGapPriorityFieldUpdateOperationsInput = {
    set?: $Enums.GapPriority
  }

  export type EnumGapStatusFieldUpdateOperationsInput = {
    set?: $Enums.GapStatus
  }

  export type CohortUpdateOneWithoutCareGapsNestedInput = {
    create?: XOR<CohortCreateWithoutCareGapsInput, CohortUncheckedCreateWithoutCareGapsInput>
    connectOrCreate?: CohortCreateOrConnectWithoutCareGapsInput
    upsert?: CohortUpsertWithoutCareGapsInput
    disconnect?: CohortWhereInput | boolean
    delete?: CohortWhereInput | boolean
    connect?: CohortWhereUniqueInput
    update?: XOR<XOR<CohortUpdateToOneWithWhereWithoutCareGapsInput, CohortUpdateWithoutCareGapsInput>, CohortUncheckedUpdateWithoutCareGapsInput>
  }

  export type PopulationCreateNestedOneWithoutSdohFactorsInput = {
    create?: XOR<PopulationCreateWithoutSdohFactorsInput, PopulationUncheckedCreateWithoutSdohFactorsInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutSdohFactorsInput
    connect?: PopulationWhereUniqueInput
  }

  export type EnumSdohCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SdohCategory
  }

  export type NullableEnumSdohSeverityFieldUpdateOperationsInput = {
    set?: $Enums.SdohSeverity | null
  }

  export type PopulationUpdateOneWithoutSdohFactorsNestedInput = {
    create?: XOR<PopulationCreateWithoutSdohFactorsInput, PopulationUncheckedCreateWithoutSdohFactorsInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutSdohFactorsInput
    upsert?: PopulationUpsertWithoutSdohFactorsInput
    disconnect?: PopulationWhereInput | boolean
    delete?: PopulationWhereInput | boolean
    connect?: PopulationWhereUniqueInput
    update?: XOR<XOR<PopulationUpdateToOneWithWhereWithoutSdohFactorsInput, PopulationUpdateWithoutSdohFactorsInput>, PopulationUncheckedUpdateWithoutSdohFactorsInput>
  }

  export type NullableEnumTrendDirectionFieldUpdateOperationsInput = {
    set?: $Enums.TrendDirection | null
  }

  export type EnumEquityMeasureTypeFieldUpdateOperationsInput = {
    set?: $Enums.EquityMeasureType
  }

  export type PopulationCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<PopulationCreateWithoutAnalyticsInput, PopulationUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutAnalyticsInput
    connect?: PopulationWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type PopulationUpdateOneWithoutAnalyticsNestedInput = {
    create?: XOR<PopulationCreateWithoutAnalyticsInput, PopulationUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: PopulationCreateOrConnectWithoutAnalyticsInput
    upsert?: PopulationUpsertWithoutAnalyticsInput
    disconnect?: PopulationWhereInput | boolean
    delete?: PopulationWhereInput | boolean
    connect?: PopulationWhereUniqueInput
    update?: XOR<XOR<PopulationUpdateToOneWithWhereWithoutAnalyticsInput, PopulationUpdateWithoutAnalyticsInput>, PopulationUncheckedUpdateWithoutAnalyticsInput>
  }

  export type EnumPredictiveModelTypeFieldUpdateOperationsInput = {
    set?: $Enums.PredictiveModelType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumDefinitionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DefinitionType | EnumDefinitionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDefinitionTypeFilter<$PrismaModel> | $Enums.DefinitionType
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumPopulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PopulationStatus | EnumPopulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPopulationStatusFilter<$PrismaModel> | $Enums.PopulationStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDefinitionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefinitionType | EnumDefinitionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefinitionType[] | ListEnumDefinitionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDefinitionTypeWithAggregatesFilter<$PrismaModel> | $Enums.DefinitionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefinitionTypeFilter<$PrismaModel>
    _max?: NestedEnumDefinitionTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPopulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PopulationStatus | EnumPopulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PopulationStatus[] | ListEnumPopulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPopulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PopulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPopulationStatusFilter<$PrismaModel>
    _max?: NestedEnumPopulationStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRiskTierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskTierNullableFilter<$PrismaModel> | $Enums.RiskTier | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRiskTierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskTierNullableWithAggregatesFilter<$PrismaModel> | $Enums.RiskTier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRiskTierNullableFilter<$PrismaModel>
    _max?: NestedEnumRiskTierNullableFilter<$PrismaModel>
  }

  export type NestedEnumCohortTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CohortType | EnumCohortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCohortTypeFilter<$PrismaModel> | $Enums.CohortType
  }

  export type NestedEnumCohortTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CohortType | EnumCohortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CohortType[] | ListEnumCohortTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCohortTypeWithAggregatesFilter<$PrismaModel> | $Enums.CohortType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCohortTypeFilter<$PrismaModel>
    _max?: NestedEnumCohortTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumMeasureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureType | EnumMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureTypeFilter<$PrismaModel> | $Enums.MeasureType
  }

  export type NestedEnumMeasureCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureCategory | EnumMeasureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureCategoryFilter<$PrismaModel> | $Enums.MeasureCategory
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumMeasureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureType | EnumMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureType[] | ListEnumMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureTypeWithAggregatesFilter<$PrismaModel> | $Enums.MeasureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeasureTypeFilter<$PrismaModel>
    _max?: NestedEnumMeasureTypeFilter<$PrismaModel>
  }

  export type NestedEnumMeasureCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasureCategory | EnumMeasureCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasureCategory[] | ListEnumMeasureCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasureCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MeasureCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeasureCategoryFilter<$PrismaModel>
    _max?: NestedEnumMeasureCategoryFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type NestedEnumScoreTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeFilter<$PrismaModel> | $Enums.ScoreType
  }

  export type NestedEnumRiskTierFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel>
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskTierFilter<$PrismaModel> | $Enums.RiskTier
  }

  export type NestedEnumScoreTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoreType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreTypeFilter<$PrismaModel>
    _max?: NestedEnumScoreTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRiskTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskTier | EnumRiskTierFieldRefInput<$PrismaModel>
    in?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskTier[] | ListEnumRiskTierFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskTierWithAggregatesFilter<$PrismaModel> | $Enums.RiskTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskTierFilter<$PrismaModel>
    _max?: NestedEnumRiskTierFilter<$PrismaModel>
  }

  export type NestedEnumGapTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GapType | EnumGapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGapTypeFilter<$PrismaModel> | $Enums.GapType
  }

  export type NestedEnumGapPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.GapPriority | EnumGapPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumGapPriorityFilter<$PrismaModel> | $Enums.GapPriority
  }

  export type NestedEnumGapStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GapStatus | EnumGapStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGapStatusFilter<$PrismaModel> | $Enums.GapStatus
  }

  export type NestedEnumGapTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GapType | EnumGapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapType[] | ListEnumGapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGapTypeWithAggregatesFilter<$PrismaModel> | $Enums.GapType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGapTypeFilter<$PrismaModel>
    _max?: NestedEnumGapTypeFilter<$PrismaModel>
  }

  export type NestedEnumGapPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GapPriority | EnumGapPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapPriority[] | ListEnumGapPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumGapPriorityWithAggregatesFilter<$PrismaModel> | $Enums.GapPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGapPriorityFilter<$PrismaModel>
    _max?: NestedEnumGapPriorityFilter<$PrismaModel>
  }

  export type NestedEnumGapStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GapStatus | EnumGapStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GapStatus[] | ListEnumGapStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGapStatusWithAggregatesFilter<$PrismaModel> | $Enums.GapStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGapStatusFilter<$PrismaModel>
    _max?: NestedEnumGapStatusFilter<$PrismaModel>
  }

  export type NestedEnumSdohCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohCategory | EnumSdohCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSdohCategoryFilter<$PrismaModel> | $Enums.SdohCategory
  }

  export type NestedEnumSdohSeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohSeverity | EnumSdohSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSdohSeverityNullableFilter<$PrismaModel> | $Enums.SdohSeverity | null
  }

  export type NestedEnumSdohCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohCategory | EnumSdohCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SdohCategory[] | ListEnumSdohCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSdohCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SdohCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSdohCategoryFilter<$PrismaModel>
    _max?: NestedEnumSdohCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSdohSeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SdohSeverity | EnumSdohSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SdohSeverity[] | ListEnumSdohSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSdohSeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.SdohSeverity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSdohSeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumSdohSeverityNullableFilter<$PrismaModel>
  }

  export type NestedEnumTrendDirectionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrendDirection | EnumTrendDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrendDirectionNullableFilter<$PrismaModel> | $Enums.TrendDirection | null
  }

  export type NestedEnumTrendDirectionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrendDirection | EnumTrendDirectionFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrendDirection[] | ListEnumTrendDirectionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrendDirectionNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrendDirection | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrendDirectionNullableFilter<$PrismaModel>
    _max?: NestedEnumTrendDirectionNullableFilter<$PrismaModel>
  }

  export type NestedEnumEquityMeasureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EquityMeasureType | EnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquityMeasureTypeFilter<$PrismaModel> | $Enums.EquityMeasureType
  }

  export type NestedEnumEquityMeasureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquityMeasureType | EnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquityMeasureType[] | ListEnumEquityMeasureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquityMeasureTypeWithAggregatesFilter<$PrismaModel> | $Enums.EquityMeasureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquityMeasureTypeFilter<$PrismaModel>
    _max?: NestedEnumEquityMeasureTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumPredictiveModelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictiveModelType | EnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictiveModelTypeFilter<$PrismaModel> | $Enums.PredictiveModelType
  }

  export type NestedEnumPredictiveModelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictiveModelType | EnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictiveModelType[] | ListEnumPredictiveModelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictiveModelTypeWithAggregatesFilter<$PrismaModel> | $Enums.PredictiveModelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPredictiveModelTypeFilter<$PrismaModel>
    _max?: NestedEnumPredictiveModelTypeFilter<$PrismaModel>
  }

  export type CohortCreateWithoutPopulationInput = {
    id?: string
    name: string
    description?: string | null
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    careGaps?: CareGapCreateNestedManyWithoutCohortInput
  }

  export type CohortUncheckedCreateWithoutPopulationInput = {
    id?: string
    name: string
    description?: string | null
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    careGaps?: CareGapUncheckedCreateNestedManyWithoutCohortInput
  }

  export type CohortCreateOrConnectWithoutPopulationInput = {
    where: CohortWhereUniqueInput
    create: XOR<CohortCreateWithoutPopulationInput, CohortUncheckedCreateWithoutPopulationInput>
  }

  export type CohortCreateManyPopulationInputEnvelope = {
    data: CohortCreateManyPopulationInput | CohortCreateManyPopulationInput[]
    skipDuplicates?: boolean
  }

  export type PopulationQualityMeasureCreateWithoutPopulationInput = {
    id?: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityMeasure: QualityMeasureCreateNestedOneWithoutPopulationMeasuresInput
  }

  export type PopulationQualityMeasureUncheckedCreateWithoutPopulationInput = {
    id?: string
    qualityMeasureId: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationQualityMeasureCreateOrConnectWithoutPopulationInput = {
    where: PopulationQualityMeasureWhereUniqueInput
    create: XOR<PopulationQualityMeasureCreateWithoutPopulationInput, PopulationQualityMeasureUncheckedCreateWithoutPopulationInput>
  }

  export type PopulationQualityMeasureCreateManyPopulationInputEnvelope = {
    data: PopulationQualityMeasureCreateManyPopulationInput | PopulationQualityMeasureCreateManyPopulationInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsReportCreateWithoutPopulationInput = {
    id?: string
    reportType: $Enums.ReportType
    title: string
    description?: string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUncheckedCreateWithoutPopulationInput = {
    id?: string
    reportType: $Enums.ReportType
    title: string
    description?: string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportCreateOrConnectWithoutPopulationInput = {
    where: AnalyticsReportWhereUniqueInput
    create: XOR<AnalyticsReportCreateWithoutPopulationInput, AnalyticsReportUncheckedCreateWithoutPopulationInput>
  }

  export type AnalyticsReportCreateManyPopulationInputEnvelope = {
    data: AnalyticsReportCreateManyPopulationInput | AnalyticsReportCreateManyPopulationInput[]
    skipDuplicates?: boolean
  }

  export type SdohFactorCreateWithoutPopulationInput = {
    id?: string
    patientId?: string | null
    fhirPatientRef?: string | null
    category: $Enums.SdohCategory
    factor: string
    value?: string | null
    severity?: $Enums.SdohSeverity | null
    assessmentDate?: Date | string
    assessmentTool?: string | null
    screeningScore?: number | null
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: string | null
    interventionStatus?: string | null
    referralMade?: boolean
    referralDetails?: string | null
    fhirObservationRef?: string | null
    fhirConditionRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdohFactorUncheckedCreateWithoutPopulationInput = {
    id?: string
    patientId?: string | null
    fhirPatientRef?: string | null
    category: $Enums.SdohCategory
    factor: string
    value?: string | null
    severity?: $Enums.SdohSeverity | null
    assessmentDate?: Date | string
    assessmentTool?: string | null
    screeningScore?: number | null
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: string | null
    interventionStatus?: string | null
    referralMade?: boolean
    referralDetails?: string | null
    fhirObservationRef?: string | null
    fhirConditionRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdohFactorCreateOrConnectWithoutPopulationInput = {
    where: SdohFactorWhereUniqueInput
    create: XOR<SdohFactorCreateWithoutPopulationInput, SdohFactorUncheckedCreateWithoutPopulationInput>
  }

  export type SdohFactorCreateManyPopulationInputEnvelope = {
    data: SdohFactorCreateManyPopulationInput | SdohFactorCreateManyPopulationInput[]
    skipDuplicates?: boolean
  }

  export type CohortUpsertWithWhereUniqueWithoutPopulationInput = {
    where: CohortWhereUniqueInput
    update: XOR<CohortUpdateWithoutPopulationInput, CohortUncheckedUpdateWithoutPopulationInput>
    create: XOR<CohortCreateWithoutPopulationInput, CohortUncheckedCreateWithoutPopulationInput>
  }

  export type CohortUpdateWithWhereUniqueWithoutPopulationInput = {
    where: CohortWhereUniqueInput
    data: XOR<CohortUpdateWithoutPopulationInput, CohortUncheckedUpdateWithoutPopulationInput>
  }

  export type CohortUpdateManyWithWhereWithoutPopulationInput = {
    where: CohortScalarWhereInput
    data: XOR<CohortUpdateManyMutationInput, CohortUncheckedUpdateManyWithoutPopulationInput>
  }

  export type CohortScalarWhereInput = {
    AND?: CohortScalarWhereInput | CohortScalarWhereInput[]
    OR?: CohortScalarWhereInput[]
    NOT?: CohortScalarWhereInput | CohortScalarWhereInput[]
    id?: StringFilter<"Cohort"> | string
    name?: StringFilter<"Cohort"> | string
    description?: StringNullableFilter<"Cohort"> | string | null
    populationId?: StringFilter<"Cohort"> | string
    cohortType?: EnumCohortTypeFilter<"Cohort"> | $Enums.CohortType
    criteria?: JsonFilter<"Cohort">
    memberCount?: IntFilter<"Cohort"> | number
    fhirGroupId?: StringNullableFilter<"Cohort"> | string | null
    riskLevel?: EnumRiskTierNullableFilter<"Cohort"> | $Enums.RiskTier | null
    interventionPriority?: IntNullableFilter<"Cohort"> | number | null
    createdAt?: DateTimeFilter<"Cohort"> | Date | string
    updatedAt?: DateTimeFilter<"Cohort"> | Date | string
    createdBy?: StringNullableFilter<"Cohort"> | string | null
  }

  export type PopulationQualityMeasureUpsertWithWhereUniqueWithoutPopulationInput = {
    where: PopulationQualityMeasureWhereUniqueInput
    update: XOR<PopulationQualityMeasureUpdateWithoutPopulationInput, PopulationQualityMeasureUncheckedUpdateWithoutPopulationInput>
    create: XOR<PopulationQualityMeasureCreateWithoutPopulationInput, PopulationQualityMeasureUncheckedCreateWithoutPopulationInput>
  }

  export type PopulationQualityMeasureUpdateWithWhereUniqueWithoutPopulationInput = {
    where: PopulationQualityMeasureWhereUniqueInput
    data: XOR<PopulationQualityMeasureUpdateWithoutPopulationInput, PopulationQualityMeasureUncheckedUpdateWithoutPopulationInput>
  }

  export type PopulationQualityMeasureUpdateManyWithWhereWithoutPopulationInput = {
    where: PopulationQualityMeasureScalarWhereInput
    data: XOR<PopulationQualityMeasureUpdateManyMutationInput, PopulationQualityMeasureUncheckedUpdateManyWithoutPopulationInput>
  }

  export type PopulationQualityMeasureScalarWhereInput = {
    AND?: PopulationQualityMeasureScalarWhereInput | PopulationQualityMeasureScalarWhereInput[]
    OR?: PopulationQualityMeasureScalarWhereInput[]
    NOT?: PopulationQualityMeasureScalarWhereInput | PopulationQualityMeasureScalarWhereInput[]
    id?: StringFilter<"PopulationQualityMeasure"> | string
    populationId?: StringFilter<"PopulationQualityMeasure"> | string
    qualityMeasureId?: StringFilter<"PopulationQualityMeasure"> | string
    numerator?: IntFilter<"PopulationQualityMeasure"> | number
    denominator?: IntFilter<"PopulationQualityMeasure"> | number
    exclusions?: IntFilter<"PopulationQualityMeasure"> | number
    performanceRate?: FloatNullableFilter<"PopulationQualityMeasure"> | number | null
    benchmarkRate?: FloatNullableFilter<"PopulationQualityMeasure"> | number | null
    benchmarkPercentile?: IntNullableFilter<"PopulationQualityMeasure"> | number | null
    starRating?: IntNullableFilter<"PopulationQualityMeasure"> | number | null
    measurePeriod?: StringFilter<"PopulationQualityMeasure"> | string
    calculatedAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    createdAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"PopulationQualityMeasure"> | Date | string
  }

  export type AnalyticsReportUpsertWithWhereUniqueWithoutPopulationInput = {
    where: AnalyticsReportWhereUniqueInput
    update: XOR<AnalyticsReportUpdateWithoutPopulationInput, AnalyticsReportUncheckedUpdateWithoutPopulationInput>
    create: XOR<AnalyticsReportCreateWithoutPopulationInput, AnalyticsReportUncheckedCreateWithoutPopulationInput>
  }

  export type AnalyticsReportUpdateWithWhereUniqueWithoutPopulationInput = {
    where: AnalyticsReportWhereUniqueInput
    data: XOR<AnalyticsReportUpdateWithoutPopulationInput, AnalyticsReportUncheckedUpdateWithoutPopulationInput>
  }

  export type AnalyticsReportUpdateManyWithWhereWithoutPopulationInput = {
    where: AnalyticsReportScalarWhereInput
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyWithoutPopulationInput>
  }

  export type AnalyticsReportScalarWhereInput = {
    AND?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
    OR?: AnalyticsReportScalarWhereInput[]
    NOT?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
    id?: StringFilter<"AnalyticsReport"> | string
    populationId?: StringNullableFilter<"AnalyticsReport"> | string | null
    reportType?: EnumReportTypeFilter<"AnalyticsReport"> | $Enums.ReportType
    title?: StringFilter<"AnalyticsReport"> | string
    description?: StringNullableFilter<"AnalyticsReport"> | string | null
    parameters?: JsonNullableFilter<"AnalyticsReport">
    data?: JsonFilter<"AnalyticsReport">
    visualizations?: JsonNullableFilter<"AnalyticsReport">
    generatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringNullableFilter<"AnalyticsReport"> | string | null
    periodStart?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    periodEnd?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    exportFormats?: JsonNullableFilter<"AnalyticsReport">
    lastExportedAt?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
  }

  export type SdohFactorUpsertWithWhereUniqueWithoutPopulationInput = {
    where: SdohFactorWhereUniqueInput
    update: XOR<SdohFactorUpdateWithoutPopulationInput, SdohFactorUncheckedUpdateWithoutPopulationInput>
    create: XOR<SdohFactorCreateWithoutPopulationInput, SdohFactorUncheckedCreateWithoutPopulationInput>
  }

  export type SdohFactorUpdateWithWhereUniqueWithoutPopulationInput = {
    where: SdohFactorWhereUniqueInput
    data: XOR<SdohFactorUpdateWithoutPopulationInput, SdohFactorUncheckedUpdateWithoutPopulationInput>
  }

  export type SdohFactorUpdateManyWithWhereWithoutPopulationInput = {
    where: SdohFactorScalarWhereInput
    data: XOR<SdohFactorUpdateManyMutationInput, SdohFactorUncheckedUpdateManyWithoutPopulationInput>
  }

  export type SdohFactorScalarWhereInput = {
    AND?: SdohFactorScalarWhereInput | SdohFactorScalarWhereInput[]
    OR?: SdohFactorScalarWhereInput[]
    NOT?: SdohFactorScalarWhereInput | SdohFactorScalarWhereInput[]
    id?: StringFilter<"SdohFactor"> | string
    patientId?: StringNullableFilter<"SdohFactor"> | string | null
    populationId?: StringNullableFilter<"SdohFactor"> | string | null
    fhirPatientRef?: StringNullableFilter<"SdohFactor"> | string | null
    category?: EnumSdohCategoryFilter<"SdohFactor"> | $Enums.SdohCategory
    factor?: StringFilter<"SdohFactor"> | string
    value?: StringNullableFilter<"SdohFactor"> | string | null
    severity?: EnumSdohSeverityNullableFilter<"SdohFactor"> | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFilter<"SdohFactor"> | Date | string
    assessmentTool?: StringNullableFilter<"SdohFactor"> | string | null
    screeningScore?: FloatNullableFilter<"SdohFactor"> | number | null
    isPositiveScreen?: BoolFilter<"SdohFactor"> | boolean
    interventionNeeded?: BoolFilter<"SdohFactor"> | boolean
    interventionType?: StringNullableFilter<"SdohFactor"> | string | null
    interventionStatus?: StringNullableFilter<"SdohFactor"> | string | null
    referralMade?: BoolFilter<"SdohFactor"> | boolean
    referralDetails?: StringNullableFilter<"SdohFactor"> | string | null
    fhirObservationRef?: StringNullableFilter<"SdohFactor"> | string | null
    fhirConditionRef?: StringNullableFilter<"SdohFactor"> | string | null
    createdAt?: DateTimeFilter<"SdohFactor"> | Date | string
    updatedAt?: DateTimeFilter<"SdohFactor"> | Date | string
  }

  export type PopulationCreateWithoutCohortsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    qualityMeasures?: PopulationQualityMeasureCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorCreateNestedManyWithoutPopulationInput
  }

  export type PopulationUncheckedCreateWithoutCohortsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    qualityMeasures?: PopulationQualityMeasureUncheckedCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportUncheckedCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorUncheckedCreateNestedManyWithoutPopulationInput
  }

  export type PopulationCreateOrConnectWithoutCohortsInput = {
    where: PopulationWhereUniqueInput
    create: XOR<PopulationCreateWithoutCohortsInput, PopulationUncheckedCreateWithoutCohortsInput>
  }

  export type CareGapCreateWithoutCohortInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    gapType: $Enums.GapType
    title: string
    description?: string | null
    priority?: $Enums.GapPriority
    qualityMeasureId?: string | null
    recommendedAction?: string | null
    actionDueDate?: Date | string | null
    status?: $Enums.GapStatus
    identifiedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolutionNotes?: string | null
    fhirConditionRef?: string | null
    fhirProcedureRef?: string | null
    fhirMedicationRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareGapUncheckedCreateWithoutCohortInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    gapType: $Enums.GapType
    title: string
    description?: string | null
    priority?: $Enums.GapPriority
    qualityMeasureId?: string | null
    recommendedAction?: string | null
    actionDueDate?: Date | string | null
    status?: $Enums.GapStatus
    identifiedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolutionNotes?: string | null
    fhirConditionRef?: string | null
    fhirProcedureRef?: string | null
    fhirMedicationRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareGapCreateOrConnectWithoutCohortInput = {
    where: CareGapWhereUniqueInput
    create: XOR<CareGapCreateWithoutCohortInput, CareGapUncheckedCreateWithoutCohortInput>
  }

  export type CareGapCreateManyCohortInputEnvelope = {
    data: CareGapCreateManyCohortInput | CareGapCreateManyCohortInput[]
    skipDuplicates?: boolean
  }

  export type PopulationUpsertWithoutCohortsInput = {
    update: XOR<PopulationUpdateWithoutCohortsInput, PopulationUncheckedUpdateWithoutCohortsInput>
    create: XOR<PopulationCreateWithoutCohortsInput, PopulationUncheckedCreateWithoutCohortsInput>
    where?: PopulationWhereInput
  }

  export type PopulationUpdateToOneWithWhereWithoutCohortsInput = {
    where?: PopulationWhereInput
    data: XOR<PopulationUpdateWithoutCohortsInput, PopulationUncheckedUpdateWithoutCohortsInput>
  }

  export type PopulationUpdateWithoutCohortsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualityMeasures?: PopulationQualityMeasureUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUpdateManyWithoutPopulationNestedInput
  }

  export type PopulationUncheckedUpdateWithoutCohortsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualityMeasures?: PopulationQualityMeasureUncheckedUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUncheckedUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUncheckedUpdateManyWithoutPopulationNestedInput
  }

  export type CareGapUpsertWithWhereUniqueWithoutCohortInput = {
    where: CareGapWhereUniqueInput
    update: XOR<CareGapUpdateWithoutCohortInput, CareGapUncheckedUpdateWithoutCohortInput>
    create: XOR<CareGapCreateWithoutCohortInput, CareGapUncheckedCreateWithoutCohortInput>
  }

  export type CareGapUpdateWithWhereUniqueWithoutCohortInput = {
    where: CareGapWhereUniqueInput
    data: XOR<CareGapUpdateWithoutCohortInput, CareGapUncheckedUpdateWithoutCohortInput>
  }

  export type CareGapUpdateManyWithWhereWithoutCohortInput = {
    where: CareGapScalarWhereInput
    data: XOR<CareGapUpdateManyMutationInput, CareGapUncheckedUpdateManyWithoutCohortInput>
  }

  export type CareGapScalarWhereInput = {
    AND?: CareGapScalarWhereInput | CareGapScalarWhereInput[]
    OR?: CareGapScalarWhereInput[]
    NOT?: CareGapScalarWhereInput | CareGapScalarWhereInput[]
    id?: StringFilter<"CareGap"> | string
    patientId?: StringFilter<"CareGap"> | string
    fhirPatientRef?: StringNullableFilter<"CareGap"> | string | null
    cohortId?: StringNullableFilter<"CareGap"> | string | null
    gapType?: EnumGapTypeFilter<"CareGap"> | $Enums.GapType
    title?: StringFilter<"CareGap"> | string
    description?: StringNullableFilter<"CareGap"> | string | null
    priority?: EnumGapPriorityFilter<"CareGap"> | $Enums.GapPriority
    qualityMeasureId?: StringNullableFilter<"CareGap"> | string | null
    recommendedAction?: StringNullableFilter<"CareGap"> | string | null
    actionDueDate?: DateTimeNullableFilter<"CareGap"> | Date | string | null
    status?: EnumGapStatusFilter<"CareGap"> | $Enums.GapStatus
    identifiedAt?: DateTimeFilter<"CareGap"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"CareGap"> | Date | string | null
    resolvedBy?: StringNullableFilter<"CareGap"> | string | null
    resolutionNotes?: StringNullableFilter<"CareGap"> | string | null
    fhirConditionRef?: StringNullableFilter<"CareGap"> | string | null
    fhirProcedureRef?: StringNullableFilter<"CareGap"> | string | null
    fhirMedicationRef?: StringNullableFilter<"CareGap"> | string | null
    createdAt?: DateTimeFilter<"CareGap"> | Date | string
    updatedAt?: DateTimeFilter<"CareGap"> | Date | string
  }

  export type PopulationQualityMeasureCreateWithoutQualityMeasureInput = {
    id?: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    population: PopulationCreateNestedOneWithoutQualityMeasuresInput
  }

  export type PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput = {
    id?: string
    populationId: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationQualityMeasureCreateOrConnectWithoutQualityMeasureInput = {
    where: PopulationQualityMeasureWhereUniqueInput
    create: XOR<PopulationQualityMeasureCreateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput>
  }

  export type PopulationQualityMeasureCreateManyQualityMeasureInputEnvelope = {
    data: PopulationQualityMeasureCreateManyQualityMeasureInput | PopulationQualityMeasureCreateManyQualityMeasureInput[]
    skipDuplicates?: boolean
  }

  export type PatientQualityMeasureCreateWithoutQualityMeasureInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: string | null
    status?: $Enums.ComplianceStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    evidenceRef?: string | null
    notes?: string | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: string | null
    status?: $Enums.ComplianceStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    evidenceRef?: string | null
    notes?: string | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientQualityMeasureCreateOrConnectWithoutQualityMeasureInput = {
    where: PatientQualityMeasureWhereUniqueInput
    create: XOR<PatientQualityMeasureCreateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput>
  }

  export type PatientQualityMeasureCreateManyQualityMeasureInputEnvelope = {
    data: PatientQualityMeasureCreateManyQualityMeasureInput | PatientQualityMeasureCreateManyQualityMeasureInput[]
    skipDuplicates?: boolean
  }

  export type PopulationQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput = {
    where: PopulationQualityMeasureWhereUniqueInput
    update: XOR<PopulationQualityMeasureUpdateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedUpdateWithoutQualityMeasureInput>
    create: XOR<PopulationQualityMeasureCreateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedCreateWithoutQualityMeasureInput>
  }

  export type PopulationQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput = {
    where: PopulationQualityMeasureWhereUniqueInput
    data: XOR<PopulationQualityMeasureUpdateWithoutQualityMeasureInput, PopulationQualityMeasureUncheckedUpdateWithoutQualityMeasureInput>
  }

  export type PopulationQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput = {
    where: PopulationQualityMeasureScalarWhereInput
    data: XOR<PopulationQualityMeasureUpdateManyMutationInput, PopulationQualityMeasureUncheckedUpdateManyWithoutQualityMeasureInput>
  }

  export type PatientQualityMeasureUpsertWithWhereUniqueWithoutQualityMeasureInput = {
    where: PatientQualityMeasureWhereUniqueInput
    update: XOR<PatientQualityMeasureUpdateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedUpdateWithoutQualityMeasureInput>
    create: XOR<PatientQualityMeasureCreateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedCreateWithoutQualityMeasureInput>
  }

  export type PatientQualityMeasureUpdateWithWhereUniqueWithoutQualityMeasureInput = {
    where: PatientQualityMeasureWhereUniqueInput
    data: XOR<PatientQualityMeasureUpdateWithoutQualityMeasureInput, PatientQualityMeasureUncheckedUpdateWithoutQualityMeasureInput>
  }

  export type PatientQualityMeasureUpdateManyWithWhereWithoutQualityMeasureInput = {
    where: PatientQualityMeasureScalarWhereInput
    data: XOR<PatientQualityMeasureUpdateManyMutationInput, PatientQualityMeasureUncheckedUpdateManyWithoutQualityMeasureInput>
  }

  export type PatientQualityMeasureScalarWhereInput = {
    AND?: PatientQualityMeasureScalarWhereInput | PatientQualityMeasureScalarWhereInput[]
    OR?: PatientQualityMeasureScalarWhereInput[]
    NOT?: PatientQualityMeasureScalarWhereInput | PatientQualityMeasureScalarWhereInput[]
    id?: StringFilter<"PatientQualityMeasure"> | string
    patientId?: StringFilter<"PatientQualityMeasure"> | string
    fhirPatientRef?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    qualityMeasureId?: StringFilter<"PatientQualityMeasure"> | string
    inDenominator?: BoolFilter<"PatientQualityMeasure"> | boolean
    inNumerator?: BoolFilter<"PatientQualityMeasure"> | boolean
    isExcluded?: BoolFilter<"PatientQualityMeasure"> | boolean
    exclusionReason?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    status?: EnumComplianceStatusFilter<"PatientQualityMeasure"> | $Enums.ComplianceStatus
    dueDate?: DateTimeNullableFilter<"PatientQualityMeasure"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"PatientQualityMeasure"> | Date | string | null
    evidenceRef?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    notes?: StringNullableFilter<"PatientQualityMeasure"> | string | null
    measurePeriod?: StringFilter<"PatientQualityMeasure"> | string
    createdAt?: DateTimeFilter<"PatientQualityMeasure"> | Date | string
    updatedAt?: DateTimeFilter<"PatientQualityMeasure"> | Date | string
  }

  export type PopulationCreateWithoutQualityMeasuresInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorCreateNestedManyWithoutPopulationInput
  }

  export type PopulationUncheckedCreateWithoutQualityMeasuresInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortUncheckedCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportUncheckedCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorUncheckedCreateNestedManyWithoutPopulationInput
  }

  export type PopulationCreateOrConnectWithoutQualityMeasuresInput = {
    where: PopulationWhereUniqueInput
    create: XOR<PopulationCreateWithoutQualityMeasuresInput, PopulationUncheckedCreateWithoutQualityMeasuresInput>
  }

  export type QualityMeasureCreateWithoutPopulationMeasuresInput = {
    id?: string
    measureId: string
    name: string
    description?: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward?: string | null
    domain?: string | null
    fhirMeasureId?: string | null
    fhirVersion?: string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: number | null
    measurePeriodStart?: Date | string | null
    measurePeriodEnd?: Date | string | null
    reportingYear?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patientMeasures?: PatientQualityMeasureCreateNestedManyWithoutQualityMeasureInput
  }

  export type QualityMeasureUncheckedCreateWithoutPopulationMeasuresInput = {
    id?: string
    measureId: string
    name: string
    description?: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward?: string | null
    domain?: string | null
    fhirMeasureId?: string | null
    fhirVersion?: string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: number | null
    measurePeriodStart?: Date | string | null
    measurePeriodEnd?: Date | string | null
    reportingYear?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patientMeasures?: PatientQualityMeasureUncheckedCreateNestedManyWithoutQualityMeasureInput
  }

  export type QualityMeasureCreateOrConnectWithoutPopulationMeasuresInput = {
    where: QualityMeasureWhereUniqueInput
    create: XOR<QualityMeasureCreateWithoutPopulationMeasuresInput, QualityMeasureUncheckedCreateWithoutPopulationMeasuresInput>
  }

  export type PopulationUpsertWithoutQualityMeasuresInput = {
    update: XOR<PopulationUpdateWithoutQualityMeasuresInput, PopulationUncheckedUpdateWithoutQualityMeasuresInput>
    create: XOR<PopulationCreateWithoutQualityMeasuresInput, PopulationUncheckedCreateWithoutQualityMeasuresInput>
    where?: PopulationWhereInput
  }

  export type PopulationUpdateToOneWithWhereWithoutQualityMeasuresInput = {
    where?: PopulationWhereInput
    data: XOR<PopulationUpdateWithoutQualityMeasuresInput, PopulationUncheckedUpdateWithoutQualityMeasuresInput>
  }

  export type PopulationUpdateWithoutQualityMeasuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUpdateManyWithoutPopulationNestedInput
  }

  export type PopulationUncheckedUpdateWithoutQualityMeasuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUncheckedUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUncheckedUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUncheckedUpdateManyWithoutPopulationNestedInput
  }

  export type QualityMeasureUpsertWithoutPopulationMeasuresInput = {
    update: XOR<QualityMeasureUpdateWithoutPopulationMeasuresInput, QualityMeasureUncheckedUpdateWithoutPopulationMeasuresInput>
    create: XOR<QualityMeasureCreateWithoutPopulationMeasuresInput, QualityMeasureUncheckedCreateWithoutPopulationMeasuresInput>
    where?: QualityMeasureWhereInput
  }

  export type QualityMeasureUpdateToOneWithWhereWithoutPopulationMeasuresInput = {
    where?: QualityMeasureWhereInput
    data: XOR<QualityMeasureUpdateWithoutPopulationMeasuresInput, QualityMeasureUncheckedUpdateWithoutPopulationMeasuresInput>
  }

  export type QualityMeasureUpdateWithoutPopulationMeasuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientMeasures?: PatientQualityMeasureUpdateManyWithoutQualityMeasureNestedInput
  }

  export type QualityMeasureUncheckedUpdateWithoutPopulationMeasuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientMeasures?: PatientQualityMeasureUncheckedUpdateManyWithoutQualityMeasureNestedInput
  }

  export type QualityMeasureCreateWithoutPatientMeasuresInput = {
    id?: string
    measureId: string
    name: string
    description?: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward?: string | null
    domain?: string | null
    fhirMeasureId?: string | null
    fhirVersion?: string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: number | null
    measurePeriodStart?: Date | string | null
    measurePeriodEnd?: Date | string | null
    reportingYear?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    populationMeasures?: PopulationQualityMeasureCreateNestedManyWithoutQualityMeasureInput
  }

  export type QualityMeasureUncheckedCreateWithoutPatientMeasuresInput = {
    id?: string
    measureId: string
    name: string
    description?: string | null
    measureType: $Enums.MeasureType
    category: $Enums.MeasureCategory
    steward?: string | null
    domain?: string | null
    fhirMeasureId?: string | null
    fhirVersion?: string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: number | null
    measurePeriodStart?: Date | string | null
    measurePeriodEnd?: Date | string | null
    reportingYear?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    populationMeasures?: PopulationQualityMeasureUncheckedCreateNestedManyWithoutQualityMeasureInput
  }

  export type QualityMeasureCreateOrConnectWithoutPatientMeasuresInput = {
    where: QualityMeasureWhereUniqueInput
    create: XOR<QualityMeasureCreateWithoutPatientMeasuresInput, QualityMeasureUncheckedCreateWithoutPatientMeasuresInput>
  }

  export type QualityMeasureUpsertWithoutPatientMeasuresInput = {
    update: XOR<QualityMeasureUpdateWithoutPatientMeasuresInput, QualityMeasureUncheckedUpdateWithoutPatientMeasuresInput>
    create: XOR<QualityMeasureCreateWithoutPatientMeasuresInput, QualityMeasureUncheckedCreateWithoutPatientMeasuresInput>
    where?: QualityMeasureWhereInput
  }

  export type QualityMeasureUpdateToOneWithWhereWithoutPatientMeasuresInput = {
    where?: QualityMeasureWhereInput
    data: XOR<QualityMeasureUpdateWithoutPatientMeasuresInput, QualityMeasureUncheckedUpdateWithoutPatientMeasuresInput>
  }

  export type QualityMeasureUpdateWithoutPatientMeasuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    populationMeasures?: PopulationQualityMeasureUpdateManyWithoutQualityMeasureNestedInput
  }

  export type QualityMeasureUncheckedUpdateWithoutPatientMeasuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    measureId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    measureType?: EnumMeasureTypeFieldUpdateOperationsInput | $Enums.MeasureType
    category?: EnumMeasureCategoryFieldUpdateOperationsInput | $Enums.MeasureCategory
    steward?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirVersion?: NullableStringFieldUpdateOperationsInput | string | null
    numeratorCriteria?: NullableJsonNullValueInput | InputJsonValue
    denominatorCriteria?: NullableJsonNullValueInput | InputJsonValue
    exclusionCriteria?: NullableJsonNullValueInput | InputJsonValue
    targetRate?: NullableFloatFieldUpdateOperationsInput | number | null
    measurePeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurePeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportingYear?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    populationMeasures?: PopulationQualityMeasureUncheckedUpdateManyWithoutQualityMeasureNestedInput
  }

  export type CohortCreateWithoutCareGapsInput = {
    id?: string
    name: string
    description?: string | null
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    population: PopulationCreateNestedOneWithoutCohortsInput
  }

  export type CohortUncheckedCreateWithoutCareGapsInput = {
    id?: string
    name: string
    description?: string | null
    populationId: string
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type CohortCreateOrConnectWithoutCareGapsInput = {
    where: CohortWhereUniqueInput
    create: XOR<CohortCreateWithoutCareGapsInput, CohortUncheckedCreateWithoutCareGapsInput>
  }

  export type CohortUpsertWithoutCareGapsInput = {
    update: XOR<CohortUpdateWithoutCareGapsInput, CohortUncheckedUpdateWithoutCareGapsInput>
    create: XOR<CohortCreateWithoutCareGapsInput, CohortUncheckedCreateWithoutCareGapsInput>
    where?: CohortWhereInput
  }

  export type CohortUpdateToOneWithWhereWithoutCareGapsInput = {
    where?: CohortWhereInput
    data: XOR<CohortUpdateWithoutCareGapsInput, CohortUncheckedUpdateWithoutCareGapsInput>
  }

  export type CohortUpdateWithoutCareGapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    population?: PopulationUpdateOneRequiredWithoutCohortsNestedInput
  }

  export type CohortUncheckedUpdateWithoutCareGapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    populationId?: StringFieldUpdateOperationsInput | string
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopulationCreateWithoutSdohFactorsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortCreateNestedManyWithoutPopulationInput
    qualityMeasures?: PopulationQualityMeasureCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportCreateNestedManyWithoutPopulationInput
  }

  export type PopulationUncheckedCreateWithoutSdohFactorsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortUncheckedCreateNestedManyWithoutPopulationInput
    qualityMeasures?: PopulationQualityMeasureUncheckedCreateNestedManyWithoutPopulationInput
    analytics?: AnalyticsReportUncheckedCreateNestedManyWithoutPopulationInput
  }

  export type PopulationCreateOrConnectWithoutSdohFactorsInput = {
    where: PopulationWhereUniqueInput
    create: XOR<PopulationCreateWithoutSdohFactorsInput, PopulationUncheckedCreateWithoutSdohFactorsInput>
  }

  export type PopulationUpsertWithoutSdohFactorsInput = {
    update: XOR<PopulationUpdateWithoutSdohFactorsInput, PopulationUncheckedUpdateWithoutSdohFactorsInput>
    create: XOR<PopulationCreateWithoutSdohFactorsInput, PopulationUncheckedCreateWithoutSdohFactorsInput>
    where?: PopulationWhereInput
  }

  export type PopulationUpdateToOneWithWhereWithoutSdohFactorsInput = {
    where?: PopulationWhereInput
    data: XOR<PopulationUpdateWithoutSdohFactorsInput, PopulationUncheckedUpdateWithoutSdohFactorsInput>
  }

  export type PopulationUpdateWithoutSdohFactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUpdateManyWithoutPopulationNestedInput
    qualityMeasures?: PopulationQualityMeasureUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUpdateManyWithoutPopulationNestedInput
  }

  export type PopulationUncheckedUpdateWithoutSdohFactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUncheckedUpdateManyWithoutPopulationNestedInput
    qualityMeasures?: PopulationQualityMeasureUncheckedUpdateManyWithoutPopulationNestedInput
    analytics?: AnalyticsReportUncheckedUpdateManyWithoutPopulationNestedInput
  }

  export type PopulationCreateWithoutAnalyticsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortCreateNestedManyWithoutPopulationInput
    qualityMeasures?: PopulationQualityMeasureCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorCreateNestedManyWithoutPopulationInput
  }

  export type PopulationUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    definitionType?: $Enums.DefinitionType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    status?: $Enums.PopulationStatus
    fhirGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    cohorts?: CohortUncheckedCreateNestedManyWithoutPopulationInput
    qualityMeasures?: PopulationQualityMeasureUncheckedCreateNestedManyWithoutPopulationInput
    sdohFactors?: SdohFactorUncheckedCreateNestedManyWithoutPopulationInput
  }

  export type PopulationCreateOrConnectWithoutAnalyticsInput = {
    where: PopulationWhereUniqueInput
    create: XOR<PopulationCreateWithoutAnalyticsInput, PopulationUncheckedCreateWithoutAnalyticsInput>
  }

  export type PopulationUpsertWithoutAnalyticsInput = {
    update: XOR<PopulationUpdateWithoutAnalyticsInput, PopulationUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<PopulationCreateWithoutAnalyticsInput, PopulationUncheckedCreateWithoutAnalyticsInput>
    where?: PopulationWhereInput
  }

  export type PopulationUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: PopulationWhereInput
    data: XOR<PopulationUpdateWithoutAnalyticsInput, PopulationUncheckedUpdateWithoutAnalyticsInput>
  }

  export type PopulationUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUpdateManyWithoutPopulationNestedInput
    qualityMeasures?: PopulationQualityMeasureUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUpdateManyWithoutPopulationNestedInput
  }

  export type PopulationUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    definitionType?: EnumDefinitionTypeFieldUpdateOperationsInput | $Enums.DefinitionType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    status?: EnumPopulationStatusFieldUpdateOperationsInput | $Enums.PopulationStatus
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    cohorts?: CohortUncheckedUpdateManyWithoutPopulationNestedInput
    qualityMeasures?: PopulationQualityMeasureUncheckedUpdateManyWithoutPopulationNestedInput
    sdohFactors?: SdohFactorUncheckedUpdateManyWithoutPopulationNestedInput
  }

  export type CohortCreateManyPopulationInput = {
    id?: string
    name: string
    description?: string | null
    cohortType: $Enums.CohortType
    criteria: JsonNullValueInput | InputJsonValue
    memberCount?: number
    fhirGroupId?: string | null
    riskLevel?: $Enums.RiskTier | null
    interventionPriority?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type PopulationQualityMeasureCreateManyPopulationInput = {
    id?: string
    qualityMeasureId: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportCreateManyPopulationInput = {
    id?: string
    reportType: $Enums.ReportType
    title: string
    description?: string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    periodStart?: Date | string | null
    periodEnd?: Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdohFactorCreateManyPopulationInput = {
    id?: string
    patientId?: string | null
    fhirPatientRef?: string | null
    category: $Enums.SdohCategory
    factor: string
    value?: string | null
    severity?: $Enums.SdohSeverity | null
    assessmentDate?: Date | string
    assessmentTool?: string | null
    screeningScore?: number | null
    isPositiveScreen?: boolean
    interventionNeeded?: boolean
    interventionType?: string | null
    interventionStatus?: string | null
    referralMade?: boolean
    referralDetails?: string | null
    fhirObservationRef?: string | null
    fhirConditionRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CohortUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    careGaps?: CareGapUpdateManyWithoutCohortNestedInput
  }

  export type CohortUncheckedUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    careGaps?: CareGapUncheckedUpdateManyWithoutCohortNestedInput
  }

  export type CohortUncheckedUpdateManyWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cohortType?: EnumCohortTypeFieldUpdateOperationsInput | $Enums.CohortType
    criteria?: JsonNullValueInput | InputJsonValue
    memberCount?: IntFieldUpdateOperationsInput | number
    fhirGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableEnumRiskTierFieldUpdateOperationsInput | $Enums.RiskTier | null
    interventionPriority?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PopulationQualityMeasureUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityMeasure?: QualityMeasureUpdateOneRequiredWithoutPopulationMeasuresNestedInput
  }

  export type PopulationQualityMeasureUncheckedUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualityMeasureId?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationQualityMeasureUncheckedUpdateManyWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualityMeasureId?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateManyWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableJsonNullValueInput | InputJsonValue
    data?: JsonNullValueInput | InputJsonValue
    visualizations?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdohFactorUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumSdohCategoryFieldUpdateOperationsInput | $Enums.SdohCategory
    factor?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumSdohSeverityFieldUpdateOperationsInput | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentTool?: NullableStringFieldUpdateOperationsInput | string | null
    screeningScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isPositiveScreen?: BoolFieldUpdateOperationsInput | boolean
    interventionNeeded?: BoolFieldUpdateOperationsInput | boolean
    interventionType?: NullableStringFieldUpdateOperationsInput | string | null
    interventionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referralMade?: BoolFieldUpdateOperationsInput | boolean
    referralDetails?: NullableStringFieldUpdateOperationsInput | string | null
    fhirObservationRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdohFactorUncheckedUpdateWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumSdohCategoryFieldUpdateOperationsInput | $Enums.SdohCategory
    factor?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumSdohSeverityFieldUpdateOperationsInput | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentTool?: NullableStringFieldUpdateOperationsInput | string | null
    screeningScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isPositiveScreen?: BoolFieldUpdateOperationsInput | boolean
    interventionNeeded?: BoolFieldUpdateOperationsInput | boolean
    interventionType?: NullableStringFieldUpdateOperationsInput | string | null
    interventionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referralMade?: BoolFieldUpdateOperationsInput | boolean
    referralDetails?: NullableStringFieldUpdateOperationsInput | string | null
    fhirObservationRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdohFactorUncheckedUpdateManyWithoutPopulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumSdohCategoryFieldUpdateOperationsInput | $Enums.SdohCategory
    factor?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableEnumSdohSeverityFieldUpdateOperationsInput | $Enums.SdohSeverity | null
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assessmentTool?: NullableStringFieldUpdateOperationsInput | string | null
    screeningScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isPositiveScreen?: BoolFieldUpdateOperationsInput | boolean
    interventionNeeded?: BoolFieldUpdateOperationsInput | boolean
    interventionType?: NullableStringFieldUpdateOperationsInput | string | null
    interventionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    referralMade?: BoolFieldUpdateOperationsInput | boolean
    referralDetails?: NullableStringFieldUpdateOperationsInput | string | null
    fhirObservationRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareGapCreateManyCohortInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    gapType: $Enums.GapType
    title: string
    description?: string | null
    priority?: $Enums.GapPriority
    qualityMeasureId?: string | null
    recommendedAction?: string | null
    actionDueDate?: Date | string | null
    status?: $Enums.GapStatus
    identifiedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolutionNotes?: string | null
    fhirConditionRef?: string | null
    fhirProcedureRef?: string | null
    fhirMedicationRef?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareGapUpdateWithoutCohortInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    gapType?: EnumGapTypeFieldUpdateOperationsInput | $Enums.GapType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumGapPriorityFieldUpdateOperationsInput | $Enums.GapPriority
    qualityMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGapStatusFieldUpdateOperationsInput | $Enums.GapStatus
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirProcedureRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMedicationRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareGapUncheckedUpdateWithoutCohortInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    gapType?: EnumGapTypeFieldUpdateOperationsInput | $Enums.GapType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumGapPriorityFieldUpdateOperationsInput | $Enums.GapPriority
    qualityMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGapStatusFieldUpdateOperationsInput | $Enums.GapStatus
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirProcedureRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMedicationRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareGapUncheckedUpdateManyWithoutCohortInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    gapType?: EnumGapTypeFieldUpdateOperationsInput | $Enums.GapType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumGapPriorityFieldUpdateOperationsInput | $Enums.GapPriority
    qualityMeasureId?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGapStatusFieldUpdateOperationsInput | $Enums.GapStatus
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fhirConditionRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirProcedureRef?: NullableStringFieldUpdateOperationsInput | string | null
    fhirMedicationRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationQualityMeasureCreateManyQualityMeasureInput = {
    id?: string
    populationId: string
    numerator?: number
    denominator?: number
    exclusions?: number
    performanceRate?: number | null
    benchmarkRate?: number | null
    benchmarkPercentile?: number | null
    starRating?: number | null
    measurePeriod: string
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientQualityMeasureCreateManyQualityMeasureInput = {
    id?: string
    patientId: string
    fhirPatientRef?: string | null
    inDenominator?: boolean
    inNumerator?: boolean
    isExcluded?: boolean
    exclusionReason?: string | null
    status?: $Enums.ComplianceStatus
    dueDate?: Date | string | null
    completedDate?: Date | string | null
    evidenceRef?: string | null
    notes?: string | null
    measurePeriod: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PopulationQualityMeasureUpdateWithoutQualityMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: PopulationUpdateOneRequiredWithoutQualityMeasuresNestedInput
  }

  export type PopulationQualityMeasureUncheckedUpdateWithoutQualityMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PopulationQualityMeasureUncheckedUpdateManyWithoutQualityMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    populationId?: StringFieldUpdateOperationsInput | string
    numerator?: IntFieldUpdateOperationsInput | number
    denominator?: IntFieldUpdateOperationsInput | number
    exclusions?: IntFieldUpdateOperationsInput | number
    performanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkRate?: NullableFloatFieldUpdateOperationsInput | number | null
    benchmarkPercentile?: NullableIntFieldUpdateOperationsInput | number | null
    starRating?: NullableIntFieldUpdateOperationsInput | number | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientQualityMeasureUpdateWithoutQualityMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    inDenominator?: BoolFieldUpdateOperationsInput | boolean
    inNumerator?: BoolFieldUpdateOperationsInput | boolean
    isExcluded?: BoolFieldUpdateOperationsInput | boolean
    exclusionReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientQualityMeasureUncheckedUpdateWithoutQualityMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    inDenominator?: BoolFieldUpdateOperationsInput | boolean
    inNumerator?: BoolFieldUpdateOperationsInput | boolean
    isExcluded?: BoolFieldUpdateOperationsInput | boolean
    exclusionReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientQualityMeasureUncheckedUpdateManyWithoutQualityMeasureInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    fhirPatientRef?: NullableStringFieldUpdateOperationsInput | string | null
    inDenominator?: BoolFieldUpdateOperationsInput | boolean
    inNumerator?: BoolFieldUpdateOperationsInput | boolean
    isExcluded?: BoolFieldUpdateOperationsInput | boolean
    exclusionReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    measurePeriod?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PopulationCountOutputTypeDefaultArgs instead
     */
    export type PopulationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PopulationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CohortCountOutputTypeDefaultArgs instead
     */
    export type CohortCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CohortCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QualityMeasureCountOutputTypeDefaultArgs instead
     */
    export type QualityMeasureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QualityMeasureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PopulationDefaultArgs instead
     */
    export type PopulationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PopulationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PopulationMemberDefaultArgs instead
     */
    export type PopulationMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PopulationMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CohortDefaultArgs instead
     */
    export type CohortArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CohortDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CohortMemberDefaultArgs instead
     */
    export type CohortMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CohortMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QualityMeasureDefaultArgs instead
     */
    export type QualityMeasureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QualityMeasureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PopulationQualityMeasureDefaultArgs instead
     */
    export type PopulationQualityMeasureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PopulationQualityMeasureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientQualityMeasureDefaultArgs instead
     */
    export type PatientQualityMeasureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientQualityMeasureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskScoreDefaultArgs instead
     */
    export type RiskScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskScoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CareGapDefaultArgs instead
     */
    export type CareGapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CareGapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SdohFactorDefaultArgs instead
     */
    export type SdohFactorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SdohFactorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiseaseRegistryDefaultArgs instead
     */
    export type DiseaseRegistryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiseaseRegistryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthEquityMetricDefaultArgs instead
     */
    export type HealthEquityMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthEquityMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsReportDefaultArgs instead
     */
    export type AnalyticsReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PredictiveModelDefaultArgs instead
     */
    export type PredictiveModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PredictiveModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsAuditLogDefaultArgs instead
     */
    export type AnalyticsAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsAuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}