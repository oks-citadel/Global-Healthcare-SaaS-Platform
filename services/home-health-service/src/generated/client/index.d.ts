
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Caregiver
 * 
 */
export type Caregiver = $Result.DefaultSelection<Prisma.$CaregiverPayload>
/**
 * Model CaregiverSchedule
 * 
 */
export type CaregiverSchedule = $Result.DefaultSelection<Prisma.$CaregiverSchedulePayload>
/**
 * Model PatientHome
 * 
 */
export type PatientHome = $Result.DefaultSelection<Prisma.$PatientHomePayload>
/**
 * Model HomeVisit
 * 
 */
export type HomeVisit = $Result.DefaultSelection<Prisma.$HomeVisitPayload>
/**
 * Model VisitTask
 * 
 */
export type VisitTask = $Result.DefaultSelection<Prisma.$VisitTaskPayload>
/**
 * Model EVVRecord
 * 
 */
export type EVVRecord = $Result.DefaultSelection<Prisma.$EVVRecordPayload>
/**
 * Model TimeEntry
 * 
 */
export type TimeEntry = $Result.DefaultSelection<Prisma.$TimeEntryPayload>
/**
 * Model MileageEntry
 * 
 */
export type MileageEntry = $Result.DefaultSelection<Prisma.$MileageEntryPayload>
/**
 * Model HomeAssessment
 * 
 */
export type HomeAssessment = $Result.DefaultSelection<Prisma.$HomeAssessmentPayload>
/**
 * Model MedicationAdministration
 * 
 */
export type MedicationAdministration = $Result.DefaultSelection<Prisma.$MedicationAdministrationPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model VisitDocumentation
 * 
 */
export type VisitDocumentation = $Result.DefaultSelection<Prisma.$VisitDocumentationPayload>
/**
 * Model PatientEquipment
 * 
 */
export type PatientEquipment = $Result.DefaultSelection<Prisma.$PatientEquipmentPayload>
/**
 * Model FamilyCommunication
 * 
 */
export type FamilyCommunication = $Result.DefaultSelection<Prisma.$FamilyCommunicationPayload>
/**
 * Model SupplyOrder
 * 
 */
export type SupplyOrder = $Result.DefaultSelection<Prisma.$SupplyOrderPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LicenseType: {
  RN: 'RN',
  LPN: 'LPN',
  LVN: 'LVN',
  CNA: 'CNA',
  HHA: 'HHA',
  PT: 'PT',
  OT: 'OT',
  ST: 'ST',
  MSW: 'MSW',
  OTHER: 'OTHER'
};

export type LicenseType = (typeof LicenseType)[keyof typeof LicenseType]


export const CaregiverStatus: {
  active: 'active',
  inactive: 'inactive',
  on_leave: 'on_leave',
  terminated: 'terminated'
};

export type CaregiverStatus = (typeof CaregiverStatus)[keyof typeof CaregiverStatus]


export const HomeType: {
  single_family: 'single_family',
  apartment: 'apartment',
  condo: 'condo',
  townhouse: 'townhouse',
  assisted_living: 'assisted_living',
  nursing_facility: 'nursing_facility',
  group_home: 'group_home',
  other: 'other'
};

export type HomeType = (typeof HomeType)[keyof typeof HomeType]


export const VisitPriority: {
  routine: 'routine',
  urgent: 'urgent',
  emergency: 'emergency',
  prn: 'prn'
};

export type VisitPriority = (typeof VisitPriority)[keyof typeof VisitPriority]


export const VisitType: {
  skilled_nursing: 'skilled_nursing',
  physical_therapy: 'physical_therapy',
  occupational_therapy: 'occupational_therapy',
  speech_therapy: 'speech_therapy',
  home_health_aide: 'home_health_aide',
  medical_social_services: 'medical_social_services',
  wound_care: 'wound_care',
  medication_management: 'medication_management',
  post_surgical: 'post_surgical',
  chronic_care: 'chronic_care',
  palliative: 'palliative',
  hospice: 'hospice',
  pediatric: 'pediatric',
  assessment: 'assessment',
  other: 'other'
};

export type VisitType = (typeof VisitType)[keyof typeof VisitType]


export const VisitStatus: {
  scheduled: 'scheduled',
  confirmed: 'confirmed',
  en_route: 'en_route',
  arrived: 'arrived',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled',
  no_show: 'no_show',
  rescheduled: 'rescheduled'
};

export type VisitStatus = (typeof VisitStatus)[keyof typeof VisitStatus]


export const CareTaskType: {
  vital_signs: 'vital_signs',
  medication: 'medication',
  wound_care: 'wound_care',
  personal_care: 'personal_care',
  mobility: 'mobility',
  nutrition: 'nutrition',
  hydration: 'hydration',
  exercise: 'exercise',
  education: 'education',
  assessment: 'assessment',
  documentation: 'documentation',
  equipment_check: 'equipment_check',
  safety_check: 'safety_check',
  communication: 'communication',
  other: 'other'
};

export type CareTaskType = (typeof CareTaskType)[keyof typeof CareTaskType]


export const TaskCompletionStatus: {
  pending: 'pending',
  completed: 'completed',
  skipped: 'skipped',
  unable_to_complete: 'unable_to_complete',
  deferred: 'deferred'
};

export type TaskCompletionStatus = (typeof TaskCompletionStatus)[keyof typeof TaskCompletionStatus]


export const EVVRecordType: {
  clock_in: 'clock_in',
  clock_out: 'clock_out',
  location_update: 'location_update',
  task_completion: 'task_completion',
  signature_capture: 'signature_capture'
};

export type EVVRecordType = (typeof EVVRecordType)[keyof typeof EVVRecordType]


export const EVVVerificationMethod: {
  gps: 'gps',
  telephony: 'telephony',
  biometric: 'biometric',
  fixed_device: 'fixed_device',
  manual_override: 'manual_override'
};

export type EVVVerificationMethod = (typeof EVVVerificationMethod)[keyof typeof EVVVerificationMethod]


export const TimeEntryType: {
  visit: 'visit',
  travel: 'travel',
  training: 'training',
  administrative: 'administrative',
  on_call: 'on_call',
  overtime: 'overtime',
  other: 'other'
};

export type TimeEntryType = (typeof TimeEntryType)[keyof typeof TimeEntryType]


export const ApprovalStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  disputed: 'disputed'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const RiskLevel: {
  low: 'low',
  moderate: 'moderate',
  high: 'high',
  critical: 'critical'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]


export const MedicationRoute: {
  oral: 'oral',
  sublingual: 'sublingual',
  topical: 'topical',
  inhaled: 'inhaled',
  subcutaneous: 'subcutaneous',
  intramuscular: 'intramuscular',
  intravenous: 'intravenous',
  rectal: 'rectal',
  ophthalmic: 'ophthalmic',
  otic: 'otic',
  nasal: 'nasal',
  transdermal: 'transdermal',
  other: 'other'
};

export type MedicationRoute = (typeof MedicationRoute)[keyof typeof MedicationRoute]


export const MedicationStatus: {
  pending: 'pending',
  administered: 'administered',
  refused: 'refused',
  held: 'held',
  not_available: 'not_available',
  self_administered: 'self_administered'
};

export type MedicationStatus = (typeof MedicationStatus)[keyof typeof MedicationStatus]


export const IncidentType: {
  fall: 'fall',
  medication_error: 'medication_error',
  skin_injury: 'skin_injury',
  equipment_malfunction: 'equipment_malfunction',
  behavioral: 'behavioral',
  environmental: 'environmental',
  security: 'security',
  missing_patient: 'missing_patient',
  abuse_neglect: 'abuse_neglect',
  other: 'other'
};

export type IncidentType = (typeof IncidentType)[keyof typeof IncidentType]


export const IncidentSeverity: {
  minor: 'minor',
  moderate: 'moderate',
  major: 'major',
  critical: 'critical'
};

export type IncidentSeverity = (typeof IncidentSeverity)[keyof typeof IncidentSeverity]


export const FallType: {
  witnessed: 'witnessed',
  unwitnessed: 'unwitnessed',
  near_miss: 'near_miss',
  assisted_to_floor: 'assisted_to_floor'
};

export type FallType = (typeof FallType)[keyof typeof FallType]


export const IncidentStatus: {
  reported: 'reported',
  under_investigation: 'under_investigation',
  investigated: 'investigated',
  closed: 'closed',
  requires_action: 'requires_action'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const DocumentType: {
  progress_note: 'progress_note',
  assessment: 'assessment',
  care_plan: 'care_plan',
  physician_order: 'physician_order',
  consent_form: 'consent_form',
  discharge_summary: 'discharge_summary',
  wound_photo: 'wound_photo',
  vital_signs_log: 'vital_signs_log',
  medication_list: 'medication_list',
  family_communication: 'family_communication',
  other: 'other'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const EquipmentType: {
  hospital_bed: 'hospital_bed',
  wheelchair: 'wheelchair',
  walker: 'walker',
  cane: 'cane',
  oxygen_concentrator: 'oxygen_concentrator',
  oxygen_tank: 'oxygen_tank',
  nebulizer: 'nebulizer',
  suction_machine: 'suction_machine',
  feeding_pump: 'feeding_pump',
  iv_pump: 'iv_pump',
  cpap: 'cpap',
  bipap: 'bipap',
  lift: 'lift',
  commode: 'commode',
  shower_chair: 'shower_chair',
  blood_pressure_monitor: 'blood_pressure_monitor',
  glucose_monitor: 'glucose_monitor',
  pulse_oximeter: 'pulse_oximeter',
  other: 'other'
};

export type EquipmentType = (typeof EquipmentType)[keyof typeof EquipmentType]


export const EquipmentStatus: {
  active: 'active',
  returned: 'returned',
  lost: 'lost',
  damaged: 'damaged',
  maintenance: 'maintenance'
};

export type EquipmentStatus = (typeof EquipmentStatus)[keyof typeof EquipmentStatus]


export const EquipmentCondition: {
  excellent: 'excellent',
  good: 'good',
  fair: 'fair',
  poor: 'poor'
};

export type EquipmentCondition = (typeof EquipmentCondition)[keyof typeof EquipmentCondition]


export const OwnershipType: {
  rental: 'rental',
  purchase: 'purchase',
  loan: 'loan',
  insurance_provided: 'insurance_provided'
};

export type OwnershipType = (typeof OwnershipType)[keyof typeof OwnershipType]


export const CommunicationType: {
  visit_update: 'visit_update',
  schedule_change: 'schedule_change',
  medication_reminder: 'medication_reminder',
  care_plan_update: 'care_plan_update',
  general_inquiry: 'general_inquiry',
  emergency_notification: 'emergency_notification',
  documentation_shared: 'documentation_shared',
  feedback: 'feedback',
  other: 'other'
};

export type CommunicationType = (typeof CommunicationType)[keyof typeof CommunicationType]


export const SupplyOrderStatus: {
  pending: 'pending',
  ordered: 'ordered',
  shipped: 'shipped',
  delivered: 'delivered',
  cancelled: 'cancelled',
  back_ordered: 'back_ordered'
};

export type SupplyOrderStatus = (typeof SupplyOrderStatus)[keyof typeof SupplyOrderStatus]

}

export type LicenseType = $Enums.LicenseType

export const LicenseType: typeof $Enums.LicenseType

export type CaregiverStatus = $Enums.CaregiverStatus

export const CaregiverStatus: typeof $Enums.CaregiverStatus

export type HomeType = $Enums.HomeType

export const HomeType: typeof $Enums.HomeType

export type VisitPriority = $Enums.VisitPriority

export const VisitPriority: typeof $Enums.VisitPriority

export type VisitType = $Enums.VisitType

export const VisitType: typeof $Enums.VisitType

export type VisitStatus = $Enums.VisitStatus

export const VisitStatus: typeof $Enums.VisitStatus

export type CareTaskType = $Enums.CareTaskType

export const CareTaskType: typeof $Enums.CareTaskType

export type TaskCompletionStatus = $Enums.TaskCompletionStatus

export const TaskCompletionStatus: typeof $Enums.TaskCompletionStatus

export type EVVRecordType = $Enums.EVVRecordType

export const EVVRecordType: typeof $Enums.EVVRecordType

export type EVVVerificationMethod = $Enums.EVVVerificationMethod

export const EVVVerificationMethod: typeof $Enums.EVVVerificationMethod

export type TimeEntryType = $Enums.TimeEntryType

export const TimeEntryType: typeof $Enums.TimeEntryType

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

export type MedicationRoute = $Enums.MedicationRoute

export const MedicationRoute: typeof $Enums.MedicationRoute

export type MedicationStatus = $Enums.MedicationStatus

export const MedicationStatus: typeof $Enums.MedicationStatus

export type IncidentType = $Enums.IncidentType

export const IncidentType: typeof $Enums.IncidentType

export type IncidentSeverity = $Enums.IncidentSeverity

export const IncidentSeverity: typeof $Enums.IncidentSeverity

export type FallType = $Enums.FallType

export const FallType: typeof $Enums.FallType

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type EquipmentType = $Enums.EquipmentType

export const EquipmentType: typeof $Enums.EquipmentType

export type EquipmentStatus = $Enums.EquipmentStatus

export const EquipmentStatus: typeof $Enums.EquipmentStatus

export type EquipmentCondition = $Enums.EquipmentCondition

export const EquipmentCondition: typeof $Enums.EquipmentCondition

export type OwnershipType = $Enums.OwnershipType

export const OwnershipType: typeof $Enums.OwnershipType

export type CommunicationType = $Enums.CommunicationType

export const CommunicationType: typeof $Enums.CommunicationType

export type SupplyOrderStatus = $Enums.SupplyOrderStatus

export const SupplyOrderStatus: typeof $Enums.SupplyOrderStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Caregivers
 * const caregivers = await prisma.caregiver.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Caregivers
   * const caregivers = await prisma.caregiver.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.caregiver`: Exposes CRUD operations for the **Caregiver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caregivers
    * const caregivers = await prisma.caregiver.findMany()
    * ```
    */
  get caregiver(): Prisma.CaregiverDelegate<ExtArgs>;

  /**
   * `prisma.caregiverSchedule`: Exposes CRUD operations for the **CaregiverSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaregiverSchedules
    * const caregiverSchedules = await prisma.caregiverSchedule.findMany()
    * ```
    */
  get caregiverSchedule(): Prisma.CaregiverScheduleDelegate<ExtArgs>;

  /**
   * `prisma.patientHome`: Exposes CRUD operations for the **PatientHome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientHomes
    * const patientHomes = await prisma.patientHome.findMany()
    * ```
    */
  get patientHome(): Prisma.PatientHomeDelegate<ExtArgs>;

  /**
   * `prisma.homeVisit`: Exposes CRUD operations for the **HomeVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeVisits
    * const homeVisits = await prisma.homeVisit.findMany()
    * ```
    */
  get homeVisit(): Prisma.HomeVisitDelegate<ExtArgs>;

  /**
   * `prisma.visitTask`: Exposes CRUD operations for the **VisitTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitTasks
    * const visitTasks = await prisma.visitTask.findMany()
    * ```
    */
  get visitTask(): Prisma.VisitTaskDelegate<ExtArgs>;

  /**
   * `prisma.eVVRecord`: Exposes CRUD operations for the **EVVRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EVVRecords
    * const eVVRecords = await prisma.eVVRecord.findMany()
    * ```
    */
  get eVVRecord(): Prisma.EVVRecordDelegate<ExtArgs>;

  /**
   * `prisma.timeEntry`: Exposes CRUD operations for the **TimeEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeEntries
    * const timeEntries = await prisma.timeEntry.findMany()
    * ```
    */
  get timeEntry(): Prisma.TimeEntryDelegate<ExtArgs>;

  /**
   * `prisma.mileageEntry`: Exposes CRUD operations for the **MileageEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MileageEntries
    * const mileageEntries = await prisma.mileageEntry.findMany()
    * ```
    */
  get mileageEntry(): Prisma.MileageEntryDelegate<ExtArgs>;

  /**
   * `prisma.homeAssessment`: Exposes CRUD operations for the **HomeAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeAssessments
    * const homeAssessments = await prisma.homeAssessment.findMany()
    * ```
    */
  get homeAssessment(): Prisma.HomeAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.medicationAdministration`: Exposes CRUD operations for the **MedicationAdministration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicationAdministrations
    * const medicationAdministrations = await prisma.medicationAdministration.findMany()
    * ```
    */
  get medicationAdministration(): Prisma.MedicationAdministrationDelegate<ExtArgs>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs>;

  /**
   * `prisma.visitDocumentation`: Exposes CRUD operations for the **VisitDocumentation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitDocumentations
    * const visitDocumentations = await prisma.visitDocumentation.findMany()
    * ```
    */
  get visitDocumentation(): Prisma.VisitDocumentationDelegate<ExtArgs>;

  /**
   * `prisma.patientEquipment`: Exposes CRUD operations for the **PatientEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientEquipments
    * const patientEquipments = await prisma.patientEquipment.findMany()
    * ```
    */
  get patientEquipment(): Prisma.PatientEquipmentDelegate<ExtArgs>;

  /**
   * `prisma.familyCommunication`: Exposes CRUD operations for the **FamilyCommunication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyCommunications
    * const familyCommunications = await prisma.familyCommunication.findMany()
    * ```
    */
  get familyCommunication(): Prisma.FamilyCommunicationDelegate<ExtArgs>;

  /**
   * `prisma.supplyOrder`: Exposes CRUD operations for the **SupplyOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplyOrders
    * const supplyOrders = await prisma.supplyOrder.findMany()
    * ```
    */
  get supplyOrder(): Prisma.SupplyOrderDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Caregiver: 'Caregiver',
    CaregiverSchedule: 'CaregiverSchedule',
    PatientHome: 'PatientHome',
    HomeVisit: 'HomeVisit',
    VisitTask: 'VisitTask',
    EVVRecord: 'EVVRecord',
    TimeEntry: 'TimeEntry',
    MileageEntry: 'MileageEntry',
    HomeAssessment: 'HomeAssessment',
    MedicationAdministration: 'MedicationAdministration',
    Incident: 'Incident',
    VisitDocumentation: 'VisitDocumentation',
    PatientEquipment: 'PatientEquipment',
    FamilyCommunication: 'FamilyCommunication',
    SupplyOrder: 'SupplyOrder'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "caregiver" | "caregiverSchedule" | "patientHome" | "homeVisit" | "visitTask" | "eVVRecord" | "timeEntry" | "mileageEntry" | "homeAssessment" | "medicationAdministration" | "incident" | "visitDocumentation" | "patientEquipment" | "familyCommunication" | "supplyOrder"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Caregiver: {
        payload: Prisma.$CaregiverPayload<ExtArgs>
        fields: Prisma.CaregiverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaregiverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaregiverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>
          }
          findFirst: {
            args: Prisma.CaregiverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaregiverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>
          }
          findMany: {
            args: Prisma.CaregiverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>[]
          }
          create: {
            args: Prisma.CaregiverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>
          }
          createMany: {
            args: Prisma.CaregiverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaregiverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>[]
          }
          delete: {
            args: Prisma.CaregiverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>
          }
          update: {
            args: Prisma.CaregiverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>
          }
          deleteMany: {
            args: Prisma.CaregiverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaregiverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CaregiverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverPayload>
          }
          aggregate: {
            args: Prisma.CaregiverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaregiver>
          }
          groupBy: {
            args: Prisma.CaregiverGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaregiverGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaregiverCountArgs<ExtArgs>
            result: $Utils.Optional<CaregiverCountAggregateOutputType> | number
          }
        }
      }
      CaregiverSchedule: {
        payload: Prisma.$CaregiverSchedulePayload<ExtArgs>
        fields: Prisma.CaregiverScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaregiverScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaregiverScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>
          }
          findFirst: {
            args: Prisma.CaregiverScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaregiverScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>
          }
          findMany: {
            args: Prisma.CaregiverScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>[]
          }
          create: {
            args: Prisma.CaregiverScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>
          }
          createMany: {
            args: Prisma.CaregiverScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaregiverScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>[]
          }
          delete: {
            args: Prisma.CaregiverScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>
          }
          update: {
            args: Prisma.CaregiverScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>
          }
          deleteMany: {
            args: Prisma.CaregiverScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaregiverScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CaregiverScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaregiverSchedulePayload>
          }
          aggregate: {
            args: Prisma.CaregiverScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaregiverSchedule>
          }
          groupBy: {
            args: Prisma.CaregiverScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaregiverScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaregiverScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<CaregiverScheduleCountAggregateOutputType> | number
          }
        }
      }
      PatientHome: {
        payload: Prisma.$PatientHomePayload<ExtArgs>
        fields: Prisma.PatientHomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientHomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientHomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>
          }
          findFirst: {
            args: Prisma.PatientHomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientHomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>
          }
          findMany: {
            args: Prisma.PatientHomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>[]
          }
          create: {
            args: Prisma.PatientHomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>
          }
          createMany: {
            args: Prisma.PatientHomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientHomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>[]
          }
          delete: {
            args: Prisma.PatientHomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>
          }
          update: {
            args: Prisma.PatientHomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>
          }
          deleteMany: {
            args: Prisma.PatientHomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientHomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientHomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHomePayload>
          }
          aggregate: {
            args: Prisma.PatientHomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientHome>
          }
          groupBy: {
            args: Prisma.PatientHomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientHomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientHomeCountArgs<ExtArgs>
            result: $Utils.Optional<PatientHomeCountAggregateOutputType> | number
          }
        }
      }
      HomeVisit: {
        payload: Prisma.$HomeVisitPayload<ExtArgs>
        fields: Prisma.HomeVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomeVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomeVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>
          }
          findFirst: {
            args: Prisma.HomeVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomeVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>
          }
          findMany: {
            args: Prisma.HomeVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>[]
          }
          create: {
            args: Prisma.HomeVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>
          }
          createMany: {
            args: Prisma.HomeVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomeVisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>[]
          }
          delete: {
            args: Prisma.HomeVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>
          }
          update: {
            args: Prisma.HomeVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>
          }
          deleteMany: {
            args: Prisma.HomeVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomeVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HomeVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeVisitPayload>
          }
          aggregate: {
            args: Prisma.HomeVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomeVisit>
          }
          groupBy: {
            args: Prisma.HomeVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomeVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomeVisitCountArgs<ExtArgs>
            result: $Utils.Optional<HomeVisitCountAggregateOutputType> | number
          }
        }
      }
      VisitTask: {
        payload: Prisma.$VisitTaskPayload<ExtArgs>
        fields: Prisma.VisitTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>
          }
          findFirst: {
            args: Prisma.VisitTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>
          }
          findMany: {
            args: Prisma.VisitTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>[]
          }
          create: {
            args: Prisma.VisitTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>
          }
          createMany: {
            args: Prisma.VisitTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>[]
          }
          delete: {
            args: Prisma.VisitTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>
          }
          update: {
            args: Prisma.VisitTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>
          }
          deleteMany: {
            args: Prisma.VisitTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitTaskPayload>
          }
          aggregate: {
            args: Prisma.VisitTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitTask>
          }
          groupBy: {
            args: Prisma.VisitTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitTaskCountArgs<ExtArgs>
            result: $Utils.Optional<VisitTaskCountAggregateOutputType> | number
          }
        }
      }
      EVVRecord: {
        payload: Prisma.$EVVRecordPayload<ExtArgs>
        fields: Prisma.EVVRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EVVRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EVVRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>
          }
          findFirst: {
            args: Prisma.EVVRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EVVRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>
          }
          findMany: {
            args: Prisma.EVVRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>[]
          }
          create: {
            args: Prisma.EVVRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>
          }
          createMany: {
            args: Prisma.EVVRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EVVRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>[]
          }
          delete: {
            args: Prisma.EVVRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>
          }
          update: {
            args: Prisma.EVVRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>
          }
          deleteMany: {
            args: Prisma.EVVRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EVVRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EVVRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EVVRecordPayload>
          }
          aggregate: {
            args: Prisma.EVVRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEVVRecord>
          }
          groupBy: {
            args: Prisma.EVVRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<EVVRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.EVVRecordCountArgs<ExtArgs>
            result: $Utils.Optional<EVVRecordCountAggregateOutputType> | number
          }
        }
      }
      TimeEntry: {
        payload: Prisma.$TimeEntryPayload<ExtArgs>
        fields: Prisma.TimeEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findFirst: {
            args: Prisma.TimeEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findMany: {
            args: Prisma.TimeEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          create: {
            args: Prisma.TimeEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          createMany: {
            args: Prisma.TimeEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          delete: {
            args: Prisma.TimeEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          update: {
            args: Prisma.TimeEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          deleteMany: {
            args: Prisma.TimeEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          aggregate: {
            args: Prisma.TimeEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeEntry>
          }
          groupBy: {
            args: Prisma.TimeEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeEntryCountArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryCountAggregateOutputType> | number
          }
        }
      }
      MileageEntry: {
        payload: Prisma.$MileageEntryPayload<ExtArgs>
        fields: Prisma.MileageEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MileageEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MileageEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>
          }
          findFirst: {
            args: Prisma.MileageEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MileageEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>
          }
          findMany: {
            args: Prisma.MileageEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>[]
          }
          create: {
            args: Prisma.MileageEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>
          }
          createMany: {
            args: Prisma.MileageEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MileageEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>[]
          }
          delete: {
            args: Prisma.MileageEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>
          }
          update: {
            args: Prisma.MileageEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>
          }
          deleteMany: {
            args: Prisma.MileageEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MileageEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MileageEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MileageEntryPayload>
          }
          aggregate: {
            args: Prisma.MileageEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMileageEntry>
          }
          groupBy: {
            args: Prisma.MileageEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MileageEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MileageEntryCountArgs<ExtArgs>
            result: $Utils.Optional<MileageEntryCountAggregateOutputType> | number
          }
        }
      }
      HomeAssessment: {
        payload: Prisma.$HomeAssessmentPayload<ExtArgs>
        fields: Prisma.HomeAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomeAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomeAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>
          }
          findFirst: {
            args: Prisma.HomeAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomeAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>
          }
          findMany: {
            args: Prisma.HomeAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>[]
          }
          create: {
            args: Prisma.HomeAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>
          }
          createMany: {
            args: Prisma.HomeAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomeAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>[]
          }
          delete: {
            args: Prisma.HomeAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>
          }
          update: {
            args: Prisma.HomeAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.HomeAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomeAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HomeAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeAssessmentPayload>
          }
          aggregate: {
            args: Prisma.HomeAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomeAssessment>
          }
          groupBy: {
            args: Prisma.HomeAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomeAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomeAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<HomeAssessmentCountAggregateOutputType> | number
          }
        }
      }
      MedicationAdministration: {
        payload: Prisma.$MedicationAdministrationPayload<ExtArgs>
        fields: Prisma.MedicationAdministrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationAdministrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationAdministrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          findFirst: {
            args: Prisma.MedicationAdministrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationAdministrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          findMany: {
            args: Prisma.MedicationAdministrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>[]
          }
          create: {
            args: Prisma.MedicationAdministrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          createMany: {
            args: Prisma.MedicationAdministrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationAdministrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>[]
          }
          delete: {
            args: Prisma.MedicationAdministrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          update: {
            args: Prisma.MedicationAdministrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationAdministrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationAdministrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicationAdministrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAdministrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicationAdministration>
          }
          groupBy: {
            args: Prisma.MedicationAdministrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationAdministrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationAdministrationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationAdministrationCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      VisitDocumentation: {
        payload: Prisma.$VisitDocumentationPayload<ExtArgs>
        fields: Prisma.VisitDocumentationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitDocumentationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitDocumentationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>
          }
          findFirst: {
            args: Prisma.VisitDocumentationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitDocumentationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>
          }
          findMany: {
            args: Prisma.VisitDocumentationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>[]
          }
          create: {
            args: Prisma.VisitDocumentationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>
          }
          createMany: {
            args: Prisma.VisitDocumentationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitDocumentationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>[]
          }
          delete: {
            args: Prisma.VisitDocumentationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>
          }
          update: {
            args: Prisma.VisitDocumentationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>
          }
          deleteMany: {
            args: Prisma.VisitDocumentationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitDocumentationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitDocumentationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitDocumentationPayload>
          }
          aggregate: {
            args: Prisma.VisitDocumentationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitDocumentation>
          }
          groupBy: {
            args: Prisma.VisitDocumentationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitDocumentationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitDocumentationCountArgs<ExtArgs>
            result: $Utils.Optional<VisitDocumentationCountAggregateOutputType> | number
          }
        }
      }
      PatientEquipment: {
        payload: Prisma.$PatientEquipmentPayload<ExtArgs>
        fields: Prisma.PatientEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>
          }
          findFirst: {
            args: Prisma.PatientEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>
          }
          findMany: {
            args: Prisma.PatientEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>[]
          }
          create: {
            args: Prisma.PatientEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>
          }
          createMany: {
            args: Prisma.PatientEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>[]
          }
          delete: {
            args: Prisma.PatientEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>
          }
          update: {
            args: Prisma.PatientEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.PatientEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientEquipmentPayload>
          }
          aggregate: {
            args: Prisma.PatientEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientEquipment>
          }
          groupBy: {
            args: Prisma.PatientEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<PatientEquipmentCountAggregateOutputType> | number
          }
        }
      }
      FamilyCommunication: {
        payload: Prisma.$FamilyCommunicationPayload<ExtArgs>
        fields: Prisma.FamilyCommunicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyCommunicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyCommunicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>
          }
          findFirst: {
            args: Prisma.FamilyCommunicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyCommunicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>
          }
          findMany: {
            args: Prisma.FamilyCommunicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>[]
          }
          create: {
            args: Prisma.FamilyCommunicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>
          }
          createMany: {
            args: Prisma.FamilyCommunicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamilyCommunicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>[]
          }
          delete: {
            args: Prisma.FamilyCommunicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>
          }
          update: {
            args: Prisma.FamilyCommunicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>
          }
          deleteMany: {
            args: Prisma.FamilyCommunicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyCommunicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyCommunicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyCommunicationPayload>
          }
          aggregate: {
            args: Prisma.FamilyCommunicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyCommunication>
          }
          groupBy: {
            args: Prisma.FamilyCommunicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyCommunicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyCommunicationCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyCommunicationCountAggregateOutputType> | number
          }
        }
      }
      SupplyOrder: {
        payload: Prisma.$SupplyOrderPayload<ExtArgs>
        fields: Prisma.SupplyOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplyOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplyOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>
          }
          findFirst: {
            args: Prisma.SupplyOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplyOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>
          }
          findMany: {
            args: Prisma.SupplyOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>[]
          }
          create: {
            args: Prisma.SupplyOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>
          }
          createMany: {
            args: Prisma.SupplyOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplyOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>[]
          }
          delete: {
            args: Prisma.SupplyOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>
          }
          update: {
            args: Prisma.SupplyOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>
          }
          deleteMany: {
            args: Prisma.SupplyOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplyOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplyOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplyOrderPayload>
          }
          aggregate: {
            args: Prisma.SupplyOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplyOrder>
          }
          groupBy: {
            args: Prisma.SupplyOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplyOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplyOrderCountArgs<ExtArgs>
            result: $Utils.Optional<SupplyOrderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CaregiverCountOutputType
   */

  export type CaregiverCountOutputType = {
    visits: number
    schedules: number
    timeEntries: number
    mileageEntries: number
  }

  export type CaregiverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | CaregiverCountOutputTypeCountVisitsArgs
    schedules?: boolean | CaregiverCountOutputTypeCountSchedulesArgs
    timeEntries?: boolean | CaregiverCountOutputTypeCountTimeEntriesArgs
    mileageEntries?: boolean | CaregiverCountOutputTypeCountMileageEntriesArgs
  }

  // Custom InputTypes
  /**
   * CaregiverCountOutputType without action
   */
  export type CaregiverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverCountOutputType
     */
    select?: CaregiverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaregiverCountOutputType without action
   */
  export type CaregiverCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeVisitWhereInput
  }

  /**
   * CaregiverCountOutputType without action
   */
  export type CaregiverCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaregiverScheduleWhereInput
  }

  /**
   * CaregiverCountOutputType without action
   */
  export type CaregiverCountOutputTypeCountTimeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }

  /**
   * CaregiverCountOutputType without action
   */
  export type CaregiverCountOutputTypeCountMileageEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MileageEntryWhereInput
  }


  /**
   * Count Type PatientHomeCountOutputType
   */

  export type PatientHomeCountOutputType = {
    visits: number
    assessments: number
    equipment: number
  }

  export type PatientHomeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | PatientHomeCountOutputTypeCountVisitsArgs
    assessments?: boolean | PatientHomeCountOutputTypeCountAssessmentsArgs
    equipment?: boolean | PatientHomeCountOutputTypeCountEquipmentArgs
  }

  // Custom InputTypes
  /**
   * PatientHomeCountOutputType without action
   */
  export type PatientHomeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHomeCountOutputType
     */
    select?: PatientHomeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientHomeCountOutputType without action
   */
  export type PatientHomeCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeVisitWhereInput
  }

  /**
   * PatientHomeCountOutputType without action
   */
  export type PatientHomeCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeAssessmentWhereInput
  }

  /**
   * PatientHomeCountOutputType without action
   */
  export type PatientHomeCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientEquipmentWhereInput
  }


  /**
   * Count Type HomeVisitCountOutputType
   */

  export type HomeVisitCountOutputType = {
    tasks: number
    evvRecords: number
    medications: number
    incidents: number
    documentation: number
  }

  export type HomeVisitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | HomeVisitCountOutputTypeCountTasksArgs
    evvRecords?: boolean | HomeVisitCountOutputTypeCountEvvRecordsArgs
    medications?: boolean | HomeVisitCountOutputTypeCountMedicationsArgs
    incidents?: boolean | HomeVisitCountOutputTypeCountIncidentsArgs
    documentation?: boolean | HomeVisitCountOutputTypeCountDocumentationArgs
  }

  // Custom InputTypes
  /**
   * HomeVisitCountOutputType without action
   */
  export type HomeVisitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisitCountOutputType
     */
    select?: HomeVisitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HomeVisitCountOutputType without action
   */
  export type HomeVisitCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitTaskWhereInput
  }

  /**
   * HomeVisitCountOutputType without action
   */
  export type HomeVisitCountOutputTypeCountEvvRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EVVRecordWhereInput
  }

  /**
   * HomeVisitCountOutputType without action
   */
  export type HomeVisitCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationAdministrationWhereInput
  }

  /**
   * HomeVisitCountOutputType without action
   */
  export type HomeVisitCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * HomeVisitCountOutputType without action
   */
  export type HomeVisitCountOutputTypeCountDocumentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitDocumentationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Caregiver
   */

  export type AggregateCaregiver = {
    _count: CaregiverCountAggregateOutputType | null
    _avg: CaregiverAvgAggregateOutputType | null
    _sum: CaregiverSumAggregateOutputType | null
    _min: CaregiverMinAggregateOutputType | null
    _max: CaregiverMaxAggregateOutputType | null
  }

  export type CaregiverAvgAggregateOutputType = {
    hourlyRate: number | null
    maxDailyVisits: number | null
    maxWeeklyHours: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    homeLatitude: number | null
    homeLongitude: number | null
    serviceRadius: number | null
  }

  export type CaregiverSumAggregateOutputType = {
    hourlyRate: number | null
    maxDailyVisits: number | null
    maxWeeklyHours: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    homeLatitude: number | null
    homeLongitude: number | null
    serviceRadius: number | null
  }

  export type CaregiverMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    licenseNumber: string | null
    licenseType: $Enums.LicenseType | null
    licenseExpiry: Date | null
    status: $Enums.CaregiverStatus | null
    hourlyRate: number | null
    maxDailyVisits: number | null
    maxWeeklyHours: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    homeLatitude: number | null
    homeLongitude: number | null
    homeAddress: string | null
    serviceRadius: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaregiverMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    licenseNumber: string | null
    licenseType: $Enums.LicenseType | null
    licenseExpiry: Date | null
    status: $Enums.CaregiverStatus | null
    hourlyRate: number | null
    maxDailyVisits: number | null
    maxWeeklyHours: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    homeLatitude: number | null
    homeLongitude: number | null
    homeAddress: string | null
    serviceRadius: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaregiverCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    licenseNumber: number
    licenseType: number
    licenseExpiry: number
    certifications: number
    specialties: number
    languages: number
    status: number
    hourlyRate: number
    maxDailyVisits: number
    maxWeeklyHours: number
    currentLatitude: number
    currentLongitude: number
    lastLocationUpdate: number
    homeLatitude: number
    homeLongitude: number
    homeAddress: number
    serviceRadius: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CaregiverAvgAggregateInputType = {
    hourlyRate?: true
    maxDailyVisits?: true
    maxWeeklyHours?: true
    currentLatitude?: true
    currentLongitude?: true
    homeLatitude?: true
    homeLongitude?: true
    serviceRadius?: true
  }

  export type CaregiverSumAggregateInputType = {
    hourlyRate?: true
    maxDailyVisits?: true
    maxWeeklyHours?: true
    currentLatitude?: true
    currentLongitude?: true
    homeLatitude?: true
    homeLongitude?: true
    serviceRadius?: true
  }

  export type CaregiverMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    licenseNumber?: true
    licenseType?: true
    licenseExpiry?: true
    status?: true
    hourlyRate?: true
    maxDailyVisits?: true
    maxWeeklyHours?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    homeLatitude?: true
    homeLongitude?: true
    homeAddress?: true
    serviceRadius?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaregiverMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    licenseNumber?: true
    licenseType?: true
    licenseExpiry?: true
    status?: true
    hourlyRate?: true
    maxDailyVisits?: true
    maxWeeklyHours?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    homeLatitude?: true
    homeLongitude?: true
    homeAddress?: true
    serviceRadius?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaregiverCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    licenseNumber?: true
    licenseType?: true
    licenseExpiry?: true
    certifications?: true
    specialties?: true
    languages?: true
    status?: true
    hourlyRate?: true
    maxDailyVisits?: true
    maxWeeklyHours?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    homeLatitude?: true
    homeLongitude?: true
    homeAddress?: true
    serviceRadius?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CaregiverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caregiver to aggregate.
     */
    where?: CaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caregivers to fetch.
     */
    orderBy?: CaregiverOrderByWithRelationInput | CaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Caregivers
    **/
    _count?: true | CaregiverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaregiverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaregiverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaregiverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaregiverMaxAggregateInputType
  }

  export type GetCaregiverAggregateType<T extends CaregiverAggregateArgs> = {
        [P in keyof T & keyof AggregateCaregiver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaregiver[P]>
      : GetScalarType<T[P], AggregateCaregiver[P]>
  }




  export type CaregiverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaregiverWhereInput
    orderBy?: CaregiverOrderByWithAggregationInput | CaregiverOrderByWithAggregationInput[]
    by: CaregiverScalarFieldEnum[] | CaregiverScalarFieldEnum
    having?: CaregiverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaregiverCountAggregateInputType | true
    _avg?: CaregiverAvgAggregateInputType
    _sum?: CaregiverSumAggregateInputType
    _min?: CaregiverMinAggregateInputType
    _max?: CaregiverMaxAggregateInputType
  }

  export type CaregiverGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber: string | null
    licenseType: $Enums.LicenseType | null
    licenseExpiry: Date | null
    certifications: JsonValue | null
    specialties: string[]
    languages: string[]
    status: $Enums.CaregiverStatus
    hourlyRate: number | null
    maxDailyVisits: number
    maxWeeklyHours: number
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    homeLatitude: number | null
    homeLongitude: number | null
    homeAddress: string | null
    serviceRadius: number
    createdAt: Date
    updatedAt: Date
    _count: CaregiverCountAggregateOutputType | null
    _avg: CaregiverAvgAggregateOutputType | null
    _sum: CaregiverSumAggregateOutputType | null
    _min: CaregiverMinAggregateOutputType | null
    _max: CaregiverMaxAggregateOutputType | null
  }

  type GetCaregiverGroupByPayload<T extends CaregiverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaregiverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaregiverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaregiverGroupByOutputType[P]>
            : GetScalarType<T[P], CaregiverGroupByOutputType[P]>
        }
      >
    >


  export type CaregiverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    licenseNumber?: boolean
    licenseType?: boolean
    licenseExpiry?: boolean
    certifications?: boolean
    specialties?: boolean
    languages?: boolean
    status?: boolean
    hourlyRate?: boolean
    maxDailyVisits?: boolean
    maxWeeklyHours?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    homeLatitude?: boolean
    homeLongitude?: boolean
    homeAddress?: boolean
    serviceRadius?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean | Caregiver$visitsArgs<ExtArgs>
    schedules?: boolean | Caregiver$schedulesArgs<ExtArgs>
    timeEntries?: boolean | Caregiver$timeEntriesArgs<ExtArgs>
    mileageEntries?: boolean | Caregiver$mileageEntriesArgs<ExtArgs>
    _count?: boolean | CaregiverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caregiver"]>

  export type CaregiverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    licenseNumber?: boolean
    licenseType?: boolean
    licenseExpiry?: boolean
    certifications?: boolean
    specialties?: boolean
    languages?: boolean
    status?: boolean
    hourlyRate?: boolean
    maxDailyVisits?: boolean
    maxWeeklyHours?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    homeLatitude?: boolean
    homeLongitude?: boolean
    homeAddress?: boolean
    serviceRadius?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["caregiver"]>

  export type CaregiverSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    licenseNumber?: boolean
    licenseType?: boolean
    licenseExpiry?: boolean
    certifications?: boolean
    specialties?: boolean
    languages?: boolean
    status?: boolean
    hourlyRate?: boolean
    maxDailyVisits?: boolean
    maxWeeklyHours?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    homeLatitude?: boolean
    homeLongitude?: boolean
    homeAddress?: boolean
    serviceRadius?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CaregiverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | Caregiver$visitsArgs<ExtArgs>
    schedules?: boolean | Caregiver$schedulesArgs<ExtArgs>
    timeEntries?: boolean | Caregiver$timeEntriesArgs<ExtArgs>
    mileageEntries?: boolean | Caregiver$mileageEntriesArgs<ExtArgs>
    _count?: boolean | CaregiverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaregiverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CaregiverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Caregiver"
    objects: {
      visits: Prisma.$HomeVisitPayload<ExtArgs>[]
      schedules: Prisma.$CaregiverSchedulePayload<ExtArgs>[]
      timeEntries: Prisma.$TimeEntryPayload<ExtArgs>[]
      mileageEntries: Prisma.$MileageEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      email: string
      phone: string
      licenseNumber: string | null
      licenseType: $Enums.LicenseType | null
      licenseExpiry: Date | null
      certifications: Prisma.JsonValue | null
      specialties: string[]
      languages: string[]
      status: $Enums.CaregiverStatus
      hourlyRate: number | null
      maxDailyVisits: number
      maxWeeklyHours: number
      currentLatitude: number | null
      currentLongitude: number | null
      lastLocationUpdate: Date | null
      homeLatitude: number | null
      homeLongitude: number | null
      homeAddress: string | null
      serviceRadius: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["caregiver"]>
    composites: {}
  }

  type CaregiverGetPayload<S extends boolean | null | undefined | CaregiverDefaultArgs> = $Result.GetResult<Prisma.$CaregiverPayload, S>

  type CaregiverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CaregiverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CaregiverCountAggregateInputType | true
    }

  export interface CaregiverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Caregiver'], meta: { name: 'Caregiver' } }
    /**
     * Find zero or one Caregiver that matches the filter.
     * @param {CaregiverFindUniqueArgs} args - Arguments to find a Caregiver
     * @example
     * // Get one Caregiver
     * const caregiver = await prisma.caregiver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaregiverFindUniqueArgs>(args: SelectSubset<T, CaregiverFindUniqueArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Caregiver that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CaregiverFindUniqueOrThrowArgs} args - Arguments to find a Caregiver
     * @example
     * // Get one Caregiver
     * const caregiver = await prisma.caregiver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaregiverFindUniqueOrThrowArgs>(args: SelectSubset<T, CaregiverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Caregiver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverFindFirstArgs} args - Arguments to find a Caregiver
     * @example
     * // Get one Caregiver
     * const caregiver = await prisma.caregiver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaregiverFindFirstArgs>(args?: SelectSubset<T, CaregiverFindFirstArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Caregiver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverFindFirstOrThrowArgs} args - Arguments to find a Caregiver
     * @example
     * // Get one Caregiver
     * const caregiver = await prisma.caregiver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaregiverFindFirstOrThrowArgs>(args?: SelectSubset<T, CaregiverFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Caregivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caregivers
     * const caregivers = await prisma.caregiver.findMany()
     * 
     * // Get first 10 Caregivers
     * const caregivers = await prisma.caregiver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caregiverWithIdOnly = await prisma.caregiver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaregiverFindManyArgs>(args?: SelectSubset<T, CaregiverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Caregiver.
     * @param {CaregiverCreateArgs} args - Arguments to create a Caregiver.
     * @example
     * // Create one Caregiver
     * const Caregiver = await prisma.caregiver.create({
     *   data: {
     *     // ... data to create a Caregiver
     *   }
     * })
     * 
     */
    create<T extends CaregiverCreateArgs>(args: SelectSubset<T, CaregiverCreateArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Caregivers.
     * @param {CaregiverCreateManyArgs} args - Arguments to create many Caregivers.
     * @example
     * // Create many Caregivers
     * const caregiver = await prisma.caregiver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaregiverCreateManyArgs>(args?: SelectSubset<T, CaregiverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Caregivers and returns the data saved in the database.
     * @param {CaregiverCreateManyAndReturnArgs} args - Arguments to create many Caregivers.
     * @example
     * // Create many Caregivers
     * const caregiver = await prisma.caregiver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Caregivers and only return the `id`
     * const caregiverWithIdOnly = await prisma.caregiver.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaregiverCreateManyAndReturnArgs>(args?: SelectSubset<T, CaregiverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Caregiver.
     * @param {CaregiverDeleteArgs} args - Arguments to delete one Caregiver.
     * @example
     * // Delete one Caregiver
     * const Caregiver = await prisma.caregiver.delete({
     *   where: {
     *     // ... filter to delete one Caregiver
     *   }
     * })
     * 
     */
    delete<T extends CaregiverDeleteArgs>(args: SelectSubset<T, CaregiverDeleteArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Caregiver.
     * @param {CaregiverUpdateArgs} args - Arguments to update one Caregiver.
     * @example
     * // Update one Caregiver
     * const caregiver = await prisma.caregiver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaregiverUpdateArgs>(args: SelectSubset<T, CaregiverUpdateArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Caregivers.
     * @param {CaregiverDeleteManyArgs} args - Arguments to filter Caregivers to delete.
     * @example
     * // Delete a few Caregivers
     * const { count } = await prisma.caregiver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaregiverDeleteManyArgs>(args?: SelectSubset<T, CaregiverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caregivers
     * const caregiver = await prisma.caregiver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaregiverUpdateManyArgs>(args: SelectSubset<T, CaregiverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caregiver.
     * @param {CaregiverUpsertArgs} args - Arguments to update or create a Caregiver.
     * @example
     * // Update or create a Caregiver
     * const caregiver = await prisma.caregiver.upsert({
     *   create: {
     *     // ... data to create a Caregiver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caregiver we want to update
     *   }
     * })
     */
    upsert<T extends CaregiverUpsertArgs>(args: SelectSubset<T, CaregiverUpsertArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverCountArgs} args - Arguments to filter Caregivers to count.
     * @example
     * // Count the number of Caregivers
     * const count = await prisma.caregiver.count({
     *   where: {
     *     // ... the filter for the Caregivers we want to count
     *   }
     * })
    **/
    count<T extends CaregiverCountArgs>(
      args?: Subset<T, CaregiverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaregiverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caregiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaregiverAggregateArgs>(args: Subset<T, CaregiverAggregateArgs>): Prisma.PrismaPromise<GetCaregiverAggregateType<T>>

    /**
     * Group by Caregiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaregiverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaregiverGroupByArgs['orderBy'] }
        : { orderBy?: CaregiverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaregiverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaregiverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Caregiver model
   */
  readonly fields: CaregiverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Caregiver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaregiverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visits<T extends Caregiver$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Caregiver$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Caregiver$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Caregiver$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    timeEntries<T extends Caregiver$timeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Caregiver$timeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany"> | Null>
    mileageEntries<T extends Caregiver$mileageEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Caregiver$mileageEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Caregiver model
   */ 
  interface CaregiverFieldRefs {
    readonly id: FieldRef<"Caregiver", 'String'>
    readonly userId: FieldRef<"Caregiver", 'String'>
    readonly firstName: FieldRef<"Caregiver", 'String'>
    readonly lastName: FieldRef<"Caregiver", 'String'>
    readonly email: FieldRef<"Caregiver", 'String'>
    readonly phone: FieldRef<"Caregiver", 'String'>
    readonly licenseNumber: FieldRef<"Caregiver", 'String'>
    readonly licenseType: FieldRef<"Caregiver", 'LicenseType'>
    readonly licenseExpiry: FieldRef<"Caregiver", 'DateTime'>
    readonly certifications: FieldRef<"Caregiver", 'Json'>
    readonly specialties: FieldRef<"Caregiver", 'String[]'>
    readonly languages: FieldRef<"Caregiver", 'String[]'>
    readonly status: FieldRef<"Caregiver", 'CaregiverStatus'>
    readonly hourlyRate: FieldRef<"Caregiver", 'Float'>
    readonly maxDailyVisits: FieldRef<"Caregiver", 'Int'>
    readonly maxWeeklyHours: FieldRef<"Caregiver", 'Float'>
    readonly currentLatitude: FieldRef<"Caregiver", 'Float'>
    readonly currentLongitude: FieldRef<"Caregiver", 'Float'>
    readonly lastLocationUpdate: FieldRef<"Caregiver", 'DateTime'>
    readonly homeLatitude: FieldRef<"Caregiver", 'Float'>
    readonly homeLongitude: FieldRef<"Caregiver", 'Float'>
    readonly homeAddress: FieldRef<"Caregiver", 'String'>
    readonly serviceRadius: FieldRef<"Caregiver", 'Float'>
    readonly createdAt: FieldRef<"Caregiver", 'DateTime'>
    readonly updatedAt: FieldRef<"Caregiver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Caregiver findUnique
   */
  export type CaregiverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * Filter, which Caregiver to fetch.
     */
    where: CaregiverWhereUniqueInput
  }

  /**
   * Caregiver findUniqueOrThrow
   */
  export type CaregiverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * Filter, which Caregiver to fetch.
     */
    where: CaregiverWhereUniqueInput
  }

  /**
   * Caregiver findFirst
   */
  export type CaregiverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * Filter, which Caregiver to fetch.
     */
    where?: CaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caregivers to fetch.
     */
    orderBy?: CaregiverOrderByWithRelationInput | CaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caregivers.
     */
    cursor?: CaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caregivers.
     */
    distinct?: CaregiverScalarFieldEnum | CaregiverScalarFieldEnum[]
  }

  /**
   * Caregiver findFirstOrThrow
   */
  export type CaregiverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * Filter, which Caregiver to fetch.
     */
    where?: CaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caregivers to fetch.
     */
    orderBy?: CaregiverOrderByWithRelationInput | CaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caregivers.
     */
    cursor?: CaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caregivers.
     */
    distinct?: CaregiverScalarFieldEnum | CaregiverScalarFieldEnum[]
  }

  /**
   * Caregiver findMany
   */
  export type CaregiverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * Filter, which Caregivers to fetch.
     */
    where?: CaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caregivers to fetch.
     */
    orderBy?: CaregiverOrderByWithRelationInput | CaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Caregivers.
     */
    cursor?: CaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caregivers.
     */
    skip?: number
    distinct?: CaregiverScalarFieldEnum | CaregiverScalarFieldEnum[]
  }

  /**
   * Caregiver create
   */
  export type CaregiverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * The data needed to create a Caregiver.
     */
    data: XOR<CaregiverCreateInput, CaregiverUncheckedCreateInput>
  }

  /**
   * Caregiver createMany
   */
  export type CaregiverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Caregivers.
     */
    data: CaregiverCreateManyInput | CaregiverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Caregiver createManyAndReturn
   */
  export type CaregiverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Caregivers.
     */
    data: CaregiverCreateManyInput | CaregiverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Caregiver update
   */
  export type CaregiverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * The data needed to update a Caregiver.
     */
    data: XOR<CaregiverUpdateInput, CaregiverUncheckedUpdateInput>
    /**
     * Choose, which Caregiver to update.
     */
    where: CaregiverWhereUniqueInput
  }

  /**
   * Caregiver updateMany
   */
  export type CaregiverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Caregivers.
     */
    data: XOR<CaregiverUpdateManyMutationInput, CaregiverUncheckedUpdateManyInput>
    /**
     * Filter which Caregivers to update
     */
    where?: CaregiverWhereInput
  }

  /**
   * Caregiver upsert
   */
  export type CaregiverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * The filter to search for the Caregiver to update in case it exists.
     */
    where: CaregiverWhereUniqueInput
    /**
     * In case the Caregiver found by the `where` argument doesn't exist, create a new Caregiver with this data.
     */
    create: XOR<CaregiverCreateInput, CaregiverUncheckedCreateInput>
    /**
     * In case the Caregiver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaregiverUpdateInput, CaregiverUncheckedUpdateInput>
  }

  /**
   * Caregiver delete
   */
  export type CaregiverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
    /**
     * Filter which Caregiver to delete.
     */
    where: CaregiverWhereUniqueInput
  }

  /**
   * Caregiver deleteMany
   */
  export type CaregiverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caregivers to delete
     */
    where?: CaregiverWhereInput
  }

  /**
   * Caregiver.visits
   */
  export type Caregiver$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    where?: HomeVisitWhereInput
    orderBy?: HomeVisitOrderByWithRelationInput | HomeVisitOrderByWithRelationInput[]
    cursor?: HomeVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeVisitScalarFieldEnum | HomeVisitScalarFieldEnum[]
  }

  /**
   * Caregiver.schedules
   */
  export type Caregiver$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    where?: CaregiverScheduleWhereInput
    orderBy?: CaregiverScheduleOrderByWithRelationInput | CaregiverScheduleOrderByWithRelationInput[]
    cursor?: CaregiverScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaregiverScheduleScalarFieldEnum | CaregiverScheduleScalarFieldEnum[]
  }

  /**
   * Caregiver.timeEntries
   */
  export type Caregiver$timeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * Caregiver.mileageEntries
   */
  export type Caregiver$mileageEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    where?: MileageEntryWhereInput
    orderBy?: MileageEntryOrderByWithRelationInput | MileageEntryOrderByWithRelationInput[]
    cursor?: MileageEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MileageEntryScalarFieldEnum | MileageEntryScalarFieldEnum[]
  }

  /**
   * Caregiver without action
   */
  export type CaregiverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caregiver
     */
    select?: CaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverInclude<ExtArgs> | null
  }


  /**
   * Model CaregiverSchedule
   */

  export type AggregateCaregiverSchedule = {
    _count: CaregiverScheduleCountAggregateOutputType | null
    _avg: CaregiverScheduleAvgAggregateOutputType | null
    _sum: CaregiverScheduleSumAggregateOutputType | null
    _min: CaregiverScheduleMinAggregateOutputType | null
    _max: CaregiverScheduleMaxAggregateOutputType | null
  }

  export type CaregiverScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type CaregiverScheduleSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type CaregiverScheduleMinAggregateOutputType = {
    id: string | null
    caregiverId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaregiverScheduleMaxAggregateOutputType = {
    id: string | null
    caregiverId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaregiverScheduleCountAggregateOutputType = {
    id: number
    caregiverId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    isAvailable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CaregiverScheduleAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type CaregiverScheduleSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type CaregiverScheduleMinAggregateInputType = {
    id?: true
    caregiverId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaregiverScheduleMaxAggregateInputType = {
    id?: true
    caregiverId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaregiverScheduleCountAggregateInputType = {
    id?: true
    caregiverId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CaregiverScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaregiverSchedule to aggregate.
     */
    where?: CaregiverScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaregiverSchedules to fetch.
     */
    orderBy?: CaregiverScheduleOrderByWithRelationInput | CaregiverScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaregiverScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaregiverSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaregiverSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaregiverSchedules
    **/
    _count?: true | CaregiverScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaregiverScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaregiverScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaregiverScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaregiverScheduleMaxAggregateInputType
  }

  export type GetCaregiverScheduleAggregateType<T extends CaregiverScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateCaregiverSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaregiverSchedule[P]>
      : GetScalarType<T[P], AggregateCaregiverSchedule[P]>
  }




  export type CaregiverScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaregiverScheduleWhereInput
    orderBy?: CaregiverScheduleOrderByWithAggregationInput | CaregiverScheduleOrderByWithAggregationInput[]
    by: CaregiverScheduleScalarFieldEnum[] | CaregiverScheduleScalarFieldEnum
    having?: CaregiverScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaregiverScheduleCountAggregateInputType | true
    _avg?: CaregiverScheduleAvgAggregateInputType
    _sum?: CaregiverScheduleSumAggregateInputType
    _min?: CaregiverScheduleMinAggregateInputType
    _max?: CaregiverScheduleMaxAggregateInputType
  }

  export type CaregiverScheduleGroupByOutputType = {
    id: string
    caregiverId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isAvailable: boolean
    createdAt: Date
    updatedAt: Date
    _count: CaregiverScheduleCountAggregateOutputType | null
    _avg: CaregiverScheduleAvgAggregateOutputType | null
    _sum: CaregiverScheduleSumAggregateOutputType | null
    _min: CaregiverScheduleMinAggregateOutputType | null
    _max: CaregiverScheduleMaxAggregateOutputType | null
  }

  type GetCaregiverScheduleGroupByPayload<T extends CaregiverScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaregiverScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaregiverScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaregiverScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], CaregiverScheduleGroupByOutputType[P]>
        }
      >
    >


  export type CaregiverScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caregiverId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caregiverSchedule"]>

  export type CaregiverScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caregiverId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caregiverSchedule"]>

  export type CaregiverScheduleSelectScalar = {
    id?: boolean
    caregiverId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CaregiverScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }
  export type CaregiverScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }

  export type $CaregiverSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaregiverSchedule"
    objects: {
      caregiver: Prisma.$CaregiverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caregiverId: string
      dayOfWeek: number
      startTime: string
      endTime: string
      isAvailable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["caregiverSchedule"]>
    composites: {}
  }

  type CaregiverScheduleGetPayload<S extends boolean | null | undefined | CaregiverScheduleDefaultArgs> = $Result.GetResult<Prisma.$CaregiverSchedulePayload, S>

  type CaregiverScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CaregiverScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CaregiverScheduleCountAggregateInputType | true
    }

  export interface CaregiverScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaregiverSchedule'], meta: { name: 'CaregiverSchedule' } }
    /**
     * Find zero or one CaregiverSchedule that matches the filter.
     * @param {CaregiverScheduleFindUniqueArgs} args - Arguments to find a CaregiverSchedule
     * @example
     * // Get one CaregiverSchedule
     * const caregiverSchedule = await prisma.caregiverSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaregiverScheduleFindUniqueArgs>(args: SelectSubset<T, CaregiverScheduleFindUniqueArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CaregiverSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CaregiverScheduleFindUniqueOrThrowArgs} args - Arguments to find a CaregiverSchedule
     * @example
     * // Get one CaregiverSchedule
     * const caregiverSchedule = await prisma.caregiverSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaregiverScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, CaregiverScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CaregiverSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverScheduleFindFirstArgs} args - Arguments to find a CaregiverSchedule
     * @example
     * // Get one CaregiverSchedule
     * const caregiverSchedule = await prisma.caregiverSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaregiverScheduleFindFirstArgs>(args?: SelectSubset<T, CaregiverScheduleFindFirstArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CaregiverSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverScheduleFindFirstOrThrowArgs} args - Arguments to find a CaregiverSchedule
     * @example
     * // Get one CaregiverSchedule
     * const caregiverSchedule = await prisma.caregiverSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaregiverScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, CaregiverScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CaregiverSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaregiverSchedules
     * const caregiverSchedules = await prisma.caregiverSchedule.findMany()
     * 
     * // Get first 10 CaregiverSchedules
     * const caregiverSchedules = await prisma.caregiverSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caregiverScheduleWithIdOnly = await prisma.caregiverSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaregiverScheduleFindManyArgs>(args?: SelectSubset<T, CaregiverScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CaregiverSchedule.
     * @param {CaregiverScheduleCreateArgs} args - Arguments to create a CaregiverSchedule.
     * @example
     * // Create one CaregiverSchedule
     * const CaregiverSchedule = await prisma.caregiverSchedule.create({
     *   data: {
     *     // ... data to create a CaregiverSchedule
     *   }
     * })
     * 
     */
    create<T extends CaregiverScheduleCreateArgs>(args: SelectSubset<T, CaregiverScheduleCreateArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CaregiverSchedules.
     * @param {CaregiverScheduleCreateManyArgs} args - Arguments to create many CaregiverSchedules.
     * @example
     * // Create many CaregiverSchedules
     * const caregiverSchedule = await prisma.caregiverSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaregiverScheduleCreateManyArgs>(args?: SelectSubset<T, CaregiverScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaregiverSchedules and returns the data saved in the database.
     * @param {CaregiverScheduleCreateManyAndReturnArgs} args - Arguments to create many CaregiverSchedules.
     * @example
     * // Create many CaregiverSchedules
     * const caregiverSchedule = await prisma.caregiverSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CaregiverSchedules and only return the `id`
     * const caregiverScheduleWithIdOnly = await prisma.caregiverSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaregiverScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, CaregiverScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CaregiverSchedule.
     * @param {CaregiverScheduleDeleteArgs} args - Arguments to delete one CaregiverSchedule.
     * @example
     * // Delete one CaregiverSchedule
     * const CaregiverSchedule = await prisma.caregiverSchedule.delete({
     *   where: {
     *     // ... filter to delete one CaregiverSchedule
     *   }
     * })
     * 
     */
    delete<T extends CaregiverScheduleDeleteArgs>(args: SelectSubset<T, CaregiverScheduleDeleteArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CaregiverSchedule.
     * @param {CaregiverScheduleUpdateArgs} args - Arguments to update one CaregiverSchedule.
     * @example
     * // Update one CaregiverSchedule
     * const caregiverSchedule = await prisma.caregiverSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaregiverScheduleUpdateArgs>(args: SelectSubset<T, CaregiverScheduleUpdateArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CaregiverSchedules.
     * @param {CaregiverScheduleDeleteManyArgs} args - Arguments to filter CaregiverSchedules to delete.
     * @example
     * // Delete a few CaregiverSchedules
     * const { count } = await prisma.caregiverSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaregiverScheduleDeleteManyArgs>(args?: SelectSubset<T, CaregiverScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaregiverSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaregiverSchedules
     * const caregiverSchedule = await prisma.caregiverSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaregiverScheduleUpdateManyArgs>(args: SelectSubset<T, CaregiverScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CaregiverSchedule.
     * @param {CaregiverScheduleUpsertArgs} args - Arguments to update or create a CaregiverSchedule.
     * @example
     * // Update or create a CaregiverSchedule
     * const caregiverSchedule = await prisma.caregiverSchedule.upsert({
     *   create: {
     *     // ... data to create a CaregiverSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaregiverSchedule we want to update
     *   }
     * })
     */
    upsert<T extends CaregiverScheduleUpsertArgs>(args: SelectSubset<T, CaregiverScheduleUpsertArgs<ExtArgs>>): Prisma__CaregiverScheduleClient<$Result.GetResult<Prisma.$CaregiverSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CaregiverSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverScheduleCountArgs} args - Arguments to filter CaregiverSchedules to count.
     * @example
     * // Count the number of CaregiverSchedules
     * const count = await prisma.caregiverSchedule.count({
     *   where: {
     *     // ... the filter for the CaregiverSchedules we want to count
     *   }
     * })
    **/
    count<T extends CaregiverScheduleCountArgs>(
      args?: Subset<T, CaregiverScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaregiverScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaregiverSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaregiverScheduleAggregateArgs>(args: Subset<T, CaregiverScheduleAggregateArgs>): Prisma.PrismaPromise<GetCaregiverScheduleAggregateType<T>>

    /**
     * Group by CaregiverSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiverScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaregiverScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaregiverScheduleGroupByArgs['orderBy'] }
        : { orderBy?: CaregiverScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaregiverScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaregiverScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaregiverSchedule model
   */
  readonly fields: CaregiverScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaregiverSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaregiverScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caregiver<T extends CaregiverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaregiverDefaultArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaregiverSchedule model
   */ 
  interface CaregiverScheduleFieldRefs {
    readonly id: FieldRef<"CaregiverSchedule", 'String'>
    readonly caregiverId: FieldRef<"CaregiverSchedule", 'String'>
    readonly dayOfWeek: FieldRef<"CaregiverSchedule", 'Int'>
    readonly startTime: FieldRef<"CaregiverSchedule", 'String'>
    readonly endTime: FieldRef<"CaregiverSchedule", 'String'>
    readonly isAvailable: FieldRef<"CaregiverSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"CaregiverSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"CaregiverSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CaregiverSchedule findUnique
   */
  export type CaregiverScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CaregiverSchedule to fetch.
     */
    where: CaregiverScheduleWhereUniqueInput
  }

  /**
   * CaregiverSchedule findUniqueOrThrow
   */
  export type CaregiverScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CaregiverSchedule to fetch.
     */
    where: CaregiverScheduleWhereUniqueInput
  }

  /**
   * CaregiverSchedule findFirst
   */
  export type CaregiverScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CaregiverSchedule to fetch.
     */
    where?: CaregiverScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaregiverSchedules to fetch.
     */
    orderBy?: CaregiverScheduleOrderByWithRelationInput | CaregiverScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaregiverSchedules.
     */
    cursor?: CaregiverScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaregiverSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaregiverSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaregiverSchedules.
     */
    distinct?: CaregiverScheduleScalarFieldEnum | CaregiverScheduleScalarFieldEnum[]
  }

  /**
   * CaregiverSchedule findFirstOrThrow
   */
  export type CaregiverScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CaregiverSchedule to fetch.
     */
    where?: CaregiverScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaregiverSchedules to fetch.
     */
    orderBy?: CaregiverScheduleOrderByWithRelationInput | CaregiverScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaregiverSchedules.
     */
    cursor?: CaregiverScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaregiverSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaregiverSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaregiverSchedules.
     */
    distinct?: CaregiverScheduleScalarFieldEnum | CaregiverScheduleScalarFieldEnum[]
  }

  /**
   * CaregiverSchedule findMany
   */
  export type CaregiverScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CaregiverSchedules to fetch.
     */
    where?: CaregiverScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaregiverSchedules to fetch.
     */
    orderBy?: CaregiverScheduleOrderByWithRelationInput | CaregiverScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaregiverSchedules.
     */
    cursor?: CaregiverScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaregiverSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaregiverSchedules.
     */
    skip?: number
    distinct?: CaregiverScheduleScalarFieldEnum | CaregiverScheduleScalarFieldEnum[]
  }

  /**
   * CaregiverSchedule create
   */
  export type CaregiverScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a CaregiverSchedule.
     */
    data: XOR<CaregiverScheduleCreateInput, CaregiverScheduleUncheckedCreateInput>
  }

  /**
   * CaregiverSchedule createMany
   */
  export type CaregiverScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaregiverSchedules.
     */
    data: CaregiverScheduleCreateManyInput | CaregiverScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaregiverSchedule createManyAndReturn
   */
  export type CaregiverScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CaregiverSchedules.
     */
    data: CaregiverScheduleCreateManyInput | CaregiverScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaregiverSchedule update
   */
  export type CaregiverScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a CaregiverSchedule.
     */
    data: XOR<CaregiverScheduleUpdateInput, CaregiverScheduleUncheckedUpdateInput>
    /**
     * Choose, which CaregiverSchedule to update.
     */
    where: CaregiverScheduleWhereUniqueInput
  }

  /**
   * CaregiverSchedule updateMany
   */
  export type CaregiverScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaregiverSchedules.
     */
    data: XOR<CaregiverScheduleUpdateManyMutationInput, CaregiverScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CaregiverSchedules to update
     */
    where?: CaregiverScheduleWhereInput
  }

  /**
   * CaregiverSchedule upsert
   */
  export type CaregiverScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the CaregiverSchedule to update in case it exists.
     */
    where: CaregiverScheduleWhereUniqueInput
    /**
     * In case the CaregiverSchedule found by the `where` argument doesn't exist, create a new CaregiverSchedule with this data.
     */
    create: XOR<CaregiverScheduleCreateInput, CaregiverScheduleUncheckedCreateInput>
    /**
     * In case the CaregiverSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaregiverScheduleUpdateInput, CaregiverScheduleUncheckedUpdateInput>
  }

  /**
   * CaregiverSchedule delete
   */
  export type CaregiverScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
    /**
     * Filter which CaregiverSchedule to delete.
     */
    where: CaregiverScheduleWhereUniqueInput
  }

  /**
   * CaregiverSchedule deleteMany
   */
  export type CaregiverScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaregiverSchedules to delete
     */
    where?: CaregiverScheduleWhereInput
  }

  /**
   * CaregiverSchedule without action
   */
  export type CaregiverScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiverSchedule
     */
    select?: CaregiverScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaregiverScheduleInclude<ExtArgs> | null
  }


  /**
   * Model PatientHome
   */

  export type AggregatePatientHome = {
    _count: PatientHomeCountAggregateOutputType | null
    _avg: PatientHomeAvgAggregateOutputType | null
    _sum: PatientHomeSumAggregateOutputType | null
    _min: PatientHomeMinAggregateOutputType | null
    _max: PatientHomeMaxAggregateOutputType | null
  }

  export type PatientHomeAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type PatientHomeSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type PatientHomeMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    address: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    accessInstructions: string | null
    gateCode: string | null
    parkingInfo: string | null
    petInfo: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    homeType: $Enums.HomeType | null
    hasStairs: boolean | null
    wheelchairAccessible: boolean | null
    oxygenInHome: boolean | null
    safetyHazards: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientHomeMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    address: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    accessInstructions: string | null
    gateCode: string | null
    parkingInfo: string | null
    petInfo: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    homeType: $Enums.HomeType | null
    hasStairs: boolean | null
    wheelchairAccessible: boolean | null
    oxygenInHome: boolean | null
    safetyHazards: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientHomeCountAggregateOutputType = {
    id: number
    patientId: number
    address: number
    addressLine2: number
    city: number
    state: number
    zipCode: number
    country: number
    latitude: number
    longitude: number
    accessInstructions: number
    gateCode: number
    parkingInfo: number
    petInfo: number
    emergencyContact: number
    emergencyPhone: number
    homeType: number
    hasStairs: number
    wheelchairAccessible: number
    oxygenInHome: number
    safetyHazards: number
    specialEquipment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientHomeAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type PatientHomeSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type PatientHomeMinAggregateInputType = {
    id?: true
    patientId?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    latitude?: true
    longitude?: true
    accessInstructions?: true
    gateCode?: true
    parkingInfo?: true
    petInfo?: true
    emergencyContact?: true
    emergencyPhone?: true
    homeType?: true
    hasStairs?: true
    wheelchairAccessible?: true
    oxygenInHome?: true
    safetyHazards?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientHomeMaxAggregateInputType = {
    id?: true
    patientId?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    latitude?: true
    longitude?: true
    accessInstructions?: true
    gateCode?: true
    parkingInfo?: true
    petInfo?: true
    emergencyContact?: true
    emergencyPhone?: true
    homeType?: true
    hasStairs?: true
    wheelchairAccessible?: true
    oxygenInHome?: true
    safetyHazards?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientHomeCountAggregateInputType = {
    id?: true
    patientId?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    latitude?: true
    longitude?: true
    accessInstructions?: true
    gateCode?: true
    parkingInfo?: true
    petInfo?: true
    emergencyContact?: true
    emergencyPhone?: true
    homeType?: true
    hasStairs?: true
    wheelchairAccessible?: true
    oxygenInHome?: true
    safetyHazards?: true
    specialEquipment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientHomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientHome to aggregate.
     */
    where?: PatientHomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHomes to fetch.
     */
    orderBy?: PatientHomeOrderByWithRelationInput | PatientHomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientHomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientHomes
    **/
    _count?: true | PatientHomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientHomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientHomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientHomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientHomeMaxAggregateInputType
  }

  export type GetPatientHomeAggregateType<T extends PatientHomeAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientHome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientHome[P]>
      : GetScalarType<T[P], AggregatePatientHome[P]>
  }




  export type PatientHomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientHomeWhereInput
    orderBy?: PatientHomeOrderByWithAggregationInput | PatientHomeOrderByWithAggregationInput[]
    by: PatientHomeScalarFieldEnum[] | PatientHomeScalarFieldEnum
    having?: PatientHomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientHomeCountAggregateInputType | true
    _avg?: PatientHomeAvgAggregateInputType
    _sum?: PatientHomeSumAggregateInputType
    _min?: PatientHomeMinAggregateInputType
    _max?: PatientHomeMaxAggregateInputType
  }

  export type PatientHomeGroupByOutputType = {
    id: string
    patientId: string
    address: string
    addressLine2: string | null
    city: string
    state: string
    zipCode: string
    country: string
    latitude: number | null
    longitude: number | null
    accessInstructions: string | null
    gateCode: string | null
    parkingInfo: string | null
    petInfo: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    homeType: $Enums.HomeType
    hasStairs: boolean
    wheelchairAccessible: boolean
    oxygenInHome: boolean
    safetyHazards: string | null
    specialEquipment: string[]
    createdAt: Date
    updatedAt: Date
    _count: PatientHomeCountAggregateOutputType | null
    _avg: PatientHomeAvgAggregateOutputType | null
    _sum: PatientHomeSumAggregateOutputType | null
    _min: PatientHomeMinAggregateOutputType | null
    _max: PatientHomeMaxAggregateOutputType | null
  }

  type GetPatientHomeGroupByPayload<T extends PatientHomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientHomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientHomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientHomeGroupByOutputType[P]>
            : GetScalarType<T[P], PatientHomeGroupByOutputType[P]>
        }
      >
    >


  export type PatientHomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    accessInstructions?: boolean
    gateCode?: boolean
    parkingInfo?: boolean
    petInfo?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    homeType?: boolean
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: boolean
    specialEquipment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean | PatientHome$visitsArgs<ExtArgs>
    assessments?: boolean | PatientHome$assessmentsArgs<ExtArgs>
    equipment?: boolean | PatientHome$equipmentArgs<ExtArgs>
    _count?: boolean | PatientHomeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientHome"]>

  export type PatientHomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    accessInstructions?: boolean
    gateCode?: boolean
    parkingInfo?: boolean
    petInfo?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    homeType?: boolean
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: boolean
    specialEquipment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patientHome"]>

  export type PatientHomeSelectScalar = {
    id?: boolean
    patientId?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    accessInstructions?: boolean
    gateCode?: boolean
    parkingInfo?: boolean
    petInfo?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    homeType?: boolean
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: boolean
    specialEquipment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientHomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | PatientHome$visitsArgs<ExtArgs>
    assessments?: boolean | PatientHome$assessmentsArgs<ExtArgs>
    equipment?: boolean | PatientHome$equipmentArgs<ExtArgs>
    _count?: boolean | PatientHomeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientHomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientHomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientHome"
    objects: {
      visits: Prisma.$HomeVisitPayload<ExtArgs>[]
      assessments: Prisma.$HomeAssessmentPayload<ExtArgs>[]
      equipment: Prisma.$PatientEquipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      address: string
      addressLine2: string | null
      city: string
      state: string
      zipCode: string
      country: string
      latitude: number | null
      longitude: number | null
      accessInstructions: string | null
      gateCode: string | null
      parkingInfo: string | null
      petInfo: string | null
      emergencyContact: string | null
      emergencyPhone: string | null
      homeType: $Enums.HomeType
      hasStairs: boolean
      wheelchairAccessible: boolean
      oxygenInHome: boolean
      safetyHazards: string | null
      specialEquipment: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patientHome"]>
    composites: {}
  }

  type PatientHomeGetPayload<S extends boolean | null | undefined | PatientHomeDefaultArgs> = $Result.GetResult<Prisma.$PatientHomePayload, S>

  type PatientHomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientHomeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientHomeCountAggregateInputType | true
    }

  export interface PatientHomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientHome'], meta: { name: 'PatientHome' } }
    /**
     * Find zero or one PatientHome that matches the filter.
     * @param {PatientHomeFindUniqueArgs} args - Arguments to find a PatientHome
     * @example
     * // Get one PatientHome
     * const patientHome = await prisma.patientHome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientHomeFindUniqueArgs>(args: SelectSubset<T, PatientHomeFindUniqueArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientHome that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientHomeFindUniqueOrThrowArgs} args - Arguments to find a PatientHome
     * @example
     * // Get one PatientHome
     * const patientHome = await prisma.patientHome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientHomeFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientHomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientHome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHomeFindFirstArgs} args - Arguments to find a PatientHome
     * @example
     * // Get one PatientHome
     * const patientHome = await prisma.patientHome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientHomeFindFirstArgs>(args?: SelectSubset<T, PatientHomeFindFirstArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientHome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHomeFindFirstOrThrowArgs} args - Arguments to find a PatientHome
     * @example
     * // Get one PatientHome
     * const patientHome = await prisma.patientHome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientHomeFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientHomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientHomes
     * const patientHomes = await prisma.patientHome.findMany()
     * 
     * // Get first 10 PatientHomes
     * const patientHomes = await prisma.patientHome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientHomeWithIdOnly = await prisma.patientHome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientHomeFindManyArgs>(args?: SelectSubset<T, PatientHomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientHome.
     * @param {PatientHomeCreateArgs} args - Arguments to create a PatientHome.
     * @example
     * // Create one PatientHome
     * const PatientHome = await prisma.patientHome.create({
     *   data: {
     *     // ... data to create a PatientHome
     *   }
     * })
     * 
     */
    create<T extends PatientHomeCreateArgs>(args: SelectSubset<T, PatientHomeCreateArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientHomes.
     * @param {PatientHomeCreateManyArgs} args - Arguments to create many PatientHomes.
     * @example
     * // Create many PatientHomes
     * const patientHome = await prisma.patientHome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientHomeCreateManyArgs>(args?: SelectSubset<T, PatientHomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientHomes and returns the data saved in the database.
     * @param {PatientHomeCreateManyAndReturnArgs} args - Arguments to create many PatientHomes.
     * @example
     * // Create many PatientHomes
     * const patientHome = await prisma.patientHome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientHomes and only return the `id`
     * const patientHomeWithIdOnly = await prisma.patientHome.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientHomeCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientHomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientHome.
     * @param {PatientHomeDeleteArgs} args - Arguments to delete one PatientHome.
     * @example
     * // Delete one PatientHome
     * const PatientHome = await prisma.patientHome.delete({
     *   where: {
     *     // ... filter to delete one PatientHome
     *   }
     * })
     * 
     */
    delete<T extends PatientHomeDeleteArgs>(args: SelectSubset<T, PatientHomeDeleteArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientHome.
     * @param {PatientHomeUpdateArgs} args - Arguments to update one PatientHome.
     * @example
     * // Update one PatientHome
     * const patientHome = await prisma.patientHome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientHomeUpdateArgs>(args: SelectSubset<T, PatientHomeUpdateArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientHomes.
     * @param {PatientHomeDeleteManyArgs} args - Arguments to filter PatientHomes to delete.
     * @example
     * // Delete a few PatientHomes
     * const { count } = await prisma.patientHome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientHomeDeleteManyArgs>(args?: SelectSubset<T, PatientHomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientHomes
     * const patientHome = await prisma.patientHome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientHomeUpdateManyArgs>(args: SelectSubset<T, PatientHomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientHome.
     * @param {PatientHomeUpsertArgs} args - Arguments to update or create a PatientHome.
     * @example
     * // Update or create a PatientHome
     * const patientHome = await prisma.patientHome.upsert({
     *   create: {
     *     // ... data to create a PatientHome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientHome we want to update
     *   }
     * })
     */
    upsert<T extends PatientHomeUpsertArgs>(args: SelectSubset<T, PatientHomeUpsertArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHomeCountArgs} args - Arguments to filter PatientHomes to count.
     * @example
     * // Count the number of PatientHomes
     * const count = await prisma.patientHome.count({
     *   where: {
     *     // ... the filter for the PatientHomes we want to count
     *   }
     * })
    **/
    count<T extends PatientHomeCountArgs>(
      args?: Subset<T, PatientHomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientHomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientHome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientHomeAggregateArgs>(args: Subset<T, PatientHomeAggregateArgs>): Prisma.PrismaPromise<GetPatientHomeAggregateType<T>>

    /**
     * Group by PatientHome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientHomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientHomeGroupByArgs['orderBy'] }
        : { orderBy?: PatientHomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientHomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientHomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientHome model
   */
  readonly fields: PatientHomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientHome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientHomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visits<T extends PatientHome$visitsArgs<ExtArgs> = {}>(args?: Subset<T, PatientHome$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findMany"> | Null>
    assessments<T extends PatientHome$assessmentsArgs<ExtArgs> = {}>(args?: Subset<T, PatientHome$assessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    equipment<T extends PatientHome$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, PatientHome$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientHome model
   */ 
  interface PatientHomeFieldRefs {
    readonly id: FieldRef<"PatientHome", 'String'>
    readonly patientId: FieldRef<"PatientHome", 'String'>
    readonly address: FieldRef<"PatientHome", 'String'>
    readonly addressLine2: FieldRef<"PatientHome", 'String'>
    readonly city: FieldRef<"PatientHome", 'String'>
    readonly state: FieldRef<"PatientHome", 'String'>
    readonly zipCode: FieldRef<"PatientHome", 'String'>
    readonly country: FieldRef<"PatientHome", 'String'>
    readonly latitude: FieldRef<"PatientHome", 'Float'>
    readonly longitude: FieldRef<"PatientHome", 'Float'>
    readonly accessInstructions: FieldRef<"PatientHome", 'String'>
    readonly gateCode: FieldRef<"PatientHome", 'String'>
    readonly parkingInfo: FieldRef<"PatientHome", 'String'>
    readonly petInfo: FieldRef<"PatientHome", 'String'>
    readonly emergencyContact: FieldRef<"PatientHome", 'String'>
    readonly emergencyPhone: FieldRef<"PatientHome", 'String'>
    readonly homeType: FieldRef<"PatientHome", 'HomeType'>
    readonly hasStairs: FieldRef<"PatientHome", 'Boolean'>
    readonly wheelchairAccessible: FieldRef<"PatientHome", 'Boolean'>
    readonly oxygenInHome: FieldRef<"PatientHome", 'Boolean'>
    readonly safetyHazards: FieldRef<"PatientHome", 'String'>
    readonly specialEquipment: FieldRef<"PatientHome", 'String[]'>
    readonly createdAt: FieldRef<"PatientHome", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientHome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientHome findUnique
   */
  export type PatientHomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * Filter, which PatientHome to fetch.
     */
    where: PatientHomeWhereUniqueInput
  }

  /**
   * PatientHome findUniqueOrThrow
   */
  export type PatientHomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * Filter, which PatientHome to fetch.
     */
    where: PatientHomeWhereUniqueInput
  }

  /**
   * PatientHome findFirst
   */
  export type PatientHomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * Filter, which PatientHome to fetch.
     */
    where?: PatientHomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHomes to fetch.
     */
    orderBy?: PatientHomeOrderByWithRelationInput | PatientHomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientHomes.
     */
    cursor?: PatientHomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientHomes.
     */
    distinct?: PatientHomeScalarFieldEnum | PatientHomeScalarFieldEnum[]
  }

  /**
   * PatientHome findFirstOrThrow
   */
  export type PatientHomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * Filter, which PatientHome to fetch.
     */
    where?: PatientHomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHomes to fetch.
     */
    orderBy?: PatientHomeOrderByWithRelationInput | PatientHomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientHomes.
     */
    cursor?: PatientHomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientHomes.
     */
    distinct?: PatientHomeScalarFieldEnum | PatientHomeScalarFieldEnum[]
  }

  /**
   * PatientHome findMany
   */
  export type PatientHomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * Filter, which PatientHomes to fetch.
     */
    where?: PatientHomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHomes to fetch.
     */
    orderBy?: PatientHomeOrderByWithRelationInput | PatientHomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientHomes.
     */
    cursor?: PatientHomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHomes.
     */
    skip?: number
    distinct?: PatientHomeScalarFieldEnum | PatientHomeScalarFieldEnum[]
  }

  /**
   * PatientHome create
   */
  export type PatientHomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientHome.
     */
    data: XOR<PatientHomeCreateInput, PatientHomeUncheckedCreateInput>
  }

  /**
   * PatientHome createMany
   */
  export type PatientHomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientHomes.
     */
    data: PatientHomeCreateManyInput | PatientHomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientHome createManyAndReturn
   */
  export type PatientHomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientHomes.
     */
    data: PatientHomeCreateManyInput | PatientHomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientHome update
   */
  export type PatientHomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientHome.
     */
    data: XOR<PatientHomeUpdateInput, PatientHomeUncheckedUpdateInput>
    /**
     * Choose, which PatientHome to update.
     */
    where: PatientHomeWhereUniqueInput
  }

  /**
   * PatientHome updateMany
   */
  export type PatientHomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientHomes.
     */
    data: XOR<PatientHomeUpdateManyMutationInput, PatientHomeUncheckedUpdateManyInput>
    /**
     * Filter which PatientHomes to update
     */
    where?: PatientHomeWhereInput
  }

  /**
   * PatientHome upsert
   */
  export type PatientHomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientHome to update in case it exists.
     */
    where: PatientHomeWhereUniqueInput
    /**
     * In case the PatientHome found by the `where` argument doesn't exist, create a new PatientHome with this data.
     */
    create: XOR<PatientHomeCreateInput, PatientHomeUncheckedCreateInput>
    /**
     * In case the PatientHome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientHomeUpdateInput, PatientHomeUncheckedUpdateInput>
  }

  /**
   * PatientHome delete
   */
  export type PatientHomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
    /**
     * Filter which PatientHome to delete.
     */
    where: PatientHomeWhereUniqueInput
  }

  /**
   * PatientHome deleteMany
   */
  export type PatientHomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientHomes to delete
     */
    where?: PatientHomeWhereInput
  }

  /**
   * PatientHome.visits
   */
  export type PatientHome$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    where?: HomeVisitWhereInput
    orderBy?: HomeVisitOrderByWithRelationInput | HomeVisitOrderByWithRelationInput[]
    cursor?: HomeVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeVisitScalarFieldEnum | HomeVisitScalarFieldEnum[]
  }

  /**
   * PatientHome.assessments
   */
  export type PatientHome$assessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    where?: HomeAssessmentWhereInput
    orderBy?: HomeAssessmentOrderByWithRelationInput | HomeAssessmentOrderByWithRelationInput[]
    cursor?: HomeAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeAssessmentScalarFieldEnum | HomeAssessmentScalarFieldEnum[]
  }

  /**
   * PatientHome.equipment
   */
  export type PatientHome$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    where?: PatientEquipmentWhereInput
    orderBy?: PatientEquipmentOrderByWithRelationInput | PatientEquipmentOrderByWithRelationInput[]
    cursor?: PatientEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientEquipmentScalarFieldEnum | PatientEquipmentScalarFieldEnum[]
  }

  /**
   * PatientHome without action
   */
  export type PatientHomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHome
     */
    select?: PatientHomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHomeInclude<ExtArgs> | null
  }


  /**
   * Model HomeVisit
   */

  export type AggregateHomeVisit = {
    _count: HomeVisitCountAggregateOutputType | null
    _avg: HomeVisitAvgAggregateOutputType | null
    _sum: HomeVisitSumAggregateOutputType | null
    _min: HomeVisitMinAggregateOutputType | null
    _max: HomeVisitMaxAggregateOutputType | null
  }

  export type HomeVisitAvgAggregateOutputType = {
    estimatedDuration: number | null
    actualDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type HomeVisitSumAggregateOutputType = {
    estimatedDuration: number | null
    actualDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type HomeVisitMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    patientHomeId: string | null
    caregiverId: string | null
    scheduledDate: Date | null
    scheduledStartTime: string | null
    scheduledEndTime: string | null
    estimatedDuration: number | null
    priority: $Enums.VisitPriority | null
    visitType: $Enums.VisitType | null
    status: $Enums.VisitStatus | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    actualDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    reasonForVisit: string | null
    clinicalNotes: string | null
    patientCondition: string | null
    followUpRequired: boolean | null
    followUpNotes: string | null
    caregiverSignature: string | null
    patientSignature: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomeVisitMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    patientHomeId: string | null
    caregiverId: string | null
    scheduledDate: Date | null
    scheduledStartTime: string | null
    scheduledEndTime: string | null
    estimatedDuration: number | null
    priority: $Enums.VisitPriority | null
    visitType: $Enums.VisitType | null
    status: $Enums.VisitStatus | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    actualDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    reasonForVisit: string | null
    clinicalNotes: string | null
    patientCondition: string | null
    followUpRequired: boolean | null
    followUpNotes: string | null
    caregiverSignature: string | null
    patientSignature: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomeVisitCountAggregateOutputType = {
    id: number
    patientId: number
    patientHomeId: number
    caregiverId: number
    scheduledDate: number
    scheduledStartTime: number
    scheduledEndTime: number
    estimatedDuration: number
    priority: number
    visitType: number
    status: number
    actualStartTime: number
    actualEndTime: number
    actualDuration: number
    startLatitude: number
    startLongitude: number
    endLatitude: number
    endLongitude: number
    reasonForVisit: number
    clinicalNotes: number
    patientCondition: number
    followUpRequired: number
    followUpNotes: number
    caregiverSignature: number
    patientSignature: number
    signedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HomeVisitAvgAggregateInputType = {
    estimatedDuration?: true
    actualDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type HomeVisitSumAggregateInputType = {
    estimatedDuration?: true
    actualDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type HomeVisitMinAggregateInputType = {
    id?: true
    patientId?: true
    patientHomeId?: true
    caregiverId?: true
    scheduledDate?: true
    scheduledStartTime?: true
    scheduledEndTime?: true
    estimatedDuration?: true
    priority?: true
    visitType?: true
    status?: true
    actualStartTime?: true
    actualEndTime?: true
    actualDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    reasonForVisit?: true
    clinicalNotes?: true
    patientCondition?: true
    followUpRequired?: true
    followUpNotes?: true
    caregiverSignature?: true
    patientSignature?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomeVisitMaxAggregateInputType = {
    id?: true
    patientId?: true
    patientHomeId?: true
    caregiverId?: true
    scheduledDate?: true
    scheduledStartTime?: true
    scheduledEndTime?: true
    estimatedDuration?: true
    priority?: true
    visitType?: true
    status?: true
    actualStartTime?: true
    actualEndTime?: true
    actualDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    reasonForVisit?: true
    clinicalNotes?: true
    patientCondition?: true
    followUpRequired?: true
    followUpNotes?: true
    caregiverSignature?: true
    patientSignature?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomeVisitCountAggregateInputType = {
    id?: true
    patientId?: true
    patientHomeId?: true
    caregiverId?: true
    scheduledDate?: true
    scheduledStartTime?: true
    scheduledEndTime?: true
    estimatedDuration?: true
    priority?: true
    visitType?: true
    status?: true
    actualStartTime?: true
    actualEndTime?: true
    actualDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    reasonForVisit?: true
    clinicalNotes?: true
    patientCondition?: true
    followUpRequired?: true
    followUpNotes?: true
    caregiverSignature?: true
    patientSignature?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HomeVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeVisit to aggregate.
     */
    where?: HomeVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeVisits to fetch.
     */
    orderBy?: HomeVisitOrderByWithRelationInput | HomeVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeVisits
    **/
    _count?: true | HomeVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HomeVisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HomeVisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeVisitMaxAggregateInputType
  }

  export type GetHomeVisitAggregateType<T extends HomeVisitAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeVisit[P]>
      : GetScalarType<T[P], AggregateHomeVisit[P]>
  }




  export type HomeVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeVisitWhereInput
    orderBy?: HomeVisitOrderByWithAggregationInput | HomeVisitOrderByWithAggregationInput[]
    by: HomeVisitScalarFieldEnum[] | HomeVisitScalarFieldEnum
    having?: HomeVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeVisitCountAggregateInputType | true
    _avg?: HomeVisitAvgAggregateInputType
    _sum?: HomeVisitSumAggregateInputType
    _min?: HomeVisitMinAggregateInputType
    _max?: HomeVisitMaxAggregateInputType
  }

  export type HomeVisitGroupByOutputType = {
    id: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status: $Enums.VisitStatus
    actualStartTime: Date | null
    actualEndTime: Date | null
    actualDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    reasonForVisit: string | null
    clinicalNotes: string | null
    patientCondition: string | null
    followUpRequired: boolean
    followUpNotes: string | null
    caregiverSignature: string | null
    patientSignature: string | null
    signedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: HomeVisitCountAggregateOutputType | null
    _avg: HomeVisitAvgAggregateOutputType | null
    _sum: HomeVisitSumAggregateOutputType | null
    _min: HomeVisitMinAggregateOutputType | null
    _max: HomeVisitMaxAggregateOutputType | null
  }

  type GetHomeVisitGroupByPayload<T extends HomeVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeVisitGroupByOutputType[P]>
            : GetScalarType<T[P], HomeVisitGroupByOutputType[P]>
        }
      >
    >


  export type HomeVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patientHomeId?: boolean
    caregiverId?: boolean
    scheduledDate?: boolean
    scheduledStartTime?: boolean
    scheduledEndTime?: boolean
    estimatedDuration?: boolean
    priority?: boolean
    visitType?: boolean
    status?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    actualDuration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    reasonForVisit?: boolean
    clinicalNotes?: boolean
    patientCondition?: boolean
    followUpRequired?: boolean
    followUpNotes?: boolean
    caregiverSignature?: boolean
    patientSignature?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
    tasks?: boolean | HomeVisit$tasksArgs<ExtArgs>
    evvRecords?: boolean | HomeVisit$evvRecordsArgs<ExtArgs>
    medications?: boolean | HomeVisit$medicationsArgs<ExtArgs>
    incidents?: boolean | HomeVisit$incidentsArgs<ExtArgs>
    documentation?: boolean | HomeVisit$documentationArgs<ExtArgs>
    _count?: boolean | HomeVisitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeVisit"]>

  export type HomeVisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patientHomeId?: boolean
    caregiverId?: boolean
    scheduledDate?: boolean
    scheduledStartTime?: boolean
    scheduledEndTime?: boolean
    estimatedDuration?: boolean
    priority?: boolean
    visitType?: boolean
    status?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    actualDuration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    reasonForVisit?: boolean
    clinicalNotes?: boolean
    patientCondition?: boolean
    followUpRequired?: boolean
    followUpNotes?: boolean
    caregiverSignature?: boolean
    patientSignature?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeVisit"]>

  export type HomeVisitSelectScalar = {
    id?: boolean
    patientId?: boolean
    patientHomeId?: boolean
    caregiverId?: boolean
    scheduledDate?: boolean
    scheduledStartTime?: boolean
    scheduledEndTime?: boolean
    estimatedDuration?: boolean
    priority?: boolean
    visitType?: boolean
    status?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    actualDuration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    reasonForVisit?: boolean
    clinicalNotes?: boolean
    patientCondition?: boolean
    followUpRequired?: boolean
    followUpNotes?: boolean
    caregiverSignature?: boolean
    patientSignature?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HomeVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
    tasks?: boolean | HomeVisit$tasksArgs<ExtArgs>
    evvRecords?: boolean | HomeVisit$evvRecordsArgs<ExtArgs>
    medications?: boolean | HomeVisit$medicationsArgs<ExtArgs>
    incidents?: boolean | HomeVisit$incidentsArgs<ExtArgs>
    documentation?: boolean | HomeVisit$documentationArgs<ExtArgs>
    _count?: boolean | HomeVisitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HomeVisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }

  export type $HomeVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomeVisit"
    objects: {
      patientHome: Prisma.$PatientHomePayload<ExtArgs>
      caregiver: Prisma.$CaregiverPayload<ExtArgs>
      tasks: Prisma.$VisitTaskPayload<ExtArgs>[]
      evvRecords: Prisma.$EVVRecordPayload<ExtArgs>[]
      medications: Prisma.$MedicationAdministrationPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      documentation: Prisma.$VisitDocumentationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      patientHomeId: string
      caregiverId: string
      scheduledDate: Date
      scheduledStartTime: string
      scheduledEndTime: string
      estimatedDuration: number
      priority: $Enums.VisitPriority
      visitType: $Enums.VisitType
      status: $Enums.VisitStatus
      actualStartTime: Date | null
      actualEndTime: Date | null
      actualDuration: number | null
      startLatitude: number | null
      startLongitude: number | null
      endLatitude: number | null
      endLongitude: number | null
      reasonForVisit: string | null
      clinicalNotes: string | null
      patientCondition: string | null
      followUpRequired: boolean
      followUpNotes: string | null
      caregiverSignature: string | null
      patientSignature: string | null
      signedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["homeVisit"]>
    composites: {}
  }

  type HomeVisitGetPayload<S extends boolean | null | undefined | HomeVisitDefaultArgs> = $Result.GetResult<Prisma.$HomeVisitPayload, S>

  type HomeVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HomeVisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HomeVisitCountAggregateInputType | true
    }

  export interface HomeVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomeVisit'], meta: { name: 'HomeVisit' } }
    /**
     * Find zero or one HomeVisit that matches the filter.
     * @param {HomeVisitFindUniqueArgs} args - Arguments to find a HomeVisit
     * @example
     * // Get one HomeVisit
     * const homeVisit = await prisma.homeVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomeVisitFindUniqueArgs>(args: SelectSubset<T, HomeVisitFindUniqueArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HomeVisit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HomeVisitFindUniqueOrThrowArgs} args - Arguments to find a HomeVisit
     * @example
     * // Get one HomeVisit
     * const homeVisit = await prisma.homeVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomeVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, HomeVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HomeVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeVisitFindFirstArgs} args - Arguments to find a HomeVisit
     * @example
     * // Get one HomeVisit
     * const homeVisit = await prisma.homeVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomeVisitFindFirstArgs>(args?: SelectSubset<T, HomeVisitFindFirstArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HomeVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeVisitFindFirstOrThrowArgs} args - Arguments to find a HomeVisit
     * @example
     * // Get one HomeVisit
     * const homeVisit = await prisma.homeVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomeVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, HomeVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HomeVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeVisits
     * const homeVisits = await prisma.homeVisit.findMany()
     * 
     * // Get first 10 HomeVisits
     * const homeVisits = await prisma.homeVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeVisitWithIdOnly = await prisma.homeVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomeVisitFindManyArgs>(args?: SelectSubset<T, HomeVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HomeVisit.
     * @param {HomeVisitCreateArgs} args - Arguments to create a HomeVisit.
     * @example
     * // Create one HomeVisit
     * const HomeVisit = await prisma.homeVisit.create({
     *   data: {
     *     // ... data to create a HomeVisit
     *   }
     * })
     * 
     */
    create<T extends HomeVisitCreateArgs>(args: SelectSubset<T, HomeVisitCreateArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HomeVisits.
     * @param {HomeVisitCreateManyArgs} args - Arguments to create many HomeVisits.
     * @example
     * // Create many HomeVisits
     * const homeVisit = await prisma.homeVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomeVisitCreateManyArgs>(args?: SelectSubset<T, HomeVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomeVisits and returns the data saved in the database.
     * @param {HomeVisitCreateManyAndReturnArgs} args - Arguments to create many HomeVisits.
     * @example
     * // Create many HomeVisits
     * const homeVisit = await prisma.homeVisit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomeVisits and only return the `id`
     * const homeVisitWithIdOnly = await prisma.homeVisit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomeVisitCreateManyAndReturnArgs>(args?: SelectSubset<T, HomeVisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HomeVisit.
     * @param {HomeVisitDeleteArgs} args - Arguments to delete one HomeVisit.
     * @example
     * // Delete one HomeVisit
     * const HomeVisit = await prisma.homeVisit.delete({
     *   where: {
     *     // ... filter to delete one HomeVisit
     *   }
     * })
     * 
     */
    delete<T extends HomeVisitDeleteArgs>(args: SelectSubset<T, HomeVisitDeleteArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HomeVisit.
     * @param {HomeVisitUpdateArgs} args - Arguments to update one HomeVisit.
     * @example
     * // Update one HomeVisit
     * const homeVisit = await prisma.homeVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomeVisitUpdateArgs>(args: SelectSubset<T, HomeVisitUpdateArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HomeVisits.
     * @param {HomeVisitDeleteManyArgs} args - Arguments to filter HomeVisits to delete.
     * @example
     * // Delete a few HomeVisits
     * const { count } = await prisma.homeVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomeVisitDeleteManyArgs>(args?: SelectSubset<T, HomeVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeVisits
     * const homeVisit = await prisma.homeVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomeVisitUpdateManyArgs>(args: SelectSubset<T, HomeVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomeVisit.
     * @param {HomeVisitUpsertArgs} args - Arguments to update or create a HomeVisit.
     * @example
     * // Update or create a HomeVisit
     * const homeVisit = await prisma.homeVisit.upsert({
     *   create: {
     *     // ... data to create a HomeVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeVisit we want to update
     *   }
     * })
     */
    upsert<T extends HomeVisitUpsertArgs>(args: SelectSubset<T, HomeVisitUpsertArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HomeVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeVisitCountArgs} args - Arguments to filter HomeVisits to count.
     * @example
     * // Count the number of HomeVisits
     * const count = await prisma.homeVisit.count({
     *   where: {
     *     // ... the filter for the HomeVisits we want to count
     *   }
     * })
    **/
    count<T extends HomeVisitCountArgs>(
      args?: Subset<T, HomeVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeVisitAggregateArgs>(args: Subset<T, HomeVisitAggregateArgs>): Prisma.PrismaPromise<GetHomeVisitAggregateType<T>>

    /**
     * Group by HomeVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeVisitGroupByArgs['orderBy'] }
        : { orderBy?: HomeVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomeVisit model
   */
  readonly fields: HomeVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomeVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientHome<T extends PatientHomeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientHomeDefaultArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    caregiver<T extends CaregiverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaregiverDefaultArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tasks<T extends HomeVisit$tasksArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisit$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "findMany"> | Null>
    evvRecords<T extends HomeVisit$evvRecordsArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisit$evvRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "findMany"> | Null>
    medications<T extends HomeVisit$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisit$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findMany"> | Null>
    incidents<T extends HomeVisit$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisit$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    documentation<T extends HomeVisit$documentationArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisit$documentationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomeVisit model
   */ 
  interface HomeVisitFieldRefs {
    readonly id: FieldRef<"HomeVisit", 'String'>
    readonly patientId: FieldRef<"HomeVisit", 'String'>
    readonly patientHomeId: FieldRef<"HomeVisit", 'String'>
    readonly caregiverId: FieldRef<"HomeVisit", 'String'>
    readonly scheduledDate: FieldRef<"HomeVisit", 'DateTime'>
    readonly scheduledStartTime: FieldRef<"HomeVisit", 'String'>
    readonly scheduledEndTime: FieldRef<"HomeVisit", 'String'>
    readonly estimatedDuration: FieldRef<"HomeVisit", 'Int'>
    readonly priority: FieldRef<"HomeVisit", 'VisitPriority'>
    readonly visitType: FieldRef<"HomeVisit", 'VisitType'>
    readonly status: FieldRef<"HomeVisit", 'VisitStatus'>
    readonly actualStartTime: FieldRef<"HomeVisit", 'DateTime'>
    readonly actualEndTime: FieldRef<"HomeVisit", 'DateTime'>
    readonly actualDuration: FieldRef<"HomeVisit", 'Int'>
    readonly startLatitude: FieldRef<"HomeVisit", 'Float'>
    readonly startLongitude: FieldRef<"HomeVisit", 'Float'>
    readonly endLatitude: FieldRef<"HomeVisit", 'Float'>
    readonly endLongitude: FieldRef<"HomeVisit", 'Float'>
    readonly reasonForVisit: FieldRef<"HomeVisit", 'String'>
    readonly clinicalNotes: FieldRef<"HomeVisit", 'String'>
    readonly patientCondition: FieldRef<"HomeVisit", 'String'>
    readonly followUpRequired: FieldRef<"HomeVisit", 'Boolean'>
    readonly followUpNotes: FieldRef<"HomeVisit", 'String'>
    readonly caregiverSignature: FieldRef<"HomeVisit", 'String'>
    readonly patientSignature: FieldRef<"HomeVisit", 'String'>
    readonly signedAt: FieldRef<"HomeVisit", 'DateTime'>
    readonly createdAt: FieldRef<"HomeVisit", 'DateTime'>
    readonly updatedAt: FieldRef<"HomeVisit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HomeVisit findUnique
   */
  export type HomeVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * Filter, which HomeVisit to fetch.
     */
    where: HomeVisitWhereUniqueInput
  }

  /**
   * HomeVisit findUniqueOrThrow
   */
  export type HomeVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * Filter, which HomeVisit to fetch.
     */
    where: HomeVisitWhereUniqueInput
  }

  /**
   * HomeVisit findFirst
   */
  export type HomeVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * Filter, which HomeVisit to fetch.
     */
    where?: HomeVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeVisits to fetch.
     */
    orderBy?: HomeVisitOrderByWithRelationInput | HomeVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeVisits.
     */
    cursor?: HomeVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeVisits.
     */
    distinct?: HomeVisitScalarFieldEnum | HomeVisitScalarFieldEnum[]
  }

  /**
   * HomeVisit findFirstOrThrow
   */
  export type HomeVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * Filter, which HomeVisit to fetch.
     */
    where?: HomeVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeVisits to fetch.
     */
    orderBy?: HomeVisitOrderByWithRelationInput | HomeVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeVisits.
     */
    cursor?: HomeVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeVisits.
     */
    distinct?: HomeVisitScalarFieldEnum | HomeVisitScalarFieldEnum[]
  }

  /**
   * HomeVisit findMany
   */
  export type HomeVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * Filter, which HomeVisits to fetch.
     */
    where?: HomeVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeVisits to fetch.
     */
    orderBy?: HomeVisitOrderByWithRelationInput | HomeVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeVisits.
     */
    cursor?: HomeVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeVisits.
     */
    skip?: number
    distinct?: HomeVisitScalarFieldEnum | HomeVisitScalarFieldEnum[]
  }

  /**
   * HomeVisit create
   */
  export type HomeVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a HomeVisit.
     */
    data: XOR<HomeVisitCreateInput, HomeVisitUncheckedCreateInput>
  }

  /**
   * HomeVisit createMany
   */
  export type HomeVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomeVisits.
     */
    data: HomeVisitCreateManyInput | HomeVisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomeVisit createManyAndReturn
   */
  export type HomeVisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HomeVisits.
     */
    data: HomeVisitCreateManyInput | HomeVisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomeVisit update
   */
  export type HomeVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a HomeVisit.
     */
    data: XOR<HomeVisitUpdateInput, HomeVisitUncheckedUpdateInput>
    /**
     * Choose, which HomeVisit to update.
     */
    where: HomeVisitWhereUniqueInput
  }

  /**
   * HomeVisit updateMany
   */
  export type HomeVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomeVisits.
     */
    data: XOR<HomeVisitUpdateManyMutationInput, HomeVisitUncheckedUpdateManyInput>
    /**
     * Filter which HomeVisits to update
     */
    where?: HomeVisitWhereInput
  }

  /**
   * HomeVisit upsert
   */
  export type HomeVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the HomeVisit to update in case it exists.
     */
    where: HomeVisitWhereUniqueInput
    /**
     * In case the HomeVisit found by the `where` argument doesn't exist, create a new HomeVisit with this data.
     */
    create: XOR<HomeVisitCreateInput, HomeVisitUncheckedCreateInput>
    /**
     * In case the HomeVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeVisitUpdateInput, HomeVisitUncheckedUpdateInput>
  }

  /**
   * HomeVisit delete
   */
  export type HomeVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    /**
     * Filter which HomeVisit to delete.
     */
    where: HomeVisitWhereUniqueInput
  }

  /**
   * HomeVisit deleteMany
   */
  export type HomeVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeVisits to delete
     */
    where?: HomeVisitWhereInput
  }

  /**
   * HomeVisit.tasks
   */
  export type HomeVisit$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    where?: VisitTaskWhereInput
    orderBy?: VisitTaskOrderByWithRelationInput | VisitTaskOrderByWithRelationInput[]
    cursor?: VisitTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitTaskScalarFieldEnum | VisitTaskScalarFieldEnum[]
  }

  /**
   * HomeVisit.evvRecords
   */
  export type HomeVisit$evvRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    where?: EVVRecordWhereInput
    orderBy?: EVVRecordOrderByWithRelationInput | EVVRecordOrderByWithRelationInput[]
    cursor?: EVVRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EVVRecordScalarFieldEnum | EVVRecordScalarFieldEnum[]
  }

  /**
   * HomeVisit.medications
   */
  export type HomeVisit$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    where?: MedicationAdministrationWhereInput
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    cursor?: MedicationAdministrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * HomeVisit.incidents
   */
  export type HomeVisit$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * HomeVisit.documentation
   */
  export type HomeVisit$documentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    where?: VisitDocumentationWhereInput
    orderBy?: VisitDocumentationOrderByWithRelationInput | VisitDocumentationOrderByWithRelationInput[]
    cursor?: VisitDocumentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitDocumentationScalarFieldEnum | VisitDocumentationScalarFieldEnum[]
  }

  /**
   * HomeVisit without action
   */
  export type HomeVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
  }


  /**
   * Model VisitTask
   */

  export type AggregateVisitTask = {
    _count: VisitTaskCountAggregateOutputType | null
    _avg: VisitTaskAvgAggregateOutputType | null
    _sum: VisitTaskSumAggregateOutputType | null
    _min: VisitTaskMinAggregateOutputType | null
    _max: VisitTaskMaxAggregateOutputType | null
  }

  export type VisitTaskAvgAggregateOutputType = {
    sequence: number | null
    vitalValue: number | null
  }

  export type VisitTaskSumAggregateOutputType = {
    sequence: number | null
    vitalValue: number | null
  }

  export type VisitTaskMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    taskType: $Enums.CareTaskType | null
    title: string | null
    description: string | null
    isRequired: boolean | null
    sequence: number | null
    status: $Enums.TaskCompletionStatus | null
    completedAt: Date | null
    completedBy: string | null
    notes: string | null
    vitalType: string | null
    vitalValue: number | null
    vitalUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitTaskMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    taskType: $Enums.CareTaskType | null
    title: string | null
    description: string | null
    isRequired: boolean | null
    sequence: number | null
    status: $Enums.TaskCompletionStatus | null
    completedAt: Date | null
    completedBy: string | null
    notes: string | null
    vitalType: string | null
    vitalValue: number | null
    vitalUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitTaskCountAggregateOutputType = {
    id: number
    visitId: number
    taskType: number
    title: number
    description: number
    isRequired: number
    sequence: number
    status: number
    completedAt: number
    completedBy: number
    notes: number
    vitalType: number
    vitalValue: number
    vitalUnit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitTaskAvgAggregateInputType = {
    sequence?: true
    vitalValue?: true
  }

  export type VisitTaskSumAggregateInputType = {
    sequence?: true
    vitalValue?: true
  }

  export type VisitTaskMinAggregateInputType = {
    id?: true
    visitId?: true
    taskType?: true
    title?: true
    description?: true
    isRequired?: true
    sequence?: true
    status?: true
    completedAt?: true
    completedBy?: true
    notes?: true
    vitalType?: true
    vitalValue?: true
    vitalUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitTaskMaxAggregateInputType = {
    id?: true
    visitId?: true
    taskType?: true
    title?: true
    description?: true
    isRequired?: true
    sequence?: true
    status?: true
    completedAt?: true
    completedBy?: true
    notes?: true
    vitalType?: true
    vitalValue?: true
    vitalUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitTaskCountAggregateInputType = {
    id?: true
    visitId?: true
    taskType?: true
    title?: true
    description?: true
    isRequired?: true
    sequence?: true
    status?: true
    completedAt?: true
    completedBy?: true
    notes?: true
    vitalType?: true
    vitalValue?: true
    vitalUnit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitTask to aggregate.
     */
    where?: VisitTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTasks to fetch.
     */
    orderBy?: VisitTaskOrderByWithRelationInput | VisitTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitTasks
    **/
    _count?: true | VisitTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitTaskMaxAggregateInputType
  }

  export type GetVisitTaskAggregateType<T extends VisitTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitTask[P]>
      : GetScalarType<T[P], AggregateVisitTask[P]>
  }




  export type VisitTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitTaskWhereInput
    orderBy?: VisitTaskOrderByWithAggregationInput | VisitTaskOrderByWithAggregationInput[]
    by: VisitTaskScalarFieldEnum[] | VisitTaskScalarFieldEnum
    having?: VisitTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitTaskCountAggregateInputType | true
    _avg?: VisitTaskAvgAggregateInputType
    _sum?: VisitTaskSumAggregateInputType
    _min?: VisitTaskMinAggregateInputType
    _max?: VisitTaskMaxAggregateInputType
  }

  export type VisitTaskGroupByOutputType = {
    id: string
    visitId: string
    taskType: $Enums.CareTaskType
    title: string
    description: string | null
    isRequired: boolean
    sequence: number
    status: $Enums.TaskCompletionStatus
    completedAt: Date | null
    completedBy: string | null
    notes: string | null
    vitalType: string | null
    vitalValue: number | null
    vitalUnit: string | null
    createdAt: Date
    updatedAt: Date
    _count: VisitTaskCountAggregateOutputType | null
    _avg: VisitTaskAvgAggregateOutputType | null
    _sum: VisitTaskSumAggregateOutputType | null
    _min: VisitTaskMinAggregateOutputType | null
    _max: VisitTaskMaxAggregateOutputType | null
  }

  type GetVisitTaskGroupByPayload<T extends VisitTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitTaskGroupByOutputType[P]>
            : GetScalarType<T[P], VisitTaskGroupByOutputType[P]>
        }
      >
    >


  export type VisitTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    taskType?: boolean
    title?: boolean
    description?: boolean
    isRequired?: boolean
    sequence?: boolean
    status?: boolean
    completedAt?: boolean
    completedBy?: boolean
    notes?: boolean
    vitalType?: boolean
    vitalValue?: boolean
    vitalUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitTask"]>

  export type VisitTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    taskType?: boolean
    title?: boolean
    description?: boolean
    isRequired?: boolean
    sequence?: boolean
    status?: boolean
    completedAt?: boolean
    completedBy?: boolean
    notes?: boolean
    vitalType?: boolean
    vitalValue?: boolean
    vitalUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitTask"]>

  export type VisitTaskSelectScalar = {
    id?: boolean
    visitId?: boolean
    taskType?: boolean
    title?: boolean
    description?: boolean
    isRequired?: boolean
    sequence?: boolean
    status?: boolean
    completedAt?: boolean
    completedBy?: boolean
    notes?: boolean
    vitalType?: boolean
    vitalValue?: boolean
    vitalUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }
  export type VisitTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }

  export type $VisitTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitTask"
    objects: {
      visit: Prisma.$HomeVisitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      taskType: $Enums.CareTaskType
      title: string
      description: string | null
      isRequired: boolean
      sequence: number
      status: $Enums.TaskCompletionStatus
      completedAt: Date | null
      completedBy: string | null
      notes: string | null
      vitalType: string | null
      vitalValue: number | null
      vitalUnit: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitTask"]>
    composites: {}
  }

  type VisitTaskGetPayload<S extends boolean | null | undefined | VisitTaskDefaultArgs> = $Result.GetResult<Prisma.$VisitTaskPayload, S>

  type VisitTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitTaskCountAggregateInputType | true
    }

  export interface VisitTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitTask'], meta: { name: 'VisitTask' } }
    /**
     * Find zero or one VisitTask that matches the filter.
     * @param {VisitTaskFindUniqueArgs} args - Arguments to find a VisitTask
     * @example
     * // Get one VisitTask
     * const visitTask = await prisma.visitTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitTaskFindUniqueArgs>(args: SelectSubset<T, VisitTaskFindUniqueArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitTaskFindUniqueOrThrowArgs} args - Arguments to find a VisitTask
     * @example
     * // Get one VisitTask
     * const visitTask = await prisma.visitTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTaskFindFirstArgs} args - Arguments to find a VisitTask
     * @example
     * // Get one VisitTask
     * const visitTask = await prisma.visitTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitTaskFindFirstArgs>(args?: SelectSubset<T, VisitTaskFindFirstArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTaskFindFirstOrThrowArgs} args - Arguments to find a VisitTask
     * @example
     * // Get one VisitTask
     * const visitTask = await prisma.visitTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitTasks
     * const visitTasks = await prisma.visitTask.findMany()
     * 
     * // Get first 10 VisitTasks
     * const visitTasks = await prisma.visitTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitTaskWithIdOnly = await prisma.visitTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitTaskFindManyArgs>(args?: SelectSubset<T, VisitTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitTask.
     * @param {VisitTaskCreateArgs} args - Arguments to create a VisitTask.
     * @example
     * // Create one VisitTask
     * const VisitTask = await prisma.visitTask.create({
     *   data: {
     *     // ... data to create a VisitTask
     *   }
     * })
     * 
     */
    create<T extends VisitTaskCreateArgs>(args: SelectSubset<T, VisitTaskCreateArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitTasks.
     * @param {VisitTaskCreateManyArgs} args - Arguments to create many VisitTasks.
     * @example
     * // Create many VisitTasks
     * const visitTask = await prisma.visitTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitTaskCreateManyArgs>(args?: SelectSubset<T, VisitTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitTasks and returns the data saved in the database.
     * @param {VisitTaskCreateManyAndReturnArgs} args - Arguments to create many VisitTasks.
     * @example
     * // Create many VisitTasks
     * const visitTask = await prisma.visitTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitTasks and only return the `id`
     * const visitTaskWithIdOnly = await prisma.visitTask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitTask.
     * @param {VisitTaskDeleteArgs} args - Arguments to delete one VisitTask.
     * @example
     * // Delete one VisitTask
     * const VisitTask = await prisma.visitTask.delete({
     *   where: {
     *     // ... filter to delete one VisitTask
     *   }
     * })
     * 
     */
    delete<T extends VisitTaskDeleteArgs>(args: SelectSubset<T, VisitTaskDeleteArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitTask.
     * @param {VisitTaskUpdateArgs} args - Arguments to update one VisitTask.
     * @example
     * // Update one VisitTask
     * const visitTask = await prisma.visitTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitTaskUpdateArgs>(args: SelectSubset<T, VisitTaskUpdateArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitTasks.
     * @param {VisitTaskDeleteManyArgs} args - Arguments to filter VisitTasks to delete.
     * @example
     * // Delete a few VisitTasks
     * const { count } = await prisma.visitTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitTaskDeleteManyArgs>(args?: SelectSubset<T, VisitTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitTasks
     * const visitTask = await prisma.visitTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitTaskUpdateManyArgs>(args: SelectSubset<T, VisitTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitTask.
     * @param {VisitTaskUpsertArgs} args - Arguments to update or create a VisitTask.
     * @example
     * // Update or create a VisitTask
     * const visitTask = await prisma.visitTask.upsert({
     *   create: {
     *     // ... data to create a VisitTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitTask we want to update
     *   }
     * })
     */
    upsert<T extends VisitTaskUpsertArgs>(args: SelectSubset<T, VisitTaskUpsertArgs<ExtArgs>>): Prisma__VisitTaskClient<$Result.GetResult<Prisma.$VisitTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTaskCountArgs} args - Arguments to filter VisitTasks to count.
     * @example
     * // Count the number of VisitTasks
     * const count = await prisma.visitTask.count({
     *   where: {
     *     // ... the filter for the VisitTasks we want to count
     *   }
     * })
    **/
    count<T extends VisitTaskCountArgs>(
      args?: Subset<T, VisitTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitTaskAggregateArgs>(args: Subset<T, VisitTaskAggregateArgs>): Prisma.PrismaPromise<GetVisitTaskAggregateType<T>>

    /**
     * Group by VisitTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitTaskGroupByArgs['orderBy'] }
        : { orderBy?: VisitTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitTask model
   */
  readonly fields: VisitTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends HomeVisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisitDefaultArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitTask model
   */ 
  interface VisitTaskFieldRefs {
    readonly id: FieldRef<"VisitTask", 'String'>
    readonly visitId: FieldRef<"VisitTask", 'String'>
    readonly taskType: FieldRef<"VisitTask", 'CareTaskType'>
    readonly title: FieldRef<"VisitTask", 'String'>
    readonly description: FieldRef<"VisitTask", 'String'>
    readonly isRequired: FieldRef<"VisitTask", 'Boolean'>
    readonly sequence: FieldRef<"VisitTask", 'Int'>
    readonly status: FieldRef<"VisitTask", 'TaskCompletionStatus'>
    readonly completedAt: FieldRef<"VisitTask", 'DateTime'>
    readonly completedBy: FieldRef<"VisitTask", 'String'>
    readonly notes: FieldRef<"VisitTask", 'String'>
    readonly vitalType: FieldRef<"VisitTask", 'String'>
    readonly vitalValue: FieldRef<"VisitTask", 'Float'>
    readonly vitalUnit: FieldRef<"VisitTask", 'String'>
    readonly createdAt: FieldRef<"VisitTask", 'DateTime'>
    readonly updatedAt: FieldRef<"VisitTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitTask findUnique
   */
  export type VisitTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * Filter, which VisitTask to fetch.
     */
    where: VisitTaskWhereUniqueInput
  }

  /**
   * VisitTask findUniqueOrThrow
   */
  export type VisitTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * Filter, which VisitTask to fetch.
     */
    where: VisitTaskWhereUniqueInput
  }

  /**
   * VisitTask findFirst
   */
  export type VisitTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * Filter, which VisitTask to fetch.
     */
    where?: VisitTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTasks to fetch.
     */
    orderBy?: VisitTaskOrderByWithRelationInput | VisitTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTasks.
     */
    cursor?: VisitTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTasks.
     */
    distinct?: VisitTaskScalarFieldEnum | VisitTaskScalarFieldEnum[]
  }

  /**
   * VisitTask findFirstOrThrow
   */
  export type VisitTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * Filter, which VisitTask to fetch.
     */
    where?: VisitTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTasks to fetch.
     */
    orderBy?: VisitTaskOrderByWithRelationInput | VisitTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitTasks.
     */
    cursor?: VisitTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitTasks.
     */
    distinct?: VisitTaskScalarFieldEnum | VisitTaskScalarFieldEnum[]
  }

  /**
   * VisitTask findMany
   */
  export type VisitTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * Filter, which VisitTasks to fetch.
     */
    where?: VisitTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitTasks to fetch.
     */
    orderBy?: VisitTaskOrderByWithRelationInput | VisitTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitTasks.
     */
    cursor?: VisitTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitTasks.
     */
    skip?: number
    distinct?: VisitTaskScalarFieldEnum | VisitTaskScalarFieldEnum[]
  }

  /**
   * VisitTask create
   */
  export type VisitTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitTask.
     */
    data: XOR<VisitTaskCreateInput, VisitTaskUncheckedCreateInput>
  }

  /**
   * VisitTask createMany
   */
  export type VisitTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitTasks.
     */
    data: VisitTaskCreateManyInput | VisitTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitTask createManyAndReturn
   */
  export type VisitTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitTasks.
     */
    data: VisitTaskCreateManyInput | VisitTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitTask update
   */
  export type VisitTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitTask.
     */
    data: XOR<VisitTaskUpdateInput, VisitTaskUncheckedUpdateInput>
    /**
     * Choose, which VisitTask to update.
     */
    where: VisitTaskWhereUniqueInput
  }

  /**
   * VisitTask updateMany
   */
  export type VisitTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitTasks.
     */
    data: XOR<VisitTaskUpdateManyMutationInput, VisitTaskUncheckedUpdateManyInput>
    /**
     * Filter which VisitTasks to update
     */
    where?: VisitTaskWhereInput
  }

  /**
   * VisitTask upsert
   */
  export type VisitTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitTask to update in case it exists.
     */
    where: VisitTaskWhereUniqueInput
    /**
     * In case the VisitTask found by the `where` argument doesn't exist, create a new VisitTask with this data.
     */
    create: XOR<VisitTaskCreateInput, VisitTaskUncheckedCreateInput>
    /**
     * In case the VisitTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitTaskUpdateInput, VisitTaskUncheckedUpdateInput>
  }

  /**
   * VisitTask delete
   */
  export type VisitTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
    /**
     * Filter which VisitTask to delete.
     */
    where: VisitTaskWhereUniqueInput
  }

  /**
   * VisitTask deleteMany
   */
  export type VisitTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitTasks to delete
     */
    where?: VisitTaskWhereInput
  }

  /**
   * VisitTask without action
   */
  export type VisitTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitTask
     */
    select?: VisitTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitTaskInclude<ExtArgs> | null
  }


  /**
   * Model EVVRecord
   */

  export type AggregateEVVRecord = {
    _count: EVVRecordCountAggregateOutputType | null
    _avg: EVVRecordAvgAggregateOutputType | null
    _sum: EVVRecordSumAggregateOutputType | null
    _min: EVVRecordMinAggregateOutputType | null
    _max: EVVRecordMaxAggregateOutputType | null
  }

  export type EVVRecordAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    distanceFromHome: number | null
    geofenceRadius: number | null
  }

  export type EVVRecordSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    distanceFromHome: number | null
    geofenceRadius: number | null
  }

  export type EVVRecordMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    recordType: $Enums.EVVRecordType | null
    timestamp: Date | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    deviceId: string | null
    deviceType: string | null
    ipAddress: string | null
    isVerified: boolean | null
    verificationMethod: $Enums.EVVVerificationMethod | null
    verificationNotes: string | null
    distanceFromHome: number | null
    isWithinGeofence: boolean | null
    geofenceRadius: number | null
    createdAt: Date | null
  }

  export type EVVRecordMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    recordType: $Enums.EVVRecordType | null
    timestamp: Date | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    deviceId: string | null
    deviceType: string | null
    ipAddress: string | null
    isVerified: boolean | null
    verificationMethod: $Enums.EVVVerificationMethod | null
    verificationNotes: string | null
    distanceFromHome: number | null
    isWithinGeofence: boolean | null
    geofenceRadius: number | null
    createdAt: Date | null
  }

  export type EVVRecordCountAggregateOutputType = {
    id: number
    visitId: number
    recordType: number
    timestamp: number
    latitude: number
    longitude: number
    accuracy: number
    deviceId: number
    deviceType: number
    ipAddress: number
    isVerified: number
    verificationMethod: number
    verificationNotes: number
    distanceFromHome: number
    isWithinGeofence: number
    geofenceRadius: number
    createdAt: number
    _all: number
  }


  export type EVVRecordAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
    distanceFromHome?: true
    geofenceRadius?: true
  }

  export type EVVRecordSumAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
    distanceFromHome?: true
    geofenceRadius?: true
  }

  export type EVVRecordMinAggregateInputType = {
    id?: true
    visitId?: true
    recordType?: true
    timestamp?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    deviceId?: true
    deviceType?: true
    ipAddress?: true
    isVerified?: true
    verificationMethod?: true
    verificationNotes?: true
    distanceFromHome?: true
    isWithinGeofence?: true
    geofenceRadius?: true
    createdAt?: true
  }

  export type EVVRecordMaxAggregateInputType = {
    id?: true
    visitId?: true
    recordType?: true
    timestamp?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    deviceId?: true
    deviceType?: true
    ipAddress?: true
    isVerified?: true
    verificationMethod?: true
    verificationNotes?: true
    distanceFromHome?: true
    isWithinGeofence?: true
    geofenceRadius?: true
    createdAt?: true
  }

  export type EVVRecordCountAggregateInputType = {
    id?: true
    visitId?: true
    recordType?: true
    timestamp?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    deviceId?: true
    deviceType?: true
    ipAddress?: true
    isVerified?: true
    verificationMethod?: true
    verificationNotes?: true
    distanceFromHome?: true
    isWithinGeofence?: true
    geofenceRadius?: true
    createdAt?: true
    _all?: true
  }

  export type EVVRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EVVRecord to aggregate.
     */
    where?: EVVRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EVVRecords to fetch.
     */
    orderBy?: EVVRecordOrderByWithRelationInput | EVVRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EVVRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EVVRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EVVRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EVVRecords
    **/
    _count?: true | EVVRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EVVRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EVVRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EVVRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EVVRecordMaxAggregateInputType
  }

  export type GetEVVRecordAggregateType<T extends EVVRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateEVVRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEVVRecord[P]>
      : GetScalarType<T[P], AggregateEVVRecord[P]>
  }




  export type EVVRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EVVRecordWhereInput
    orderBy?: EVVRecordOrderByWithAggregationInput | EVVRecordOrderByWithAggregationInput[]
    by: EVVRecordScalarFieldEnum[] | EVVRecordScalarFieldEnum
    having?: EVVRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EVVRecordCountAggregateInputType | true
    _avg?: EVVRecordAvgAggregateInputType
    _sum?: EVVRecordSumAggregateInputType
    _min?: EVVRecordMinAggregateInputType
    _max?: EVVRecordMaxAggregateInputType
  }

  export type EVVRecordGroupByOutputType = {
    id: string
    visitId: string
    recordType: $Enums.EVVRecordType
    timestamp: Date
    latitude: number
    longitude: number
    accuracy: number | null
    deviceId: string | null
    deviceType: string | null
    ipAddress: string | null
    isVerified: boolean
    verificationMethod: $Enums.EVVVerificationMethod
    verificationNotes: string | null
    distanceFromHome: number | null
    isWithinGeofence: boolean
    geofenceRadius: number
    createdAt: Date
    _count: EVVRecordCountAggregateOutputType | null
    _avg: EVVRecordAvgAggregateOutputType | null
    _sum: EVVRecordSumAggregateOutputType | null
    _min: EVVRecordMinAggregateOutputType | null
    _max: EVVRecordMaxAggregateOutputType | null
  }

  type GetEVVRecordGroupByPayload<T extends EVVRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EVVRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EVVRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EVVRecordGroupByOutputType[P]>
            : GetScalarType<T[P], EVVRecordGroupByOutputType[P]>
        }
      >
    >


  export type EVVRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    recordType?: boolean
    timestamp?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    deviceId?: boolean
    deviceType?: boolean
    ipAddress?: boolean
    isVerified?: boolean
    verificationMethod?: boolean
    verificationNotes?: boolean
    distanceFromHome?: boolean
    isWithinGeofence?: boolean
    geofenceRadius?: boolean
    createdAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eVVRecord"]>

  export type EVVRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    recordType?: boolean
    timestamp?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    deviceId?: boolean
    deviceType?: boolean
    ipAddress?: boolean
    isVerified?: boolean
    verificationMethod?: boolean
    verificationNotes?: boolean
    distanceFromHome?: boolean
    isWithinGeofence?: boolean
    geofenceRadius?: boolean
    createdAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eVVRecord"]>

  export type EVVRecordSelectScalar = {
    id?: boolean
    visitId?: boolean
    recordType?: boolean
    timestamp?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    deviceId?: boolean
    deviceType?: boolean
    ipAddress?: boolean
    isVerified?: boolean
    verificationMethod?: boolean
    verificationNotes?: boolean
    distanceFromHome?: boolean
    isWithinGeofence?: boolean
    geofenceRadius?: boolean
    createdAt?: boolean
  }

  export type EVVRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }
  export type EVVRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }

  export type $EVVRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EVVRecord"
    objects: {
      visit: Prisma.$HomeVisitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      recordType: $Enums.EVVRecordType
      timestamp: Date
      latitude: number
      longitude: number
      accuracy: number | null
      deviceId: string | null
      deviceType: string | null
      ipAddress: string | null
      isVerified: boolean
      verificationMethod: $Enums.EVVVerificationMethod
      verificationNotes: string | null
      distanceFromHome: number | null
      isWithinGeofence: boolean
      geofenceRadius: number
      createdAt: Date
    }, ExtArgs["result"]["eVVRecord"]>
    composites: {}
  }

  type EVVRecordGetPayload<S extends boolean | null | undefined | EVVRecordDefaultArgs> = $Result.GetResult<Prisma.$EVVRecordPayload, S>

  type EVVRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EVVRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EVVRecordCountAggregateInputType | true
    }

  export interface EVVRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EVVRecord'], meta: { name: 'EVVRecord' } }
    /**
     * Find zero or one EVVRecord that matches the filter.
     * @param {EVVRecordFindUniqueArgs} args - Arguments to find a EVVRecord
     * @example
     * // Get one EVVRecord
     * const eVVRecord = await prisma.eVVRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EVVRecordFindUniqueArgs>(args: SelectSubset<T, EVVRecordFindUniqueArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EVVRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EVVRecordFindUniqueOrThrowArgs} args - Arguments to find a EVVRecord
     * @example
     * // Get one EVVRecord
     * const eVVRecord = await prisma.eVVRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EVVRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, EVVRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EVVRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EVVRecordFindFirstArgs} args - Arguments to find a EVVRecord
     * @example
     * // Get one EVVRecord
     * const eVVRecord = await prisma.eVVRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EVVRecordFindFirstArgs>(args?: SelectSubset<T, EVVRecordFindFirstArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EVVRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EVVRecordFindFirstOrThrowArgs} args - Arguments to find a EVVRecord
     * @example
     * // Get one EVVRecord
     * const eVVRecord = await prisma.eVVRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EVVRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, EVVRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EVVRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EVVRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EVVRecords
     * const eVVRecords = await prisma.eVVRecord.findMany()
     * 
     * // Get first 10 EVVRecords
     * const eVVRecords = await prisma.eVVRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eVVRecordWithIdOnly = await prisma.eVVRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EVVRecordFindManyArgs>(args?: SelectSubset<T, EVVRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EVVRecord.
     * @param {EVVRecordCreateArgs} args - Arguments to create a EVVRecord.
     * @example
     * // Create one EVVRecord
     * const EVVRecord = await prisma.eVVRecord.create({
     *   data: {
     *     // ... data to create a EVVRecord
     *   }
     * })
     * 
     */
    create<T extends EVVRecordCreateArgs>(args: SelectSubset<T, EVVRecordCreateArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EVVRecords.
     * @param {EVVRecordCreateManyArgs} args - Arguments to create many EVVRecords.
     * @example
     * // Create many EVVRecords
     * const eVVRecord = await prisma.eVVRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EVVRecordCreateManyArgs>(args?: SelectSubset<T, EVVRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EVVRecords and returns the data saved in the database.
     * @param {EVVRecordCreateManyAndReturnArgs} args - Arguments to create many EVVRecords.
     * @example
     * // Create many EVVRecords
     * const eVVRecord = await prisma.eVVRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EVVRecords and only return the `id`
     * const eVVRecordWithIdOnly = await prisma.eVVRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EVVRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, EVVRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EVVRecord.
     * @param {EVVRecordDeleteArgs} args - Arguments to delete one EVVRecord.
     * @example
     * // Delete one EVVRecord
     * const EVVRecord = await prisma.eVVRecord.delete({
     *   where: {
     *     // ... filter to delete one EVVRecord
     *   }
     * })
     * 
     */
    delete<T extends EVVRecordDeleteArgs>(args: SelectSubset<T, EVVRecordDeleteArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EVVRecord.
     * @param {EVVRecordUpdateArgs} args - Arguments to update one EVVRecord.
     * @example
     * // Update one EVVRecord
     * const eVVRecord = await prisma.eVVRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EVVRecordUpdateArgs>(args: SelectSubset<T, EVVRecordUpdateArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EVVRecords.
     * @param {EVVRecordDeleteManyArgs} args - Arguments to filter EVVRecords to delete.
     * @example
     * // Delete a few EVVRecords
     * const { count } = await prisma.eVVRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EVVRecordDeleteManyArgs>(args?: SelectSubset<T, EVVRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EVVRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EVVRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EVVRecords
     * const eVVRecord = await prisma.eVVRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EVVRecordUpdateManyArgs>(args: SelectSubset<T, EVVRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EVVRecord.
     * @param {EVVRecordUpsertArgs} args - Arguments to update or create a EVVRecord.
     * @example
     * // Update or create a EVVRecord
     * const eVVRecord = await prisma.eVVRecord.upsert({
     *   create: {
     *     // ... data to create a EVVRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EVVRecord we want to update
     *   }
     * })
     */
    upsert<T extends EVVRecordUpsertArgs>(args: SelectSubset<T, EVVRecordUpsertArgs<ExtArgs>>): Prisma__EVVRecordClient<$Result.GetResult<Prisma.$EVVRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EVVRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EVVRecordCountArgs} args - Arguments to filter EVVRecords to count.
     * @example
     * // Count the number of EVVRecords
     * const count = await prisma.eVVRecord.count({
     *   where: {
     *     // ... the filter for the EVVRecords we want to count
     *   }
     * })
    **/
    count<T extends EVVRecordCountArgs>(
      args?: Subset<T, EVVRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EVVRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EVVRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EVVRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EVVRecordAggregateArgs>(args: Subset<T, EVVRecordAggregateArgs>): Prisma.PrismaPromise<GetEVVRecordAggregateType<T>>

    /**
     * Group by EVVRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EVVRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EVVRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EVVRecordGroupByArgs['orderBy'] }
        : { orderBy?: EVVRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EVVRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEVVRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EVVRecord model
   */
  readonly fields: EVVRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EVVRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EVVRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends HomeVisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisitDefaultArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EVVRecord model
   */ 
  interface EVVRecordFieldRefs {
    readonly id: FieldRef<"EVVRecord", 'String'>
    readonly visitId: FieldRef<"EVVRecord", 'String'>
    readonly recordType: FieldRef<"EVVRecord", 'EVVRecordType'>
    readonly timestamp: FieldRef<"EVVRecord", 'DateTime'>
    readonly latitude: FieldRef<"EVVRecord", 'Float'>
    readonly longitude: FieldRef<"EVVRecord", 'Float'>
    readonly accuracy: FieldRef<"EVVRecord", 'Float'>
    readonly deviceId: FieldRef<"EVVRecord", 'String'>
    readonly deviceType: FieldRef<"EVVRecord", 'String'>
    readonly ipAddress: FieldRef<"EVVRecord", 'String'>
    readonly isVerified: FieldRef<"EVVRecord", 'Boolean'>
    readonly verificationMethod: FieldRef<"EVVRecord", 'EVVVerificationMethod'>
    readonly verificationNotes: FieldRef<"EVVRecord", 'String'>
    readonly distanceFromHome: FieldRef<"EVVRecord", 'Float'>
    readonly isWithinGeofence: FieldRef<"EVVRecord", 'Boolean'>
    readonly geofenceRadius: FieldRef<"EVVRecord", 'Float'>
    readonly createdAt: FieldRef<"EVVRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EVVRecord findUnique
   */
  export type EVVRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * Filter, which EVVRecord to fetch.
     */
    where: EVVRecordWhereUniqueInput
  }

  /**
   * EVVRecord findUniqueOrThrow
   */
  export type EVVRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * Filter, which EVVRecord to fetch.
     */
    where: EVVRecordWhereUniqueInput
  }

  /**
   * EVVRecord findFirst
   */
  export type EVVRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * Filter, which EVVRecord to fetch.
     */
    where?: EVVRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EVVRecords to fetch.
     */
    orderBy?: EVVRecordOrderByWithRelationInput | EVVRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EVVRecords.
     */
    cursor?: EVVRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EVVRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EVVRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EVVRecords.
     */
    distinct?: EVVRecordScalarFieldEnum | EVVRecordScalarFieldEnum[]
  }

  /**
   * EVVRecord findFirstOrThrow
   */
  export type EVVRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * Filter, which EVVRecord to fetch.
     */
    where?: EVVRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EVVRecords to fetch.
     */
    orderBy?: EVVRecordOrderByWithRelationInput | EVVRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EVVRecords.
     */
    cursor?: EVVRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EVVRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EVVRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EVVRecords.
     */
    distinct?: EVVRecordScalarFieldEnum | EVVRecordScalarFieldEnum[]
  }

  /**
   * EVVRecord findMany
   */
  export type EVVRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * Filter, which EVVRecords to fetch.
     */
    where?: EVVRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EVVRecords to fetch.
     */
    orderBy?: EVVRecordOrderByWithRelationInput | EVVRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EVVRecords.
     */
    cursor?: EVVRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EVVRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EVVRecords.
     */
    skip?: number
    distinct?: EVVRecordScalarFieldEnum | EVVRecordScalarFieldEnum[]
  }

  /**
   * EVVRecord create
   */
  export type EVVRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a EVVRecord.
     */
    data: XOR<EVVRecordCreateInput, EVVRecordUncheckedCreateInput>
  }

  /**
   * EVVRecord createMany
   */
  export type EVVRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EVVRecords.
     */
    data: EVVRecordCreateManyInput | EVVRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EVVRecord createManyAndReturn
   */
  export type EVVRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EVVRecords.
     */
    data: EVVRecordCreateManyInput | EVVRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EVVRecord update
   */
  export type EVVRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a EVVRecord.
     */
    data: XOR<EVVRecordUpdateInput, EVVRecordUncheckedUpdateInput>
    /**
     * Choose, which EVVRecord to update.
     */
    where: EVVRecordWhereUniqueInput
  }

  /**
   * EVVRecord updateMany
   */
  export type EVVRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EVVRecords.
     */
    data: XOR<EVVRecordUpdateManyMutationInput, EVVRecordUncheckedUpdateManyInput>
    /**
     * Filter which EVVRecords to update
     */
    where?: EVVRecordWhereInput
  }

  /**
   * EVVRecord upsert
   */
  export type EVVRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the EVVRecord to update in case it exists.
     */
    where: EVVRecordWhereUniqueInput
    /**
     * In case the EVVRecord found by the `where` argument doesn't exist, create a new EVVRecord with this data.
     */
    create: XOR<EVVRecordCreateInput, EVVRecordUncheckedCreateInput>
    /**
     * In case the EVVRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EVVRecordUpdateInput, EVVRecordUncheckedUpdateInput>
  }

  /**
   * EVVRecord delete
   */
  export type EVVRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
    /**
     * Filter which EVVRecord to delete.
     */
    where: EVVRecordWhereUniqueInput
  }

  /**
   * EVVRecord deleteMany
   */
  export type EVVRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EVVRecords to delete
     */
    where?: EVVRecordWhereInput
  }

  /**
   * EVVRecord without action
   */
  export type EVVRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EVVRecord
     */
    select?: EVVRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EVVRecordInclude<ExtArgs> | null
  }


  /**
   * Model TimeEntry
   */

  export type AggregateTimeEntry = {
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  export type TimeEntryAvgAggregateOutputType = {
    duration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type TimeEntrySumAggregateOutputType = {
    duration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type TimeEntryMinAggregateOutputType = {
    id: string | null
    caregiverId: string | null
    visitId: string | null
    entryType: $Enums.TimeEntryType | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    status: $Enums.ApprovalStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryMaxAggregateOutputType = {
    id: string | null
    caregiverId: string | null
    visitId: string | null
    entryType: $Enums.TimeEntryType | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    status: $Enums.ApprovalStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryCountAggregateOutputType = {
    id: number
    caregiverId: number
    visitId: number
    entryType: number
    startTime: number
    endTime: number
    duration: number
    startLatitude: number
    startLongitude: number
    endLatitude: number
    endLongitude: number
    status: number
    approvedBy: number
    approvedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeEntryAvgAggregateInputType = {
    duration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type TimeEntrySumAggregateInputType = {
    duration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type TimeEntryMinAggregateInputType = {
    id?: true
    caregiverId?: true
    visitId?: true
    entryType?: true
    startTime?: true
    endTime?: true
    duration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryMaxAggregateInputType = {
    id?: true
    caregiverId?: true
    visitId?: true
    entryType?: true
    startTime?: true
    endTime?: true
    duration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryCountAggregateInputType = {
    id?: true
    caregiverId?: true
    visitId?: true
    entryType?: true
    startTime?: true
    endTime?: true
    duration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntry to aggregate.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeEntries
    **/
    _count?: true | TimeEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeEntryMaxAggregateInputType
  }

  export type GetTimeEntryAggregateType<T extends TimeEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeEntry[P]>
      : GetScalarType<T[P], AggregateTimeEntry[P]>
  }




  export type TimeEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithAggregationInput | TimeEntryOrderByWithAggregationInput[]
    by: TimeEntryScalarFieldEnum[] | TimeEntryScalarFieldEnum
    having?: TimeEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeEntryCountAggregateInputType | true
    _avg?: TimeEntryAvgAggregateInputType
    _sum?: TimeEntrySumAggregateInputType
    _min?: TimeEntryMinAggregateInputType
    _max?: TimeEntryMaxAggregateInputType
  }

  export type TimeEntryGroupByOutputType = {
    id: string
    caregiverId: string
    visitId: string | null
    entryType: $Enums.TimeEntryType
    startTime: Date
    endTime: Date | null
    duration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    status: $Enums.ApprovalStatus
    approvedBy: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  type GetTimeEntryGroupByPayload<T extends TimeEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
            : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
        }
      >
    >


  export type TimeEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caregiverId?: boolean
    visitId?: boolean
    entryType?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caregiverId?: boolean
    visitId?: boolean
    entryType?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectScalar = {
    id?: boolean
    caregiverId?: boolean
    visitId?: boolean
    entryType?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }
  export type TimeEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }

  export type $TimeEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeEntry"
    objects: {
      caregiver: Prisma.$CaregiverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caregiverId: string
      visitId: string | null
      entryType: $Enums.TimeEntryType
      startTime: Date
      endTime: Date | null
      duration: number | null
      startLatitude: number | null
      startLongitude: number | null
      endLatitude: number | null
      endLongitude: number | null
      status: $Enums.ApprovalStatus
      approvedBy: string | null
      approvedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeEntry"]>
    composites: {}
  }

  type TimeEntryGetPayload<S extends boolean | null | undefined | TimeEntryDefaultArgs> = $Result.GetResult<Prisma.$TimeEntryPayload, S>

  type TimeEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeEntryCountAggregateInputType | true
    }

  export interface TimeEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeEntry'], meta: { name: 'TimeEntry' } }
    /**
     * Find zero or one TimeEntry that matches the filter.
     * @param {TimeEntryFindUniqueArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeEntryFindUniqueArgs>(args: SelectSubset<T, TimeEntryFindUniqueArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeEntryFindUniqueOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeEntryFindFirstArgs>(args?: SelectSubset<T, TimeEntryFindFirstArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany()
     * 
     * // Get first 10 TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeEntryFindManyArgs>(args?: SelectSubset<T, TimeEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeEntry.
     * @param {TimeEntryCreateArgs} args - Arguments to create a TimeEntry.
     * @example
     * // Create one TimeEntry
     * const TimeEntry = await prisma.timeEntry.create({
     *   data: {
     *     // ... data to create a TimeEntry
     *   }
     * })
     * 
     */
    create<T extends TimeEntryCreateArgs>(args: SelectSubset<T, TimeEntryCreateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeEntries.
     * @param {TimeEntryCreateManyArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeEntryCreateManyArgs>(args?: SelectSubset<T, TimeEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeEntries and returns the data saved in the database.
     * @param {TimeEntryCreateManyAndReturnArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeEntries and only return the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimeEntry.
     * @param {TimeEntryDeleteArgs} args - Arguments to delete one TimeEntry.
     * @example
     * // Delete one TimeEntry
     * const TimeEntry = await prisma.timeEntry.delete({
     *   where: {
     *     // ... filter to delete one TimeEntry
     *   }
     * })
     * 
     */
    delete<T extends TimeEntryDeleteArgs>(args: SelectSubset<T, TimeEntryDeleteArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeEntry.
     * @param {TimeEntryUpdateArgs} args - Arguments to update one TimeEntry.
     * @example
     * // Update one TimeEntry
     * const timeEntry = await prisma.timeEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeEntryUpdateArgs>(args: SelectSubset<T, TimeEntryUpdateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeEntries.
     * @param {TimeEntryDeleteManyArgs} args - Arguments to filter TimeEntries to delete.
     * @example
     * // Delete a few TimeEntries
     * const { count } = await prisma.timeEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeEntryDeleteManyArgs>(args?: SelectSubset<T, TimeEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeEntries
     * const timeEntry = await prisma.timeEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeEntryUpdateManyArgs>(args: SelectSubset<T, TimeEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeEntry.
     * @param {TimeEntryUpsertArgs} args - Arguments to update or create a TimeEntry.
     * @example
     * // Update or create a TimeEntry
     * const timeEntry = await prisma.timeEntry.upsert({
     *   create: {
     *     // ... data to create a TimeEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeEntry we want to update
     *   }
     * })
     */
    upsert<T extends TimeEntryUpsertArgs>(args: SelectSubset<T, TimeEntryUpsertArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryCountArgs} args - Arguments to filter TimeEntries to count.
     * @example
     * // Count the number of TimeEntries
     * const count = await prisma.timeEntry.count({
     *   where: {
     *     // ... the filter for the TimeEntries we want to count
     *   }
     * })
    **/
    count<T extends TimeEntryCountArgs>(
      args?: Subset<T, TimeEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeEntryAggregateArgs>(args: Subset<T, TimeEntryAggregateArgs>): Prisma.PrismaPromise<GetTimeEntryAggregateType<T>>

    /**
     * Group by TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeEntryGroupByArgs['orderBy'] }
        : { orderBy?: TimeEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeEntry model
   */
  readonly fields: TimeEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caregiver<T extends CaregiverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaregiverDefaultArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeEntry model
   */ 
  interface TimeEntryFieldRefs {
    readonly id: FieldRef<"TimeEntry", 'String'>
    readonly caregiverId: FieldRef<"TimeEntry", 'String'>
    readonly visitId: FieldRef<"TimeEntry", 'String'>
    readonly entryType: FieldRef<"TimeEntry", 'TimeEntryType'>
    readonly startTime: FieldRef<"TimeEntry", 'DateTime'>
    readonly endTime: FieldRef<"TimeEntry", 'DateTime'>
    readonly duration: FieldRef<"TimeEntry", 'Int'>
    readonly startLatitude: FieldRef<"TimeEntry", 'Float'>
    readonly startLongitude: FieldRef<"TimeEntry", 'Float'>
    readonly endLatitude: FieldRef<"TimeEntry", 'Float'>
    readonly endLongitude: FieldRef<"TimeEntry", 'Float'>
    readonly status: FieldRef<"TimeEntry", 'ApprovalStatus'>
    readonly approvedBy: FieldRef<"TimeEntry", 'String'>
    readonly approvedAt: FieldRef<"TimeEntry", 'DateTime'>
    readonly notes: FieldRef<"TimeEntry", 'String'>
    readonly createdAt: FieldRef<"TimeEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeEntry findUnique
   */
  export type TimeEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findUniqueOrThrow
   */
  export type TimeEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findFirst
   */
  export type TimeEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findFirstOrThrow
   */
  export type TimeEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findMany
   */
  export type TimeEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntries to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry create
   */
  export type TimeEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeEntry.
     */
    data: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
  }

  /**
   * TimeEntry createMany
   */
  export type TimeEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeEntry createManyAndReturn
   */
  export type TimeEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeEntry update
   */
  export type TimeEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeEntry.
     */
    data: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
    /**
     * Choose, which TimeEntry to update.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry updateMany
   */
  export type TimeEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeEntries.
     */
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyInput>
    /**
     * Filter which TimeEntries to update
     */
    where?: TimeEntryWhereInput
  }

  /**
   * TimeEntry upsert
   */
  export type TimeEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeEntry to update in case it exists.
     */
    where: TimeEntryWhereUniqueInput
    /**
     * In case the TimeEntry found by the `where` argument doesn't exist, create a new TimeEntry with this data.
     */
    create: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
    /**
     * In case the TimeEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
  }

  /**
   * TimeEntry delete
   */
  export type TimeEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter which TimeEntry to delete.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry deleteMany
   */
  export type TimeEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntries to delete
     */
    where?: TimeEntryWhereInput
  }

  /**
   * TimeEntry without action
   */
  export type TimeEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
  }


  /**
   * Model MileageEntry
   */

  export type AggregateMileageEntry = {
    _count: MileageEntryCountAggregateOutputType | null
    _avg: MileageEntryAvgAggregateOutputType | null
    _sum: MileageEntrySumAggregateOutputType | null
    _min: MileageEntryMinAggregateOutputType | null
    _max: MileageEntryMaxAggregateOutputType | null
  }

  export type MileageEntryAvgAggregateOutputType = {
    distance: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    ratePerMile: number | null
    totalAmount: number | null
  }

  export type MileageEntrySumAggregateOutputType = {
    distance: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    ratePerMile: number | null
    totalAmount: number | null
  }

  export type MileageEntryMinAggregateOutputType = {
    id: string | null
    caregiverId: string | null
    date: Date | null
    startAddress: string | null
    endAddress: string | null
    distance: number | null
    purpose: string | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    ratePerMile: number | null
    totalAmount: number | null
    status: $Enums.ApprovalStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MileageEntryMaxAggregateOutputType = {
    id: string | null
    caregiverId: string | null
    date: Date | null
    startAddress: string | null
    endAddress: string | null
    distance: number | null
    purpose: string | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    ratePerMile: number | null
    totalAmount: number | null
    status: $Enums.ApprovalStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MileageEntryCountAggregateOutputType = {
    id: number
    caregiverId: number
    date: number
    startAddress: number
    endAddress: number
    distance: number
    purpose: number
    startLatitude: number
    startLongitude: number
    endLatitude: number
    endLongitude: number
    routeData: number
    ratePerMile: number
    totalAmount: number
    status: number
    approvedBy: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MileageEntryAvgAggregateInputType = {
    distance?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    ratePerMile?: true
    totalAmount?: true
  }

  export type MileageEntrySumAggregateInputType = {
    distance?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    ratePerMile?: true
    totalAmount?: true
  }

  export type MileageEntryMinAggregateInputType = {
    id?: true
    caregiverId?: true
    date?: true
    startAddress?: true
    endAddress?: true
    distance?: true
    purpose?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    ratePerMile?: true
    totalAmount?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MileageEntryMaxAggregateInputType = {
    id?: true
    caregiverId?: true
    date?: true
    startAddress?: true
    endAddress?: true
    distance?: true
    purpose?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    ratePerMile?: true
    totalAmount?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MileageEntryCountAggregateInputType = {
    id?: true
    caregiverId?: true
    date?: true
    startAddress?: true
    endAddress?: true
    distance?: true
    purpose?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    routeData?: true
    ratePerMile?: true
    totalAmount?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MileageEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MileageEntry to aggregate.
     */
    where?: MileageEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MileageEntries to fetch.
     */
    orderBy?: MileageEntryOrderByWithRelationInput | MileageEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MileageEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MileageEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MileageEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MileageEntries
    **/
    _count?: true | MileageEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MileageEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MileageEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MileageEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MileageEntryMaxAggregateInputType
  }

  export type GetMileageEntryAggregateType<T extends MileageEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateMileageEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMileageEntry[P]>
      : GetScalarType<T[P], AggregateMileageEntry[P]>
  }




  export type MileageEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MileageEntryWhereInput
    orderBy?: MileageEntryOrderByWithAggregationInput | MileageEntryOrderByWithAggregationInput[]
    by: MileageEntryScalarFieldEnum[] | MileageEntryScalarFieldEnum
    having?: MileageEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MileageEntryCountAggregateInputType | true
    _avg?: MileageEntryAvgAggregateInputType
    _sum?: MileageEntrySumAggregateInputType
    _min?: MileageEntryMinAggregateInputType
    _max?: MileageEntryMaxAggregateInputType
  }

  export type MileageEntryGroupByOutputType = {
    id: string
    caregiverId: string
    date: Date
    startAddress: string
    endAddress: string
    distance: number
    purpose: string | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    routeData: JsonValue | null
    ratePerMile: number
    totalAmount: number | null
    status: $Enums.ApprovalStatus
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MileageEntryCountAggregateOutputType | null
    _avg: MileageEntryAvgAggregateOutputType | null
    _sum: MileageEntrySumAggregateOutputType | null
    _min: MileageEntryMinAggregateOutputType | null
    _max: MileageEntryMaxAggregateOutputType | null
  }

  type GetMileageEntryGroupByPayload<T extends MileageEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MileageEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MileageEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MileageEntryGroupByOutputType[P]>
            : GetScalarType<T[P], MileageEntryGroupByOutputType[P]>
        }
      >
    >


  export type MileageEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caregiverId?: boolean
    date?: boolean
    startAddress?: boolean
    endAddress?: boolean
    distance?: boolean
    purpose?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    routeData?: boolean
    ratePerMile?: boolean
    totalAmount?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mileageEntry"]>

  export type MileageEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caregiverId?: boolean
    date?: boolean
    startAddress?: boolean
    endAddress?: boolean
    distance?: boolean
    purpose?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    routeData?: boolean
    ratePerMile?: boolean
    totalAmount?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mileageEntry"]>

  export type MileageEntrySelectScalar = {
    id?: boolean
    caregiverId?: boolean
    date?: boolean
    startAddress?: boolean
    endAddress?: boolean
    distance?: boolean
    purpose?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    routeData?: boolean
    ratePerMile?: boolean
    totalAmount?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MileageEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }
  export type MileageEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregiver?: boolean | CaregiverDefaultArgs<ExtArgs>
  }

  export type $MileageEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MileageEntry"
    objects: {
      caregiver: Prisma.$CaregiverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caregiverId: string
      date: Date
      startAddress: string
      endAddress: string
      distance: number
      purpose: string | null
      startLatitude: number | null
      startLongitude: number | null
      endLatitude: number | null
      endLongitude: number | null
      routeData: Prisma.JsonValue | null
      ratePerMile: number
      totalAmount: number | null
      status: $Enums.ApprovalStatus
      approvedBy: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mileageEntry"]>
    composites: {}
  }

  type MileageEntryGetPayload<S extends boolean | null | undefined | MileageEntryDefaultArgs> = $Result.GetResult<Prisma.$MileageEntryPayload, S>

  type MileageEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MileageEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MileageEntryCountAggregateInputType | true
    }

  export interface MileageEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MileageEntry'], meta: { name: 'MileageEntry' } }
    /**
     * Find zero or one MileageEntry that matches the filter.
     * @param {MileageEntryFindUniqueArgs} args - Arguments to find a MileageEntry
     * @example
     * // Get one MileageEntry
     * const mileageEntry = await prisma.mileageEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MileageEntryFindUniqueArgs>(args: SelectSubset<T, MileageEntryFindUniqueArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MileageEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MileageEntryFindUniqueOrThrowArgs} args - Arguments to find a MileageEntry
     * @example
     * // Get one MileageEntry
     * const mileageEntry = await prisma.mileageEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MileageEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, MileageEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MileageEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MileageEntryFindFirstArgs} args - Arguments to find a MileageEntry
     * @example
     * // Get one MileageEntry
     * const mileageEntry = await prisma.mileageEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MileageEntryFindFirstArgs>(args?: SelectSubset<T, MileageEntryFindFirstArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MileageEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MileageEntryFindFirstOrThrowArgs} args - Arguments to find a MileageEntry
     * @example
     * // Get one MileageEntry
     * const mileageEntry = await prisma.mileageEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MileageEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, MileageEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MileageEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MileageEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MileageEntries
     * const mileageEntries = await prisma.mileageEntry.findMany()
     * 
     * // Get first 10 MileageEntries
     * const mileageEntries = await prisma.mileageEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mileageEntryWithIdOnly = await prisma.mileageEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MileageEntryFindManyArgs>(args?: SelectSubset<T, MileageEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MileageEntry.
     * @param {MileageEntryCreateArgs} args - Arguments to create a MileageEntry.
     * @example
     * // Create one MileageEntry
     * const MileageEntry = await prisma.mileageEntry.create({
     *   data: {
     *     // ... data to create a MileageEntry
     *   }
     * })
     * 
     */
    create<T extends MileageEntryCreateArgs>(args: SelectSubset<T, MileageEntryCreateArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MileageEntries.
     * @param {MileageEntryCreateManyArgs} args - Arguments to create many MileageEntries.
     * @example
     * // Create many MileageEntries
     * const mileageEntry = await prisma.mileageEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MileageEntryCreateManyArgs>(args?: SelectSubset<T, MileageEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MileageEntries and returns the data saved in the database.
     * @param {MileageEntryCreateManyAndReturnArgs} args - Arguments to create many MileageEntries.
     * @example
     * // Create many MileageEntries
     * const mileageEntry = await prisma.mileageEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MileageEntries and only return the `id`
     * const mileageEntryWithIdOnly = await prisma.mileageEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MileageEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, MileageEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MileageEntry.
     * @param {MileageEntryDeleteArgs} args - Arguments to delete one MileageEntry.
     * @example
     * // Delete one MileageEntry
     * const MileageEntry = await prisma.mileageEntry.delete({
     *   where: {
     *     // ... filter to delete one MileageEntry
     *   }
     * })
     * 
     */
    delete<T extends MileageEntryDeleteArgs>(args: SelectSubset<T, MileageEntryDeleteArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MileageEntry.
     * @param {MileageEntryUpdateArgs} args - Arguments to update one MileageEntry.
     * @example
     * // Update one MileageEntry
     * const mileageEntry = await prisma.mileageEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MileageEntryUpdateArgs>(args: SelectSubset<T, MileageEntryUpdateArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MileageEntries.
     * @param {MileageEntryDeleteManyArgs} args - Arguments to filter MileageEntries to delete.
     * @example
     * // Delete a few MileageEntries
     * const { count } = await prisma.mileageEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MileageEntryDeleteManyArgs>(args?: SelectSubset<T, MileageEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MileageEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MileageEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MileageEntries
     * const mileageEntry = await prisma.mileageEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MileageEntryUpdateManyArgs>(args: SelectSubset<T, MileageEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MileageEntry.
     * @param {MileageEntryUpsertArgs} args - Arguments to update or create a MileageEntry.
     * @example
     * // Update or create a MileageEntry
     * const mileageEntry = await prisma.mileageEntry.upsert({
     *   create: {
     *     // ... data to create a MileageEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MileageEntry we want to update
     *   }
     * })
     */
    upsert<T extends MileageEntryUpsertArgs>(args: SelectSubset<T, MileageEntryUpsertArgs<ExtArgs>>): Prisma__MileageEntryClient<$Result.GetResult<Prisma.$MileageEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MileageEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MileageEntryCountArgs} args - Arguments to filter MileageEntries to count.
     * @example
     * // Count the number of MileageEntries
     * const count = await prisma.mileageEntry.count({
     *   where: {
     *     // ... the filter for the MileageEntries we want to count
     *   }
     * })
    **/
    count<T extends MileageEntryCountArgs>(
      args?: Subset<T, MileageEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MileageEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MileageEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MileageEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MileageEntryAggregateArgs>(args: Subset<T, MileageEntryAggregateArgs>): Prisma.PrismaPromise<GetMileageEntryAggregateType<T>>

    /**
     * Group by MileageEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MileageEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MileageEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MileageEntryGroupByArgs['orderBy'] }
        : { orderBy?: MileageEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MileageEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMileageEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MileageEntry model
   */
  readonly fields: MileageEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MileageEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MileageEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caregiver<T extends CaregiverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaregiverDefaultArgs<ExtArgs>>): Prisma__CaregiverClient<$Result.GetResult<Prisma.$CaregiverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MileageEntry model
   */ 
  interface MileageEntryFieldRefs {
    readonly id: FieldRef<"MileageEntry", 'String'>
    readonly caregiverId: FieldRef<"MileageEntry", 'String'>
    readonly date: FieldRef<"MileageEntry", 'DateTime'>
    readonly startAddress: FieldRef<"MileageEntry", 'String'>
    readonly endAddress: FieldRef<"MileageEntry", 'String'>
    readonly distance: FieldRef<"MileageEntry", 'Float'>
    readonly purpose: FieldRef<"MileageEntry", 'String'>
    readonly startLatitude: FieldRef<"MileageEntry", 'Float'>
    readonly startLongitude: FieldRef<"MileageEntry", 'Float'>
    readonly endLatitude: FieldRef<"MileageEntry", 'Float'>
    readonly endLongitude: FieldRef<"MileageEntry", 'Float'>
    readonly routeData: FieldRef<"MileageEntry", 'Json'>
    readonly ratePerMile: FieldRef<"MileageEntry", 'Float'>
    readonly totalAmount: FieldRef<"MileageEntry", 'Float'>
    readonly status: FieldRef<"MileageEntry", 'ApprovalStatus'>
    readonly approvedBy: FieldRef<"MileageEntry", 'String'>
    readonly approvedAt: FieldRef<"MileageEntry", 'DateTime'>
    readonly createdAt: FieldRef<"MileageEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"MileageEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MileageEntry findUnique
   */
  export type MileageEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * Filter, which MileageEntry to fetch.
     */
    where: MileageEntryWhereUniqueInput
  }

  /**
   * MileageEntry findUniqueOrThrow
   */
  export type MileageEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * Filter, which MileageEntry to fetch.
     */
    where: MileageEntryWhereUniqueInput
  }

  /**
   * MileageEntry findFirst
   */
  export type MileageEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * Filter, which MileageEntry to fetch.
     */
    where?: MileageEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MileageEntries to fetch.
     */
    orderBy?: MileageEntryOrderByWithRelationInput | MileageEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MileageEntries.
     */
    cursor?: MileageEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MileageEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MileageEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MileageEntries.
     */
    distinct?: MileageEntryScalarFieldEnum | MileageEntryScalarFieldEnum[]
  }

  /**
   * MileageEntry findFirstOrThrow
   */
  export type MileageEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * Filter, which MileageEntry to fetch.
     */
    where?: MileageEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MileageEntries to fetch.
     */
    orderBy?: MileageEntryOrderByWithRelationInput | MileageEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MileageEntries.
     */
    cursor?: MileageEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MileageEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MileageEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MileageEntries.
     */
    distinct?: MileageEntryScalarFieldEnum | MileageEntryScalarFieldEnum[]
  }

  /**
   * MileageEntry findMany
   */
  export type MileageEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * Filter, which MileageEntries to fetch.
     */
    where?: MileageEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MileageEntries to fetch.
     */
    orderBy?: MileageEntryOrderByWithRelationInput | MileageEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MileageEntries.
     */
    cursor?: MileageEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MileageEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MileageEntries.
     */
    skip?: number
    distinct?: MileageEntryScalarFieldEnum | MileageEntryScalarFieldEnum[]
  }

  /**
   * MileageEntry create
   */
  export type MileageEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a MileageEntry.
     */
    data: XOR<MileageEntryCreateInput, MileageEntryUncheckedCreateInput>
  }

  /**
   * MileageEntry createMany
   */
  export type MileageEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MileageEntries.
     */
    data: MileageEntryCreateManyInput | MileageEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MileageEntry createManyAndReturn
   */
  export type MileageEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MileageEntries.
     */
    data: MileageEntryCreateManyInput | MileageEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MileageEntry update
   */
  export type MileageEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a MileageEntry.
     */
    data: XOR<MileageEntryUpdateInput, MileageEntryUncheckedUpdateInput>
    /**
     * Choose, which MileageEntry to update.
     */
    where: MileageEntryWhereUniqueInput
  }

  /**
   * MileageEntry updateMany
   */
  export type MileageEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MileageEntries.
     */
    data: XOR<MileageEntryUpdateManyMutationInput, MileageEntryUncheckedUpdateManyInput>
    /**
     * Filter which MileageEntries to update
     */
    where?: MileageEntryWhereInput
  }

  /**
   * MileageEntry upsert
   */
  export type MileageEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the MileageEntry to update in case it exists.
     */
    where: MileageEntryWhereUniqueInput
    /**
     * In case the MileageEntry found by the `where` argument doesn't exist, create a new MileageEntry with this data.
     */
    create: XOR<MileageEntryCreateInput, MileageEntryUncheckedCreateInput>
    /**
     * In case the MileageEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MileageEntryUpdateInput, MileageEntryUncheckedUpdateInput>
  }

  /**
   * MileageEntry delete
   */
  export type MileageEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
    /**
     * Filter which MileageEntry to delete.
     */
    where: MileageEntryWhereUniqueInput
  }

  /**
   * MileageEntry deleteMany
   */
  export type MileageEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MileageEntries to delete
     */
    where?: MileageEntryWhereInput
  }

  /**
   * MileageEntry without action
   */
  export type MileageEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MileageEntry
     */
    select?: MileageEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MileageEntryInclude<ExtArgs> | null
  }


  /**
   * Model HomeAssessment
   */

  export type AggregateHomeAssessment = {
    _count: HomeAssessmentCountAggregateOutputType | null
    _avg: HomeAssessmentAvgAggregateOutputType | null
    _sum: HomeAssessmentSumAggregateOutputType | null
    _min: HomeAssessmentMinAggregateOutputType | null
    _max: HomeAssessmentMaxAggregateOutputType | null
  }

  export type HomeAssessmentAvgAggregateOutputType = {
    safetyScore: number | null
    cleanlinessScore: number | null
  }

  export type HomeAssessmentSumAggregateOutputType = {
    safetyScore: number | null
    cleanlinessScore: number | null
  }

  export type HomeAssessmentMinAggregateOutputType = {
    id: string | null
    patientHomeId: string | null
    assessorId: string | null
    assessmentDate: Date | null
    safetyScore: number | null
    fallRisk: $Enums.RiskLevel | null
    fireRisk: $Enums.RiskLevel | null
    infectionRisk: $Enums.RiskLevel | null
    cleanlinessScore: number | null
    adequateLighting: boolean | null
    adequateVentilation: boolean | null
    workingUtilities: boolean | null
    bathroomAccessible: boolean | null
    bedroomAccessible: boolean | null
    kitchenAccessible: boolean | null
    followUpDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomeAssessmentMaxAggregateOutputType = {
    id: string | null
    patientHomeId: string | null
    assessorId: string | null
    assessmentDate: Date | null
    safetyScore: number | null
    fallRisk: $Enums.RiskLevel | null
    fireRisk: $Enums.RiskLevel | null
    infectionRisk: $Enums.RiskLevel | null
    cleanlinessScore: number | null
    adequateLighting: boolean | null
    adequateVentilation: boolean | null
    workingUtilities: boolean | null
    bathroomAccessible: boolean | null
    bedroomAccessible: boolean | null
    kitchenAccessible: boolean | null
    followUpDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomeAssessmentCountAggregateOutputType = {
    id: number
    patientHomeId: number
    assessorId: number
    assessmentDate: number
    safetyScore: number
    fallRisk: number
    fireRisk: number
    infectionRisk: number
    cleanlinessScore: number
    adequateLighting: number
    adequateVentilation: number
    workingUtilities: number
    bathroomAccessible: number
    bedroomAccessible: number
    kitchenAccessible: number
    recommendations: number
    requiredEquipment: number
    followUpDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HomeAssessmentAvgAggregateInputType = {
    safetyScore?: true
    cleanlinessScore?: true
  }

  export type HomeAssessmentSumAggregateInputType = {
    safetyScore?: true
    cleanlinessScore?: true
  }

  export type HomeAssessmentMinAggregateInputType = {
    id?: true
    patientHomeId?: true
    assessorId?: true
    assessmentDate?: true
    safetyScore?: true
    fallRisk?: true
    fireRisk?: true
    infectionRisk?: true
    cleanlinessScore?: true
    adequateLighting?: true
    adequateVentilation?: true
    workingUtilities?: true
    bathroomAccessible?: true
    bedroomAccessible?: true
    kitchenAccessible?: true
    followUpDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomeAssessmentMaxAggregateInputType = {
    id?: true
    patientHomeId?: true
    assessorId?: true
    assessmentDate?: true
    safetyScore?: true
    fallRisk?: true
    fireRisk?: true
    infectionRisk?: true
    cleanlinessScore?: true
    adequateLighting?: true
    adequateVentilation?: true
    workingUtilities?: true
    bathroomAccessible?: true
    bedroomAccessible?: true
    kitchenAccessible?: true
    followUpDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomeAssessmentCountAggregateInputType = {
    id?: true
    patientHomeId?: true
    assessorId?: true
    assessmentDate?: true
    safetyScore?: true
    fallRisk?: true
    fireRisk?: true
    infectionRisk?: true
    cleanlinessScore?: true
    adequateLighting?: true
    adequateVentilation?: true
    workingUtilities?: true
    bathroomAccessible?: true
    bedroomAccessible?: true
    kitchenAccessible?: true
    recommendations?: true
    requiredEquipment?: true
    followUpDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HomeAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeAssessment to aggregate.
     */
    where?: HomeAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeAssessments to fetch.
     */
    orderBy?: HomeAssessmentOrderByWithRelationInput | HomeAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeAssessments
    **/
    _count?: true | HomeAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HomeAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HomeAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeAssessmentMaxAggregateInputType
  }

  export type GetHomeAssessmentAggregateType<T extends HomeAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeAssessment[P]>
      : GetScalarType<T[P], AggregateHomeAssessment[P]>
  }




  export type HomeAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeAssessmentWhereInput
    orderBy?: HomeAssessmentOrderByWithAggregationInput | HomeAssessmentOrderByWithAggregationInput[]
    by: HomeAssessmentScalarFieldEnum[] | HomeAssessmentScalarFieldEnum
    having?: HomeAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeAssessmentCountAggregateInputType | true
    _avg?: HomeAssessmentAvgAggregateInputType
    _sum?: HomeAssessmentSumAggregateInputType
    _min?: HomeAssessmentMinAggregateInputType
    _max?: HomeAssessmentMaxAggregateInputType
  }

  export type HomeAssessmentGroupByOutputType = {
    id: string
    patientHomeId: string
    assessorId: string
    assessmentDate: Date
    safetyScore: number | null
    fallRisk: $Enums.RiskLevel
    fireRisk: $Enums.RiskLevel
    infectionRisk: $Enums.RiskLevel
    cleanlinessScore: number | null
    adequateLighting: boolean
    adequateVentilation: boolean
    workingUtilities: boolean
    bathroomAccessible: boolean
    bedroomAccessible: boolean
    kitchenAccessible: boolean
    recommendations: JsonValue | null
    requiredEquipment: string[]
    followUpDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: HomeAssessmentCountAggregateOutputType | null
    _avg: HomeAssessmentAvgAggregateOutputType | null
    _sum: HomeAssessmentSumAggregateOutputType | null
    _min: HomeAssessmentMinAggregateOutputType | null
    _max: HomeAssessmentMaxAggregateOutputType | null
  }

  type GetHomeAssessmentGroupByPayload<T extends HomeAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], HomeAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type HomeAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientHomeId?: boolean
    assessorId?: boolean
    assessmentDate?: boolean
    safetyScore?: boolean
    fallRisk?: boolean
    fireRisk?: boolean
    infectionRisk?: boolean
    cleanlinessScore?: boolean
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: boolean
    requiredEquipment?: boolean
    followUpDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeAssessment"]>

  export type HomeAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientHomeId?: boolean
    assessorId?: boolean
    assessmentDate?: boolean
    safetyScore?: boolean
    fallRisk?: boolean
    fireRisk?: boolean
    infectionRisk?: boolean
    cleanlinessScore?: boolean
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: boolean
    requiredEquipment?: boolean
    followUpDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeAssessment"]>

  export type HomeAssessmentSelectScalar = {
    id?: boolean
    patientHomeId?: boolean
    assessorId?: boolean
    assessmentDate?: boolean
    safetyScore?: boolean
    fallRisk?: boolean
    fireRisk?: boolean
    infectionRisk?: boolean
    cleanlinessScore?: boolean
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: boolean
    requiredEquipment?: boolean
    followUpDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HomeAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }
  export type HomeAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }

  export type $HomeAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomeAssessment"
    objects: {
      patientHome: Prisma.$PatientHomePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientHomeId: string
      assessorId: string
      assessmentDate: Date
      safetyScore: number | null
      fallRisk: $Enums.RiskLevel
      fireRisk: $Enums.RiskLevel
      infectionRisk: $Enums.RiskLevel
      cleanlinessScore: number | null
      adequateLighting: boolean
      adequateVentilation: boolean
      workingUtilities: boolean
      bathroomAccessible: boolean
      bedroomAccessible: boolean
      kitchenAccessible: boolean
      recommendations: Prisma.JsonValue | null
      requiredEquipment: string[]
      followUpDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["homeAssessment"]>
    composites: {}
  }

  type HomeAssessmentGetPayload<S extends boolean | null | undefined | HomeAssessmentDefaultArgs> = $Result.GetResult<Prisma.$HomeAssessmentPayload, S>

  type HomeAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HomeAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HomeAssessmentCountAggregateInputType | true
    }

  export interface HomeAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomeAssessment'], meta: { name: 'HomeAssessment' } }
    /**
     * Find zero or one HomeAssessment that matches the filter.
     * @param {HomeAssessmentFindUniqueArgs} args - Arguments to find a HomeAssessment
     * @example
     * // Get one HomeAssessment
     * const homeAssessment = await prisma.homeAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomeAssessmentFindUniqueArgs>(args: SelectSubset<T, HomeAssessmentFindUniqueArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HomeAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HomeAssessmentFindUniqueOrThrowArgs} args - Arguments to find a HomeAssessment
     * @example
     * // Get one HomeAssessment
     * const homeAssessment = await prisma.homeAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomeAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, HomeAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HomeAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeAssessmentFindFirstArgs} args - Arguments to find a HomeAssessment
     * @example
     * // Get one HomeAssessment
     * const homeAssessment = await prisma.homeAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomeAssessmentFindFirstArgs>(args?: SelectSubset<T, HomeAssessmentFindFirstArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HomeAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeAssessmentFindFirstOrThrowArgs} args - Arguments to find a HomeAssessment
     * @example
     * // Get one HomeAssessment
     * const homeAssessment = await prisma.homeAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomeAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, HomeAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HomeAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeAssessments
     * const homeAssessments = await prisma.homeAssessment.findMany()
     * 
     * // Get first 10 HomeAssessments
     * const homeAssessments = await prisma.homeAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeAssessmentWithIdOnly = await prisma.homeAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomeAssessmentFindManyArgs>(args?: SelectSubset<T, HomeAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HomeAssessment.
     * @param {HomeAssessmentCreateArgs} args - Arguments to create a HomeAssessment.
     * @example
     * // Create one HomeAssessment
     * const HomeAssessment = await prisma.homeAssessment.create({
     *   data: {
     *     // ... data to create a HomeAssessment
     *   }
     * })
     * 
     */
    create<T extends HomeAssessmentCreateArgs>(args: SelectSubset<T, HomeAssessmentCreateArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HomeAssessments.
     * @param {HomeAssessmentCreateManyArgs} args - Arguments to create many HomeAssessments.
     * @example
     * // Create many HomeAssessments
     * const homeAssessment = await prisma.homeAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomeAssessmentCreateManyArgs>(args?: SelectSubset<T, HomeAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomeAssessments and returns the data saved in the database.
     * @param {HomeAssessmentCreateManyAndReturnArgs} args - Arguments to create many HomeAssessments.
     * @example
     * // Create many HomeAssessments
     * const homeAssessment = await prisma.homeAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomeAssessments and only return the `id`
     * const homeAssessmentWithIdOnly = await prisma.homeAssessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomeAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, HomeAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HomeAssessment.
     * @param {HomeAssessmentDeleteArgs} args - Arguments to delete one HomeAssessment.
     * @example
     * // Delete one HomeAssessment
     * const HomeAssessment = await prisma.homeAssessment.delete({
     *   where: {
     *     // ... filter to delete one HomeAssessment
     *   }
     * })
     * 
     */
    delete<T extends HomeAssessmentDeleteArgs>(args: SelectSubset<T, HomeAssessmentDeleteArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HomeAssessment.
     * @param {HomeAssessmentUpdateArgs} args - Arguments to update one HomeAssessment.
     * @example
     * // Update one HomeAssessment
     * const homeAssessment = await prisma.homeAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomeAssessmentUpdateArgs>(args: SelectSubset<T, HomeAssessmentUpdateArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HomeAssessments.
     * @param {HomeAssessmentDeleteManyArgs} args - Arguments to filter HomeAssessments to delete.
     * @example
     * // Delete a few HomeAssessments
     * const { count } = await prisma.homeAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomeAssessmentDeleteManyArgs>(args?: SelectSubset<T, HomeAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeAssessments
     * const homeAssessment = await prisma.homeAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomeAssessmentUpdateManyArgs>(args: SelectSubset<T, HomeAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomeAssessment.
     * @param {HomeAssessmentUpsertArgs} args - Arguments to update or create a HomeAssessment.
     * @example
     * // Update or create a HomeAssessment
     * const homeAssessment = await prisma.homeAssessment.upsert({
     *   create: {
     *     // ... data to create a HomeAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeAssessment we want to update
     *   }
     * })
     */
    upsert<T extends HomeAssessmentUpsertArgs>(args: SelectSubset<T, HomeAssessmentUpsertArgs<ExtArgs>>): Prisma__HomeAssessmentClient<$Result.GetResult<Prisma.$HomeAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HomeAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeAssessmentCountArgs} args - Arguments to filter HomeAssessments to count.
     * @example
     * // Count the number of HomeAssessments
     * const count = await prisma.homeAssessment.count({
     *   where: {
     *     // ... the filter for the HomeAssessments we want to count
     *   }
     * })
    **/
    count<T extends HomeAssessmentCountArgs>(
      args?: Subset<T, HomeAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeAssessmentAggregateArgs>(args: Subset<T, HomeAssessmentAggregateArgs>): Prisma.PrismaPromise<GetHomeAssessmentAggregateType<T>>

    /**
     * Group by HomeAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: HomeAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomeAssessment model
   */
  readonly fields: HomeAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomeAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientHome<T extends PatientHomeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientHomeDefaultArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomeAssessment model
   */ 
  interface HomeAssessmentFieldRefs {
    readonly id: FieldRef<"HomeAssessment", 'String'>
    readonly patientHomeId: FieldRef<"HomeAssessment", 'String'>
    readonly assessorId: FieldRef<"HomeAssessment", 'String'>
    readonly assessmentDate: FieldRef<"HomeAssessment", 'DateTime'>
    readonly safetyScore: FieldRef<"HomeAssessment", 'Int'>
    readonly fallRisk: FieldRef<"HomeAssessment", 'RiskLevel'>
    readonly fireRisk: FieldRef<"HomeAssessment", 'RiskLevel'>
    readonly infectionRisk: FieldRef<"HomeAssessment", 'RiskLevel'>
    readonly cleanlinessScore: FieldRef<"HomeAssessment", 'Int'>
    readonly adequateLighting: FieldRef<"HomeAssessment", 'Boolean'>
    readonly adequateVentilation: FieldRef<"HomeAssessment", 'Boolean'>
    readonly workingUtilities: FieldRef<"HomeAssessment", 'Boolean'>
    readonly bathroomAccessible: FieldRef<"HomeAssessment", 'Boolean'>
    readonly bedroomAccessible: FieldRef<"HomeAssessment", 'Boolean'>
    readonly kitchenAccessible: FieldRef<"HomeAssessment", 'Boolean'>
    readonly recommendations: FieldRef<"HomeAssessment", 'Json'>
    readonly requiredEquipment: FieldRef<"HomeAssessment", 'String[]'>
    readonly followUpDate: FieldRef<"HomeAssessment", 'DateTime'>
    readonly notes: FieldRef<"HomeAssessment", 'String'>
    readonly createdAt: FieldRef<"HomeAssessment", 'DateTime'>
    readonly updatedAt: FieldRef<"HomeAssessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HomeAssessment findUnique
   */
  export type HomeAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which HomeAssessment to fetch.
     */
    where: HomeAssessmentWhereUniqueInput
  }

  /**
   * HomeAssessment findUniqueOrThrow
   */
  export type HomeAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which HomeAssessment to fetch.
     */
    where: HomeAssessmentWhereUniqueInput
  }

  /**
   * HomeAssessment findFirst
   */
  export type HomeAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which HomeAssessment to fetch.
     */
    where?: HomeAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeAssessments to fetch.
     */
    orderBy?: HomeAssessmentOrderByWithRelationInput | HomeAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeAssessments.
     */
    cursor?: HomeAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeAssessments.
     */
    distinct?: HomeAssessmentScalarFieldEnum | HomeAssessmentScalarFieldEnum[]
  }

  /**
   * HomeAssessment findFirstOrThrow
   */
  export type HomeAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which HomeAssessment to fetch.
     */
    where?: HomeAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeAssessments to fetch.
     */
    orderBy?: HomeAssessmentOrderByWithRelationInput | HomeAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeAssessments.
     */
    cursor?: HomeAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeAssessments.
     */
    distinct?: HomeAssessmentScalarFieldEnum | HomeAssessmentScalarFieldEnum[]
  }

  /**
   * HomeAssessment findMany
   */
  export type HomeAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which HomeAssessments to fetch.
     */
    where?: HomeAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeAssessments to fetch.
     */
    orderBy?: HomeAssessmentOrderByWithRelationInput | HomeAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeAssessments.
     */
    cursor?: HomeAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeAssessments.
     */
    skip?: number
    distinct?: HomeAssessmentScalarFieldEnum | HomeAssessmentScalarFieldEnum[]
  }

  /**
   * HomeAssessment create
   */
  export type HomeAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a HomeAssessment.
     */
    data: XOR<HomeAssessmentCreateInput, HomeAssessmentUncheckedCreateInput>
  }

  /**
   * HomeAssessment createMany
   */
  export type HomeAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomeAssessments.
     */
    data: HomeAssessmentCreateManyInput | HomeAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomeAssessment createManyAndReturn
   */
  export type HomeAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HomeAssessments.
     */
    data: HomeAssessmentCreateManyInput | HomeAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomeAssessment update
   */
  export type HomeAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a HomeAssessment.
     */
    data: XOR<HomeAssessmentUpdateInput, HomeAssessmentUncheckedUpdateInput>
    /**
     * Choose, which HomeAssessment to update.
     */
    where: HomeAssessmentWhereUniqueInput
  }

  /**
   * HomeAssessment updateMany
   */
  export type HomeAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomeAssessments.
     */
    data: XOR<HomeAssessmentUpdateManyMutationInput, HomeAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which HomeAssessments to update
     */
    where?: HomeAssessmentWhereInput
  }

  /**
   * HomeAssessment upsert
   */
  export type HomeAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the HomeAssessment to update in case it exists.
     */
    where: HomeAssessmentWhereUniqueInput
    /**
     * In case the HomeAssessment found by the `where` argument doesn't exist, create a new HomeAssessment with this data.
     */
    create: XOR<HomeAssessmentCreateInput, HomeAssessmentUncheckedCreateInput>
    /**
     * In case the HomeAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeAssessmentUpdateInput, HomeAssessmentUncheckedUpdateInput>
  }

  /**
   * HomeAssessment delete
   */
  export type HomeAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
    /**
     * Filter which HomeAssessment to delete.
     */
    where: HomeAssessmentWhereUniqueInput
  }

  /**
   * HomeAssessment deleteMany
   */
  export type HomeAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeAssessments to delete
     */
    where?: HomeAssessmentWhereInput
  }

  /**
   * HomeAssessment without action
   */
  export type HomeAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeAssessment
     */
    select?: HomeAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model MedicationAdministration
   */

  export type AggregateMedicationAdministration = {
    _count: MedicationAdministrationCountAggregateOutputType | null
    _min: MedicationAdministrationMinAggregateOutputType | null
    _max: MedicationAdministrationMaxAggregateOutputType | null
  }

  export type MedicationAdministrationMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    medicationName: string | null
    dosage: string | null
    route: $Enums.MedicationRoute | null
    scheduledTime: Date | null
    administeredTime: Date | null
    status: $Enums.MedicationStatus | null
    refusedReason: string | null
    notes: string | null
    administeredBy: string | null
    witnessedBy: string | null
    medicationBarcode: string | null
    patientBarcode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationAdministrationMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    medicationName: string | null
    dosage: string | null
    route: $Enums.MedicationRoute | null
    scheduledTime: Date | null
    administeredTime: Date | null
    status: $Enums.MedicationStatus | null
    refusedReason: string | null
    notes: string | null
    administeredBy: string | null
    witnessedBy: string | null
    medicationBarcode: string | null
    patientBarcode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationAdministrationCountAggregateOutputType = {
    id: number
    visitId: number
    medicationName: number
    dosage: number
    route: number
    scheduledTime: number
    administeredTime: number
    status: number
    refusedReason: number
    notes: number
    administeredBy: number
    witnessedBy: number
    medicationBarcode: number
    patientBarcode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationAdministrationMinAggregateInputType = {
    id?: true
    visitId?: true
    medicationName?: true
    dosage?: true
    route?: true
    scheduledTime?: true
    administeredTime?: true
    status?: true
    refusedReason?: true
    notes?: true
    administeredBy?: true
    witnessedBy?: true
    medicationBarcode?: true
    patientBarcode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationAdministrationMaxAggregateInputType = {
    id?: true
    visitId?: true
    medicationName?: true
    dosage?: true
    route?: true
    scheduledTime?: true
    administeredTime?: true
    status?: true
    refusedReason?: true
    notes?: true
    administeredBy?: true
    witnessedBy?: true
    medicationBarcode?: true
    patientBarcode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationAdministrationCountAggregateInputType = {
    id?: true
    visitId?: true
    medicationName?: true
    dosage?: true
    route?: true
    scheduledTime?: true
    administeredTime?: true
    status?: true
    refusedReason?: true
    notes?: true
    administeredBy?: true
    witnessedBy?: true
    medicationBarcode?: true
    patientBarcode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationAdministrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationAdministration to aggregate.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicationAdministrations
    **/
    _count?: true | MedicationAdministrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationAdministrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationAdministrationMaxAggregateInputType
  }

  export type GetMedicationAdministrationAggregateType<T extends MedicationAdministrationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicationAdministration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicationAdministration[P]>
      : GetScalarType<T[P], AggregateMedicationAdministration[P]>
  }




  export type MedicationAdministrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationAdministrationWhereInput
    orderBy?: MedicationAdministrationOrderByWithAggregationInput | MedicationAdministrationOrderByWithAggregationInput[]
    by: MedicationAdministrationScalarFieldEnum[] | MedicationAdministrationScalarFieldEnum
    having?: MedicationAdministrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationAdministrationCountAggregateInputType | true
    _min?: MedicationAdministrationMinAggregateInputType
    _max?: MedicationAdministrationMaxAggregateInputType
  }

  export type MedicationAdministrationGroupByOutputType = {
    id: string
    visitId: string
    medicationName: string
    dosage: string
    route: $Enums.MedicationRoute
    scheduledTime: Date
    administeredTime: Date | null
    status: $Enums.MedicationStatus
    refusedReason: string | null
    notes: string | null
    administeredBy: string | null
    witnessedBy: string | null
    medicationBarcode: string | null
    patientBarcode: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicationAdministrationCountAggregateOutputType | null
    _min: MedicationAdministrationMinAggregateOutputType | null
    _max: MedicationAdministrationMaxAggregateOutputType | null
  }

  type GetMedicationAdministrationGroupByPayload<T extends MedicationAdministrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationAdministrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationAdministrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationAdministrationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationAdministrationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationAdministrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    medicationName?: boolean
    dosage?: boolean
    route?: boolean
    scheduledTime?: boolean
    administeredTime?: boolean
    status?: boolean
    refusedReason?: boolean
    notes?: boolean
    administeredBy?: boolean
    witnessedBy?: boolean
    medicationBarcode?: boolean
    patientBarcode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationAdministration"]>

  export type MedicationAdministrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    medicationName?: boolean
    dosage?: boolean
    route?: boolean
    scheduledTime?: boolean
    administeredTime?: boolean
    status?: boolean
    refusedReason?: boolean
    notes?: boolean
    administeredBy?: boolean
    witnessedBy?: boolean
    medicationBarcode?: boolean
    patientBarcode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationAdministration"]>

  export type MedicationAdministrationSelectScalar = {
    id?: boolean
    visitId?: boolean
    medicationName?: boolean
    dosage?: boolean
    route?: boolean
    scheduledTime?: boolean
    administeredTime?: boolean
    status?: boolean
    refusedReason?: boolean
    notes?: boolean
    administeredBy?: boolean
    witnessedBy?: boolean
    medicationBarcode?: boolean
    patientBarcode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicationAdministrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }
  export type MedicationAdministrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }

  export type $MedicationAdministrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicationAdministration"
    objects: {
      visit: Prisma.$HomeVisitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      medicationName: string
      dosage: string
      route: $Enums.MedicationRoute
      scheduledTime: Date
      administeredTime: Date | null
      status: $Enums.MedicationStatus
      refusedReason: string | null
      notes: string | null
      administeredBy: string | null
      witnessedBy: string | null
      medicationBarcode: string | null
      patientBarcode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicationAdministration"]>
    composites: {}
  }

  type MedicationAdministrationGetPayload<S extends boolean | null | undefined | MedicationAdministrationDefaultArgs> = $Result.GetResult<Prisma.$MedicationAdministrationPayload, S>

  type MedicationAdministrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicationAdministrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicationAdministrationCountAggregateInputType | true
    }

  export interface MedicationAdministrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicationAdministration'], meta: { name: 'MedicationAdministration' } }
    /**
     * Find zero or one MedicationAdministration that matches the filter.
     * @param {MedicationAdministrationFindUniqueArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationAdministrationFindUniqueArgs>(args: SelectSubset<T, MedicationAdministrationFindUniqueArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MedicationAdministration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicationAdministrationFindUniqueOrThrowArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationAdministrationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationAdministrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MedicationAdministration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationFindFirstArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationAdministrationFindFirstArgs>(args?: SelectSubset<T, MedicationAdministrationFindFirstArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MedicationAdministration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationFindFirstOrThrowArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationAdministrationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationAdministrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MedicationAdministrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicationAdministrations
     * const medicationAdministrations = await prisma.medicationAdministration.findMany()
     * 
     * // Get first 10 MedicationAdministrations
     * const medicationAdministrations = await prisma.medicationAdministration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationAdministrationWithIdOnly = await prisma.medicationAdministration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationAdministrationFindManyArgs>(args?: SelectSubset<T, MedicationAdministrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MedicationAdministration.
     * @param {MedicationAdministrationCreateArgs} args - Arguments to create a MedicationAdministration.
     * @example
     * // Create one MedicationAdministration
     * const MedicationAdministration = await prisma.medicationAdministration.create({
     *   data: {
     *     // ... data to create a MedicationAdministration
     *   }
     * })
     * 
     */
    create<T extends MedicationAdministrationCreateArgs>(args: SelectSubset<T, MedicationAdministrationCreateArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MedicationAdministrations.
     * @param {MedicationAdministrationCreateManyArgs} args - Arguments to create many MedicationAdministrations.
     * @example
     * // Create many MedicationAdministrations
     * const medicationAdministration = await prisma.medicationAdministration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationAdministrationCreateManyArgs>(args?: SelectSubset<T, MedicationAdministrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicationAdministrations and returns the data saved in the database.
     * @param {MedicationAdministrationCreateManyAndReturnArgs} args - Arguments to create many MedicationAdministrations.
     * @example
     * // Create many MedicationAdministrations
     * const medicationAdministration = await prisma.medicationAdministration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicationAdministrations and only return the `id`
     * const medicationAdministrationWithIdOnly = await prisma.medicationAdministration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationAdministrationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationAdministrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MedicationAdministration.
     * @param {MedicationAdministrationDeleteArgs} args - Arguments to delete one MedicationAdministration.
     * @example
     * // Delete one MedicationAdministration
     * const MedicationAdministration = await prisma.medicationAdministration.delete({
     *   where: {
     *     // ... filter to delete one MedicationAdministration
     *   }
     * })
     * 
     */
    delete<T extends MedicationAdministrationDeleteArgs>(args: SelectSubset<T, MedicationAdministrationDeleteArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MedicationAdministration.
     * @param {MedicationAdministrationUpdateArgs} args - Arguments to update one MedicationAdministration.
     * @example
     * // Update one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationAdministrationUpdateArgs>(args: SelectSubset<T, MedicationAdministrationUpdateArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MedicationAdministrations.
     * @param {MedicationAdministrationDeleteManyArgs} args - Arguments to filter MedicationAdministrations to delete.
     * @example
     * // Delete a few MedicationAdministrations
     * const { count } = await prisma.medicationAdministration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationAdministrationDeleteManyArgs>(args?: SelectSubset<T, MedicationAdministrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationAdministrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicationAdministrations
     * const medicationAdministration = await prisma.medicationAdministration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationAdministrationUpdateManyArgs>(args: SelectSubset<T, MedicationAdministrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicationAdministration.
     * @param {MedicationAdministrationUpsertArgs} args - Arguments to update or create a MedicationAdministration.
     * @example
     * // Update or create a MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.upsert({
     *   create: {
     *     // ... data to create a MedicationAdministration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicationAdministration we want to update
     *   }
     * })
     */
    upsert<T extends MedicationAdministrationUpsertArgs>(args: SelectSubset<T, MedicationAdministrationUpsertArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MedicationAdministrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationCountArgs} args - Arguments to filter MedicationAdministrations to count.
     * @example
     * // Count the number of MedicationAdministrations
     * const count = await prisma.medicationAdministration.count({
     *   where: {
     *     // ... the filter for the MedicationAdministrations we want to count
     *   }
     * })
    **/
    count<T extends MedicationAdministrationCountArgs>(
      args?: Subset<T, MedicationAdministrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationAdministrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicationAdministration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAdministrationAggregateArgs>(args: Subset<T, MedicationAdministrationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAdministrationAggregateType<T>>

    /**
     * Group by MedicationAdministration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationAdministrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationAdministrationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationAdministrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationAdministrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationAdministrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicationAdministration model
   */
  readonly fields: MedicationAdministrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicationAdministration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationAdministrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends HomeVisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisitDefaultArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicationAdministration model
   */ 
  interface MedicationAdministrationFieldRefs {
    readonly id: FieldRef<"MedicationAdministration", 'String'>
    readonly visitId: FieldRef<"MedicationAdministration", 'String'>
    readonly medicationName: FieldRef<"MedicationAdministration", 'String'>
    readonly dosage: FieldRef<"MedicationAdministration", 'String'>
    readonly route: FieldRef<"MedicationAdministration", 'MedicationRoute'>
    readonly scheduledTime: FieldRef<"MedicationAdministration", 'DateTime'>
    readonly administeredTime: FieldRef<"MedicationAdministration", 'DateTime'>
    readonly status: FieldRef<"MedicationAdministration", 'MedicationStatus'>
    readonly refusedReason: FieldRef<"MedicationAdministration", 'String'>
    readonly notes: FieldRef<"MedicationAdministration", 'String'>
    readonly administeredBy: FieldRef<"MedicationAdministration", 'String'>
    readonly witnessedBy: FieldRef<"MedicationAdministration", 'String'>
    readonly medicationBarcode: FieldRef<"MedicationAdministration", 'String'>
    readonly patientBarcode: FieldRef<"MedicationAdministration", 'String'>
    readonly createdAt: FieldRef<"MedicationAdministration", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicationAdministration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicationAdministration findUnique
   */
  export type MedicationAdministrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration findUniqueOrThrow
   */
  export type MedicationAdministrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration findFirst
   */
  export type MedicationAdministrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationAdministrations.
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationAdministrations.
     */
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * MedicationAdministration findFirstOrThrow
   */
  export type MedicationAdministrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationAdministrations.
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationAdministrations.
     */
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * MedicationAdministration findMany
   */
  export type MedicationAdministrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministrations to fetch.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicationAdministrations.
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * MedicationAdministration create
   */
  export type MedicationAdministrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicationAdministration.
     */
    data: XOR<MedicationAdministrationCreateInput, MedicationAdministrationUncheckedCreateInput>
  }

  /**
   * MedicationAdministration createMany
   */
  export type MedicationAdministrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicationAdministrations.
     */
    data: MedicationAdministrationCreateManyInput | MedicationAdministrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicationAdministration createManyAndReturn
   */
  export type MedicationAdministrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MedicationAdministrations.
     */
    data: MedicationAdministrationCreateManyInput | MedicationAdministrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationAdministration update
   */
  export type MedicationAdministrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicationAdministration.
     */
    data: XOR<MedicationAdministrationUpdateInput, MedicationAdministrationUncheckedUpdateInput>
    /**
     * Choose, which MedicationAdministration to update.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration updateMany
   */
  export type MedicationAdministrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicationAdministrations.
     */
    data: XOR<MedicationAdministrationUpdateManyMutationInput, MedicationAdministrationUncheckedUpdateManyInput>
    /**
     * Filter which MedicationAdministrations to update
     */
    where?: MedicationAdministrationWhereInput
  }

  /**
   * MedicationAdministration upsert
   */
  export type MedicationAdministrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicationAdministration to update in case it exists.
     */
    where: MedicationAdministrationWhereUniqueInput
    /**
     * In case the MedicationAdministration found by the `where` argument doesn't exist, create a new MedicationAdministration with this data.
     */
    create: XOR<MedicationAdministrationCreateInput, MedicationAdministrationUncheckedCreateInput>
    /**
     * In case the MedicationAdministration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationAdministrationUpdateInput, MedicationAdministrationUncheckedUpdateInput>
  }

  /**
   * MedicationAdministration delete
   */
  export type MedicationAdministrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter which MedicationAdministration to delete.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration deleteMany
   */
  export type MedicationAdministrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationAdministrations to delete
     */
    where?: MedicationAdministrationWhereInput
  }

  /**
   * MedicationAdministration without action
   */
  export type MedicationAdministrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    patientId: string | null
    caregiverId: string | null
    incidentType: $Enums.IncidentType | null
    severity: $Enums.IncidentSeverity | null
    occurredAt: Date | null
    location: string | null
    description: string | null
    immediateAction: string | null
    witnessNames: string | null
    fallType: $Enums.FallType | null
    injuryOccurred: boolean | null
    injuryDescription: string | null
    medicalAttentionRequired: boolean | null
    emergencyServicesNotified: boolean | null
    status: $Enums.IncidentStatus | null
    investigatedBy: string | null
    investigatedAt: Date | null
    rootCause: string | null
    preventiveMeasures: string | null
    familyNotified: boolean | null
    physicianNotified: boolean | null
    supervisorNotified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    patientId: string | null
    caregiverId: string | null
    incidentType: $Enums.IncidentType | null
    severity: $Enums.IncidentSeverity | null
    occurredAt: Date | null
    location: string | null
    description: string | null
    immediateAction: string | null
    witnessNames: string | null
    fallType: $Enums.FallType | null
    injuryOccurred: boolean | null
    injuryDescription: string | null
    medicalAttentionRequired: boolean | null
    emergencyServicesNotified: boolean | null
    status: $Enums.IncidentStatus | null
    investigatedBy: string | null
    investigatedAt: Date | null
    rootCause: string | null
    preventiveMeasures: string | null
    familyNotified: boolean | null
    physicianNotified: boolean | null
    supervisorNotified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    visitId: number
    patientId: number
    caregiverId: number
    incidentType: number
    severity: number
    occurredAt: number
    location: number
    description: number
    immediateAction: number
    witnessNames: number
    fallType: number
    injuryOccurred: number
    injuryDescription: number
    medicalAttentionRequired: number
    emergencyServicesNotified: number
    status: number
    investigatedBy: number
    investigatedAt: number
    rootCause: number
    preventiveMeasures: number
    familyNotified: number
    physicianNotified: number
    supervisorNotified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentMinAggregateInputType = {
    id?: true
    visitId?: true
    patientId?: true
    caregiverId?: true
    incidentType?: true
    severity?: true
    occurredAt?: true
    location?: true
    description?: true
    immediateAction?: true
    witnessNames?: true
    fallType?: true
    injuryOccurred?: true
    injuryDescription?: true
    medicalAttentionRequired?: true
    emergencyServicesNotified?: true
    status?: true
    investigatedBy?: true
    investigatedAt?: true
    rootCause?: true
    preventiveMeasures?: true
    familyNotified?: true
    physicianNotified?: true
    supervisorNotified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    visitId?: true
    patientId?: true
    caregiverId?: true
    incidentType?: true
    severity?: true
    occurredAt?: true
    location?: true
    description?: true
    immediateAction?: true
    witnessNames?: true
    fallType?: true
    injuryOccurred?: true
    injuryDescription?: true
    medicalAttentionRequired?: true
    emergencyServicesNotified?: true
    status?: true
    investigatedBy?: true
    investigatedAt?: true
    rootCause?: true
    preventiveMeasures?: true
    familyNotified?: true
    physicianNotified?: true
    supervisorNotified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    visitId?: true
    patientId?: true
    caregiverId?: true
    incidentType?: true
    severity?: true
    occurredAt?: true
    location?: true
    description?: true
    immediateAction?: true
    witnessNames?: true
    fallType?: true
    injuryOccurred?: true
    injuryDescription?: true
    medicalAttentionRequired?: true
    emergencyServicesNotified?: true
    status?: true
    investigatedBy?: true
    investigatedAt?: true
    rootCause?: true
    preventiveMeasures?: true
    familyNotified?: true
    physicianNotified?: true
    supervisorNotified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    visitId: string | null
    patientId: string
    caregiverId: string | null
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    occurredAt: Date
    location: string | null
    description: string
    immediateAction: string | null
    witnessNames: string | null
    fallType: $Enums.FallType | null
    injuryOccurred: boolean
    injuryDescription: string | null
    medicalAttentionRequired: boolean
    emergencyServicesNotified: boolean
    status: $Enums.IncidentStatus
    investigatedBy: string | null
    investigatedAt: Date | null
    rootCause: string | null
    preventiveMeasures: string | null
    familyNotified: boolean
    physicianNotified: boolean
    supervisorNotified: boolean
    createdAt: Date
    updatedAt: Date
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    patientId?: boolean
    caregiverId?: boolean
    incidentType?: boolean
    severity?: boolean
    occurredAt?: boolean
    location?: boolean
    description?: boolean
    immediateAction?: boolean
    witnessNames?: boolean
    fallType?: boolean
    injuryOccurred?: boolean
    injuryDescription?: boolean
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: boolean
    investigatedBy?: boolean
    investigatedAt?: boolean
    rootCause?: boolean
    preventiveMeasures?: boolean
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | Incident$visitArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    patientId?: boolean
    caregiverId?: boolean
    incidentType?: boolean
    severity?: boolean
    occurredAt?: boolean
    location?: boolean
    description?: boolean
    immediateAction?: boolean
    witnessNames?: boolean
    fallType?: boolean
    injuryOccurred?: boolean
    injuryDescription?: boolean
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: boolean
    investigatedBy?: boolean
    investigatedAt?: boolean
    rootCause?: boolean
    preventiveMeasures?: boolean
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | Incident$visitArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    visitId?: boolean
    patientId?: boolean
    caregiverId?: boolean
    incidentType?: boolean
    severity?: boolean
    occurredAt?: boolean
    location?: boolean
    description?: boolean
    immediateAction?: boolean
    witnessNames?: boolean
    fallType?: boolean
    injuryOccurred?: boolean
    injuryDescription?: boolean
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: boolean
    investigatedBy?: boolean
    investigatedAt?: boolean
    rootCause?: boolean
    preventiveMeasures?: boolean
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | Incident$visitArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | Incident$visitArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      visit: Prisma.$HomeVisitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string | null
      patientId: string
      caregiverId: string | null
      incidentType: $Enums.IncidentType
      severity: $Enums.IncidentSeverity
      occurredAt: Date
      location: string | null
      description: string
      immediateAction: string | null
      witnessNames: string | null
      fallType: $Enums.FallType | null
      injuryOccurred: boolean
      injuryDescription: string | null
      medicalAttentionRequired: boolean
      emergencyServicesNotified: boolean
      status: $Enums.IncidentStatus
      investigatedBy: string | null
      investigatedAt: Date | null
      rootCause: string | null
      preventiveMeasures: string | null
      familyNotified: boolean
      physicianNotified: boolean
      supervisorNotified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends Incident$visitArgs<ExtArgs> = {}>(args?: Subset<T, Incident$visitArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */ 
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly visitId: FieldRef<"Incident", 'String'>
    readonly patientId: FieldRef<"Incident", 'String'>
    readonly caregiverId: FieldRef<"Incident", 'String'>
    readonly incidentType: FieldRef<"Incident", 'IncidentType'>
    readonly severity: FieldRef<"Incident", 'IncidentSeverity'>
    readonly occurredAt: FieldRef<"Incident", 'DateTime'>
    readonly location: FieldRef<"Incident", 'String'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly immediateAction: FieldRef<"Incident", 'String'>
    readonly witnessNames: FieldRef<"Incident", 'String'>
    readonly fallType: FieldRef<"Incident", 'FallType'>
    readonly injuryOccurred: FieldRef<"Incident", 'Boolean'>
    readonly injuryDescription: FieldRef<"Incident", 'String'>
    readonly medicalAttentionRequired: FieldRef<"Incident", 'Boolean'>
    readonly emergencyServicesNotified: FieldRef<"Incident", 'Boolean'>
    readonly status: FieldRef<"Incident", 'IncidentStatus'>
    readonly investigatedBy: FieldRef<"Incident", 'String'>
    readonly investigatedAt: FieldRef<"Incident", 'DateTime'>
    readonly rootCause: FieldRef<"Incident", 'String'>
    readonly preventiveMeasures: FieldRef<"Incident", 'String'>
    readonly familyNotified: FieldRef<"Incident", 'Boolean'>
    readonly physicianNotified: FieldRef<"Incident", 'Boolean'>
    readonly supervisorNotified: FieldRef<"Incident", 'Boolean'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident.visit
   */
  export type Incident$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeVisit
     */
    select?: HomeVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeVisitInclude<ExtArgs> | null
    where?: HomeVisitWhereInput
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model VisitDocumentation
   */

  export type AggregateVisitDocumentation = {
    _count: VisitDocumentationCountAggregateOutputType | null
    _avg: VisitDocumentationAvgAggregateOutputType | null
    _sum: VisitDocumentationSumAggregateOutputType | null
    _min: VisitDocumentationMinAggregateOutputType | null
    _max: VisitDocumentationMaxAggregateOutputType | null
  }

  export type VisitDocumentationAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type VisitDocumentationSumAggregateOutputType = {
    fileSize: number | null
  }

  export type VisitDocumentationMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    documentType: $Enums.DocumentType | null
    title: string | null
    content: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitDocumentationMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    documentType: $Enums.DocumentType | null
    title: string | null
    content: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitDocumentationCountAggregateOutputType = {
    id: number
    visitId: number
    documentType: number
    title: number
    content: number
    fileUrl: number
    fileType: number
    fileSize: number
    assessmentData: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitDocumentationAvgAggregateInputType = {
    fileSize?: true
  }

  export type VisitDocumentationSumAggregateInputType = {
    fileSize?: true
  }

  export type VisitDocumentationMinAggregateInputType = {
    id?: true
    visitId?: true
    documentType?: true
    title?: true
    content?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitDocumentationMaxAggregateInputType = {
    id?: true
    visitId?: true
    documentType?: true
    title?: true
    content?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitDocumentationCountAggregateInputType = {
    id?: true
    visitId?: true
    documentType?: true
    title?: true
    content?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    assessmentData?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitDocumentationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitDocumentation to aggregate.
     */
    where?: VisitDocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDocumentations to fetch.
     */
    orderBy?: VisitDocumentationOrderByWithRelationInput | VisitDocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitDocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDocumentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDocumentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitDocumentations
    **/
    _count?: true | VisitDocumentationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitDocumentationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitDocumentationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitDocumentationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitDocumentationMaxAggregateInputType
  }

  export type GetVisitDocumentationAggregateType<T extends VisitDocumentationAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitDocumentation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitDocumentation[P]>
      : GetScalarType<T[P], AggregateVisitDocumentation[P]>
  }




  export type VisitDocumentationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitDocumentationWhereInput
    orderBy?: VisitDocumentationOrderByWithAggregationInput | VisitDocumentationOrderByWithAggregationInput[]
    by: VisitDocumentationScalarFieldEnum[] | VisitDocumentationScalarFieldEnum
    having?: VisitDocumentationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitDocumentationCountAggregateInputType | true
    _avg?: VisitDocumentationAvgAggregateInputType
    _sum?: VisitDocumentationSumAggregateInputType
    _min?: VisitDocumentationMinAggregateInputType
    _max?: VisitDocumentationMaxAggregateInputType
  }

  export type VisitDocumentationGroupByOutputType = {
    id: string
    visitId: string
    documentType: $Enums.DocumentType
    title: string
    content: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    assessmentData: JsonValue | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: VisitDocumentationCountAggregateOutputType | null
    _avg: VisitDocumentationAvgAggregateOutputType | null
    _sum: VisitDocumentationSumAggregateOutputType | null
    _min: VisitDocumentationMinAggregateOutputType | null
    _max: VisitDocumentationMaxAggregateOutputType | null
  }

  type GetVisitDocumentationGroupByPayload<T extends VisitDocumentationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitDocumentationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitDocumentationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitDocumentationGroupByOutputType[P]>
            : GetScalarType<T[P], VisitDocumentationGroupByOutputType[P]>
        }
      >
    >


  export type VisitDocumentationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    documentType?: boolean
    title?: boolean
    content?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    assessmentData?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitDocumentation"]>

  export type VisitDocumentationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    documentType?: boolean
    title?: boolean
    content?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    assessmentData?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitDocumentation"]>

  export type VisitDocumentationSelectScalar = {
    id?: boolean
    visitId?: boolean
    documentType?: boolean
    title?: boolean
    content?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    assessmentData?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitDocumentationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }
  export type VisitDocumentationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | HomeVisitDefaultArgs<ExtArgs>
  }

  export type $VisitDocumentationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitDocumentation"
    objects: {
      visit: Prisma.$HomeVisitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      documentType: $Enums.DocumentType
      title: string
      content: string | null
      fileUrl: string | null
      fileType: string | null
      fileSize: number | null
      assessmentData: Prisma.JsonValue | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitDocumentation"]>
    composites: {}
  }

  type VisitDocumentationGetPayload<S extends boolean | null | undefined | VisitDocumentationDefaultArgs> = $Result.GetResult<Prisma.$VisitDocumentationPayload, S>

  type VisitDocumentationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitDocumentationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitDocumentationCountAggregateInputType | true
    }

  export interface VisitDocumentationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitDocumentation'], meta: { name: 'VisitDocumentation' } }
    /**
     * Find zero or one VisitDocumentation that matches the filter.
     * @param {VisitDocumentationFindUniqueArgs} args - Arguments to find a VisitDocumentation
     * @example
     * // Get one VisitDocumentation
     * const visitDocumentation = await prisma.visitDocumentation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitDocumentationFindUniqueArgs>(args: SelectSubset<T, VisitDocumentationFindUniqueArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitDocumentation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitDocumentationFindUniqueOrThrowArgs} args - Arguments to find a VisitDocumentation
     * @example
     * // Get one VisitDocumentation
     * const visitDocumentation = await prisma.visitDocumentation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitDocumentationFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitDocumentationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitDocumentation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDocumentationFindFirstArgs} args - Arguments to find a VisitDocumentation
     * @example
     * // Get one VisitDocumentation
     * const visitDocumentation = await prisma.visitDocumentation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitDocumentationFindFirstArgs>(args?: SelectSubset<T, VisitDocumentationFindFirstArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitDocumentation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDocumentationFindFirstOrThrowArgs} args - Arguments to find a VisitDocumentation
     * @example
     * // Get one VisitDocumentation
     * const visitDocumentation = await prisma.visitDocumentation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitDocumentationFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitDocumentationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitDocumentations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDocumentationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitDocumentations
     * const visitDocumentations = await prisma.visitDocumentation.findMany()
     * 
     * // Get first 10 VisitDocumentations
     * const visitDocumentations = await prisma.visitDocumentation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitDocumentationWithIdOnly = await prisma.visitDocumentation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitDocumentationFindManyArgs>(args?: SelectSubset<T, VisitDocumentationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitDocumentation.
     * @param {VisitDocumentationCreateArgs} args - Arguments to create a VisitDocumentation.
     * @example
     * // Create one VisitDocumentation
     * const VisitDocumentation = await prisma.visitDocumentation.create({
     *   data: {
     *     // ... data to create a VisitDocumentation
     *   }
     * })
     * 
     */
    create<T extends VisitDocumentationCreateArgs>(args: SelectSubset<T, VisitDocumentationCreateArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitDocumentations.
     * @param {VisitDocumentationCreateManyArgs} args - Arguments to create many VisitDocumentations.
     * @example
     * // Create many VisitDocumentations
     * const visitDocumentation = await prisma.visitDocumentation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitDocumentationCreateManyArgs>(args?: SelectSubset<T, VisitDocumentationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitDocumentations and returns the data saved in the database.
     * @param {VisitDocumentationCreateManyAndReturnArgs} args - Arguments to create many VisitDocumentations.
     * @example
     * // Create many VisitDocumentations
     * const visitDocumentation = await prisma.visitDocumentation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitDocumentations and only return the `id`
     * const visitDocumentationWithIdOnly = await prisma.visitDocumentation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitDocumentationCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitDocumentationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitDocumentation.
     * @param {VisitDocumentationDeleteArgs} args - Arguments to delete one VisitDocumentation.
     * @example
     * // Delete one VisitDocumentation
     * const VisitDocumentation = await prisma.visitDocumentation.delete({
     *   where: {
     *     // ... filter to delete one VisitDocumentation
     *   }
     * })
     * 
     */
    delete<T extends VisitDocumentationDeleteArgs>(args: SelectSubset<T, VisitDocumentationDeleteArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitDocumentation.
     * @param {VisitDocumentationUpdateArgs} args - Arguments to update one VisitDocumentation.
     * @example
     * // Update one VisitDocumentation
     * const visitDocumentation = await prisma.visitDocumentation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitDocumentationUpdateArgs>(args: SelectSubset<T, VisitDocumentationUpdateArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitDocumentations.
     * @param {VisitDocumentationDeleteManyArgs} args - Arguments to filter VisitDocumentations to delete.
     * @example
     * // Delete a few VisitDocumentations
     * const { count } = await prisma.visitDocumentation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitDocumentationDeleteManyArgs>(args?: SelectSubset<T, VisitDocumentationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitDocumentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDocumentationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitDocumentations
     * const visitDocumentation = await prisma.visitDocumentation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitDocumentationUpdateManyArgs>(args: SelectSubset<T, VisitDocumentationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitDocumentation.
     * @param {VisitDocumentationUpsertArgs} args - Arguments to update or create a VisitDocumentation.
     * @example
     * // Update or create a VisitDocumentation
     * const visitDocumentation = await prisma.visitDocumentation.upsert({
     *   create: {
     *     // ... data to create a VisitDocumentation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitDocumentation we want to update
     *   }
     * })
     */
    upsert<T extends VisitDocumentationUpsertArgs>(args: SelectSubset<T, VisitDocumentationUpsertArgs<ExtArgs>>): Prisma__VisitDocumentationClient<$Result.GetResult<Prisma.$VisitDocumentationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitDocumentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDocumentationCountArgs} args - Arguments to filter VisitDocumentations to count.
     * @example
     * // Count the number of VisitDocumentations
     * const count = await prisma.visitDocumentation.count({
     *   where: {
     *     // ... the filter for the VisitDocumentations we want to count
     *   }
     * })
    **/
    count<T extends VisitDocumentationCountArgs>(
      args?: Subset<T, VisitDocumentationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitDocumentationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitDocumentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDocumentationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitDocumentationAggregateArgs>(args: Subset<T, VisitDocumentationAggregateArgs>): Prisma.PrismaPromise<GetVisitDocumentationAggregateType<T>>

    /**
     * Group by VisitDocumentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitDocumentationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitDocumentationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitDocumentationGroupByArgs['orderBy'] }
        : { orderBy?: VisitDocumentationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitDocumentationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitDocumentationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitDocumentation model
   */
  readonly fields: VisitDocumentationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitDocumentation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitDocumentationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends HomeVisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HomeVisitDefaultArgs<ExtArgs>>): Prisma__HomeVisitClient<$Result.GetResult<Prisma.$HomeVisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitDocumentation model
   */ 
  interface VisitDocumentationFieldRefs {
    readonly id: FieldRef<"VisitDocumentation", 'String'>
    readonly visitId: FieldRef<"VisitDocumentation", 'String'>
    readonly documentType: FieldRef<"VisitDocumentation", 'DocumentType'>
    readonly title: FieldRef<"VisitDocumentation", 'String'>
    readonly content: FieldRef<"VisitDocumentation", 'String'>
    readonly fileUrl: FieldRef<"VisitDocumentation", 'String'>
    readonly fileType: FieldRef<"VisitDocumentation", 'String'>
    readonly fileSize: FieldRef<"VisitDocumentation", 'Int'>
    readonly assessmentData: FieldRef<"VisitDocumentation", 'Json'>
    readonly createdBy: FieldRef<"VisitDocumentation", 'String'>
    readonly createdAt: FieldRef<"VisitDocumentation", 'DateTime'>
    readonly updatedAt: FieldRef<"VisitDocumentation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitDocumentation findUnique
   */
  export type VisitDocumentationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * Filter, which VisitDocumentation to fetch.
     */
    where: VisitDocumentationWhereUniqueInput
  }

  /**
   * VisitDocumentation findUniqueOrThrow
   */
  export type VisitDocumentationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * Filter, which VisitDocumentation to fetch.
     */
    where: VisitDocumentationWhereUniqueInput
  }

  /**
   * VisitDocumentation findFirst
   */
  export type VisitDocumentationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * Filter, which VisitDocumentation to fetch.
     */
    where?: VisitDocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDocumentations to fetch.
     */
    orderBy?: VisitDocumentationOrderByWithRelationInput | VisitDocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitDocumentations.
     */
    cursor?: VisitDocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDocumentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDocumentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitDocumentations.
     */
    distinct?: VisitDocumentationScalarFieldEnum | VisitDocumentationScalarFieldEnum[]
  }

  /**
   * VisitDocumentation findFirstOrThrow
   */
  export type VisitDocumentationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * Filter, which VisitDocumentation to fetch.
     */
    where?: VisitDocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDocumentations to fetch.
     */
    orderBy?: VisitDocumentationOrderByWithRelationInput | VisitDocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitDocumentations.
     */
    cursor?: VisitDocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDocumentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDocumentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitDocumentations.
     */
    distinct?: VisitDocumentationScalarFieldEnum | VisitDocumentationScalarFieldEnum[]
  }

  /**
   * VisitDocumentation findMany
   */
  export type VisitDocumentationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * Filter, which VisitDocumentations to fetch.
     */
    where?: VisitDocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitDocumentations to fetch.
     */
    orderBy?: VisitDocumentationOrderByWithRelationInput | VisitDocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitDocumentations.
     */
    cursor?: VisitDocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitDocumentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitDocumentations.
     */
    skip?: number
    distinct?: VisitDocumentationScalarFieldEnum | VisitDocumentationScalarFieldEnum[]
  }

  /**
   * VisitDocumentation create
   */
  export type VisitDocumentationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitDocumentation.
     */
    data: XOR<VisitDocumentationCreateInput, VisitDocumentationUncheckedCreateInput>
  }

  /**
   * VisitDocumentation createMany
   */
  export type VisitDocumentationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitDocumentations.
     */
    data: VisitDocumentationCreateManyInput | VisitDocumentationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitDocumentation createManyAndReturn
   */
  export type VisitDocumentationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitDocumentations.
     */
    data: VisitDocumentationCreateManyInput | VisitDocumentationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitDocumentation update
   */
  export type VisitDocumentationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitDocumentation.
     */
    data: XOR<VisitDocumentationUpdateInput, VisitDocumentationUncheckedUpdateInput>
    /**
     * Choose, which VisitDocumentation to update.
     */
    where: VisitDocumentationWhereUniqueInput
  }

  /**
   * VisitDocumentation updateMany
   */
  export type VisitDocumentationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitDocumentations.
     */
    data: XOR<VisitDocumentationUpdateManyMutationInput, VisitDocumentationUncheckedUpdateManyInput>
    /**
     * Filter which VisitDocumentations to update
     */
    where?: VisitDocumentationWhereInput
  }

  /**
   * VisitDocumentation upsert
   */
  export type VisitDocumentationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitDocumentation to update in case it exists.
     */
    where: VisitDocumentationWhereUniqueInput
    /**
     * In case the VisitDocumentation found by the `where` argument doesn't exist, create a new VisitDocumentation with this data.
     */
    create: XOR<VisitDocumentationCreateInput, VisitDocumentationUncheckedCreateInput>
    /**
     * In case the VisitDocumentation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitDocumentationUpdateInput, VisitDocumentationUncheckedUpdateInput>
  }

  /**
   * VisitDocumentation delete
   */
  export type VisitDocumentationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
    /**
     * Filter which VisitDocumentation to delete.
     */
    where: VisitDocumentationWhereUniqueInput
  }

  /**
   * VisitDocumentation deleteMany
   */
  export type VisitDocumentationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitDocumentations to delete
     */
    where?: VisitDocumentationWhereInput
  }

  /**
   * VisitDocumentation without action
   */
  export type VisitDocumentationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitDocumentation
     */
    select?: VisitDocumentationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitDocumentationInclude<ExtArgs> | null
  }


  /**
   * Model PatientEquipment
   */

  export type AggregatePatientEquipment = {
    _count: PatientEquipmentCountAggregateOutputType | null
    _avg: PatientEquipmentAvgAggregateOutputType | null
    _sum: PatientEquipmentSumAggregateOutputType | null
    _min: PatientEquipmentMinAggregateOutputType | null
    _max: PatientEquipmentMaxAggregateOutputType | null
  }

  export type PatientEquipmentAvgAggregateOutputType = {
    monthlyRentalCost: number | null
  }

  export type PatientEquipmentSumAggregateOutputType = {
    monthlyRentalCost: number | null
  }

  export type PatientEquipmentMinAggregateOutputType = {
    id: string | null
    patientHomeId: string | null
    equipmentType: $Enums.EquipmentType | null
    name: string | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    status: $Enums.EquipmentStatus | null
    condition: $Enums.EquipmentCondition | null
    deliveredDate: Date | null
    expectedReturnDate: Date | null
    returnedDate: Date | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    maintenanceNotes: string | null
    ownershipType: $Enums.OwnershipType | null
    rentalCompany: string | null
    monthlyRentalCost: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientEquipmentMaxAggregateOutputType = {
    id: string | null
    patientHomeId: string | null
    equipmentType: $Enums.EquipmentType | null
    name: string | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    status: $Enums.EquipmentStatus | null
    condition: $Enums.EquipmentCondition | null
    deliveredDate: Date | null
    expectedReturnDate: Date | null
    returnedDate: Date | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    maintenanceNotes: string | null
    ownershipType: $Enums.OwnershipType | null
    rentalCompany: string | null
    monthlyRentalCost: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientEquipmentCountAggregateOutputType = {
    id: number
    patientHomeId: number
    equipmentType: number
    name: number
    serialNumber: number
    manufacturer: number
    model: number
    status: number
    condition: number
    deliveredDate: number
    expectedReturnDate: number
    returnedDate: number
    lastMaintenanceDate: number
    nextMaintenanceDate: number
    maintenanceNotes: number
    ownershipType: number
    rentalCompany: number
    monthlyRentalCost: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientEquipmentAvgAggregateInputType = {
    monthlyRentalCost?: true
  }

  export type PatientEquipmentSumAggregateInputType = {
    monthlyRentalCost?: true
  }

  export type PatientEquipmentMinAggregateInputType = {
    id?: true
    patientHomeId?: true
    equipmentType?: true
    name?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    status?: true
    condition?: true
    deliveredDate?: true
    expectedReturnDate?: true
    returnedDate?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    maintenanceNotes?: true
    ownershipType?: true
    rentalCompany?: true
    monthlyRentalCost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientEquipmentMaxAggregateInputType = {
    id?: true
    patientHomeId?: true
    equipmentType?: true
    name?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    status?: true
    condition?: true
    deliveredDate?: true
    expectedReturnDate?: true
    returnedDate?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    maintenanceNotes?: true
    ownershipType?: true
    rentalCompany?: true
    monthlyRentalCost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientEquipmentCountAggregateInputType = {
    id?: true
    patientHomeId?: true
    equipmentType?: true
    name?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    status?: true
    condition?: true
    deliveredDate?: true
    expectedReturnDate?: true
    returnedDate?: true
    lastMaintenanceDate?: true
    nextMaintenanceDate?: true
    maintenanceNotes?: true
    ownershipType?: true
    rentalCompany?: true
    monthlyRentalCost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientEquipment to aggregate.
     */
    where?: PatientEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientEquipments to fetch.
     */
    orderBy?: PatientEquipmentOrderByWithRelationInput | PatientEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientEquipments
    **/
    _count?: true | PatientEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientEquipmentMaxAggregateInputType
  }

  export type GetPatientEquipmentAggregateType<T extends PatientEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientEquipment[P]>
      : GetScalarType<T[P], AggregatePatientEquipment[P]>
  }




  export type PatientEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientEquipmentWhereInput
    orderBy?: PatientEquipmentOrderByWithAggregationInput | PatientEquipmentOrderByWithAggregationInput[]
    by: PatientEquipmentScalarFieldEnum[] | PatientEquipmentScalarFieldEnum
    having?: PatientEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientEquipmentCountAggregateInputType | true
    _avg?: PatientEquipmentAvgAggregateInputType
    _sum?: PatientEquipmentSumAggregateInputType
    _min?: PatientEquipmentMinAggregateInputType
    _max?: PatientEquipmentMaxAggregateInputType
  }

  export type PatientEquipmentGroupByOutputType = {
    id: string
    patientHomeId: string
    equipmentType: $Enums.EquipmentType
    name: string
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    status: $Enums.EquipmentStatus
    condition: $Enums.EquipmentCondition
    deliveredDate: Date | null
    expectedReturnDate: Date | null
    returnedDate: Date | null
    lastMaintenanceDate: Date | null
    nextMaintenanceDate: Date | null
    maintenanceNotes: string | null
    ownershipType: $Enums.OwnershipType
    rentalCompany: string | null
    monthlyRentalCost: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PatientEquipmentCountAggregateOutputType | null
    _avg: PatientEquipmentAvgAggregateOutputType | null
    _sum: PatientEquipmentSumAggregateOutputType | null
    _min: PatientEquipmentMinAggregateOutputType | null
    _max: PatientEquipmentMaxAggregateOutputType | null
  }

  type GetPatientEquipmentGroupByPayload<T extends PatientEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], PatientEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type PatientEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientHomeId?: boolean
    equipmentType?: boolean
    name?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    status?: boolean
    condition?: boolean
    deliveredDate?: boolean
    expectedReturnDate?: boolean
    returnedDate?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    maintenanceNotes?: boolean
    ownershipType?: boolean
    rentalCompany?: boolean
    monthlyRentalCost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientEquipment"]>

  export type PatientEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientHomeId?: boolean
    equipmentType?: boolean
    name?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    status?: boolean
    condition?: boolean
    deliveredDate?: boolean
    expectedReturnDate?: boolean
    returnedDate?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    maintenanceNotes?: boolean
    ownershipType?: boolean
    rentalCompany?: boolean
    monthlyRentalCost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientEquipment"]>

  export type PatientEquipmentSelectScalar = {
    id?: boolean
    patientHomeId?: boolean
    equipmentType?: boolean
    name?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    status?: boolean
    condition?: boolean
    deliveredDate?: boolean
    expectedReturnDate?: boolean
    returnedDate?: boolean
    lastMaintenanceDate?: boolean
    nextMaintenanceDate?: boolean
    maintenanceNotes?: boolean
    ownershipType?: boolean
    rentalCompany?: boolean
    monthlyRentalCost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }
  export type PatientEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientHome?: boolean | PatientHomeDefaultArgs<ExtArgs>
  }

  export type $PatientEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientEquipment"
    objects: {
      patientHome: Prisma.$PatientHomePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientHomeId: string
      equipmentType: $Enums.EquipmentType
      name: string
      serialNumber: string | null
      manufacturer: string | null
      model: string | null
      status: $Enums.EquipmentStatus
      condition: $Enums.EquipmentCondition
      deliveredDate: Date | null
      expectedReturnDate: Date | null
      returnedDate: Date | null
      lastMaintenanceDate: Date | null
      nextMaintenanceDate: Date | null
      maintenanceNotes: string | null
      ownershipType: $Enums.OwnershipType
      rentalCompany: string | null
      monthlyRentalCost: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patientEquipment"]>
    composites: {}
  }

  type PatientEquipmentGetPayload<S extends boolean | null | undefined | PatientEquipmentDefaultArgs> = $Result.GetResult<Prisma.$PatientEquipmentPayload, S>

  type PatientEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientEquipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientEquipmentCountAggregateInputType | true
    }

  export interface PatientEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientEquipment'], meta: { name: 'PatientEquipment' } }
    /**
     * Find zero or one PatientEquipment that matches the filter.
     * @param {PatientEquipmentFindUniqueArgs} args - Arguments to find a PatientEquipment
     * @example
     * // Get one PatientEquipment
     * const patientEquipment = await prisma.patientEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientEquipmentFindUniqueArgs>(args: SelectSubset<T, PatientEquipmentFindUniqueArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientEquipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientEquipmentFindUniqueOrThrowArgs} args - Arguments to find a PatientEquipment
     * @example
     * // Get one PatientEquipment
     * const patientEquipment = await prisma.patientEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientEquipmentFindFirstArgs} args - Arguments to find a PatientEquipment
     * @example
     * // Get one PatientEquipment
     * const patientEquipment = await prisma.patientEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientEquipmentFindFirstArgs>(args?: SelectSubset<T, PatientEquipmentFindFirstArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientEquipmentFindFirstOrThrowArgs} args - Arguments to find a PatientEquipment
     * @example
     * // Get one PatientEquipment
     * const patientEquipment = await prisma.patientEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientEquipments
     * const patientEquipments = await prisma.patientEquipment.findMany()
     * 
     * // Get first 10 PatientEquipments
     * const patientEquipments = await prisma.patientEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientEquipmentWithIdOnly = await prisma.patientEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientEquipmentFindManyArgs>(args?: SelectSubset<T, PatientEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientEquipment.
     * @param {PatientEquipmentCreateArgs} args - Arguments to create a PatientEquipment.
     * @example
     * // Create one PatientEquipment
     * const PatientEquipment = await prisma.patientEquipment.create({
     *   data: {
     *     // ... data to create a PatientEquipment
     *   }
     * })
     * 
     */
    create<T extends PatientEquipmentCreateArgs>(args: SelectSubset<T, PatientEquipmentCreateArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientEquipments.
     * @param {PatientEquipmentCreateManyArgs} args - Arguments to create many PatientEquipments.
     * @example
     * // Create many PatientEquipments
     * const patientEquipment = await prisma.patientEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientEquipmentCreateManyArgs>(args?: SelectSubset<T, PatientEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientEquipments and returns the data saved in the database.
     * @param {PatientEquipmentCreateManyAndReturnArgs} args - Arguments to create many PatientEquipments.
     * @example
     * // Create many PatientEquipments
     * const patientEquipment = await prisma.patientEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientEquipments and only return the `id`
     * const patientEquipmentWithIdOnly = await prisma.patientEquipment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientEquipment.
     * @param {PatientEquipmentDeleteArgs} args - Arguments to delete one PatientEquipment.
     * @example
     * // Delete one PatientEquipment
     * const PatientEquipment = await prisma.patientEquipment.delete({
     *   where: {
     *     // ... filter to delete one PatientEquipment
     *   }
     * })
     * 
     */
    delete<T extends PatientEquipmentDeleteArgs>(args: SelectSubset<T, PatientEquipmentDeleteArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientEquipment.
     * @param {PatientEquipmentUpdateArgs} args - Arguments to update one PatientEquipment.
     * @example
     * // Update one PatientEquipment
     * const patientEquipment = await prisma.patientEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientEquipmentUpdateArgs>(args: SelectSubset<T, PatientEquipmentUpdateArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientEquipments.
     * @param {PatientEquipmentDeleteManyArgs} args - Arguments to filter PatientEquipments to delete.
     * @example
     * // Delete a few PatientEquipments
     * const { count } = await prisma.patientEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientEquipmentDeleteManyArgs>(args?: SelectSubset<T, PatientEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientEquipments
     * const patientEquipment = await prisma.patientEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientEquipmentUpdateManyArgs>(args: SelectSubset<T, PatientEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientEquipment.
     * @param {PatientEquipmentUpsertArgs} args - Arguments to update or create a PatientEquipment.
     * @example
     * // Update or create a PatientEquipment
     * const patientEquipment = await prisma.patientEquipment.upsert({
     *   create: {
     *     // ... data to create a PatientEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientEquipment we want to update
     *   }
     * })
     */
    upsert<T extends PatientEquipmentUpsertArgs>(args: SelectSubset<T, PatientEquipmentUpsertArgs<ExtArgs>>): Prisma__PatientEquipmentClient<$Result.GetResult<Prisma.$PatientEquipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientEquipmentCountArgs} args - Arguments to filter PatientEquipments to count.
     * @example
     * // Count the number of PatientEquipments
     * const count = await prisma.patientEquipment.count({
     *   where: {
     *     // ... the filter for the PatientEquipments we want to count
     *   }
     * })
    **/
    count<T extends PatientEquipmentCountArgs>(
      args?: Subset<T, PatientEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientEquipmentAggregateArgs>(args: Subset<T, PatientEquipmentAggregateArgs>): Prisma.PrismaPromise<GetPatientEquipmentAggregateType<T>>

    /**
     * Group by PatientEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: PatientEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientEquipment model
   */
  readonly fields: PatientEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientHome<T extends PatientHomeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientHomeDefaultArgs<ExtArgs>>): Prisma__PatientHomeClient<$Result.GetResult<Prisma.$PatientHomePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientEquipment model
   */ 
  interface PatientEquipmentFieldRefs {
    readonly id: FieldRef<"PatientEquipment", 'String'>
    readonly patientHomeId: FieldRef<"PatientEquipment", 'String'>
    readonly equipmentType: FieldRef<"PatientEquipment", 'EquipmentType'>
    readonly name: FieldRef<"PatientEquipment", 'String'>
    readonly serialNumber: FieldRef<"PatientEquipment", 'String'>
    readonly manufacturer: FieldRef<"PatientEquipment", 'String'>
    readonly model: FieldRef<"PatientEquipment", 'String'>
    readonly status: FieldRef<"PatientEquipment", 'EquipmentStatus'>
    readonly condition: FieldRef<"PatientEquipment", 'EquipmentCondition'>
    readonly deliveredDate: FieldRef<"PatientEquipment", 'DateTime'>
    readonly expectedReturnDate: FieldRef<"PatientEquipment", 'DateTime'>
    readonly returnedDate: FieldRef<"PatientEquipment", 'DateTime'>
    readonly lastMaintenanceDate: FieldRef<"PatientEquipment", 'DateTime'>
    readonly nextMaintenanceDate: FieldRef<"PatientEquipment", 'DateTime'>
    readonly maintenanceNotes: FieldRef<"PatientEquipment", 'String'>
    readonly ownershipType: FieldRef<"PatientEquipment", 'OwnershipType'>
    readonly rentalCompany: FieldRef<"PatientEquipment", 'String'>
    readonly monthlyRentalCost: FieldRef<"PatientEquipment", 'Float'>
    readonly notes: FieldRef<"PatientEquipment", 'String'>
    readonly createdAt: FieldRef<"PatientEquipment", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientEquipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientEquipment findUnique
   */
  export type PatientEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientEquipment to fetch.
     */
    where: PatientEquipmentWhereUniqueInput
  }

  /**
   * PatientEquipment findUniqueOrThrow
   */
  export type PatientEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientEquipment to fetch.
     */
    where: PatientEquipmentWhereUniqueInput
  }

  /**
   * PatientEquipment findFirst
   */
  export type PatientEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientEquipment to fetch.
     */
    where?: PatientEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientEquipments to fetch.
     */
    orderBy?: PatientEquipmentOrderByWithRelationInput | PatientEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientEquipments.
     */
    cursor?: PatientEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientEquipments.
     */
    distinct?: PatientEquipmentScalarFieldEnum | PatientEquipmentScalarFieldEnum[]
  }

  /**
   * PatientEquipment findFirstOrThrow
   */
  export type PatientEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientEquipment to fetch.
     */
    where?: PatientEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientEquipments to fetch.
     */
    orderBy?: PatientEquipmentOrderByWithRelationInput | PatientEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientEquipments.
     */
    cursor?: PatientEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientEquipments.
     */
    distinct?: PatientEquipmentScalarFieldEnum | PatientEquipmentScalarFieldEnum[]
  }

  /**
   * PatientEquipment findMany
   */
  export type PatientEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientEquipments to fetch.
     */
    where?: PatientEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientEquipments to fetch.
     */
    orderBy?: PatientEquipmentOrderByWithRelationInput | PatientEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientEquipments.
     */
    cursor?: PatientEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientEquipments.
     */
    skip?: number
    distinct?: PatientEquipmentScalarFieldEnum | PatientEquipmentScalarFieldEnum[]
  }

  /**
   * PatientEquipment create
   */
  export type PatientEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientEquipment.
     */
    data: XOR<PatientEquipmentCreateInput, PatientEquipmentUncheckedCreateInput>
  }

  /**
   * PatientEquipment createMany
   */
  export type PatientEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientEquipments.
     */
    data: PatientEquipmentCreateManyInput | PatientEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientEquipment createManyAndReturn
   */
  export type PatientEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientEquipments.
     */
    data: PatientEquipmentCreateManyInput | PatientEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientEquipment update
   */
  export type PatientEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientEquipment.
     */
    data: XOR<PatientEquipmentUpdateInput, PatientEquipmentUncheckedUpdateInput>
    /**
     * Choose, which PatientEquipment to update.
     */
    where: PatientEquipmentWhereUniqueInput
  }

  /**
   * PatientEquipment updateMany
   */
  export type PatientEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientEquipments.
     */
    data: XOR<PatientEquipmentUpdateManyMutationInput, PatientEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which PatientEquipments to update
     */
    where?: PatientEquipmentWhereInput
  }

  /**
   * PatientEquipment upsert
   */
  export type PatientEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientEquipment to update in case it exists.
     */
    where: PatientEquipmentWhereUniqueInput
    /**
     * In case the PatientEquipment found by the `where` argument doesn't exist, create a new PatientEquipment with this data.
     */
    create: XOR<PatientEquipmentCreateInput, PatientEquipmentUncheckedCreateInput>
    /**
     * In case the PatientEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientEquipmentUpdateInput, PatientEquipmentUncheckedUpdateInput>
  }

  /**
   * PatientEquipment delete
   */
  export type PatientEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
    /**
     * Filter which PatientEquipment to delete.
     */
    where: PatientEquipmentWhereUniqueInput
  }

  /**
   * PatientEquipment deleteMany
   */
  export type PatientEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientEquipments to delete
     */
    where?: PatientEquipmentWhereInput
  }

  /**
   * PatientEquipment without action
   */
  export type PatientEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientEquipment
     */
    select?: PatientEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model FamilyCommunication
   */

  export type AggregateFamilyCommunication = {
    _count: FamilyCommunicationCountAggregateOutputType | null
    _min: FamilyCommunicationMinAggregateOutputType | null
    _max: FamilyCommunicationMaxAggregateOutputType | null
  }

  export type FamilyCommunicationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    familyMemberId: string | null
    caregiverId: string | null
    communicationType: $Enums.CommunicationType | null
    subject: string | null
    message: string | null
    visitId: string | null
    isRead: boolean | null
    readAt: Date | null
    parentMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyCommunicationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    familyMemberId: string | null
    caregiverId: string | null
    communicationType: $Enums.CommunicationType | null
    subject: string | null
    message: string | null
    visitId: string | null
    isRead: boolean | null
    readAt: Date | null
    parentMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyCommunicationCountAggregateOutputType = {
    id: number
    patientId: number
    familyMemberId: number
    caregiverId: number
    communicationType: number
    subject: number
    message: number
    visitId: number
    isRead: number
    readAt: number
    parentMessageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FamilyCommunicationMinAggregateInputType = {
    id?: true
    patientId?: true
    familyMemberId?: true
    caregiverId?: true
    communicationType?: true
    subject?: true
    message?: true
    visitId?: true
    isRead?: true
    readAt?: true
    parentMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyCommunicationMaxAggregateInputType = {
    id?: true
    patientId?: true
    familyMemberId?: true
    caregiverId?: true
    communicationType?: true
    subject?: true
    message?: true
    visitId?: true
    isRead?: true
    readAt?: true
    parentMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyCommunicationCountAggregateInputType = {
    id?: true
    patientId?: true
    familyMemberId?: true
    caregiverId?: true
    communicationType?: true
    subject?: true
    message?: true
    visitId?: true
    isRead?: true
    readAt?: true
    parentMessageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FamilyCommunicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyCommunication to aggregate.
     */
    where?: FamilyCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyCommunications to fetch.
     */
    orderBy?: FamilyCommunicationOrderByWithRelationInput | FamilyCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyCommunications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyCommunications
    **/
    _count?: true | FamilyCommunicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyCommunicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyCommunicationMaxAggregateInputType
  }

  export type GetFamilyCommunicationAggregateType<T extends FamilyCommunicationAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyCommunication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyCommunication[P]>
      : GetScalarType<T[P], AggregateFamilyCommunication[P]>
  }




  export type FamilyCommunicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyCommunicationWhereInput
    orderBy?: FamilyCommunicationOrderByWithAggregationInput | FamilyCommunicationOrderByWithAggregationInput[]
    by: FamilyCommunicationScalarFieldEnum[] | FamilyCommunicationScalarFieldEnum
    having?: FamilyCommunicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyCommunicationCountAggregateInputType | true
    _min?: FamilyCommunicationMinAggregateInputType
    _max?: FamilyCommunicationMaxAggregateInputType
  }

  export type FamilyCommunicationGroupByOutputType = {
    id: string
    patientId: string
    familyMemberId: string | null
    caregiverId: string | null
    communicationType: $Enums.CommunicationType
    subject: string | null
    message: string
    visitId: string | null
    isRead: boolean
    readAt: Date | null
    parentMessageId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FamilyCommunicationCountAggregateOutputType | null
    _min: FamilyCommunicationMinAggregateOutputType | null
    _max: FamilyCommunicationMaxAggregateOutputType | null
  }

  type GetFamilyCommunicationGroupByPayload<T extends FamilyCommunicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyCommunicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyCommunicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyCommunicationGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyCommunicationGroupByOutputType[P]>
        }
      >
    >


  export type FamilyCommunicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    familyMemberId?: boolean
    caregiverId?: boolean
    communicationType?: boolean
    subject?: boolean
    message?: boolean
    visitId?: boolean
    isRead?: boolean
    readAt?: boolean
    parentMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["familyCommunication"]>

  export type FamilyCommunicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    familyMemberId?: boolean
    caregiverId?: boolean
    communicationType?: boolean
    subject?: boolean
    message?: boolean
    visitId?: boolean
    isRead?: boolean
    readAt?: boolean
    parentMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["familyCommunication"]>

  export type FamilyCommunicationSelectScalar = {
    id?: boolean
    patientId?: boolean
    familyMemberId?: boolean
    caregiverId?: boolean
    communicationType?: boolean
    subject?: boolean
    message?: boolean
    visitId?: boolean
    isRead?: boolean
    readAt?: boolean
    parentMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FamilyCommunicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyCommunication"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      familyMemberId: string | null
      caregiverId: string | null
      communicationType: $Enums.CommunicationType
      subject: string | null
      message: string
      visitId: string | null
      isRead: boolean
      readAt: Date | null
      parentMessageId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["familyCommunication"]>
    composites: {}
  }

  type FamilyCommunicationGetPayload<S extends boolean | null | undefined | FamilyCommunicationDefaultArgs> = $Result.GetResult<Prisma.$FamilyCommunicationPayload, S>

  type FamilyCommunicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FamilyCommunicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FamilyCommunicationCountAggregateInputType | true
    }

  export interface FamilyCommunicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyCommunication'], meta: { name: 'FamilyCommunication' } }
    /**
     * Find zero or one FamilyCommunication that matches the filter.
     * @param {FamilyCommunicationFindUniqueArgs} args - Arguments to find a FamilyCommunication
     * @example
     * // Get one FamilyCommunication
     * const familyCommunication = await prisma.familyCommunication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyCommunicationFindUniqueArgs>(args: SelectSubset<T, FamilyCommunicationFindUniqueArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FamilyCommunication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FamilyCommunicationFindUniqueOrThrowArgs} args - Arguments to find a FamilyCommunication
     * @example
     * // Get one FamilyCommunication
     * const familyCommunication = await prisma.familyCommunication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyCommunicationFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyCommunicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FamilyCommunication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCommunicationFindFirstArgs} args - Arguments to find a FamilyCommunication
     * @example
     * // Get one FamilyCommunication
     * const familyCommunication = await prisma.familyCommunication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyCommunicationFindFirstArgs>(args?: SelectSubset<T, FamilyCommunicationFindFirstArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FamilyCommunication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCommunicationFindFirstOrThrowArgs} args - Arguments to find a FamilyCommunication
     * @example
     * // Get one FamilyCommunication
     * const familyCommunication = await prisma.familyCommunication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyCommunicationFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyCommunicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FamilyCommunications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCommunicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyCommunications
     * const familyCommunications = await prisma.familyCommunication.findMany()
     * 
     * // Get first 10 FamilyCommunications
     * const familyCommunications = await prisma.familyCommunication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyCommunicationWithIdOnly = await prisma.familyCommunication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyCommunicationFindManyArgs>(args?: SelectSubset<T, FamilyCommunicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FamilyCommunication.
     * @param {FamilyCommunicationCreateArgs} args - Arguments to create a FamilyCommunication.
     * @example
     * // Create one FamilyCommunication
     * const FamilyCommunication = await prisma.familyCommunication.create({
     *   data: {
     *     // ... data to create a FamilyCommunication
     *   }
     * })
     * 
     */
    create<T extends FamilyCommunicationCreateArgs>(args: SelectSubset<T, FamilyCommunicationCreateArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FamilyCommunications.
     * @param {FamilyCommunicationCreateManyArgs} args - Arguments to create many FamilyCommunications.
     * @example
     * // Create many FamilyCommunications
     * const familyCommunication = await prisma.familyCommunication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyCommunicationCreateManyArgs>(args?: SelectSubset<T, FamilyCommunicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FamilyCommunications and returns the data saved in the database.
     * @param {FamilyCommunicationCreateManyAndReturnArgs} args - Arguments to create many FamilyCommunications.
     * @example
     * // Create many FamilyCommunications
     * const familyCommunication = await prisma.familyCommunication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FamilyCommunications and only return the `id`
     * const familyCommunicationWithIdOnly = await prisma.familyCommunication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamilyCommunicationCreateManyAndReturnArgs>(args?: SelectSubset<T, FamilyCommunicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FamilyCommunication.
     * @param {FamilyCommunicationDeleteArgs} args - Arguments to delete one FamilyCommunication.
     * @example
     * // Delete one FamilyCommunication
     * const FamilyCommunication = await prisma.familyCommunication.delete({
     *   where: {
     *     // ... filter to delete one FamilyCommunication
     *   }
     * })
     * 
     */
    delete<T extends FamilyCommunicationDeleteArgs>(args: SelectSubset<T, FamilyCommunicationDeleteArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FamilyCommunication.
     * @param {FamilyCommunicationUpdateArgs} args - Arguments to update one FamilyCommunication.
     * @example
     * // Update one FamilyCommunication
     * const familyCommunication = await prisma.familyCommunication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyCommunicationUpdateArgs>(args: SelectSubset<T, FamilyCommunicationUpdateArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FamilyCommunications.
     * @param {FamilyCommunicationDeleteManyArgs} args - Arguments to filter FamilyCommunications to delete.
     * @example
     * // Delete a few FamilyCommunications
     * const { count } = await prisma.familyCommunication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyCommunicationDeleteManyArgs>(args?: SelectSubset<T, FamilyCommunicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyCommunications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCommunicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyCommunications
     * const familyCommunication = await prisma.familyCommunication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyCommunicationUpdateManyArgs>(args: SelectSubset<T, FamilyCommunicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyCommunication.
     * @param {FamilyCommunicationUpsertArgs} args - Arguments to update or create a FamilyCommunication.
     * @example
     * // Update or create a FamilyCommunication
     * const familyCommunication = await prisma.familyCommunication.upsert({
     *   create: {
     *     // ... data to create a FamilyCommunication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyCommunication we want to update
     *   }
     * })
     */
    upsert<T extends FamilyCommunicationUpsertArgs>(args: SelectSubset<T, FamilyCommunicationUpsertArgs<ExtArgs>>): Prisma__FamilyCommunicationClient<$Result.GetResult<Prisma.$FamilyCommunicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FamilyCommunications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCommunicationCountArgs} args - Arguments to filter FamilyCommunications to count.
     * @example
     * // Count the number of FamilyCommunications
     * const count = await prisma.familyCommunication.count({
     *   where: {
     *     // ... the filter for the FamilyCommunications we want to count
     *   }
     * })
    **/
    count<T extends FamilyCommunicationCountArgs>(
      args?: Subset<T, FamilyCommunicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyCommunicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyCommunication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCommunicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyCommunicationAggregateArgs>(args: Subset<T, FamilyCommunicationAggregateArgs>): Prisma.PrismaPromise<GetFamilyCommunicationAggregateType<T>>

    /**
     * Group by FamilyCommunication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCommunicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyCommunicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyCommunicationGroupByArgs['orderBy'] }
        : { orderBy?: FamilyCommunicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyCommunicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyCommunicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyCommunication model
   */
  readonly fields: FamilyCommunicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyCommunication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyCommunicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyCommunication model
   */ 
  interface FamilyCommunicationFieldRefs {
    readonly id: FieldRef<"FamilyCommunication", 'String'>
    readonly patientId: FieldRef<"FamilyCommunication", 'String'>
    readonly familyMemberId: FieldRef<"FamilyCommunication", 'String'>
    readonly caregiverId: FieldRef<"FamilyCommunication", 'String'>
    readonly communicationType: FieldRef<"FamilyCommunication", 'CommunicationType'>
    readonly subject: FieldRef<"FamilyCommunication", 'String'>
    readonly message: FieldRef<"FamilyCommunication", 'String'>
    readonly visitId: FieldRef<"FamilyCommunication", 'String'>
    readonly isRead: FieldRef<"FamilyCommunication", 'Boolean'>
    readonly readAt: FieldRef<"FamilyCommunication", 'DateTime'>
    readonly parentMessageId: FieldRef<"FamilyCommunication", 'String'>
    readonly createdAt: FieldRef<"FamilyCommunication", 'DateTime'>
    readonly updatedAt: FieldRef<"FamilyCommunication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyCommunication findUnique
   */
  export type FamilyCommunicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * Filter, which FamilyCommunication to fetch.
     */
    where: FamilyCommunicationWhereUniqueInput
  }

  /**
   * FamilyCommunication findUniqueOrThrow
   */
  export type FamilyCommunicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * Filter, which FamilyCommunication to fetch.
     */
    where: FamilyCommunicationWhereUniqueInput
  }

  /**
   * FamilyCommunication findFirst
   */
  export type FamilyCommunicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * Filter, which FamilyCommunication to fetch.
     */
    where?: FamilyCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyCommunications to fetch.
     */
    orderBy?: FamilyCommunicationOrderByWithRelationInput | FamilyCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyCommunications.
     */
    cursor?: FamilyCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyCommunications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyCommunications.
     */
    distinct?: FamilyCommunicationScalarFieldEnum | FamilyCommunicationScalarFieldEnum[]
  }

  /**
   * FamilyCommunication findFirstOrThrow
   */
  export type FamilyCommunicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * Filter, which FamilyCommunication to fetch.
     */
    where?: FamilyCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyCommunications to fetch.
     */
    orderBy?: FamilyCommunicationOrderByWithRelationInput | FamilyCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyCommunications.
     */
    cursor?: FamilyCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyCommunications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyCommunications.
     */
    distinct?: FamilyCommunicationScalarFieldEnum | FamilyCommunicationScalarFieldEnum[]
  }

  /**
   * FamilyCommunication findMany
   */
  export type FamilyCommunicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * Filter, which FamilyCommunications to fetch.
     */
    where?: FamilyCommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyCommunications to fetch.
     */
    orderBy?: FamilyCommunicationOrderByWithRelationInput | FamilyCommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyCommunications.
     */
    cursor?: FamilyCommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyCommunications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyCommunications.
     */
    skip?: number
    distinct?: FamilyCommunicationScalarFieldEnum | FamilyCommunicationScalarFieldEnum[]
  }

  /**
   * FamilyCommunication create
   */
  export type FamilyCommunicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * The data needed to create a FamilyCommunication.
     */
    data: XOR<FamilyCommunicationCreateInput, FamilyCommunicationUncheckedCreateInput>
  }

  /**
   * FamilyCommunication createMany
   */
  export type FamilyCommunicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyCommunications.
     */
    data: FamilyCommunicationCreateManyInput | FamilyCommunicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyCommunication createManyAndReturn
   */
  export type FamilyCommunicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FamilyCommunications.
     */
    data: FamilyCommunicationCreateManyInput | FamilyCommunicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyCommunication update
   */
  export type FamilyCommunicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * The data needed to update a FamilyCommunication.
     */
    data: XOR<FamilyCommunicationUpdateInput, FamilyCommunicationUncheckedUpdateInput>
    /**
     * Choose, which FamilyCommunication to update.
     */
    where: FamilyCommunicationWhereUniqueInput
  }

  /**
   * FamilyCommunication updateMany
   */
  export type FamilyCommunicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyCommunications.
     */
    data: XOR<FamilyCommunicationUpdateManyMutationInput, FamilyCommunicationUncheckedUpdateManyInput>
    /**
     * Filter which FamilyCommunications to update
     */
    where?: FamilyCommunicationWhereInput
  }

  /**
   * FamilyCommunication upsert
   */
  export type FamilyCommunicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * The filter to search for the FamilyCommunication to update in case it exists.
     */
    where: FamilyCommunicationWhereUniqueInput
    /**
     * In case the FamilyCommunication found by the `where` argument doesn't exist, create a new FamilyCommunication with this data.
     */
    create: XOR<FamilyCommunicationCreateInput, FamilyCommunicationUncheckedCreateInput>
    /**
     * In case the FamilyCommunication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyCommunicationUpdateInput, FamilyCommunicationUncheckedUpdateInput>
  }

  /**
   * FamilyCommunication delete
   */
  export type FamilyCommunicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
    /**
     * Filter which FamilyCommunication to delete.
     */
    where: FamilyCommunicationWhereUniqueInput
  }

  /**
   * FamilyCommunication deleteMany
   */
  export type FamilyCommunicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyCommunications to delete
     */
    where?: FamilyCommunicationWhereInput
  }

  /**
   * FamilyCommunication without action
   */
  export type FamilyCommunicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCommunication
     */
    select?: FamilyCommunicationSelect<ExtArgs> | null
  }


  /**
   * Model SupplyOrder
   */

  export type AggregateSupplyOrder = {
    _count: SupplyOrderCountAggregateOutputType | null
    _avg: SupplyOrderAvgAggregateOutputType | null
    _sum: SupplyOrderSumAggregateOutputType | null
    _min: SupplyOrderMinAggregateOutputType | null
    _max: SupplyOrderMaxAggregateOutputType | null
  }

  export type SupplyOrderAvgAggregateOutputType = {
    totalCost: number | null
  }

  export type SupplyOrderSumAggregateOutputType = {
    totalCost: number | null
  }

  export type SupplyOrderMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    orderedBy: string | null
    totalCost: number | null
    status: $Enums.SupplyOrderStatus | null
    orderedAt: Date | null
    expectedDelivery: Date | null
    deliveredAt: Date | null
    deliveryNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplyOrderMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    orderedBy: string | null
    totalCost: number | null
    status: $Enums.SupplyOrderStatus | null
    orderedAt: Date | null
    expectedDelivery: Date | null
    deliveredAt: Date | null
    deliveryNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplyOrderCountAggregateOutputType = {
    id: number
    patientId: number
    orderedBy: number
    items: number
    totalCost: number
    status: number
    orderedAt: number
    expectedDelivery: number
    deliveredAt: number
    deliveryNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplyOrderAvgAggregateInputType = {
    totalCost?: true
  }

  export type SupplyOrderSumAggregateInputType = {
    totalCost?: true
  }

  export type SupplyOrderMinAggregateInputType = {
    id?: true
    patientId?: true
    orderedBy?: true
    totalCost?: true
    status?: true
    orderedAt?: true
    expectedDelivery?: true
    deliveredAt?: true
    deliveryNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplyOrderMaxAggregateInputType = {
    id?: true
    patientId?: true
    orderedBy?: true
    totalCost?: true
    status?: true
    orderedAt?: true
    expectedDelivery?: true
    deliveredAt?: true
    deliveryNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplyOrderCountAggregateInputType = {
    id?: true
    patientId?: true
    orderedBy?: true
    items?: true
    totalCost?: true
    status?: true
    orderedAt?: true
    expectedDelivery?: true
    deliveredAt?: true
    deliveryNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplyOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplyOrder to aggregate.
     */
    where?: SupplyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyOrders to fetch.
     */
    orderBy?: SupplyOrderOrderByWithRelationInput | SupplyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplyOrders
    **/
    _count?: true | SupplyOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplyOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplyOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplyOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplyOrderMaxAggregateInputType
  }

  export type GetSupplyOrderAggregateType<T extends SupplyOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplyOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplyOrder[P]>
      : GetScalarType<T[P], AggregateSupplyOrder[P]>
  }




  export type SupplyOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplyOrderWhereInput
    orderBy?: SupplyOrderOrderByWithAggregationInput | SupplyOrderOrderByWithAggregationInput[]
    by: SupplyOrderScalarFieldEnum[] | SupplyOrderScalarFieldEnum
    having?: SupplyOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplyOrderCountAggregateInputType | true
    _avg?: SupplyOrderAvgAggregateInputType
    _sum?: SupplyOrderSumAggregateInputType
    _min?: SupplyOrderMinAggregateInputType
    _max?: SupplyOrderMaxAggregateInputType
  }

  export type SupplyOrderGroupByOutputType = {
    id: string
    patientId: string
    orderedBy: string
    items: JsonValue
    totalCost: number | null
    status: $Enums.SupplyOrderStatus
    orderedAt: Date
    expectedDelivery: Date | null
    deliveredAt: Date | null
    deliveryNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplyOrderCountAggregateOutputType | null
    _avg: SupplyOrderAvgAggregateOutputType | null
    _sum: SupplyOrderSumAggregateOutputType | null
    _min: SupplyOrderMinAggregateOutputType | null
    _max: SupplyOrderMaxAggregateOutputType | null
  }

  type GetSupplyOrderGroupByPayload<T extends SupplyOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplyOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplyOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplyOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SupplyOrderGroupByOutputType[P]>
        }
      >
    >


  export type SupplyOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    orderedBy?: boolean
    items?: boolean
    totalCost?: boolean
    status?: boolean
    orderedAt?: boolean
    expectedDelivery?: boolean
    deliveredAt?: boolean
    deliveryNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplyOrder"]>

  export type SupplyOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    orderedBy?: boolean
    items?: boolean
    totalCost?: boolean
    status?: boolean
    orderedAt?: boolean
    expectedDelivery?: boolean
    deliveredAt?: boolean
    deliveryNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplyOrder"]>

  export type SupplyOrderSelectScalar = {
    id?: boolean
    patientId?: boolean
    orderedBy?: boolean
    items?: boolean
    totalCost?: boolean
    status?: boolean
    orderedAt?: boolean
    expectedDelivery?: boolean
    deliveredAt?: boolean
    deliveryNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SupplyOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplyOrder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      orderedBy: string
      items: Prisma.JsonValue
      totalCost: number | null
      status: $Enums.SupplyOrderStatus
      orderedAt: Date
      expectedDelivery: Date | null
      deliveredAt: Date | null
      deliveryNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplyOrder"]>
    composites: {}
  }

  type SupplyOrderGetPayload<S extends boolean | null | undefined | SupplyOrderDefaultArgs> = $Result.GetResult<Prisma.$SupplyOrderPayload, S>

  type SupplyOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplyOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplyOrderCountAggregateInputType | true
    }

  export interface SupplyOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplyOrder'], meta: { name: 'SupplyOrder' } }
    /**
     * Find zero or one SupplyOrder that matches the filter.
     * @param {SupplyOrderFindUniqueArgs} args - Arguments to find a SupplyOrder
     * @example
     * // Get one SupplyOrder
     * const supplyOrder = await prisma.supplyOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplyOrderFindUniqueArgs>(args: SelectSubset<T, SupplyOrderFindUniqueArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupplyOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplyOrderFindUniqueOrThrowArgs} args - Arguments to find a SupplyOrder
     * @example
     * // Get one SupplyOrder
     * const supplyOrder = await prisma.supplyOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplyOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplyOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupplyOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyOrderFindFirstArgs} args - Arguments to find a SupplyOrder
     * @example
     * // Get one SupplyOrder
     * const supplyOrder = await prisma.supplyOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplyOrderFindFirstArgs>(args?: SelectSubset<T, SupplyOrderFindFirstArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupplyOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyOrderFindFirstOrThrowArgs} args - Arguments to find a SupplyOrder
     * @example
     * // Get one SupplyOrder
     * const supplyOrder = await prisma.supplyOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplyOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplyOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupplyOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplyOrders
     * const supplyOrders = await prisma.supplyOrder.findMany()
     * 
     * // Get first 10 SupplyOrders
     * const supplyOrders = await prisma.supplyOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplyOrderWithIdOnly = await prisma.supplyOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplyOrderFindManyArgs>(args?: SelectSubset<T, SupplyOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupplyOrder.
     * @param {SupplyOrderCreateArgs} args - Arguments to create a SupplyOrder.
     * @example
     * // Create one SupplyOrder
     * const SupplyOrder = await prisma.supplyOrder.create({
     *   data: {
     *     // ... data to create a SupplyOrder
     *   }
     * })
     * 
     */
    create<T extends SupplyOrderCreateArgs>(args: SelectSubset<T, SupplyOrderCreateArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupplyOrders.
     * @param {SupplyOrderCreateManyArgs} args - Arguments to create many SupplyOrders.
     * @example
     * // Create many SupplyOrders
     * const supplyOrder = await prisma.supplyOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplyOrderCreateManyArgs>(args?: SelectSubset<T, SupplyOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplyOrders and returns the data saved in the database.
     * @param {SupplyOrderCreateManyAndReturnArgs} args - Arguments to create many SupplyOrders.
     * @example
     * // Create many SupplyOrders
     * const supplyOrder = await prisma.supplyOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplyOrders and only return the `id`
     * const supplyOrderWithIdOnly = await prisma.supplyOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplyOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplyOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupplyOrder.
     * @param {SupplyOrderDeleteArgs} args - Arguments to delete one SupplyOrder.
     * @example
     * // Delete one SupplyOrder
     * const SupplyOrder = await prisma.supplyOrder.delete({
     *   where: {
     *     // ... filter to delete one SupplyOrder
     *   }
     * })
     * 
     */
    delete<T extends SupplyOrderDeleteArgs>(args: SelectSubset<T, SupplyOrderDeleteArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupplyOrder.
     * @param {SupplyOrderUpdateArgs} args - Arguments to update one SupplyOrder.
     * @example
     * // Update one SupplyOrder
     * const supplyOrder = await prisma.supplyOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplyOrderUpdateArgs>(args: SelectSubset<T, SupplyOrderUpdateArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupplyOrders.
     * @param {SupplyOrderDeleteManyArgs} args - Arguments to filter SupplyOrders to delete.
     * @example
     * // Delete a few SupplyOrders
     * const { count } = await prisma.supplyOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplyOrderDeleteManyArgs>(args?: SelectSubset<T, SupplyOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplyOrders
     * const supplyOrder = await prisma.supplyOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplyOrderUpdateManyArgs>(args: SelectSubset<T, SupplyOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplyOrder.
     * @param {SupplyOrderUpsertArgs} args - Arguments to update or create a SupplyOrder.
     * @example
     * // Update or create a SupplyOrder
     * const supplyOrder = await prisma.supplyOrder.upsert({
     *   create: {
     *     // ... data to create a SupplyOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplyOrder we want to update
     *   }
     * })
     */
    upsert<T extends SupplyOrderUpsertArgs>(args: SelectSubset<T, SupplyOrderUpsertArgs<ExtArgs>>): Prisma__SupplyOrderClient<$Result.GetResult<Prisma.$SupplyOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupplyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyOrderCountArgs} args - Arguments to filter SupplyOrders to count.
     * @example
     * // Count the number of SupplyOrders
     * const count = await prisma.supplyOrder.count({
     *   where: {
     *     // ... the filter for the SupplyOrders we want to count
     *   }
     * })
    **/
    count<T extends SupplyOrderCountArgs>(
      args?: Subset<T, SupplyOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplyOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplyOrderAggregateArgs>(args: Subset<T, SupplyOrderAggregateArgs>): Prisma.PrismaPromise<GetSupplyOrderAggregateType<T>>

    /**
     * Group by SupplyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplyOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplyOrderGroupByArgs['orderBy'] }
        : { orderBy?: SupplyOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplyOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplyOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplyOrder model
   */
  readonly fields: SupplyOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplyOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplyOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplyOrder model
   */ 
  interface SupplyOrderFieldRefs {
    readonly id: FieldRef<"SupplyOrder", 'String'>
    readonly patientId: FieldRef<"SupplyOrder", 'String'>
    readonly orderedBy: FieldRef<"SupplyOrder", 'String'>
    readonly items: FieldRef<"SupplyOrder", 'Json'>
    readonly totalCost: FieldRef<"SupplyOrder", 'Float'>
    readonly status: FieldRef<"SupplyOrder", 'SupplyOrderStatus'>
    readonly orderedAt: FieldRef<"SupplyOrder", 'DateTime'>
    readonly expectedDelivery: FieldRef<"SupplyOrder", 'DateTime'>
    readonly deliveredAt: FieldRef<"SupplyOrder", 'DateTime'>
    readonly deliveryNotes: FieldRef<"SupplyOrder", 'String'>
    readonly createdAt: FieldRef<"SupplyOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplyOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplyOrder findUnique
   */
  export type SupplyOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * Filter, which SupplyOrder to fetch.
     */
    where: SupplyOrderWhereUniqueInput
  }

  /**
   * SupplyOrder findUniqueOrThrow
   */
  export type SupplyOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * Filter, which SupplyOrder to fetch.
     */
    where: SupplyOrderWhereUniqueInput
  }

  /**
   * SupplyOrder findFirst
   */
  export type SupplyOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * Filter, which SupplyOrder to fetch.
     */
    where?: SupplyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyOrders to fetch.
     */
    orderBy?: SupplyOrderOrderByWithRelationInput | SupplyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplyOrders.
     */
    cursor?: SupplyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplyOrders.
     */
    distinct?: SupplyOrderScalarFieldEnum | SupplyOrderScalarFieldEnum[]
  }

  /**
   * SupplyOrder findFirstOrThrow
   */
  export type SupplyOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * Filter, which SupplyOrder to fetch.
     */
    where?: SupplyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyOrders to fetch.
     */
    orderBy?: SupplyOrderOrderByWithRelationInput | SupplyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplyOrders.
     */
    cursor?: SupplyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplyOrders.
     */
    distinct?: SupplyOrderScalarFieldEnum | SupplyOrderScalarFieldEnum[]
  }

  /**
   * SupplyOrder findMany
   */
  export type SupplyOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * Filter, which SupplyOrders to fetch.
     */
    where?: SupplyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyOrders to fetch.
     */
    orderBy?: SupplyOrderOrderByWithRelationInput | SupplyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplyOrders.
     */
    cursor?: SupplyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyOrders.
     */
    skip?: number
    distinct?: SupplyOrderScalarFieldEnum | SupplyOrderScalarFieldEnum[]
  }

  /**
   * SupplyOrder create
   */
  export type SupplyOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * The data needed to create a SupplyOrder.
     */
    data: XOR<SupplyOrderCreateInput, SupplyOrderUncheckedCreateInput>
  }

  /**
   * SupplyOrder createMany
   */
  export type SupplyOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplyOrders.
     */
    data: SupplyOrderCreateManyInput | SupplyOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplyOrder createManyAndReturn
   */
  export type SupplyOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupplyOrders.
     */
    data: SupplyOrderCreateManyInput | SupplyOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplyOrder update
   */
  export type SupplyOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * The data needed to update a SupplyOrder.
     */
    data: XOR<SupplyOrderUpdateInput, SupplyOrderUncheckedUpdateInput>
    /**
     * Choose, which SupplyOrder to update.
     */
    where: SupplyOrderWhereUniqueInput
  }

  /**
   * SupplyOrder updateMany
   */
  export type SupplyOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplyOrders.
     */
    data: XOR<SupplyOrderUpdateManyMutationInput, SupplyOrderUncheckedUpdateManyInput>
    /**
     * Filter which SupplyOrders to update
     */
    where?: SupplyOrderWhereInput
  }

  /**
   * SupplyOrder upsert
   */
  export type SupplyOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * The filter to search for the SupplyOrder to update in case it exists.
     */
    where: SupplyOrderWhereUniqueInput
    /**
     * In case the SupplyOrder found by the `where` argument doesn't exist, create a new SupplyOrder with this data.
     */
    create: XOR<SupplyOrderCreateInput, SupplyOrderUncheckedCreateInput>
    /**
     * In case the SupplyOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplyOrderUpdateInput, SupplyOrderUncheckedUpdateInput>
  }

  /**
   * SupplyOrder delete
   */
  export type SupplyOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
    /**
     * Filter which SupplyOrder to delete.
     */
    where: SupplyOrderWhereUniqueInput
  }

  /**
   * SupplyOrder deleteMany
   */
  export type SupplyOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplyOrders to delete
     */
    where?: SupplyOrderWhereInput
  }

  /**
   * SupplyOrder without action
   */
  export type SupplyOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyOrder
     */
    select?: SupplyOrderSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CaregiverScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    licenseNumber: 'licenseNumber',
    licenseType: 'licenseType',
    licenseExpiry: 'licenseExpiry',
    certifications: 'certifications',
    specialties: 'specialties',
    languages: 'languages',
    status: 'status',
    hourlyRate: 'hourlyRate',
    maxDailyVisits: 'maxDailyVisits',
    maxWeeklyHours: 'maxWeeklyHours',
    currentLatitude: 'currentLatitude',
    currentLongitude: 'currentLongitude',
    lastLocationUpdate: 'lastLocationUpdate',
    homeLatitude: 'homeLatitude',
    homeLongitude: 'homeLongitude',
    homeAddress: 'homeAddress',
    serviceRadius: 'serviceRadius',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CaregiverScalarFieldEnum = (typeof CaregiverScalarFieldEnum)[keyof typeof CaregiverScalarFieldEnum]


  export const CaregiverScheduleScalarFieldEnum: {
    id: 'id',
    caregiverId: 'caregiverId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    isAvailable: 'isAvailable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CaregiverScheduleScalarFieldEnum = (typeof CaregiverScheduleScalarFieldEnum)[keyof typeof CaregiverScheduleScalarFieldEnum]


  export const PatientHomeScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    address: 'address',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    latitude: 'latitude',
    longitude: 'longitude',
    accessInstructions: 'accessInstructions',
    gateCode: 'gateCode',
    parkingInfo: 'parkingInfo',
    petInfo: 'petInfo',
    emergencyContact: 'emergencyContact',
    emergencyPhone: 'emergencyPhone',
    homeType: 'homeType',
    hasStairs: 'hasStairs',
    wheelchairAccessible: 'wheelchairAccessible',
    oxygenInHome: 'oxygenInHome',
    safetyHazards: 'safetyHazards',
    specialEquipment: 'specialEquipment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientHomeScalarFieldEnum = (typeof PatientHomeScalarFieldEnum)[keyof typeof PatientHomeScalarFieldEnum]


  export const HomeVisitScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patientHomeId: 'patientHomeId',
    caregiverId: 'caregiverId',
    scheduledDate: 'scheduledDate',
    scheduledStartTime: 'scheduledStartTime',
    scheduledEndTime: 'scheduledEndTime',
    estimatedDuration: 'estimatedDuration',
    priority: 'priority',
    visitType: 'visitType',
    status: 'status',
    actualStartTime: 'actualStartTime',
    actualEndTime: 'actualEndTime',
    actualDuration: 'actualDuration',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    reasonForVisit: 'reasonForVisit',
    clinicalNotes: 'clinicalNotes',
    patientCondition: 'patientCondition',
    followUpRequired: 'followUpRequired',
    followUpNotes: 'followUpNotes',
    caregiverSignature: 'caregiverSignature',
    patientSignature: 'patientSignature',
    signedAt: 'signedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HomeVisitScalarFieldEnum = (typeof HomeVisitScalarFieldEnum)[keyof typeof HomeVisitScalarFieldEnum]


  export const VisitTaskScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    taskType: 'taskType',
    title: 'title',
    description: 'description',
    isRequired: 'isRequired',
    sequence: 'sequence',
    status: 'status',
    completedAt: 'completedAt',
    completedBy: 'completedBy',
    notes: 'notes',
    vitalType: 'vitalType',
    vitalValue: 'vitalValue',
    vitalUnit: 'vitalUnit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitTaskScalarFieldEnum = (typeof VisitTaskScalarFieldEnum)[keyof typeof VisitTaskScalarFieldEnum]


  export const EVVRecordScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    recordType: 'recordType',
    timestamp: 'timestamp',
    latitude: 'latitude',
    longitude: 'longitude',
    accuracy: 'accuracy',
    deviceId: 'deviceId',
    deviceType: 'deviceType',
    ipAddress: 'ipAddress',
    isVerified: 'isVerified',
    verificationMethod: 'verificationMethod',
    verificationNotes: 'verificationNotes',
    distanceFromHome: 'distanceFromHome',
    isWithinGeofence: 'isWithinGeofence',
    geofenceRadius: 'geofenceRadius',
    createdAt: 'createdAt'
  };

  export type EVVRecordScalarFieldEnum = (typeof EVVRecordScalarFieldEnum)[keyof typeof EVVRecordScalarFieldEnum]


  export const TimeEntryScalarFieldEnum: {
    id: 'id',
    caregiverId: 'caregiverId',
    visitId: 'visitId',
    entryType: 'entryType',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeEntryScalarFieldEnum = (typeof TimeEntryScalarFieldEnum)[keyof typeof TimeEntryScalarFieldEnum]


  export const MileageEntryScalarFieldEnum: {
    id: 'id',
    caregiverId: 'caregiverId',
    date: 'date',
    startAddress: 'startAddress',
    endAddress: 'endAddress',
    distance: 'distance',
    purpose: 'purpose',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    routeData: 'routeData',
    ratePerMile: 'ratePerMile',
    totalAmount: 'totalAmount',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MileageEntryScalarFieldEnum = (typeof MileageEntryScalarFieldEnum)[keyof typeof MileageEntryScalarFieldEnum]


  export const HomeAssessmentScalarFieldEnum: {
    id: 'id',
    patientHomeId: 'patientHomeId',
    assessorId: 'assessorId',
    assessmentDate: 'assessmentDate',
    safetyScore: 'safetyScore',
    fallRisk: 'fallRisk',
    fireRisk: 'fireRisk',
    infectionRisk: 'infectionRisk',
    cleanlinessScore: 'cleanlinessScore',
    adequateLighting: 'adequateLighting',
    adequateVentilation: 'adequateVentilation',
    workingUtilities: 'workingUtilities',
    bathroomAccessible: 'bathroomAccessible',
    bedroomAccessible: 'bedroomAccessible',
    kitchenAccessible: 'kitchenAccessible',
    recommendations: 'recommendations',
    requiredEquipment: 'requiredEquipment',
    followUpDate: 'followUpDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HomeAssessmentScalarFieldEnum = (typeof HomeAssessmentScalarFieldEnum)[keyof typeof HomeAssessmentScalarFieldEnum]


  export const MedicationAdministrationScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    medicationName: 'medicationName',
    dosage: 'dosage',
    route: 'route',
    scheduledTime: 'scheduledTime',
    administeredTime: 'administeredTime',
    status: 'status',
    refusedReason: 'refusedReason',
    notes: 'notes',
    administeredBy: 'administeredBy',
    witnessedBy: 'witnessedBy',
    medicationBarcode: 'medicationBarcode',
    patientBarcode: 'patientBarcode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationAdministrationScalarFieldEnum = (typeof MedicationAdministrationScalarFieldEnum)[keyof typeof MedicationAdministrationScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    patientId: 'patientId',
    caregiverId: 'caregiverId',
    incidentType: 'incidentType',
    severity: 'severity',
    occurredAt: 'occurredAt',
    location: 'location',
    description: 'description',
    immediateAction: 'immediateAction',
    witnessNames: 'witnessNames',
    fallType: 'fallType',
    injuryOccurred: 'injuryOccurred',
    injuryDescription: 'injuryDescription',
    medicalAttentionRequired: 'medicalAttentionRequired',
    emergencyServicesNotified: 'emergencyServicesNotified',
    status: 'status',
    investigatedBy: 'investigatedBy',
    investigatedAt: 'investigatedAt',
    rootCause: 'rootCause',
    preventiveMeasures: 'preventiveMeasures',
    familyNotified: 'familyNotified',
    physicianNotified: 'physicianNotified',
    supervisorNotified: 'supervisorNotified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const VisitDocumentationScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    documentType: 'documentType',
    title: 'title',
    content: 'content',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    assessmentData: 'assessmentData',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitDocumentationScalarFieldEnum = (typeof VisitDocumentationScalarFieldEnum)[keyof typeof VisitDocumentationScalarFieldEnum]


  export const PatientEquipmentScalarFieldEnum: {
    id: 'id',
    patientHomeId: 'patientHomeId',
    equipmentType: 'equipmentType',
    name: 'name',
    serialNumber: 'serialNumber',
    manufacturer: 'manufacturer',
    model: 'model',
    status: 'status',
    condition: 'condition',
    deliveredDate: 'deliveredDate',
    expectedReturnDate: 'expectedReturnDate',
    returnedDate: 'returnedDate',
    lastMaintenanceDate: 'lastMaintenanceDate',
    nextMaintenanceDate: 'nextMaintenanceDate',
    maintenanceNotes: 'maintenanceNotes',
    ownershipType: 'ownershipType',
    rentalCompany: 'rentalCompany',
    monthlyRentalCost: 'monthlyRentalCost',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientEquipmentScalarFieldEnum = (typeof PatientEquipmentScalarFieldEnum)[keyof typeof PatientEquipmentScalarFieldEnum]


  export const FamilyCommunicationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    familyMemberId: 'familyMemberId',
    caregiverId: 'caregiverId',
    communicationType: 'communicationType',
    subject: 'subject',
    message: 'message',
    visitId: 'visitId',
    isRead: 'isRead',
    readAt: 'readAt',
    parentMessageId: 'parentMessageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FamilyCommunicationScalarFieldEnum = (typeof FamilyCommunicationScalarFieldEnum)[keyof typeof FamilyCommunicationScalarFieldEnum]


  export const SupplyOrderScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    orderedBy: 'orderedBy',
    items: 'items',
    totalCost: 'totalCost',
    status: 'status',
    orderedAt: 'orderedAt',
    expectedDelivery: 'expectedDelivery',
    deliveredAt: 'deliveredAt',
    deliveryNotes: 'deliveryNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplyOrderScalarFieldEnum = (typeof SupplyOrderScalarFieldEnum)[keyof typeof SupplyOrderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'LicenseType'
   */
  export type EnumLicenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseType'>
    


  /**
   * Reference to a field of type 'LicenseType[]'
   */
  export type ListEnumLicenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'CaregiverStatus'
   */
  export type EnumCaregiverStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaregiverStatus'>
    


  /**
   * Reference to a field of type 'CaregiverStatus[]'
   */
  export type ListEnumCaregiverStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaregiverStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'HomeType'
   */
  export type EnumHomeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HomeType'>
    


  /**
   * Reference to a field of type 'HomeType[]'
   */
  export type ListEnumHomeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HomeType[]'>
    


  /**
   * Reference to a field of type 'VisitPriority'
   */
  export type EnumVisitPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitPriority'>
    


  /**
   * Reference to a field of type 'VisitPriority[]'
   */
  export type ListEnumVisitPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitPriority[]'>
    


  /**
   * Reference to a field of type 'VisitType'
   */
  export type EnumVisitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitType'>
    


  /**
   * Reference to a field of type 'VisitType[]'
   */
  export type ListEnumVisitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitType[]'>
    


  /**
   * Reference to a field of type 'VisitStatus'
   */
  export type EnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus'>
    


  /**
   * Reference to a field of type 'VisitStatus[]'
   */
  export type ListEnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus[]'>
    


  /**
   * Reference to a field of type 'CareTaskType'
   */
  export type EnumCareTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareTaskType'>
    


  /**
   * Reference to a field of type 'CareTaskType[]'
   */
  export type ListEnumCareTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareTaskType[]'>
    


  /**
   * Reference to a field of type 'TaskCompletionStatus'
   */
  export type EnumTaskCompletionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCompletionStatus'>
    


  /**
   * Reference to a field of type 'TaskCompletionStatus[]'
   */
  export type ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCompletionStatus[]'>
    


  /**
   * Reference to a field of type 'EVVRecordType'
   */
  export type EnumEVVRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EVVRecordType'>
    


  /**
   * Reference to a field of type 'EVVRecordType[]'
   */
  export type ListEnumEVVRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EVVRecordType[]'>
    


  /**
   * Reference to a field of type 'EVVVerificationMethod'
   */
  export type EnumEVVVerificationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EVVVerificationMethod'>
    


  /**
   * Reference to a field of type 'EVVVerificationMethod[]'
   */
  export type ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EVVVerificationMethod[]'>
    


  /**
   * Reference to a field of type 'TimeEntryType'
   */
  export type EnumTimeEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeEntryType'>
    


  /**
   * Reference to a field of type 'TimeEntryType[]'
   */
  export type ListEnumTimeEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeEntryType[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    


  /**
   * Reference to a field of type 'MedicationRoute'
   */
  export type EnumMedicationRouteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicationRoute'>
    


  /**
   * Reference to a field of type 'MedicationRoute[]'
   */
  export type ListEnumMedicationRouteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicationRoute[]'>
    


  /**
   * Reference to a field of type 'MedicationStatus'
   */
  export type EnumMedicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicationStatus'>
    


  /**
   * Reference to a field of type 'MedicationStatus[]'
   */
  export type ListEnumMedicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicationStatus[]'>
    


  /**
   * Reference to a field of type 'IncidentType'
   */
  export type EnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType'>
    


  /**
   * Reference to a field of type 'IncidentType[]'
   */
  export type ListEnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType[]'>
    


  /**
   * Reference to a field of type 'IncidentSeverity'
   */
  export type EnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity'>
    


  /**
   * Reference to a field of type 'IncidentSeverity[]'
   */
  export type ListEnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity[]'>
    


  /**
   * Reference to a field of type 'FallType'
   */
  export type EnumFallTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FallType'>
    


  /**
   * Reference to a field of type 'FallType[]'
   */
  export type ListEnumFallTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FallType[]'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'EquipmentType'
   */
  export type EnumEquipmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentType'>
    


  /**
   * Reference to a field of type 'EquipmentType[]'
   */
  export type ListEnumEquipmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentType[]'>
    


  /**
   * Reference to a field of type 'EquipmentStatus'
   */
  export type EnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus'>
    


  /**
   * Reference to a field of type 'EquipmentStatus[]'
   */
  export type ListEnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus[]'>
    


  /**
   * Reference to a field of type 'EquipmentCondition'
   */
  export type EnumEquipmentConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentCondition'>
    


  /**
   * Reference to a field of type 'EquipmentCondition[]'
   */
  export type ListEnumEquipmentConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentCondition[]'>
    


  /**
   * Reference to a field of type 'OwnershipType'
   */
  export type EnumOwnershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnershipType'>
    


  /**
   * Reference to a field of type 'OwnershipType[]'
   */
  export type ListEnumOwnershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnershipType[]'>
    


  /**
   * Reference to a field of type 'CommunicationType'
   */
  export type EnumCommunicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationType'>
    


  /**
   * Reference to a field of type 'CommunicationType[]'
   */
  export type ListEnumCommunicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationType[]'>
    


  /**
   * Reference to a field of type 'SupplyOrderStatus'
   */
  export type EnumSupplyOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupplyOrderStatus'>
    


  /**
   * Reference to a field of type 'SupplyOrderStatus[]'
   */
  export type ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupplyOrderStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CaregiverWhereInput = {
    AND?: CaregiverWhereInput | CaregiverWhereInput[]
    OR?: CaregiverWhereInput[]
    NOT?: CaregiverWhereInput | CaregiverWhereInput[]
    id?: StringFilter<"Caregiver"> | string
    userId?: StringFilter<"Caregiver"> | string
    firstName?: StringFilter<"Caregiver"> | string
    lastName?: StringFilter<"Caregiver"> | string
    email?: StringFilter<"Caregiver"> | string
    phone?: StringFilter<"Caregiver"> | string
    licenseNumber?: StringNullableFilter<"Caregiver"> | string | null
    licenseType?: EnumLicenseTypeNullableFilter<"Caregiver"> | $Enums.LicenseType | null
    licenseExpiry?: DateTimeNullableFilter<"Caregiver"> | Date | string | null
    certifications?: JsonNullableFilter<"Caregiver">
    specialties?: StringNullableListFilter<"Caregiver">
    languages?: StringNullableListFilter<"Caregiver">
    status?: EnumCaregiverStatusFilter<"Caregiver"> | $Enums.CaregiverStatus
    hourlyRate?: FloatNullableFilter<"Caregiver"> | number | null
    maxDailyVisits?: IntFilter<"Caregiver"> | number
    maxWeeklyHours?: FloatFilter<"Caregiver"> | number
    currentLatitude?: FloatNullableFilter<"Caregiver"> | number | null
    currentLongitude?: FloatNullableFilter<"Caregiver"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Caregiver"> | Date | string | null
    homeLatitude?: FloatNullableFilter<"Caregiver"> | number | null
    homeLongitude?: FloatNullableFilter<"Caregiver"> | number | null
    homeAddress?: StringNullableFilter<"Caregiver"> | string | null
    serviceRadius?: FloatFilter<"Caregiver"> | number
    createdAt?: DateTimeFilter<"Caregiver"> | Date | string
    updatedAt?: DateTimeFilter<"Caregiver"> | Date | string
    visits?: HomeVisitListRelationFilter
    schedules?: CaregiverScheduleListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
    mileageEntries?: MileageEntryListRelationFilter
  }

  export type CaregiverOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseType?: SortOrderInput | SortOrder
    licenseExpiry?: SortOrderInput | SortOrder
    certifications?: SortOrderInput | SortOrder
    specialties?: SortOrder
    languages?: SortOrder
    status?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    maxDailyVisits?: SortOrder
    maxWeeklyHours?: SortOrder
    currentLatitude?: SortOrderInput | SortOrder
    currentLongitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    homeLatitude?: SortOrderInput | SortOrder
    homeLongitude?: SortOrderInput | SortOrder
    homeAddress?: SortOrderInput | SortOrder
    serviceRadius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: HomeVisitOrderByRelationAggregateInput
    schedules?: CaregiverScheduleOrderByRelationAggregateInput
    timeEntries?: TimeEntryOrderByRelationAggregateInput
    mileageEntries?: MileageEntryOrderByRelationAggregateInput
  }

  export type CaregiverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    email?: string
    AND?: CaregiverWhereInput | CaregiverWhereInput[]
    OR?: CaregiverWhereInput[]
    NOT?: CaregiverWhereInput | CaregiverWhereInput[]
    firstName?: StringFilter<"Caregiver"> | string
    lastName?: StringFilter<"Caregiver"> | string
    phone?: StringFilter<"Caregiver"> | string
    licenseNumber?: StringNullableFilter<"Caregiver"> | string | null
    licenseType?: EnumLicenseTypeNullableFilter<"Caregiver"> | $Enums.LicenseType | null
    licenseExpiry?: DateTimeNullableFilter<"Caregiver"> | Date | string | null
    certifications?: JsonNullableFilter<"Caregiver">
    specialties?: StringNullableListFilter<"Caregiver">
    languages?: StringNullableListFilter<"Caregiver">
    status?: EnumCaregiverStatusFilter<"Caregiver"> | $Enums.CaregiverStatus
    hourlyRate?: FloatNullableFilter<"Caregiver"> | number | null
    maxDailyVisits?: IntFilter<"Caregiver"> | number
    maxWeeklyHours?: FloatFilter<"Caregiver"> | number
    currentLatitude?: FloatNullableFilter<"Caregiver"> | number | null
    currentLongitude?: FloatNullableFilter<"Caregiver"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Caregiver"> | Date | string | null
    homeLatitude?: FloatNullableFilter<"Caregiver"> | number | null
    homeLongitude?: FloatNullableFilter<"Caregiver"> | number | null
    homeAddress?: StringNullableFilter<"Caregiver"> | string | null
    serviceRadius?: FloatFilter<"Caregiver"> | number
    createdAt?: DateTimeFilter<"Caregiver"> | Date | string
    updatedAt?: DateTimeFilter<"Caregiver"> | Date | string
    visits?: HomeVisitListRelationFilter
    schedules?: CaregiverScheduleListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
    mileageEntries?: MileageEntryListRelationFilter
  }, "id" | "userId" | "email">

  export type CaregiverOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseType?: SortOrderInput | SortOrder
    licenseExpiry?: SortOrderInput | SortOrder
    certifications?: SortOrderInput | SortOrder
    specialties?: SortOrder
    languages?: SortOrder
    status?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    maxDailyVisits?: SortOrder
    maxWeeklyHours?: SortOrder
    currentLatitude?: SortOrderInput | SortOrder
    currentLongitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    homeLatitude?: SortOrderInput | SortOrder
    homeLongitude?: SortOrderInput | SortOrder
    homeAddress?: SortOrderInput | SortOrder
    serviceRadius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CaregiverCountOrderByAggregateInput
    _avg?: CaregiverAvgOrderByAggregateInput
    _max?: CaregiverMaxOrderByAggregateInput
    _min?: CaregiverMinOrderByAggregateInput
    _sum?: CaregiverSumOrderByAggregateInput
  }

  export type CaregiverScalarWhereWithAggregatesInput = {
    AND?: CaregiverScalarWhereWithAggregatesInput | CaregiverScalarWhereWithAggregatesInput[]
    OR?: CaregiverScalarWhereWithAggregatesInput[]
    NOT?: CaregiverScalarWhereWithAggregatesInput | CaregiverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Caregiver"> | string
    userId?: StringWithAggregatesFilter<"Caregiver"> | string
    firstName?: StringWithAggregatesFilter<"Caregiver"> | string
    lastName?: StringWithAggregatesFilter<"Caregiver"> | string
    email?: StringWithAggregatesFilter<"Caregiver"> | string
    phone?: StringWithAggregatesFilter<"Caregiver"> | string
    licenseNumber?: StringNullableWithAggregatesFilter<"Caregiver"> | string | null
    licenseType?: EnumLicenseTypeNullableWithAggregatesFilter<"Caregiver"> | $Enums.LicenseType | null
    licenseExpiry?: DateTimeNullableWithAggregatesFilter<"Caregiver"> | Date | string | null
    certifications?: JsonNullableWithAggregatesFilter<"Caregiver">
    specialties?: StringNullableListFilter<"Caregiver">
    languages?: StringNullableListFilter<"Caregiver">
    status?: EnumCaregiverStatusWithAggregatesFilter<"Caregiver"> | $Enums.CaregiverStatus
    hourlyRate?: FloatNullableWithAggregatesFilter<"Caregiver"> | number | null
    maxDailyVisits?: IntWithAggregatesFilter<"Caregiver"> | number
    maxWeeklyHours?: FloatWithAggregatesFilter<"Caregiver"> | number
    currentLatitude?: FloatNullableWithAggregatesFilter<"Caregiver"> | number | null
    currentLongitude?: FloatNullableWithAggregatesFilter<"Caregiver"> | number | null
    lastLocationUpdate?: DateTimeNullableWithAggregatesFilter<"Caregiver"> | Date | string | null
    homeLatitude?: FloatNullableWithAggregatesFilter<"Caregiver"> | number | null
    homeLongitude?: FloatNullableWithAggregatesFilter<"Caregiver"> | number | null
    homeAddress?: StringNullableWithAggregatesFilter<"Caregiver"> | string | null
    serviceRadius?: FloatWithAggregatesFilter<"Caregiver"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Caregiver"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Caregiver"> | Date | string
  }

  export type CaregiverScheduleWhereInput = {
    AND?: CaregiverScheduleWhereInput | CaregiverScheduleWhereInput[]
    OR?: CaregiverScheduleWhereInput[]
    NOT?: CaregiverScheduleWhereInput | CaregiverScheduleWhereInput[]
    id?: StringFilter<"CaregiverSchedule"> | string
    caregiverId?: StringFilter<"CaregiverSchedule"> | string
    dayOfWeek?: IntFilter<"CaregiverSchedule"> | number
    startTime?: StringFilter<"CaregiverSchedule"> | string
    endTime?: StringFilter<"CaregiverSchedule"> | string
    isAvailable?: BoolFilter<"CaregiverSchedule"> | boolean
    createdAt?: DateTimeFilter<"CaregiverSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CaregiverSchedule"> | Date | string
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
  }

  export type CaregiverScheduleOrderByWithRelationInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caregiver?: CaregiverOrderByWithRelationInput
  }

  export type CaregiverScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    caregiverId_dayOfWeek?: CaregiverScheduleCaregiverIdDayOfWeekCompoundUniqueInput
    AND?: CaregiverScheduleWhereInput | CaregiverScheduleWhereInput[]
    OR?: CaregiverScheduleWhereInput[]
    NOT?: CaregiverScheduleWhereInput | CaregiverScheduleWhereInput[]
    caregiverId?: StringFilter<"CaregiverSchedule"> | string
    dayOfWeek?: IntFilter<"CaregiverSchedule"> | number
    startTime?: StringFilter<"CaregiverSchedule"> | string
    endTime?: StringFilter<"CaregiverSchedule"> | string
    isAvailable?: BoolFilter<"CaregiverSchedule"> | boolean
    createdAt?: DateTimeFilter<"CaregiverSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CaregiverSchedule"> | Date | string
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
  }, "id" | "caregiverId_dayOfWeek">

  export type CaregiverScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CaregiverScheduleCountOrderByAggregateInput
    _avg?: CaregiverScheduleAvgOrderByAggregateInput
    _max?: CaregiverScheduleMaxOrderByAggregateInput
    _min?: CaregiverScheduleMinOrderByAggregateInput
    _sum?: CaregiverScheduleSumOrderByAggregateInput
  }

  export type CaregiverScheduleScalarWhereWithAggregatesInput = {
    AND?: CaregiverScheduleScalarWhereWithAggregatesInput | CaregiverScheduleScalarWhereWithAggregatesInput[]
    OR?: CaregiverScheduleScalarWhereWithAggregatesInput[]
    NOT?: CaregiverScheduleScalarWhereWithAggregatesInput | CaregiverScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaregiverSchedule"> | string
    caregiverId?: StringWithAggregatesFilter<"CaregiverSchedule"> | string
    dayOfWeek?: IntWithAggregatesFilter<"CaregiverSchedule"> | number
    startTime?: StringWithAggregatesFilter<"CaregiverSchedule"> | string
    endTime?: StringWithAggregatesFilter<"CaregiverSchedule"> | string
    isAvailable?: BoolWithAggregatesFilter<"CaregiverSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CaregiverSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CaregiverSchedule"> | Date | string
  }

  export type PatientHomeWhereInput = {
    AND?: PatientHomeWhereInput | PatientHomeWhereInput[]
    OR?: PatientHomeWhereInput[]
    NOT?: PatientHomeWhereInput | PatientHomeWhereInput[]
    id?: StringFilter<"PatientHome"> | string
    patientId?: StringFilter<"PatientHome"> | string
    address?: StringFilter<"PatientHome"> | string
    addressLine2?: StringNullableFilter<"PatientHome"> | string | null
    city?: StringFilter<"PatientHome"> | string
    state?: StringFilter<"PatientHome"> | string
    zipCode?: StringFilter<"PatientHome"> | string
    country?: StringFilter<"PatientHome"> | string
    latitude?: FloatNullableFilter<"PatientHome"> | number | null
    longitude?: FloatNullableFilter<"PatientHome"> | number | null
    accessInstructions?: StringNullableFilter<"PatientHome"> | string | null
    gateCode?: StringNullableFilter<"PatientHome"> | string | null
    parkingInfo?: StringNullableFilter<"PatientHome"> | string | null
    petInfo?: StringNullableFilter<"PatientHome"> | string | null
    emergencyContact?: StringNullableFilter<"PatientHome"> | string | null
    emergencyPhone?: StringNullableFilter<"PatientHome"> | string | null
    homeType?: EnumHomeTypeFilter<"PatientHome"> | $Enums.HomeType
    hasStairs?: BoolFilter<"PatientHome"> | boolean
    wheelchairAccessible?: BoolFilter<"PatientHome"> | boolean
    oxygenInHome?: BoolFilter<"PatientHome"> | boolean
    safetyHazards?: StringNullableFilter<"PatientHome"> | string | null
    specialEquipment?: StringNullableListFilter<"PatientHome">
    createdAt?: DateTimeFilter<"PatientHome"> | Date | string
    updatedAt?: DateTimeFilter<"PatientHome"> | Date | string
    visits?: HomeVisitListRelationFilter
    assessments?: HomeAssessmentListRelationFilter
    equipment?: PatientEquipmentListRelationFilter
  }

  export type PatientHomeOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    accessInstructions?: SortOrderInput | SortOrder
    gateCode?: SortOrderInput | SortOrder
    parkingInfo?: SortOrderInput | SortOrder
    petInfo?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    homeType?: SortOrder
    hasStairs?: SortOrder
    wheelchairAccessible?: SortOrder
    oxygenInHome?: SortOrder
    safetyHazards?: SortOrderInput | SortOrder
    specialEquipment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: HomeVisitOrderByRelationAggregateInput
    assessments?: HomeAssessmentOrderByRelationAggregateInput
    equipment?: PatientEquipmentOrderByRelationAggregateInput
  }

  export type PatientHomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patientId?: string
    AND?: PatientHomeWhereInput | PatientHomeWhereInput[]
    OR?: PatientHomeWhereInput[]
    NOT?: PatientHomeWhereInput | PatientHomeWhereInput[]
    address?: StringFilter<"PatientHome"> | string
    addressLine2?: StringNullableFilter<"PatientHome"> | string | null
    city?: StringFilter<"PatientHome"> | string
    state?: StringFilter<"PatientHome"> | string
    zipCode?: StringFilter<"PatientHome"> | string
    country?: StringFilter<"PatientHome"> | string
    latitude?: FloatNullableFilter<"PatientHome"> | number | null
    longitude?: FloatNullableFilter<"PatientHome"> | number | null
    accessInstructions?: StringNullableFilter<"PatientHome"> | string | null
    gateCode?: StringNullableFilter<"PatientHome"> | string | null
    parkingInfo?: StringNullableFilter<"PatientHome"> | string | null
    petInfo?: StringNullableFilter<"PatientHome"> | string | null
    emergencyContact?: StringNullableFilter<"PatientHome"> | string | null
    emergencyPhone?: StringNullableFilter<"PatientHome"> | string | null
    homeType?: EnumHomeTypeFilter<"PatientHome"> | $Enums.HomeType
    hasStairs?: BoolFilter<"PatientHome"> | boolean
    wheelchairAccessible?: BoolFilter<"PatientHome"> | boolean
    oxygenInHome?: BoolFilter<"PatientHome"> | boolean
    safetyHazards?: StringNullableFilter<"PatientHome"> | string | null
    specialEquipment?: StringNullableListFilter<"PatientHome">
    createdAt?: DateTimeFilter<"PatientHome"> | Date | string
    updatedAt?: DateTimeFilter<"PatientHome"> | Date | string
    visits?: HomeVisitListRelationFilter
    assessments?: HomeAssessmentListRelationFilter
    equipment?: PatientEquipmentListRelationFilter
  }, "id" | "patientId">

  export type PatientHomeOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    accessInstructions?: SortOrderInput | SortOrder
    gateCode?: SortOrderInput | SortOrder
    parkingInfo?: SortOrderInput | SortOrder
    petInfo?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    homeType?: SortOrder
    hasStairs?: SortOrder
    wheelchairAccessible?: SortOrder
    oxygenInHome?: SortOrder
    safetyHazards?: SortOrderInput | SortOrder
    specialEquipment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientHomeCountOrderByAggregateInput
    _avg?: PatientHomeAvgOrderByAggregateInput
    _max?: PatientHomeMaxOrderByAggregateInput
    _min?: PatientHomeMinOrderByAggregateInput
    _sum?: PatientHomeSumOrderByAggregateInput
  }

  export type PatientHomeScalarWhereWithAggregatesInput = {
    AND?: PatientHomeScalarWhereWithAggregatesInput | PatientHomeScalarWhereWithAggregatesInput[]
    OR?: PatientHomeScalarWhereWithAggregatesInput[]
    NOT?: PatientHomeScalarWhereWithAggregatesInput | PatientHomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientHome"> | string
    patientId?: StringWithAggregatesFilter<"PatientHome"> | string
    address?: StringWithAggregatesFilter<"PatientHome"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    city?: StringWithAggregatesFilter<"PatientHome"> | string
    state?: StringWithAggregatesFilter<"PatientHome"> | string
    zipCode?: StringWithAggregatesFilter<"PatientHome"> | string
    country?: StringWithAggregatesFilter<"PatientHome"> | string
    latitude?: FloatNullableWithAggregatesFilter<"PatientHome"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"PatientHome"> | number | null
    accessInstructions?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    gateCode?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    parkingInfo?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    petInfo?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    homeType?: EnumHomeTypeWithAggregatesFilter<"PatientHome"> | $Enums.HomeType
    hasStairs?: BoolWithAggregatesFilter<"PatientHome"> | boolean
    wheelchairAccessible?: BoolWithAggregatesFilter<"PatientHome"> | boolean
    oxygenInHome?: BoolWithAggregatesFilter<"PatientHome"> | boolean
    safetyHazards?: StringNullableWithAggregatesFilter<"PatientHome"> | string | null
    specialEquipment?: StringNullableListFilter<"PatientHome">
    createdAt?: DateTimeWithAggregatesFilter<"PatientHome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatientHome"> | Date | string
  }

  export type HomeVisitWhereInput = {
    AND?: HomeVisitWhereInput | HomeVisitWhereInput[]
    OR?: HomeVisitWhereInput[]
    NOT?: HomeVisitWhereInput | HomeVisitWhereInput[]
    id?: StringFilter<"HomeVisit"> | string
    patientId?: StringFilter<"HomeVisit"> | string
    patientHomeId?: StringFilter<"HomeVisit"> | string
    caregiverId?: StringFilter<"HomeVisit"> | string
    scheduledDate?: DateTimeFilter<"HomeVisit"> | Date | string
    scheduledStartTime?: StringFilter<"HomeVisit"> | string
    scheduledEndTime?: StringFilter<"HomeVisit"> | string
    estimatedDuration?: IntFilter<"HomeVisit"> | number
    priority?: EnumVisitPriorityFilter<"HomeVisit"> | $Enums.VisitPriority
    visitType?: EnumVisitTypeFilter<"HomeVisit"> | $Enums.VisitType
    status?: EnumVisitStatusFilter<"HomeVisit"> | $Enums.VisitStatus
    actualStartTime?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    actualDuration?: IntNullableFilter<"HomeVisit"> | number | null
    startLatitude?: FloatNullableFilter<"HomeVisit"> | number | null
    startLongitude?: FloatNullableFilter<"HomeVisit"> | number | null
    endLatitude?: FloatNullableFilter<"HomeVisit"> | number | null
    endLongitude?: FloatNullableFilter<"HomeVisit"> | number | null
    reasonForVisit?: StringNullableFilter<"HomeVisit"> | string | null
    clinicalNotes?: StringNullableFilter<"HomeVisit"> | string | null
    patientCondition?: StringNullableFilter<"HomeVisit"> | string | null
    followUpRequired?: BoolFilter<"HomeVisit"> | boolean
    followUpNotes?: StringNullableFilter<"HomeVisit"> | string | null
    caregiverSignature?: StringNullableFilter<"HomeVisit"> | string | null
    patientSignature?: StringNullableFilter<"HomeVisit"> | string | null
    signedAt?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    createdAt?: DateTimeFilter<"HomeVisit"> | Date | string
    updatedAt?: DateTimeFilter<"HomeVisit"> | Date | string
    patientHome?: XOR<PatientHomeRelationFilter, PatientHomeWhereInput>
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
    tasks?: VisitTaskListRelationFilter
    evvRecords?: EVVRecordListRelationFilter
    medications?: MedicationAdministrationListRelationFilter
    incidents?: IncidentListRelationFilter
    documentation?: VisitDocumentationListRelationFilter
  }

  export type HomeVisitOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    patientHomeId?: SortOrder
    caregiverId?: SortOrder
    scheduledDate?: SortOrder
    scheduledStartTime?: SortOrder
    scheduledEndTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    visitType?: SortOrder
    status?: SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    reasonForVisit?: SortOrderInput | SortOrder
    clinicalNotes?: SortOrderInput | SortOrder
    patientCondition?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    caregiverSignature?: SortOrderInput | SortOrder
    patientSignature?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientHome?: PatientHomeOrderByWithRelationInput
    caregiver?: CaregiverOrderByWithRelationInput
    tasks?: VisitTaskOrderByRelationAggregateInput
    evvRecords?: EVVRecordOrderByRelationAggregateInput
    medications?: MedicationAdministrationOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    documentation?: VisitDocumentationOrderByRelationAggregateInput
  }

  export type HomeVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomeVisitWhereInput | HomeVisitWhereInput[]
    OR?: HomeVisitWhereInput[]
    NOT?: HomeVisitWhereInput | HomeVisitWhereInput[]
    patientId?: StringFilter<"HomeVisit"> | string
    patientHomeId?: StringFilter<"HomeVisit"> | string
    caregiverId?: StringFilter<"HomeVisit"> | string
    scheduledDate?: DateTimeFilter<"HomeVisit"> | Date | string
    scheduledStartTime?: StringFilter<"HomeVisit"> | string
    scheduledEndTime?: StringFilter<"HomeVisit"> | string
    estimatedDuration?: IntFilter<"HomeVisit"> | number
    priority?: EnumVisitPriorityFilter<"HomeVisit"> | $Enums.VisitPriority
    visitType?: EnumVisitTypeFilter<"HomeVisit"> | $Enums.VisitType
    status?: EnumVisitStatusFilter<"HomeVisit"> | $Enums.VisitStatus
    actualStartTime?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    actualDuration?: IntNullableFilter<"HomeVisit"> | number | null
    startLatitude?: FloatNullableFilter<"HomeVisit"> | number | null
    startLongitude?: FloatNullableFilter<"HomeVisit"> | number | null
    endLatitude?: FloatNullableFilter<"HomeVisit"> | number | null
    endLongitude?: FloatNullableFilter<"HomeVisit"> | number | null
    reasonForVisit?: StringNullableFilter<"HomeVisit"> | string | null
    clinicalNotes?: StringNullableFilter<"HomeVisit"> | string | null
    patientCondition?: StringNullableFilter<"HomeVisit"> | string | null
    followUpRequired?: BoolFilter<"HomeVisit"> | boolean
    followUpNotes?: StringNullableFilter<"HomeVisit"> | string | null
    caregiverSignature?: StringNullableFilter<"HomeVisit"> | string | null
    patientSignature?: StringNullableFilter<"HomeVisit"> | string | null
    signedAt?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    createdAt?: DateTimeFilter<"HomeVisit"> | Date | string
    updatedAt?: DateTimeFilter<"HomeVisit"> | Date | string
    patientHome?: XOR<PatientHomeRelationFilter, PatientHomeWhereInput>
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
    tasks?: VisitTaskListRelationFilter
    evvRecords?: EVVRecordListRelationFilter
    medications?: MedicationAdministrationListRelationFilter
    incidents?: IncidentListRelationFilter
    documentation?: VisitDocumentationListRelationFilter
  }, "id">

  export type HomeVisitOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    patientHomeId?: SortOrder
    caregiverId?: SortOrder
    scheduledDate?: SortOrder
    scheduledStartTime?: SortOrder
    scheduledEndTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    visitType?: SortOrder
    status?: SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    reasonForVisit?: SortOrderInput | SortOrder
    clinicalNotes?: SortOrderInput | SortOrder
    patientCondition?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    caregiverSignature?: SortOrderInput | SortOrder
    patientSignature?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HomeVisitCountOrderByAggregateInput
    _avg?: HomeVisitAvgOrderByAggregateInput
    _max?: HomeVisitMaxOrderByAggregateInput
    _min?: HomeVisitMinOrderByAggregateInput
    _sum?: HomeVisitSumOrderByAggregateInput
  }

  export type HomeVisitScalarWhereWithAggregatesInput = {
    AND?: HomeVisitScalarWhereWithAggregatesInput | HomeVisitScalarWhereWithAggregatesInput[]
    OR?: HomeVisitScalarWhereWithAggregatesInput[]
    NOT?: HomeVisitScalarWhereWithAggregatesInput | HomeVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomeVisit"> | string
    patientId?: StringWithAggregatesFilter<"HomeVisit"> | string
    patientHomeId?: StringWithAggregatesFilter<"HomeVisit"> | string
    caregiverId?: StringWithAggregatesFilter<"HomeVisit"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"HomeVisit"> | Date | string
    scheduledStartTime?: StringWithAggregatesFilter<"HomeVisit"> | string
    scheduledEndTime?: StringWithAggregatesFilter<"HomeVisit"> | string
    estimatedDuration?: IntWithAggregatesFilter<"HomeVisit"> | number
    priority?: EnumVisitPriorityWithAggregatesFilter<"HomeVisit"> | $Enums.VisitPriority
    visitType?: EnumVisitTypeWithAggregatesFilter<"HomeVisit"> | $Enums.VisitType
    status?: EnumVisitStatusWithAggregatesFilter<"HomeVisit"> | $Enums.VisitStatus
    actualStartTime?: DateTimeNullableWithAggregatesFilter<"HomeVisit"> | Date | string | null
    actualEndTime?: DateTimeNullableWithAggregatesFilter<"HomeVisit"> | Date | string | null
    actualDuration?: IntNullableWithAggregatesFilter<"HomeVisit"> | number | null
    startLatitude?: FloatNullableWithAggregatesFilter<"HomeVisit"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"HomeVisit"> | number | null
    endLatitude?: FloatNullableWithAggregatesFilter<"HomeVisit"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"HomeVisit"> | number | null
    reasonForVisit?: StringNullableWithAggregatesFilter<"HomeVisit"> | string | null
    clinicalNotes?: StringNullableWithAggregatesFilter<"HomeVisit"> | string | null
    patientCondition?: StringNullableWithAggregatesFilter<"HomeVisit"> | string | null
    followUpRequired?: BoolWithAggregatesFilter<"HomeVisit"> | boolean
    followUpNotes?: StringNullableWithAggregatesFilter<"HomeVisit"> | string | null
    caregiverSignature?: StringNullableWithAggregatesFilter<"HomeVisit"> | string | null
    patientSignature?: StringNullableWithAggregatesFilter<"HomeVisit"> | string | null
    signedAt?: DateTimeNullableWithAggregatesFilter<"HomeVisit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HomeVisit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HomeVisit"> | Date | string
  }

  export type VisitTaskWhereInput = {
    AND?: VisitTaskWhereInput | VisitTaskWhereInput[]
    OR?: VisitTaskWhereInput[]
    NOT?: VisitTaskWhereInput | VisitTaskWhereInput[]
    id?: StringFilter<"VisitTask"> | string
    visitId?: StringFilter<"VisitTask"> | string
    taskType?: EnumCareTaskTypeFilter<"VisitTask"> | $Enums.CareTaskType
    title?: StringFilter<"VisitTask"> | string
    description?: StringNullableFilter<"VisitTask"> | string | null
    isRequired?: BoolFilter<"VisitTask"> | boolean
    sequence?: IntFilter<"VisitTask"> | number
    status?: EnumTaskCompletionStatusFilter<"VisitTask"> | $Enums.TaskCompletionStatus
    completedAt?: DateTimeNullableFilter<"VisitTask"> | Date | string | null
    completedBy?: StringNullableFilter<"VisitTask"> | string | null
    notes?: StringNullableFilter<"VisitTask"> | string | null
    vitalType?: StringNullableFilter<"VisitTask"> | string | null
    vitalValue?: FloatNullableFilter<"VisitTask"> | number | null
    vitalUnit?: StringNullableFilter<"VisitTask"> | string | null
    createdAt?: DateTimeFilter<"VisitTask"> | Date | string
    updatedAt?: DateTimeFilter<"VisitTask"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }

  export type VisitTaskOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    vitalType?: SortOrderInput | SortOrder
    vitalValue?: SortOrderInput | SortOrder
    vitalUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visit?: HomeVisitOrderByWithRelationInput
  }

  export type VisitTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitTaskWhereInput | VisitTaskWhereInput[]
    OR?: VisitTaskWhereInput[]
    NOT?: VisitTaskWhereInput | VisitTaskWhereInput[]
    visitId?: StringFilter<"VisitTask"> | string
    taskType?: EnumCareTaskTypeFilter<"VisitTask"> | $Enums.CareTaskType
    title?: StringFilter<"VisitTask"> | string
    description?: StringNullableFilter<"VisitTask"> | string | null
    isRequired?: BoolFilter<"VisitTask"> | boolean
    sequence?: IntFilter<"VisitTask"> | number
    status?: EnumTaskCompletionStatusFilter<"VisitTask"> | $Enums.TaskCompletionStatus
    completedAt?: DateTimeNullableFilter<"VisitTask"> | Date | string | null
    completedBy?: StringNullableFilter<"VisitTask"> | string | null
    notes?: StringNullableFilter<"VisitTask"> | string | null
    vitalType?: StringNullableFilter<"VisitTask"> | string | null
    vitalValue?: FloatNullableFilter<"VisitTask"> | number | null
    vitalUnit?: StringNullableFilter<"VisitTask"> | string | null
    createdAt?: DateTimeFilter<"VisitTask"> | Date | string
    updatedAt?: DateTimeFilter<"VisitTask"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }, "id">

  export type VisitTaskOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    vitalType?: SortOrderInput | SortOrder
    vitalValue?: SortOrderInput | SortOrder
    vitalUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitTaskCountOrderByAggregateInput
    _avg?: VisitTaskAvgOrderByAggregateInput
    _max?: VisitTaskMaxOrderByAggregateInput
    _min?: VisitTaskMinOrderByAggregateInput
    _sum?: VisitTaskSumOrderByAggregateInput
  }

  export type VisitTaskScalarWhereWithAggregatesInput = {
    AND?: VisitTaskScalarWhereWithAggregatesInput | VisitTaskScalarWhereWithAggregatesInput[]
    OR?: VisitTaskScalarWhereWithAggregatesInput[]
    NOT?: VisitTaskScalarWhereWithAggregatesInput | VisitTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitTask"> | string
    visitId?: StringWithAggregatesFilter<"VisitTask"> | string
    taskType?: EnumCareTaskTypeWithAggregatesFilter<"VisitTask"> | $Enums.CareTaskType
    title?: StringWithAggregatesFilter<"VisitTask"> | string
    description?: StringNullableWithAggregatesFilter<"VisitTask"> | string | null
    isRequired?: BoolWithAggregatesFilter<"VisitTask"> | boolean
    sequence?: IntWithAggregatesFilter<"VisitTask"> | number
    status?: EnumTaskCompletionStatusWithAggregatesFilter<"VisitTask"> | $Enums.TaskCompletionStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"VisitTask"> | Date | string | null
    completedBy?: StringNullableWithAggregatesFilter<"VisitTask"> | string | null
    notes?: StringNullableWithAggregatesFilter<"VisitTask"> | string | null
    vitalType?: StringNullableWithAggregatesFilter<"VisitTask"> | string | null
    vitalValue?: FloatNullableWithAggregatesFilter<"VisitTask"> | number | null
    vitalUnit?: StringNullableWithAggregatesFilter<"VisitTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VisitTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VisitTask"> | Date | string
  }

  export type EVVRecordWhereInput = {
    AND?: EVVRecordWhereInput | EVVRecordWhereInput[]
    OR?: EVVRecordWhereInput[]
    NOT?: EVVRecordWhereInput | EVVRecordWhereInput[]
    id?: StringFilter<"EVVRecord"> | string
    visitId?: StringFilter<"EVVRecord"> | string
    recordType?: EnumEVVRecordTypeFilter<"EVVRecord"> | $Enums.EVVRecordType
    timestamp?: DateTimeFilter<"EVVRecord"> | Date | string
    latitude?: FloatFilter<"EVVRecord"> | number
    longitude?: FloatFilter<"EVVRecord"> | number
    accuracy?: FloatNullableFilter<"EVVRecord"> | number | null
    deviceId?: StringNullableFilter<"EVVRecord"> | string | null
    deviceType?: StringNullableFilter<"EVVRecord"> | string | null
    ipAddress?: StringNullableFilter<"EVVRecord"> | string | null
    isVerified?: BoolFilter<"EVVRecord"> | boolean
    verificationMethod?: EnumEVVVerificationMethodFilter<"EVVRecord"> | $Enums.EVVVerificationMethod
    verificationNotes?: StringNullableFilter<"EVVRecord"> | string | null
    distanceFromHome?: FloatNullableFilter<"EVVRecord"> | number | null
    isWithinGeofence?: BoolFilter<"EVVRecord"> | boolean
    geofenceRadius?: FloatFilter<"EVVRecord"> | number
    createdAt?: DateTimeFilter<"EVVRecord"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }

  export type EVVRecordOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    recordType?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    distanceFromHome?: SortOrderInput | SortOrder
    isWithinGeofence?: SortOrder
    geofenceRadius?: SortOrder
    createdAt?: SortOrder
    visit?: HomeVisitOrderByWithRelationInput
  }

  export type EVVRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EVVRecordWhereInput | EVVRecordWhereInput[]
    OR?: EVVRecordWhereInput[]
    NOT?: EVVRecordWhereInput | EVVRecordWhereInput[]
    visitId?: StringFilter<"EVVRecord"> | string
    recordType?: EnumEVVRecordTypeFilter<"EVVRecord"> | $Enums.EVVRecordType
    timestamp?: DateTimeFilter<"EVVRecord"> | Date | string
    latitude?: FloatFilter<"EVVRecord"> | number
    longitude?: FloatFilter<"EVVRecord"> | number
    accuracy?: FloatNullableFilter<"EVVRecord"> | number | null
    deviceId?: StringNullableFilter<"EVVRecord"> | string | null
    deviceType?: StringNullableFilter<"EVVRecord"> | string | null
    ipAddress?: StringNullableFilter<"EVVRecord"> | string | null
    isVerified?: BoolFilter<"EVVRecord"> | boolean
    verificationMethod?: EnumEVVVerificationMethodFilter<"EVVRecord"> | $Enums.EVVVerificationMethod
    verificationNotes?: StringNullableFilter<"EVVRecord"> | string | null
    distanceFromHome?: FloatNullableFilter<"EVVRecord"> | number | null
    isWithinGeofence?: BoolFilter<"EVVRecord"> | boolean
    geofenceRadius?: FloatFilter<"EVVRecord"> | number
    createdAt?: DateTimeFilter<"EVVRecord"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }, "id">

  export type EVVRecordOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    recordType?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    distanceFromHome?: SortOrderInput | SortOrder
    isWithinGeofence?: SortOrder
    geofenceRadius?: SortOrder
    createdAt?: SortOrder
    _count?: EVVRecordCountOrderByAggregateInput
    _avg?: EVVRecordAvgOrderByAggregateInput
    _max?: EVVRecordMaxOrderByAggregateInput
    _min?: EVVRecordMinOrderByAggregateInput
    _sum?: EVVRecordSumOrderByAggregateInput
  }

  export type EVVRecordScalarWhereWithAggregatesInput = {
    AND?: EVVRecordScalarWhereWithAggregatesInput | EVVRecordScalarWhereWithAggregatesInput[]
    OR?: EVVRecordScalarWhereWithAggregatesInput[]
    NOT?: EVVRecordScalarWhereWithAggregatesInput | EVVRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EVVRecord"> | string
    visitId?: StringWithAggregatesFilter<"EVVRecord"> | string
    recordType?: EnumEVVRecordTypeWithAggregatesFilter<"EVVRecord"> | $Enums.EVVRecordType
    timestamp?: DateTimeWithAggregatesFilter<"EVVRecord"> | Date | string
    latitude?: FloatWithAggregatesFilter<"EVVRecord"> | number
    longitude?: FloatWithAggregatesFilter<"EVVRecord"> | number
    accuracy?: FloatNullableWithAggregatesFilter<"EVVRecord"> | number | null
    deviceId?: StringNullableWithAggregatesFilter<"EVVRecord"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"EVVRecord"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"EVVRecord"> | string | null
    isVerified?: BoolWithAggregatesFilter<"EVVRecord"> | boolean
    verificationMethod?: EnumEVVVerificationMethodWithAggregatesFilter<"EVVRecord"> | $Enums.EVVVerificationMethod
    verificationNotes?: StringNullableWithAggregatesFilter<"EVVRecord"> | string | null
    distanceFromHome?: FloatNullableWithAggregatesFilter<"EVVRecord"> | number | null
    isWithinGeofence?: BoolWithAggregatesFilter<"EVVRecord"> | boolean
    geofenceRadius?: FloatWithAggregatesFilter<"EVVRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EVVRecord"> | Date | string
  }

  export type TimeEntryWhereInput = {
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    caregiverId?: StringFilter<"TimeEntry"> | string
    visitId?: StringNullableFilter<"TimeEntry"> | string | null
    entryType?: EnumTimeEntryTypeFilter<"TimeEntry"> | $Enums.TimeEntryType
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntNullableFilter<"TimeEntry"> | number | null
    startLatitude?: FloatNullableFilter<"TimeEntry"> | number | null
    startLongitude?: FloatNullableFilter<"TimeEntry"> | number | null
    endLatitude?: FloatNullableFilter<"TimeEntry"> | number | null
    endLongitude?: FloatNullableFilter<"TimeEntry"> | number | null
    status?: EnumApprovalStatusFilter<"TimeEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableFilter<"TimeEntry"> | string | null
    approvedAt?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    notes?: StringNullableFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
  }

  export type TimeEntryOrderByWithRelationInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    entryType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caregiver?: CaregiverOrderByWithRelationInput
  }

  export type TimeEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    caregiverId?: StringFilter<"TimeEntry"> | string
    visitId?: StringNullableFilter<"TimeEntry"> | string | null
    entryType?: EnumTimeEntryTypeFilter<"TimeEntry"> | $Enums.TimeEntryType
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntNullableFilter<"TimeEntry"> | number | null
    startLatitude?: FloatNullableFilter<"TimeEntry"> | number | null
    startLongitude?: FloatNullableFilter<"TimeEntry"> | number | null
    endLatitude?: FloatNullableFilter<"TimeEntry"> | number | null
    endLongitude?: FloatNullableFilter<"TimeEntry"> | number | null
    status?: EnumApprovalStatusFilter<"TimeEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableFilter<"TimeEntry"> | string | null
    approvedAt?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    notes?: StringNullableFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
  }, "id">

  export type TimeEntryOrderByWithAggregationInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    entryType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeEntryCountOrderByAggregateInput
    _avg?: TimeEntryAvgOrderByAggregateInput
    _max?: TimeEntryMaxOrderByAggregateInput
    _min?: TimeEntryMinOrderByAggregateInput
    _sum?: TimeEntrySumOrderByAggregateInput
  }

  export type TimeEntryScalarWhereWithAggregatesInput = {
    AND?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    OR?: TimeEntryScalarWhereWithAggregatesInput[]
    NOT?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeEntry"> | string
    caregiverId?: StringWithAggregatesFilter<"TimeEntry"> | string
    visitId?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    entryType?: EnumTimeEntryTypeWithAggregatesFilter<"TimeEntry"> | $Enums.TimeEntryType
    startTime?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"TimeEntry"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"TimeEntry"> | number | null
    startLatitude?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    endLatitude?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    status?: EnumApprovalStatusWithAggregatesFilter<"TimeEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"TimeEntry"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
  }

  export type MileageEntryWhereInput = {
    AND?: MileageEntryWhereInput | MileageEntryWhereInput[]
    OR?: MileageEntryWhereInput[]
    NOT?: MileageEntryWhereInput | MileageEntryWhereInput[]
    id?: StringFilter<"MileageEntry"> | string
    caregiverId?: StringFilter<"MileageEntry"> | string
    date?: DateTimeFilter<"MileageEntry"> | Date | string
    startAddress?: StringFilter<"MileageEntry"> | string
    endAddress?: StringFilter<"MileageEntry"> | string
    distance?: FloatFilter<"MileageEntry"> | number
    purpose?: StringNullableFilter<"MileageEntry"> | string | null
    startLatitude?: FloatNullableFilter<"MileageEntry"> | number | null
    startLongitude?: FloatNullableFilter<"MileageEntry"> | number | null
    endLatitude?: FloatNullableFilter<"MileageEntry"> | number | null
    endLongitude?: FloatNullableFilter<"MileageEntry"> | number | null
    routeData?: JsonNullableFilter<"MileageEntry">
    ratePerMile?: FloatFilter<"MileageEntry"> | number
    totalAmount?: FloatNullableFilter<"MileageEntry"> | number | null
    status?: EnumApprovalStatusFilter<"MileageEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableFilter<"MileageEntry"> | string | null
    approvedAt?: DateTimeNullableFilter<"MileageEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"MileageEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MileageEntry"> | Date | string
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
  }

  export type MileageEntryOrderByWithRelationInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    date?: SortOrder
    startAddress?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    purpose?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    routeData?: SortOrderInput | SortOrder
    ratePerMile?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caregiver?: CaregiverOrderByWithRelationInput
  }

  export type MileageEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MileageEntryWhereInput | MileageEntryWhereInput[]
    OR?: MileageEntryWhereInput[]
    NOT?: MileageEntryWhereInput | MileageEntryWhereInput[]
    caregiverId?: StringFilter<"MileageEntry"> | string
    date?: DateTimeFilter<"MileageEntry"> | Date | string
    startAddress?: StringFilter<"MileageEntry"> | string
    endAddress?: StringFilter<"MileageEntry"> | string
    distance?: FloatFilter<"MileageEntry"> | number
    purpose?: StringNullableFilter<"MileageEntry"> | string | null
    startLatitude?: FloatNullableFilter<"MileageEntry"> | number | null
    startLongitude?: FloatNullableFilter<"MileageEntry"> | number | null
    endLatitude?: FloatNullableFilter<"MileageEntry"> | number | null
    endLongitude?: FloatNullableFilter<"MileageEntry"> | number | null
    routeData?: JsonNullableFilter<"MileageEntry">
    ratePerMile?: FloatFilter<"MileageEntry"> | number
    totalAmount?: FloatNullableFilter<"MileageEntry"> | number | null
    status?: EnumApprovalStatusFilter<"MileageEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableFilter<"MileageEntry"> | string | null
    approvedAt?: DateTimeNullableFilter<"MileageEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"MileageEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MileageEntry"> | Date | string
    caregiver?: XOR<CaregiverRelationFilter, CaregiverWhereInput>
  }, "id">

  export type MileageEntryOrderByWithAggregationInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    date?: SortOrder
    startAddress?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    purpose?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    routeData?: SortOrderInput | SortOrder
    ratePerMile?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MileageEntryCountOrderByAggregateInput
    _avg?: MileageEntryAvgOrderByAggregateInput
    _max?: MileageEntryMaxOrderByAggregateInput
    _min?: MileageEntryMinOrderByAggregateInput
    _sum?: MileageEntrySumOrderByAggregateInput
  }

  export type MileageEntryScalarWhereWithAggregatesInput = {
    AND?: MileageEntryScalarWhereWithAggregatesInput | MileageEntryScalarWhereWithAggregatesInput[]
    OR?: MileageEntryScalarWhereWithAggregatesInput[]
    NOT?: MileageEntryScalarWhereWithAggregatesInput | MileageEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MileageEntry"> | string
    caregiverId?: StringWithAggregatesFilter<"MileageEntry"> | string
    date?: DateTimeWithAggregatesFilter<"MileageEntry"> | Date | string
    startAddress?: StringWithAggregatesFilter<"MileageEntry"> | string
    endAddress?: StringWithAggregatesFilter<"MileageEntry"> | string
    distance?: FloatWithAggregatesFilter<"MileageEntry"> | number
    purpose?: StringNullableWithAggregatesFilter<"MileageEntry"> | string | null
    startLatitude?: FloatNullableWithAggregatesFilter<"MileageEntry"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"MileageEntry"> | number | null
    endLatitude?: FloatNullableWithAggregatesFilter<"MileageEntry"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"MileageEntry"> | number | null
    routeData?: JsonNullableWithAggregatesFilter<"MileageEntry">
    ratePerMile?: FloatWithAggregatesFilter<"MileageEntry"> | number
    totalAmount?: FloatNullableWithAggregatesFilter<"MileageEntry"> | number | null
    status?: EnumApprovalStatusWithAggregatesFilter<"MileageEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableWithAggregatesFilter<"MileageEntry"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"MileageEntry"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MileageEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MileageEntry"> | Date | string
  }

  export type HomeAssessmentWhereInput = {
    AND?: HomeAssessmentWhereInput | HomeAssessmentWhereInput[]
    OR?: HomeAssessmentWhereInput[]
    NOT?: HomeAssessmentWhereInput | HomeAssessmentWhereInput[]
    id?: StringFilter<"HomeAssessment"> | string
    patientHomeId?: StringFilter<"HomeAssessment"> | string
    assessorId?: StringFilter<"HomeAssessment"> | string
    assessmentDate?: DateTimeFilter<"HomeAssessment"> | Date | string
    safetyScore?: IntNullableFilter<"HomeAssessment"> | number | null
    fallRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    cleanlinessScore?: IntNullableFilter<"HomeAssessment"> | number | null
    adequateLighting?: BoolFilter<"HomeAssessment"> | boolean
    adequateVentilation?: BoolFilter<"HomeAssessment"> | boolean
    workingUtilities?: BoolFilter<"HomeAssessment"> | boolean
    bathroomAccessible?: BoolFilter<"HomeAssessment"> | boolean
    bedroomAccessible?: BoolFilter<"HomeAssessment"> | boolean
    kitchenAccessible?: BoolFilter<"HomeAssessment"> | boolean
    recommendations?: JsonNullableFilter<"HomeAssessment">
    requiredEquipment?: StringNullableListFilter<"HomeAssessment">
    followUpDate?: DateTimeNullableFilter<"HomeAssessment"> | Date | string | null
    notes?: StringNullableFilter<"HomeAssessment"> | string | null
    createdAt?: DateTimeFilter<"HomeAssessment"> | Date | string
    updatedAt?: DateTimeFilter<"HomeAssessment"> | Date | string
    patientHome?: XOR<PatientHomeRelationFilter, PatientHomeWhereInput>
  }

  export type HomeAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    assessorId?: SortOrder
    assessmentDate?: SortOrder
    safetyScore?: SortOrderInput | SortOrder
    fallRisk?: SortOrder
    fireRisk?: SortOrder
    infectionRisk?: SortOrder
    cleanlinessScore?: SortOrderInput | SortOrder
    adequateLighting?: SortOrder
    adequateVentilation?: SortOrder
    workingUtilities?: SortOrder
    bathroomAccessible?: SortOrder
    bedroomAccessible?: SortOrder
    kitchenAccessible?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    requiredEquipment?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientHome?: PatientHomeOrderByWithRelationInput
  }

  export type HomeAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomeAssessmentWhereInput | HomeAssessmentWhereInput[]
    OR?: HomeAssessmentWhereInput[]
    NOT?: HomeAssessmentWhereInput | HomeAssessmentWhereInput[]
    patientHomeId?: StringFilter<"HomeAssessment"> | string
    assessorId?: StringFilter<"HomeAssessment"> | string
    assessmentDate?: DateTimeFilter<"HomeAssessment"> | Date | string
    safetyScore?: IntNullableFilter<"HomeAssessment"> | number | null
    fallRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    cleanlinessScore?: IntNullableFilter<"HomeAssessment"> | number | null
    adequateLighting?: BoolFilter<"HomeAssessment"> | boolean
    adequateVentilation?: BoolFilter<"HomeAssessment"> | boolean
    workingUtilities?: BoolFilter<"HomeAssessment"> | boolean
    bathroomAccessible?: BoolFilter<"HomeAssessment"> | boolean
    bedroomAccessible?: BoolFilter<"HomeAssessment"> | boolean
    kitchenAccessible?: BoolFilter<"HomeAssessment"> | boolean
    recommendations?: JsonNullableFilter<"HomeAssessment">
    requiredEquipment?: StringNullableListFilter<"HomeAssessment">
    followUpDate?: DateTimeNullableFilter<"HomeAssessment"> | Date | string | null
    notes?: StringNullableFilter<"HomeAssessment"> | string | null
    createdAt?: DateTimeFilter<"HomeAssessment"> | Date | string
    updatedAt?: DateTimeFilter<"HomeAssessment"> | Date | string
    patientHome?: XOR<PatientHomeRelationFilter, PatientHomeWhereInput>
  }, "id">

  export type HomeAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    assessorId?: SortOrder
    assessmentDate?: SortOrder
    safetyScore?: SortOrderInput | SortOrder
    fallRisk?: SortOrder
    fireRisk?: SortOrder
    infectionRisk?: SortOrder
    cleanlinessScore?: SortOrderInput | SortOrder
    adequateLighting?: SortOrder
    adequateVentilation?: SortOrder
    workingUtilities?: SortOrder
    bathroomAccessible?: SortOrder
    bedroomAccessible?: SortOrder
    kitchenAccessible?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    requiredEquipment?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HomeAssessmentCountOrderByAggregateInput
    _avg?: HomeAssessmentAvgOrderByAggregateInput
    _max?: HomeAssessmentMaxOrderByAggregateInput
    _min?: HomeAssessmentMinOrderByAggregateInput
    _sum?: HomeAssessmentSumOrderByAggregateInput
  }

  export type HomeAssessmentScalarWhereWithAggregatesInput = {
    AND?: HomeAssessmentScalarWhereWithAggregatesInput | HomeAssessmentScalarWhereWithAggregatesInput[]
    OR?: HomeAssessmentScalarWhereWithAggregatesInput[]
    NOT?: HomeAssessmentScalarWhereWithAggregatesInput | HomeAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomeAssessment"> | string
    patientHomeId?: StringWithAggregatesFilter<"HomeAssessment"> | string
    assessorId?: StringWithAggregatesFilter<"HomeAssessment"> | string
    assessmentDate?: DateTimeWithAggregatesFilter<"HomeAssessment"> | Date | string
    safetyScore?: IntNullableWithAggregatesFilter<"HomeAssessment"> | number | null
    fallRisk?: EnumRiskLevelWithAggregatesFilter<"HomeAssessment"> | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelWithAggregatesFilter<"HomeAssessment"> | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelWithAggregatesFilter<"HomeAssessment"> | $Enums.RiskLevel
    cleanlinessScore?: IntNullableWithAggregatesFilter<"HomeAssessment"> | number | null
    adequateLighting?: BoolWithAggregatesFilter<"HomeAssessment"> | boolean
    adequateVentilation?: BoolWithAggregatesFilter<"HomeAssessment"> | boolean
    workingUtilities?: BoolWithAggregatesFilter<"HomeAssessment"> | boolean
    bathroomAccessible?: BoolWithAggregatesFilter<"HomeAssessment"> | boolean
    bedroomAccessible?: BoolWithAggregatesFilter<"HomeAssessment"> | boolean
    kitchenAccessible?: BoolWithAggregatesFilter<"HomeAssessment"> | boolean
    recommendations?: JsonNullableWithAggregatesFilter<"HomeAssessment">
    requiredEquipment?: StringNullableListFilter<"HomeAssessment">
    followUpDate?: DateTimeNullableWithAggregatesFilter<"HomeAssessment"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"HomeAssessment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HomeAssessment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HomeAssessment"> | Date | string
  }

  export type MedicationAdministrationWhereInput = {
    AND?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    OR?: MedicationAdministrationWhereInput[]
    NOT?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    id?: StringFilter<"MedicationAdministration"> | string
    visitId?: StringFilter<"MedicationAdministration"> | string
    medicationName?: StringFilter<"MedicationAdministration"> | string
    dosage?: StringFilter<"MedicationAdministration"> | string
    route?: EnumMedicationRouteFilter<"MedicationAdministration"> | $Enums.MedicationRoute
    scheduledTime?: DateTimeFilter<"MedicationAdministration"> | Date | string
    administeredTime?: DateTimeNullableFilter<"MedicationAdministration"> | Date | string | null
    status?: EnumMedicationStatusFilter<"MedicationAdministration"> | $Enums.MedicationStatus
    refusedReason?: StringNullableFilter<"MedicationAdministration"> | string | null
    notes?: StringNullableFilter<"MedicationAdministration"> | string | null
    administeredBy?: StringNullableFilter<"MedicationAdministration"> | string | null
    witnessedBy?: StringNullableFilter<"MedicationAdministration"> | string | null
    medicationBarcode?: StringNullableFilter<"MedicationAdministration"> | string | null
    patientBarcode?: StringNullableFilter<"MedicationAdministration"> | string | null
    createdAt?: DateTimeFilter<"MedicationAdministration"> | Date | string
    updatedAt?: DateTimeFilter<"MedicationAdministration"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }

  export type MedicationAdministrationOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    scheduledTime?: SortOrder
    administeredTime?: SortOrderInput | SortOrder
    status?: SortOrder
    refusedReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    administeredBy?: SortOrderInput | SortOrder
    witnessedBy?: SortOrderInput | SortOrder
    medicationBarcode?: SortOrderInput | SortOrder
    patientBarcode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visit?: HomeVisitOrderByWithRelationInput
  }

  export type MedicationAdministrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    OR?: MedicationAdministrationWhereInput[]
    NOT?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    visitId?: StringFilter<"MedicationAdministration"> | string
    medicationName?: StringFilter<"MedicationAdministration"> | string
    dosage?: StringFilter<"MedicationAdministration"> | string
    route?: EnumMedicationRouteFilter<"MedicationAdministration"> | $Enums.MedicationRoute
    scheduledTime?: DateTimeFilter<"MedicationAdministration"> | Date | string
    administeredTime?: DateTimeNullableFilter<"MedicationAdministration"> | Date | string | null
    status?: EnumMedicationStatusFilter<"MedicationAdministration"> | $Enums.MedicationStatus
    refusedReason?: StringNullableFilter<"MedicationAdministration"> | string | null
    notes?: StringNullableFilter<"MedicationAdministration"> | string | null
    administeredBy?: StringNullableFilter<"MedicationAdministration"> | string | null
    witnessedBy?: StringNullableFilter<"MedicationAdministration"> | string | null
    medicationBarcode?: StringNullableFilter<"MedicationAdministration"> | string | null
    patientBarcode?: StringNullableFilter<"MedicationAdministration"> | string | null
    createdAt?: DateTimeFilter<"MedicationAdministration"> | Date | string
    updatedAt?: DateTimeFilter<"MedicationAdministration"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }, "id">

  export type MedicationAdministrationOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    scheduledTime?: SortOrder
    administeredTime?: SortOrderInput | SortOrder
    status?: SortOrder
    refusedReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    administeredBy?: SortOrderInput | SortOrder
    witnessedBy?: SortOrderInput | SortOrder
    medicationBarcode?: SortOrderInput | SortOrder
    patientBarcode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicationAdministrationCountOrderByAggregateInput
    _max?: MedicationAdministrationMaxOrderByAggregateInput
    _min?: MedicationAdministrationMinOrderByAggregateInput
  }

  export type MedicationAdministrationScalarWhereWithAggregatesInput = {
    AND?: MedicationAdministrationScalarWhereWithAggregatesInput | MedicationAdministrationScalarWhereWithAggregatesInput[]
    OR?: MedicationAdministrationScalarWhereWithAggregatesInput[]
    NOT?: MedicationAdministrationScalarWhereWithAggregatesInput | MedicationAdministrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    visitId?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    medicationName?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    dosage?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    route?: EnumMedicationRouteWithAggregatesFilter<"MedicationAdministration"> | $Enums.MedicationRoute
    scheduledTime?: DateTimeWithAggregatesFilter<"MedicationAdministration"> | Date | string
    administeredTime?: DateTimeNullableWithAggregatesFilter<"MedicationAdministration"> | Date | string | null
    status?: EnumMedicationStatusWithAggregatesFilter<"MedicationAdministration"> | $Enums.MedicationStatus
    refusedReason?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
    administeredBy?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
    witnessedBy?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
    medicationBarcode?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
    patientBarcode?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicationAdministration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicationAdministration"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    visitId?: StringNullableFilter<"Incident"> | string | null
    patientId?: StringFilter<"Incident"> | string
    caregiverId?: StringNullableFilter<"Incident"> | string | null
    incidentType?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    occurredAt?: DateTimeFilter<"Incident"> | Date | string
    location?: StringNullableFilter<"Incident"> | string | null
    description?: StringFilter<"Incident"> | string
    immediateAction?: StringNullableFilter<"Incident"> | string | null
    witnessNames?: StringNullableFilter<"Incident"> | string | null
    fallType?: EnumFallTypeNullableFilter<"Incident"> | $Enums.FallType | null
    injuryOccurred?: BoolFilter<"Incident"> | boolean
    injuryDescription?: StringNullableFilter<"Incident"> | string | null
    medicalAttentionRequired?: BoolFilter<"Incident"> | boolean
    emergencyServicesNotified?: BoolFilter<"Incident"> | boolean
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    investigatedBy?: StringNullableFilter<"Incident"> | string | null
    investigatedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableFilter<"Incident"> | string | null
    preventiveMeasures?: StringNullableFilter<"Incident"> | string | null
    familyNotified?: BoolFilter<"Incident"> | boolean
    physicianNotified?: BoolFilter<"Incident"> | boolean
    supervisorNotified?: BoolFilter<"Incident"> | boolean
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    visit?: XOR<HomeVisitNullableRelationFilter, HomeVisitWhereInput> | null
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    caregiverId?: SortOrderInput | SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    occurredAt?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrder
    immediateAction?: SortOrderInput | SortOrder
    witnessNames?: SortOrderInput | SortOrder
    fallType?: SortOrderInput | SortOrder
    injuryOccurred?: SortOrder
    injuryDescription?: SortOrderInput | SortOrder
    medicalAttentionRequired?: SortOrder
    emergencyServicesNotified?: SortOrder
    status?: SortOrder
    investigatedBy?: SortOrderInput | SortOrder
    investigatedAt?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    preventiveMeasures?: SortOrderInput | SortOrder
    familyNotified?: SortOrder
    physicianNotified?: SortOrder
    supervisorNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visit?: HomeVisitOrderByWithRelationInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    visitId?: StringNullableFilter<"Incident"> | string | null
    patientId?: StringFilter<"Incident"> | string
    caregiverId?: StringNullableFilter<"Incident"> | string | null
    incidentType?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    occurredAt?: DateTimeFilter<"Incident"> | Date | string
    location?: StringNullableFilter<"Incident"> | string | null
    description?: StringFilter<"Incident"> | string
    immediateAction?: StringNullableFilter<"Incident"> | string | null
    witnessNames?: StringNullableFilter<"Incident"> | string | null
    fallType?: EnumFallTypeNullableFilter<"Incident"> | $Enums.FallType | null
    injuryOccurred?: BoolFilter<"Incident"> | boolean
    injuryDescription?: StringNullableFilter<"Incident"> | string | null
    medicalAttentionRequired?: BoolFilter<"Incident"> | boolean
    emergencyServicesNotified?: BoolFilter<"Incident"> | boolean
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    investigatedBy?: StringNullableFilter<"Incident"> | string | null
    investigatedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableFilter<"Incident"> | string | null
    preventiveMeasures?: StringNullableFilter<"Incident"> | string | null
    familyNotified?: BoolFilter<"Incident"> | boolean
    physicianNotified?: BoolFilter<"Incident"> | boolean
    supervisorNotified?: BoolFilter<"Incident"> | boolean
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    visit?: XOR<HomeVisitNullableRelationFilter, HomeVisitWhereInput> | null
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    caregiverId?: SortOrderInput | SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    occurredAt?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrder
    immediateAction?: SortOrderInput | SortOrder
    witnessNames?: SortOrderInput | SortOrder
    fallType?: SortOrderInput | SortOrder
    injuryOccurred?: SortOrder
    injuryDescription?: SortOrderInput | SortOrder
    medicalAttentionRequired?: SortOrder
    emergencyServicesNotified?: SortOrder
    status?: SortOrder
    investigatedBy?: SortOrderInput | SortOrder
    investigatedAt?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    preventiveMeasures?: SortOrderInput | SortOrder
    familyNotified?: SortOrder
    physicianNotified?: SortOrder
    supervisorNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    visitId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    patientId?: StringWithAggregatesFilter<"Incident"> | string
    caregiverId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    incidentType?: EnumIncidentTypeWithAggregatesFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityWithAggregatesFilter<"Incident"> | $Enums.IncidentSeverity
    occurredAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    location?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    description?: StringWithAggregatesFilter<"Incident"> | string
    immediateAction?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    witnessNames?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    fallType?: EnumFallTypeNullableWithAggregatesFilter<"Incident"> | $Enums.FallType | null
    injuryOccurred?: BoolWithAggregatesFilter<"Incident"> | boolean
    injuryDescription?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    medicalAttentionRequired?: BoolWithAggregatesFilter<"Incident"> | boolean
    emergencyServicesNotified?: BoolWithAggregatesFilter<"Incident"> | boolean
    status?: EnumIncidentStatusWithAggregatesFilter<"Incident"> | $Enums.IncidentStatus
    investigatedBy?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    investigatedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    preventiveMeasures?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    familyNotified?: BoolWithAggregatesFilter<"Incident"> | boolean
    physicianNotified?: BoolWithAggregatesFilter<"Incident"> | boolean
    supervisorNotified?: BoolWithAggregatesFilter<"Incident"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
  }

  export type VisitDocumentationWhereInput = {
    AND?: VisitDocumentationWhereInput | VisitDocumentationWhereInput[]
    OR?: VisitDocumentationWhereInput[]
    NOT?: VisitDocumentationWhereInput | VisitDocumentationWhereInput[]
    id?: StringFilter<"VisitDocumentation"> | string
    visitId?: StringFilter<"VisitDocumentation"> | string
    documentType?: EnumDocumentTypeFilter<"VisitDocumentation"> | $Enums.DocumentType
    title?: StringFilter<"VisitDocumentation"> | string
    content?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileUrl?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileType?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileSize?: IntNullableFilter<"VisitDocumentation"> | number | null
    assessmentData?: JsonNullableFilter<"VisitDocumentation">
    createdBy?: StringFilter<"VisitDocumentation"> | string
    createdAt?: DateTimeFilter<"VisitDocumentation"> | Date | string
    updatedAt?: DateTimeFilter<"VisitDocumentation"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }

  export type VisitDocumentationOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    assessmentData?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visit?: HomeVisitOrderByWithRelationInput
  }

  export type VisitDocumentationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitDocumentationWhereInput | VisitDocumentationWhereInput[]
    OR?: VisitDocumentationWhereInput[]
    NOT?: VisitDocumentationWhereInput | VisitDocumentationWhereInput[]
    visitId?: StringFilter<"VisitDocumentation"> | string
    documentType?: EnumDocumentTypeFilter<"VisitDocumentation"> | $Enums.DocumentType
    title?: StringFilter<"VisitDocumentation"> | string
    content?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileUrl?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileType?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileSize?: IntNullableFilter<"VisitDocumentation"> | number | null
    assessmentData?: JsonNullableFilter<"VisitDocumentation">
    createdBy?: StringFilter<"VisitDocumentation"> | string
    createdAt?: DateTimeFilter<"VisitDocumentation"> | Date | string
    updatedAt?: DateTimeFilter<"VisitDocumentation"> | Date | string
    visit?: XOR<HomeVisitRelationFilter, HomeVisitWhereInput>
  }, "id">

  export type VisitDocumentationOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    assessmentData?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitDocumentationCountOrderByAggregateInput
    _avg?: VisitDocumentationAvgOrderByAggregateInput
    _max?: VisitDocumentationMaxOrderByAggregateInput
    _min?: VisitDocumentationMinOrderByAggregateInput
    _sum?: VisitDocumentationSumOrderByAggregateInput
  }

  export type VisitDocumentationScalarWhereWithAggregatesInput = {
    AND?: VisitDocumentationScalarWhereWithAggregatesInput | VisitDocumentationScalarWhereWithAggregatesInput[]
    OR?: VisitDocumentationScalarWhereWithAggregatesInput[]
    NOT?: VisitDocumentationScalarWhereWithAggregatesInput | VisitDocumentationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitDocumentation"> | string
    visitId?: StringWithAggregatesFilter<"VisitDocumentation"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"VisitDocumentation"> | $Enums.DocumentType
    title?: StringWithAggregatesFilter<"VisitDocumentation"> | string
    content?: StringNullableWithAggregatesFilter<"VisitDocumentation"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"VisitDocumentation"> | string | null
    fileType?: StringNullableWithAggregatesFilter<"VisitDocumentation"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"VisitDocumentation"> | number | null
    assessmentData?: JsonNullableWithAggregatesFilter<"VisitDocumentation">
    createdBy?: StringWithAggregatesFilter<"VisitDocumentation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VisitDocumentation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VisitDocumentation"> | Date | string
  }

  export type PatientEquipmentWhereInput = {
    AND?: PatientEquipmentWhereInput | PatientEquipmentWhereInput[]
    OR?: PatientEquipmentWhereInput[]
    NOT?: PatientEquipmentWhereInput | PatientEquipmentWhereInput[]
    id?: StringFilter<"PatientEquipment"> | string
    patientHomeId?: StringFilter<"PatientEquipment"> | string
    equipmentType?: EnumEquipmentTypeFilter<"PatientEquipment"> | $Enums.EquipmentType
    name?: StringFilter<"PatientEquipment"> | string
    serialNumber?: StringNullableFilter<"PatientEquipment"> | string | null
    manufacturer?: StringNullableFilter<"PatientEquipment"> | string | null
    model?: StringNullableFilter<"PatientEquipment"> | string | null
    status?: EnumEquipmentStatusFilter<"PatientEquipment"> | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFilter<"PatientEquipment"> | $Enums.EquipmentCondition
    deliveredDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    expectedReturnDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    returnedDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    maintenanceNotes?: StringNullableFilter<"PatientEquipment"> | string | null
    ownershipType?: EnumOwnershipTypeFilter<"PatientEquipment"> | $Enums.OwnershipType
    rentalCompany?: StringNullableFilter<"PatientEquipment"> | string | null
    monthlyRentalCost?: FloatNullableFilter<"PatientEquipment"> | number | null
    notes?: StringNullableFilter<"PatientEquipment"> | string | null
    createdAt?: DateTimeFilter<"PatientEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"PatientEquipment"> | Date | string
    patientHome?: XOR<PatientHomeRelationFilter, PatientHomeWhereInput>
  }

  export type PatientEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    equipmentType?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    status?: SortOrder
    condition?: SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    expectedReturnDate?: SortOrderInput | SortOrder
    returnedDate?: SortOrderInput | SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    nextMaintenanceDate?: SortOrderInput | SortOrder
    maintenanceNotes?: SortOrderInput | SortOrder
    ownershipType?: SortOrder
    rentalCompany?: SortOrderInput | SortOrder
    monthlyRentalCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientHome?: PatientHomeOrderByWithRelationInput
  }

  export type PatientEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientEquipmentWhereInput | PatientEquipmentWhereInput[]
    OR?: PatientEquipmentWhereInput[]
    NOT?: PatientEquipmentWhereInput | PatientEquipmentWhereInput[]
    patientHomeId?: StringFilter<"PatientEquipment"> | string
    equipmentType?: EnumEquipmentTypeFilter<"PatientEquipment"> | $Enums.EquipmentType
    name?: StringFilter<"PatientEquipment"> | string
    serialNumber?: StringNullableFilter<"PatientEquipment"> | string | null
    manufacturer?: StringNullableFilter<"PatientEquipment"> | string | null
    model?: StringNullableFilter<"PatientEquipment"> | string | null
    status?: EnumEquipmentStatusFilter<"PatientEquipment"> | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFilter<"PatientEquipment"> | $Enums.EquipmentCondition
    deliveredDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    expectedReturnDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    returnedDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    maintenanceNotes?: StringNullableFilter<"PatientEquipment"> | string | null
    ownershipType?: EnumOwnershipTypeFilter<"PatientEquipment"> | $Enums.OwnershipType
    rentalCompany?: StringNullableFilter<"PatientEquipment"> | string | null
    monthlyRentalCost?: FloatNullableFilter<"PatientEquipment"> | number | null
    notes?: StringNullableFilter<"PatientEquipment"> | string | null
    createdAt?: DateTimeFilter<"PatientEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"PatientEquipment"> | Date | string
    patientHome?: XOR<PatientHomeRelationFilter, PatientHomeWhereInput>
  }, "id">

  export type PatientEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    equipmentType?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    status?: SortOrder
    condition?: SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    expectedReturnDate?: SortOrderInput | SortOrder
    returnedDate?: SortOrderInput | SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    nextMaintenanceDate?: SortOrderInput | SortOrder
    maintenanceNotes?: SortOrderInput | SortOrder
    ownershipType?: SortOrder
    rentalCompany?: SortOrderInput | SortOrder
    monthlyRentalCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientEquipmentCountOrderByAggregateInput
    _avg?: PatientEquipmentAvgOrderByAggregateInput
    _max?: PatientEquipmentMaxOrderByAggregateInput
    _min?: PatientEquipmentMinOrderByAggregateInput
    _sum?: PatientEquipmentSumOrderByAggregateInput
  }

  export type PatientEquipmentScalarWhereWithAggregatesInput = {
    AND?: PatientEquipmentScalarWhereWithAggregatesInput | PatientEquipmentScalarWhereWithAggregatesInput[]
    OR?: PatientEquipmentScalarWhereWithAggregatesInput[]
    NOT?: PatientEquipmentScalarWhereWithAggregatesInput | PatientEquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientEquipment"> | string
    patientHomeId?: StringWithAggregatesFilter<"PatientEquipment"> | string
    equipmentType?: EnumEquipmentTypeWithAggregatesFilter<"PatientEquipment"> | $Enums.EquipmentType
    name?: StringWithAggregatesFilter<"PatientEquipment"> | string
    serialNumber?: StringNullableWithAggregatesFilter<"PatientEquipment"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"PatientEquipment"> | string | null
    model?: StringNullableWithAggregatesFilter<"PatientEquipment"> | string | null
    status?: EnumEquipmentStatusWithAggregatesFilter<"PatientEquipment"> | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionWithAggregatesFilter<"PatientEquipment"> | $Enums.EquipmentCondition
    deliveredDate?: DateTimeNullableWithAggregatesFilter<"PatientEquipment"> | Date | string | null
    expectedReturnDate?: DateTimeNullableWithAggregatesFilter<"PatientEquipment"> | Date | string | null
    returnedDate?: DateTimeNullableWithAggregatesFilter<"PatientEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"PatientEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"PatientEquipment"> | Date | string | null
    maintenanceNotes?: StringNullableWithAggregatesFilter<"PatientEquipment"> | string | null
    ownershipType?: EnumOwnershipTypeWithAggregatesFilter<"PatientEquipment"> | $Enums.OwnershipType
    rentalCompany?: StringNullableWithAggregatesFilter<"PatientEquipment"> | string | null
    monthlyRentalCost?: FloatNullableWithAggregatesFilter<"PatientEquipment"> | number | null
    notes?: StringNullableWithAggregatesFilter<"PatientEquipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PatientEquipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatientEquipment"> | Date | string
  }

  export type FamilyCommunicationWhereInput = {
    AND?: FamilyCommunicationWhereInput | FamilyCommunicationWhereInput[]
    OR?: FamilyCommunicationWhereInput[]
    NOT?: FamilyCommunicationWhereInput | FamilyCommunicationWhereInput[]
    id?: StringFilter<"FamilyCommunication"> | string
    patientId?: StringFilter<"FamilyCommunication"> | string
    familyMemberId?: StringNullableFilter<"FamilyCommunication"> | string | null
    caregiverId?: StringNullableFilter<"FamilyCommunication"> | string | null
    communicationType?: EnumCommunicationTypeFilter<"FamilyCommunication"> | $Enums.CommunicationType
    subject?: StringNullableFilter<"FamilyCommunication"> | string | null
    message?: StringFilter<"FamilyCommunication"> | string
    visitId?: StringNullableFilter<"FamilyCommunication"> | string | null
    isRead?: BoolFilter<"FamilyCommunication"> | boolean
    readAt?: DateTimeNullableFilter<"FamilyCommunication"> | Date | string | null
    parentMessageId?: StringNullableFilter<"FamilyCommunication"> | string | null
    createdAt?: DateTimeFilter<"FamilyCommunication"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyCommunication"> | Date | string
  }

  export type FamilyCommunicationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    familyMemberId?: SortOrderInput | SortOrder
    caregiverId?: SortOrderInput | SortOrder
    communicationType?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    visitId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyCommunicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FamilyCommunicationWhereInput | FamilyCommunicationWhereInput[]
    OR?: FamilyCommunicationWhereInput[]
    NOT?: FamilyCommunicationWhereInput | FamilyCommunicationWhereInput[]
    patientId?: StringFilter<"FamilyCommunication"> | string
    familyMemberId?: StringNullableFilter<"FamilyCommunication"> | string | null
    caregiverId?: StringNullableFilter<"FamilyCommunication"> | string | null
    communicationType?: EnumCommunicationTypeFilter<"FamilyCommunication"> | $Enums.CommunicationType
    subject?: StringNullableFilter<"FamilyCommunication"> | string | null
    message?: StringFilter<"FamilyCommunication"> | string
    visitId?: StringNullableFilter<"FamilyCommunication"> | string | null
    isRead?: BoolFilter<"FamilyCommunication"> | boolean
    readAt?: DateTimeNullableFilter<"FamilyCommunication"> | Date | string | null
    parentMessageId?: StringNullableFilter<"FamilyCommunication"> | string | null
    createdAt?: DateTimeFilter<"FamilyCommunication"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyCommunication"> | Date | string
  }, "id">

  export type FamilyCommunicationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    familyMemberId?: SortOrderInput | SortOrder
    caregiverId?: SortOrderInput | SortOrder
    communicationType?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    visitId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FamilyCommunicationCountOrderByAggregateInput
    _max?: FamilyCommunicationMaxOrderByAggregateInput
    _min?: FamilyCommunicationMinOrderByAggregateInput
  }

  export type FamilyCommunicationScalarWhereWithAggregatesInput = {
    AND?: FamilyCommunicationScalarWhereWithAggregatesInput | FamilyCommunicationScalarWhereWithAggregatesInput[]
    OR?: FamilyCommunicationScalarWhereWithAggregatesInput[]
    NOT?: FamilyCommunicationScalarWhereWithAggregatesInput | FamilyCommunicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyCommunication"> | string
    patientId?: StringWithAggregatesFilter<"FamilyCommunication"> | string
    familyMemberId?: StringNullableWithAggregatesFilter<"FamilyCommunication"> | string | null
    caregiverId?: StringNullableWithAggregatesFilter<"FamilyCommunication"> | string | null
    communicationType?: EnumCommunicationTypeWithAggregatesFilter<"FamilyCommunication"> | $Enums.CommunicationType
    subject?: StringNullableWithAggregatesFilter<"FamilyCommunication"> | string | null
    message?: StringWithAggregatesFilter<"FamilyCommunication"> | string
    visitId?: StringNullableWithAggregatesFilter<"FamilyCommunication"> | string | null
    isRead?: BoolWithAggregatesFilter<"FamilyCommunication"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"FamilyCommunication"> | Date | string | null
    parentMessageId?: StringNullableWithAggregatesFilter<"FamilyCommunication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FamilyCommunication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FamilyCommunication"> | Date | string
  }

  export type SupplyOrderWhereInput = {
    AND?: SupplyOrderWhereInput | SupplyOrderWhereInput[]
    OR?: SupplyOrderWhereInput[]
    NOT?: SupplyOrderWhereInput | SupplyOrderWhereInput[]
    id?: StringFilter<"SupplyOrder"> | string
    patientId?: StringFilter<"SupplyOrder"> | string
    orderedBy?: StringFilter<"SupplyOrder"> | string
    items?: JsonFilter<"SupplyOrder">
    totalCost?: FloatNullableFilter<"SupplyOrder"> | number | null
    status?: EnumSupplyOrderStatusFilter<"SupplyOrder"> | $Enums.SupplyOrderStatus
    orderedAt?: DateTimeFilter<"SupplyOrder"> | Date | string
    expectedDelivery?: DateTimeNullableFilter<"SupplyOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"SupplyOrder"> | Date | string | null
    deliveryNotes?: StringNullableFilter<"SupplyOrder"> | string | null
    createdAt?: DateTimeFilter<"SupplyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SupplyOrder"> | Date | string
  }

  export type SupplyOrderOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderedBy?: SortOrder
    items?: SortOrder
    totalCost?: SortOrderInput | SortOrder
    status?: SortOrder
    orderedAt?: SortOrder
    expectedDelivery?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    deliveryNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplyOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplyOrderWhereInput | SupplyOrderWhereInput[]
    OR?: SupplyOrderWhereInput[]
    NOT?: SupplyOrderWhereInput | SupplyOrderWhereInput[]
    patientId?: StringFilter<"SupplyOrder"> | string
    orderedBy?: StringFilter<"SupplyOrder"> | string
    items?: JsonFilter<"SupplyOrder">
    totalCost?: FloatNullableFilter<"SupplyOrder"> | number | null
    status?: EnumSupplyOrderStatusFilter<"SupplyOrder"> | $Enums.SupplyOrderStatus
    orderedAt?: DateTimeFilter<"SupplyOrder"> | Date | string
    expectedDelivery?: DateTimeNullableFilter<"SupplyOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"SupplyOrder"> | Date | string | null
    deliveryNotes?: StringNullableFilter<"SupplyOrder"> | string | null
    createdAt?: DateTimeFilter<"SupplyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SupplyOrder"> | Date | string
  }, "id">

  export type SupplyOrderOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderedBy?: SortOrder
    items?: SortOrder
    totalCost?: SortOrderInput | SortOrder
    status?: SortOrder
    orderedAt?: SortOrder
    expectedDelivery?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    deliveryNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplyOrderCountOrderByAggregateInput
    _avg?: SupplyOrderAvgOrderByAggregateInput
    _max?: SupplyOrderMaxOrderByAggregateInput
    _min?: SupplyOrderMinOrderByAggregateInput
    _sum?: SupplyOrderSumOrderByAggregateInput
  }

  export type SupplyOrderScalarWhereWithAggregatesInput = {
    AND?: SupplyOrderScalarWhereWithAggregatesInput | SupplyOrderScalarWhereWithAggregatesInput[]
    OR?: SupplyOrderScalarWhereWithAggregatesInput[]
    NOT?: SupplyOrderScalarWhereWithAggregatesInput | SupplyOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupplyOrder"> | string
    patientId?: StringWithAggregatesFilter<"SupplyOrder"> | string
    orderedBy?: StringWithAggregatesFilter<"SupplyOrder"> | string
    items?: JsonWithAggregatesFilter<"SupplyOrder">
    totalCost?: FloatNullableWithAggregatesFilter<"SupplyOrder"> | number | null
    status?: EnumSupplyOrderStatusWithAggregatesFilter<"SupplyOrder"> | $Enums.SupplyOrderStatus
    orderedAt?: DateTimeWithAggregatesFilter<"SupplyOrder"> | Date | string
    expectedDelivery?: DateTimeNullableWithAggregatesFilter<"SupplyOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"SupplyOrder"> | Date | string | null
    deliveryNotes?: StringNullableWithAggregatesFilter<"SupplyOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupplyOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplyOrder"> | Date | string
  }

  export type CaregiverCreateInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitCreateNestedManyWithoutCaregiverInput
    schedules?: CaregiverScheduleCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverUncheckedCreateInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitUncheckedCreateNestedManyWithoutCaregiverInput
    schedules?: CaregiverScheduleUncheckedCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryUncheckedCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUpdateManyWithoutCaregiverNestedInput
    schedules?: CaregiverScheduleUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUpdateManyWithoutCaregiverNestedInput
  }

  export type CaregiverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUncheckedUpdateManyWithoutCaregiverNestedInput
    schedules?: CaregiverScheduleUncheckedUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUncheckedUpdateManyWithoutCaregiverNestedInput
  }

  export type CaregiverCreateManyInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaregiverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaregiverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaregiverScheduleCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    caregiver: CaregiverCreateNestedOneWithoutSchedulesInput
  }

  export type CaregiverScheduleUncheckedCreateInput = {
    id?: string
    caregiverId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaregiverScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caregiver?: CaregiverUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type CaregiverScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaregiverScheduleCreateManyInput = {
    id?: string
    caregiverId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaregiverScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaregiverScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientHomeCreateInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitCreateNestedManyWithoutPatientHomeInput
    assessments?: HomeAssessmentCreateNestedManyWithoutPatientHomeInput
    equipment?: PatientEquipmentCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeUncheckedCreateInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitUncheckedCreateNestedManyWithoutPatientHomeInput
    assessments?: HomeAssessmentUncheckedCreateNestedManyWithoutPatientHomeInput
    equipment?: PatientEquipmentUncheckedCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUpdateManyWithoutPatientHomeNestedInput
    assessments?: HomeAssessmentUpdateManyWithoutPatientHomeNestedInput
    equipment?: PatientEquipmentUpdateManyWithoutPatientHomeNestedInput
  }

  export type PatientHomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUncheckedUpdateManyWithoutPatientHomeNestedInput
    assessments?: HomeAssessmentUncheckedUpdateManyWithoutPatientHomeNestedInput
    equipment?: PatientEquipmentUncheckedUpdateManyWithoutPatientHomeNestedInput
  }

  export type PatientHomeCreateManyInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientHomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientHomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeVisitCreateInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutVisitsInput
    caregiver: CaregiverCreateNestedOneWithoutVisitsInput
    tasks?: VisitTaskCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateInput = {
    id?: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: VisitTaskUncheckedCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordUncheckedCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutVisitsNestedInput
    caregiver?: CaregiverUpdateOneRequiredWithoutVisitsNestedInput
    tasks?: VisitTaskUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: VisitTaskUncheckedUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUncheckedUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitCreateManyInput = {
    id?: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitTaskCreateInput = {
    id?: string
    taskType: $Enums.CareTaskType
    title: string
    description?: string | null
    isRequired?: boolean
    sequence?: number
    status?: $Enums.TaskCompletionStatus
    completedAt?: Date | string | null
    completedBy?: string | null
    notes?: string | null
    vitalType?: string | null
    vitalValue?: number | null
    vitalUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visit: HomeVisitCreateNestedOneWithoutTasksInput
  }

  export type VisitTaskUncheckedCreateInput = {
    id?: string
    visitId: string
    taskType: $Enums.CareTaskType
    title: string
    description?: string | null
    isRequired?: boolean
    sequence?: number
    status?: $Enums.TaskCompletionStatus
    completedAt?: Date | string | null
    completedBy?: string | null
    notes?: string | null
    vitalType?: string | null
    vitalValue?: number | null
    vitalUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumCareTaskTypeFieldUpdateOperationsInput | $Enums.CareTaskType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumTaskCompletionStatusFieldUpdateOperationsInput | $Enums.TaskCompletionStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vitalType?: NullableStringFieldUpdateOperationsInput | string | null
    vitalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    vitalUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: HomeVisitUpdateOneRequiredWithoutTasksNestedInput
  }

  export type VisitTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    taskType?: EnumCareTaskTypeFieldUpdateOperationsInput | $Enums.CareTaskType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumTaskCompletionStatusFieldUpdateOperationsInput | $Enums.TaskCompletionStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vitalType?: NullableStringFieldUpdateOperationsInput | string | null
    vitalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    vitalUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitTaskCreateManyInput = {
    id?: string
    visitId: string
    taskType: $Enums.CareTaskType
    title: string
    description?: string | null
    isRequired?: boolean
    sequence?: number
    status?: $Enums.TaskCompletionStatus
    completedAt?: Date | string | null
    completedBy?: string | null
    notes?: string | null
    vitalType?: string | null
    vitalValue?: number | null
    vitalUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumCareTaskTypeFieldUpdateOperationsInput | $Enums.CareTaskType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumTaskCompletionStatusFieldUpdateOperationsInput | $Enums.TaskCompletionStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vitalType?: NullableStringFieldUpdateOperationsInput | string | null
    vitalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    vitalUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    taskType?: EnumCareTaskTypeFieldUpdateOperationsInput | $Enums.CareTaskType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumTaskCompletionStatusFieldUpdateOperationsInput | $Enums.TaskCompletionStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vitalType?: NullableStringFieldUpdateOperationsInput | string | null
    vitalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    vitalUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EVVRecordCreateInput = {
    id?: string
    recordType: $Enums.EVVRecordType
    timestamp?: Date | string
    latitude: number
    longitude: number
    accuracy?: number | null
    deviceId?: string | null
    deviceType?: string | null
    ipAddress?: string | null
    isVerified?: boolean
    verificationMethod: $Enums.EVVVerificationMethod
    verificationNotes?: string | null
    distanceFromHome?: number | null
    isWithinGeofence?: boolean
    geofenceRadius?: number
    createdAt?: Date | string
    visit: HomeVisitCreateNestedOneWithoutEvvRecordsInput
  }

  export type EVVRecordUncheckedCreateInput = {
    id?: string
    visitId: string
    recordType: $Enums.EVVRecordType
    timestamp?: Date | string
    latitude: number
    longitude: number
    accuracy?: number | null
    deviceId?: string | null
    deviceType?: string | null
    ipAddress?: string | null
    isVerified?: boolean
    verificationMethod: $Enums.EVVVerificationMethod
    verificationNotes?: string | null
    distanceFromHome?: number | null
    isWithinGeofence?: boolean
    geofenceRadius?: number
    createdAt?: Date | string
  }

  export type EVVRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumEVVRecordTypeFieldUpdateOperationsInput | $Enums.EVVRecordType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: EnumEVVVerificationMethodFieldUpdateOperationsInput | $Enums.EVVVerificationMethod
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromHome?: NullableFloatFieldUpdateOperationsInput | number | null
    isWithinGeofence?: BoolFieldUpdateOperationsInput | boolean
    geofenceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: HomeVisitUpdateOneRequiredWithoutEvvRecordsNestedInput
  }

  export type EVVRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumEVVRecordTypeFieldUpdateOperationsInput | $Enums.EVVRecordType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: EnumEVVVerificationMethodFieldUpdateOperationsInput | $Enums.EVVVerificationMethod
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromHome?: NullableFloatFieldUpdateOperationsInput | number | null
    isWithinGeofence?: BoolFieldUpdateOperationsInput | boolean
    geofenceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EVVRecordCreateManyInput = {
    id?: string
    visitId: string
    recordType: $Enums.EVVRecordType
    timestamp?: Date | string
    latitude: number
    longitude: number
    accuracy?: number | null
    deviceId?: string | null
    deviceType?: string | null
    ipAddress?: string | null
    isVerified?: boolean
    verificationMethod: $Enums.EVVVerificationMethod
    verificationNotes?: string | null
    distanceFromHome?: number | null
    isWithinGeofence?: boolean
    geofenceRadius?: number
    createdAt?: Date | string
  }

  export type EVVRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumEVVRecordTypeFieldUpdateOperationsInput | $Enums.EVVRecordType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: EnumEVVVerificationMethodFieldUpdateOperationsInput | $Enums.EVVVerificationMethod
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromHome?: NullableFloatFieldUpdateOperationsInput | number | null
    isWithinGeofence?: BoolFieldUpdateOperationsInput | boolean
    geofenceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EVVRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumEVVRecordTypeFieldUpdateOperationsInput | $Enums.EVVRecordType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: EnumEVVVerificationMethodFieldUpdateOperationsInput | $Enums.EVVVerificationMethod
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromHome?: NullableFloatFieldUpdateOperationsInput | number | null
    isWithinGeofence?: BoolFieldUpdateOperationsInput | boolean
    geofenceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryCreateInput = {
    id?: string
    visitId?: string | null
    entryType: $Enums.TimeEntryType
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caregiver: CaregiverCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateInput = {
    id?: string
    caregiverId: string
    visitId?: string | null
    entryType: $Enums.TimeEntryType
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumTimeEntryTypeFieldUpdateOperationsInput | $Enums.TimeEntryType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caregiver?: CaregiverUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumTimeEntryTypeFieldUpdateOperationsInput | $Enums.TimeEntryType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryCreateManyInput = {
    id?: string
    caregiverId: string
    visitId?: string | null
    entryType: $Enums.TimeEntryType
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumTimeEntryTypeFieldUpdateOperationsInput | $Enums.TimeEntryType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumTimeEntryTypeFieldUpdateOperationsInput | $Enums.TimeEntryType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MileageEntryCreateInput = {
    id?: string
    date?: Date | string
    startAddress: string
    endAddress: string
    distance: number
    purpose?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: number
    totalAmount?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caregiver: CaregiverCreateNestedOneWithoutMileageEntriesInput
  }

  export type MileageEntryUncheckedCreateInput = {
    id?: string
    caregiverId: string
    date?: Date | string
    startAddress: string
    endAddress: string
    distance: number
    purpose?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: number
    totalAmount?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MileageEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startAddress?: StringFieldUpdateOperationsInput | string
    endAddress?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: FloatFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caregiver?: CaregiverUpdateOneRequiredWithoutMileageEntriesNestedInput
  }

  export type MileageEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startAddress?: StringFieldUpdateOperationsInput | string
    endAddress?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: FloatFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MileageEntryCreateManyInput = {
    id?: string
    caregiverId: string
    date?: Date | string
    startAddress: string
    endAddress: string
    distance: number
    purpose?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: number
    totalAmount?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MileageEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startAddress?: StringFieldUpdateOperationsInput | string
    endAddress?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: FloatFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MileageEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startAddress?: StringFieldUpdateOperationsInput | string
    endAddress?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: FloatFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeAssessmentCreateInput = {
    id?: string
    assessorId: string
    assessmentDate?: Date | string
    safetyScore?: number | null
    fallRisk?: $Enums.RiskLevel
    fireRisk?: $Enums.RiskLevel
    infectionRisk?: $Enums.RiskLevel
    cleanlinessScore?: number | null
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentCreaterequiredEquipmentInput | string[]
    followUpDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutAssessmentsInput
  }

  export type HomeAssessmentUncheckedCreateInput = {
    id?: string
    patientHomeId: string
    assessorId: string
    assessmentDate?: Date | string
    safetyScore?: number | null
    fallRisk?: $Enums.RiskLevel
    fireRisk?: $Enums.RiskLevel
    infectionRisk?: $Enums.RiskLevel
    cleanlinessScore?: number | null
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentCreaterequiredEquipmentInput | string[]
    followUpDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessorId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    fallRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    cleanlinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    adequateLighting?: BoolFieldUpdateOperationsInput | boolean
    adequateVentilation?: BoolFieldUpdateOperationsInput | boolean
    workingUtilities?: BoolFieldUpdateOperationsInput | boolean
    bathroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    bedroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    kitchenAccessible?: BoolFieldUpdateOperationsInput | boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentUpdaterequiredEquipmentInput | string[]
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type HomeAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    assessorId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    fallRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    cleanlinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    adequateLighting?: BoolFieldUpdateOperationsInput | boolean
    adequateVentilation?: BoolFieldUpdateOperationsInput | boolean
    workingUtilities?: BoolFieldUpdateOperationsInput | boolean
    bathroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    bedroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    kitchenAccessible?: BoolFieldUpdateOperationsInput | boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentUpdaterequiredEquipmentInput | string[]
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeAssessmentCreateManyInput = {
    id?: string
    patientHomeId: string
    assessorId: string
    assessmentDate?: Date | string
    safetyScore?: number | null
    fallRisk?: $Enums.RiskLevel
    fireRisk?: $Enums.RiskLevel
    infectionRisk?: $Enums.RiskLevel
    cleanlinessScore?: number | null
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentCreaterequiredEquipmentInput | string[]
    followUpDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessorId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    fallRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    cleanlinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    adequateLighting?: BoolFieldUpdateOperationsInput | boolean
    adequateVentilation?: BoolFieldUpdateOperationsInput | boolean
    workingUtilities?: BoolFieldUpdateOperationsInput | boolean
    bathroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    bedroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    kitchenAccessible?: BoolFieldUpdateOperationsInput | boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentUpdaterequiredEquipmentInput | string[]
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    assessorId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    fallRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    cleanlinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    adequateLighting?: BoolFieldUpdateOperationsInput | boolean
    adequateVentilation?: BoolFieldUpdateOperationsInput | boolean
    workingUtilities?: BoolFieldUpdateOperationsInput | boolean
    bathroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    bedroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    kitchenAccessible?: BoolFieldUpdateOperationsInput | boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentUpdaterequiredEquipmentInput | string[]
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationCreateInput = {
    id?: string
    medicationName: string
    dosage: string
    route: $Enums.MedicationRoute
    scheduledTime: Date | string
    administeredTime?: Date | string | null
    status?: $Enums.MedicationStatus
    refusedReason?: string | null
    notes?: string | null
    administeredBy?: string | null
    witnessedBy?: string | null
    medicationBarcode?: string | null
    patientBarcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visit: HomeVisitCreateNestedOneWithoutMedicationsInput
  }

  export type MedicationAdministrationUncheckedCreateInput = {
    id?: string
    visitId: string
    medicationName: string
    dosage: string
    route: $Enums.MedicationRoute
    scheduledTime: Date | string
    administeredTime?: Date | string | null
    status?: $Enums.MedicationStatus
    refusedReason?: string | null
    notes?: string | null
    administeredBy?: string | null
    witnessedBy?: string | null
    medicationBarcode?: string | null
    patientBarcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationAdministrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: EnumMedicationRouteFieldUpdateOperationsInput | $Enums.MedicationRoute
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    refusedReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    administeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    witnessedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medicationBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    patientBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: HomeVisitUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type MedicationAdministrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: EnumMedicationRouteFieldUpdateOperationsInput | $Enums.MedicationRoute
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    refusedReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    administeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    witnessedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medicationBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    patientBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationCreateManyInput = {
    id?: string
    visitId: string
    medicationName: string
    dosage: string
    route: $Enums.MedicationRoute
    scheduledTime: Date | string
    administeredTime?: Date | string | null
    status?: $Enums.MedicationStatus
    refusedReason?: string | null
    notes?: string | null
    administeredBy?: string | null
    witnessedBy?: string | null
    medicationBarcode?: string | null
    patientBarcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationAdministrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: EnumMedicationRouteFieldUpdateOperationsInput | $Enums.MedicationRoute
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    refusedReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    administeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    witnessedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medicationBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    patientBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: EnumMedicationRouteFieldUpdateOperationsInput | $Enums.MedicationRoute
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    refusedReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    administeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    witnessedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medicationBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    patientBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    patientId: string
    caregiverId?: string | null
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    occurredAt: Date | string
    location?: string | null
    description: string
    immediateAction?: string | null
    witnessNames?: string | null
    fallType?: $Enums.FallType | null
    injuryOccurred?: boolean
    injuryDescription?: string | null
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: $Enums.IncidentStatus
    investigatedBy?: string | null
    investigatedAt?: Date | string | null
    rootCause?: string | null
    preventiveMeasures?: string | null
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    visit?: HomeVisitCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    visitId?: string | null
    patientId: string
    caregiverId?: string | null
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    occurredAt: Date | string
    location?: string | null
    description: string
    immediateAction?: string | null
    witnessNames?: string | null
    fallType?: $Enums.FallType | null
    injuryOccurred?: boolean
    injuryDescription?: string | null
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: $Enums.IncidentStatus
    investigatedBy?: string | null
    investigatedAt?: Date | string | null
    rootCause?: string | null
    preventiveMeasures?: string | null
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    immediateAction?: NullableStringFieldUpdateOperationsInput | string | null
    witnessNames?: NullableStringFieldUpdateOperationsInput | string | null
    fallType?: NullableEnumFallTypeFieldUpdateOperationsInput | $Enums.FallType | null
    injuryOccurred?: BoolFieldUpdateOperationsInput | boolean
    injuryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    medicalAttentionRequired?: BoolFieldUpdateOperationsInput | boolean
    emergencyServicesNotified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    investigatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveMeasures?: NullableStringFieldUpdateOperationsInput | string | null
    familyNotified?: BoolFieldUpdateOperationsInput | boolean
    physicianNotified?: BoolFieldUpdateOperationsInput | boolean
    supervisorNotified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: HomeVisitUpdateOneWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    immediateAction?: NullableStringFieldUpdateOperationsInput | string | null
    witnessNames?: NullableStringFieldUpdateOperationsInput | string | null
    fallType?: NullableEnumFallTypeFieldUpdateOperationsInput | $Enums.FallType | null
    injuryOccurred?: BoolFieldUpdateOperationsInput | boolean
    injuryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    medicalAttentionRequired?: BoolFieldUpdateOperationsInput | boolean
    emergencyServicesNotified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    investigatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveMeasures?: NullableStringFieldUpdateOperationsInput | string | null
    familyNotified?: BoolFieldUpdateOperationsInput | boolean
    physicianNotified?: BoolFieldUpdateOperationsInput | boolean
    supervisorNotified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateManyInput = {
    id?: string
    visitId?: string | null
    patientId: string
    caregiverId?: string | null
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    occurredAt: Date | string
    location?: string | null
    description: string
    immediateAction?: string | null
    witnessNames?: string | null
    fallType?: $Enums.FallType | null
    injuryOccurred?: boolean
    injuryDescription?: string | null
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: $Enums.IncidentStatus
    investigatedBy?: string | null
    investigatedAt?: Date | string | null
    rootCause?: string | null
    preventiveMeasures?: string | null
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    immediateAction?: NullableStringFieldUpdateOperationsInput | string | null
    witnessNames?: NullableStringFieldUpdateOperationsInput | string | null
    fallType?: NullableEnumFallTypeFieldUpdateOperationsInput | $Enums.FallType | null
    injuryOccurred?: BoolFieldUpdateOperationsInput | boolean
    injuryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    medicalAttentionRequired?: BoolFieldUpdateOperationsInput | boolean
    emergencyServicesNotified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    investigatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveMeasures?: NullableStringFieldUpdateOperationsInput | string | null
    familyNotified?: BoolFieldUpdateOperationsInput | boolean
    physicianNotified?: BoolFieldUpdateOperationsInput | boolean
    supervisorNotified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    immediateAction?: NullableStringFieldUpdateOperationsInput | string | null
    witnessNames?: NullableStringFieldUpdateOperationsInput | string | null
    fallType?: NullableEnumFallTypeFieldUpdateOperationsInput | $Enums.FallType | null
    injuryOccurred?: BoolFieldUpdateOperationsInput | boolean
    injuryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    medicalAttentionRequired?: BoolFieldUpdateOperationsInput | boolean
    emergencyServicesNotified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    investigatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveMeasures?: NullableStringFieldUpdateOperationsInput | string | null
    familyNotified?: BoolFieldUpdateOperationsInput | boolean
    physicianNotified?: BoolFieldUpdateOperationsInput | boolean
    supervisorNotified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDocumentationCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    title: string
    content?: string | null
    fileUrl?: string | null
    fileType?: string | null
    fileSize?: number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visit: HomeVisitCreateNestedOneWithoutDocumentationInput
  }

  export type VisitDocumentationUncheckedCreateInput = {
    id?: string
    visitId: string
    documentType: $Enums.DocumentType
    title: string
    content?: string | null
    fileUrl?: string | null
    fileType?: string | null
    fileSize?: number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitDocumentationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: HomeVisitUpdateOneRequiredWithoutDocumentationNestedInput
  }

  export type VisitDocumentationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDocumentationCreateManyInput = {
    id?: string
    visitId: string
    documentType: $Enums.DocumentType
    title: string
    content?: string | null
    fileUrl?: string | null
    fileType?: string | null
    fileSize?: number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitDocumentationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDocumentationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientEquipmentCreateInput = {
    id?: string
    equipmentType: $Enums.EquipmentType
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    status?: $Enums.EquipmentStatus
    condition?: $Enums.EquipmentCondition
    deliveredDate?: Date | string | null
    expectedReturnDate?: Date | string | null
    returnedDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    maintenanceNotes?: string | null
    ownershipType?: $Enums.OwnershipType
    rentalCompany?: string | null
    monthlyRentalCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutEquipmentInput
  }

  export type PatientEquipmentUncheckedCreateInput = {
    id?: string
    patientHomeId: string
    equipmentType: $Enums.EquipmentType
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    status?: $Enums.EquipmentStatus
    condition?: $Enums.EquipmentCondition
    deliveredDate?: Date | string | null
    expectedReturnDate?: Date | string | null
    returnedDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    maintenanceNotes?: string | null
    ownershipType?: $Enums.OwnershipType
    rentalCompany?: string | null
    monthlyRentalCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientEquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentType?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFieldUpdateOperationsInput | $Enums.EquipmentCondition
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: EnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType
    rentalCompany?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutEquipmentNestedInput
  }

  export type PatientEquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    equipmentType?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFieldUpdateOperationsInput | $Enums.EquipmentCondition
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: EnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType
    rentalCompany?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientEquipmentCreateManyInput = {
    id?: string
    patientHomeId: string
    equipmentType: $Enums.EquipmentType
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    status?: $Enums.EquipmentStatus
    condition?: $Enums.EquipmentCondition
    deliveredDate?: Date | string | null
    expectedReturnDate?: Date | string | null
    returnedDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    maintenanceNotes?: string | null
    ownershipType?: $Enums.OwnershipType
    rentalCompany?: string | null
    monthlyRentalCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientEquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentType?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFieldUpdateOperationsInput | $Enums.EquipmentCondition
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: EnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType
    rentalCompany?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientEquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    equipmentType?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFieldUpdateOperationsInput | $Enums.EquipmentCondition
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: EnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType
    rentalCompany?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyCommunicationCreateInput = {
    id?: string
    patientId: string
    familyMemberId?: string | null
    caregiverId?: string | null
    communicationType: $Enums.CommunicationType
    subject?: string | null
    message: string
    visitId?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyCommunicationUncheckedCreateInput = {
    id?: string
    patientId: string
    familyMemberId?: string | null
    caregiverId?: string | null
    communicationType: $Enums.CommunicationType
    subject?: string | null
    message: string
    visitId?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyCommunicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    familyMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyCommunicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    familyMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyCommunicationCreateManyInput = {
    id?: string
    patientId: string
    familyMemberId?: string | null
    caregiverId?: string | null
    communicationType: $Enums.CommunicationType
    subject?: string | null
    message: string
    visitId?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyCommunicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    familyMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyCommunicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    familyMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationType?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyOrderCreateInput = {
    id?: string
    patientId: string
    orderedBy: string
    items: JsonNullValueInput | InputJsonValue
    totalCost?: number | null
    status?: $Enums.SupplyOrderStatus
    orderedAt?: Date | string
    expectedDelivery?: Date | string | null
    deliveredAt?: Date | string | null
    deliveryNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyOrderUncheckedCreateInput = {
    id?: string
    patientId: string
    orderedBy: string
    items: JsonNullValueInput | InputJsonValue
    totalCost?: number | null
    status?: $Enums.SupplyOrderStatus
    orderedAt?: Date | string
    expectedDelivery?: Date | string | null
    deliveredAt?: Date | string | null
    deliveryNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderedBy?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSupplyOrderStatusFieldUpdateOperationsInput | $Enums.SupplyOrderStatus
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderedBy?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSupplyOrderStatusFieldUpdateOperationsInput | $Enums.SupplyOrderStatus
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyOrderCreateManyInput = {
    id?: string
    patientId: string
    orderedBy: string
    items: JsonNullValueInput | InputJsonValue
    totalCost?: number | null
    status?: $Enums.SupplyOrderStatus
    orderedAt?: Date | string
    expectedDelivery?: Date | string | null
    deliveredAt?: Date | string | null
    deliveryNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplyOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderedBy?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSupplyOrderStatusFieldUpdateOperationsInput | $Enums.SupplyOrderStatus
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplyOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderedBy?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSupplyOrderStatusFieldUpdateOperationsInput | $Enums.SupplyOrderStatus
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumLicenseTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseTypeNullableFilter<$PrismaModel> | $Enums.LicenseType | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumCaregiverStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CaregiverStatus | EnumCaregiverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaregiverStatusFilter<$PrismaModel> | $Enums.CaregiverStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HomeVisitListRelationFilter = {
    every?: HomeVisitWhereInput
    some?: HomeVisitWhereInput
    none?: HomeVisitWhereInput
  }

  export type CaregiverScheduleListRelationFilter = {
    every?: CaregiverScheduleWhereInput
    some?: CaregiverScheduleWhereInput
    none?: CaregiverScheduleWhereInput
  }

  export type TimeEntryListRelationFilter = {
    every?: TimeEntryWhereInput
    some?: TimeEntryWhereInput
    none?: TimeEntryWhereInput
  }

  export type MileageEntryListRelationFilter = {
    every?: MileageEntryWhereInput
    some?: MileageEntryWhereInput
    none?: MileageEntryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type HomeVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaregiverScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MileageEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaregiverCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrder
    licenseType?: SortOrder
    licenseExpiry?: SortOrder
    certifications?: SortOrder
    specialties?: SortOrder
    languages?: SortOrder
    status?: SortOrder
    hourlyRate?: SortOrder
    maxDailyVisits?: SortOrder
    maxWeeklyHours?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    homeLatitude?: SortOrder
    homeLongitude?: SortOrder
    homeAddress?: SortOrder
    serviceRadius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaregiverAvgOrderByAggregateInput = {
    hourlyRate?: SortOrder
    maxDailyVisits?: SortOrder
    maxWeeklyHours?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    homeLatitude?: SortOrder
    homeLongitude?: SortOrder
    serviceRadius?: SortOrder
  }

  export type CaregiverMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrder
    licenseType?: SortOrder
    licenseExpiry?: SortOrder
    status?: SortOrder
    hourlyRate?: SortOrder
    maxDailyVisits?: SortOrder
    maxWeeklyHours?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    homeLatitude?: SortOrder
    homeLongitude?: SortOrder
    homeAddress?: SortOrder
    serviceRadius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaregiverMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrder
    licenseType?: SortOrder
    licenseExpiry?: SortOrder
    status?: SortOrder
    hourlyRate?: SortOrder
    maxDailyVisits?: SortOrder
    maxWeeklyHours?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    homeLatitude?: SortOrder
    homeLongitude?: SortOrder
    homeAddress?: SortOrder
    serviceRadius?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaregiverSumOrderByAggregateInput = {
    hourlyRate?: SortOrder
    maxDailyVisits?: SortOrder
    maxWeeklyHours?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    homeLatitude?: SortOrder
    homeLongitude?: SortOrder
    serviceRadius?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumLicenseTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.LicenseType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLicenseTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumLicenseTypeNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCaregiverStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaregiverStatus | EnumCaregiverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaregiverStatusWithAggregatesFilter<$PrismaModel> | $Enums.CaregiverStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaregiverStatusFilter<$PrismaModel>
    _max?: NestedEnumCaregiverStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CaregiverRelationFilter = {
    is?: CaregiverWhereInput
    isNot?: CaregiverWhereInput
  }

  export type CaregiverScheduleCaregiverIdDayOfWeekCompoundUniqueInput = {
    caregiverId: string
    dayOfWeek: number
  }

  export type CaregiverScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaregiverScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type CaregiverScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaregiverScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaregiverScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumHomeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeType | EnumHomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeTypeFilter<$PrismaModel> | $Enums.HomeType
  }

  export type HomeAssessmentListRelationFilter = {
    every?: HomeAssessmentWhereInput
    some?: HomeAssessmentWhereInput
    none?: HomeAssessmentWhereInput
  }

  export type PatientEquipmentListRelationFilter = {
    every?: PatientEquipmentWhereInput
    some?: PatientEquipmentWhereInput
    none?: PatientEquipmentWhereInput
  }

  export type HomeAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientHomeCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accessInstructions?: SortOrder
    gateCode?: SortOrder
    parkingInfo?: SortOrder
    petInfo?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    homeType?: SortOrder
    hasStairs?: SortOrder
    wheelchairAccessible?: SortOrder
    oxygenInHome?: SortOrder
    safetyHazards?: SortOrder
    specialEquipment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientHomeAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type PatientHomeMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accessInstructions?: SortOrder
    gateCode?: SortOrder
    parkingInfo?: SortOrder
    petInfo?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    homeType?: SortOrder
    hasStairs?: SortOrder
    wheelchairAccessible?: SortOrder
    oxygenInHome?: SortOrder
    safetyHazards?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientHomeMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accessInstructions?: SortOrder
    gateCode?: SortOrder
    parkingInfo?: SortOrder
    petInfo?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    homeType?: SortOrder
    hasStairs?: SortOrder
    wheelchairAccessible?: SortOrder
    oxygenInHome?: SortOrder
    safetyHazards?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientHomeSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumHomeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeType | EnumHomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeTypeWithAggregatesFilter<$PrismaModel> | $Enums.HomeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHomeTypeFilter<$PrismaModel>
    _max?: NestedEnumHomeTypeFilter<$PrismaModel>
  }

  export type EnumVisitPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitPriority | EnumVisitPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitPriorityFilter<$PrismaModel> | $Enums.VisitPriority
  }

  export type EnumVisitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeFilter<$PrismaModel> | $Enums.VisitType
  }

  export type EnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PatientHomeRelationFilter = {
    is?: PatientHomeWhereInput
    isNot?: PatientHomeWhereInput
  }

  export type VisitTaskListRelationFilter = {
    every?: VisitTaskWhereInput
    some?: VisitTaskWhereInput
    none?: VisitTaskWhereInput
  }

  export type EVVRecordListRelationFilter = {
    every?: EVVRecordWhereInput
    some?: EVVRecordWhereInput
    none?: EVVRecordWhereInput
  }

  export type MedicationAdministrationListRelationFilter = {
    every?: MedicationAdministrationWhereInput
    some?: MedicationAdministrationWhereInput
    none?: MedicationAdministrationWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type VisitDocumentationListRelationFilter = {
    every?: VisitDocumentationWhereInput
    some?: VisitDocumentationWhereInput
    none?: VisitDocumentationWhereInput
  }

  export type VisitTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EVVRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationAdministrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitDocumentationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HomeVisitCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patientHomeId?: SortOrder
    caregiverId?: SortOrder
    scheduledDate?: SortOrder
    scheduledStartTime?: SortOrder
    scheduledEndTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    visitType?: SortOrder
    status?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    actualDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    reasonForVisit?: SortOrder
    clinicalNotes?: SortOrder
    patientCondition?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrder
    caregiverSignature?: SortOrder
    patientSignature?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomeVisitAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type HomeVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patientHomeId?: SortOrder
    caregiverId?: SortOrder
    scheduledDate?: SortOrder
    scheduledStartTime?: SortOrder
    scheduledEndTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    visitType?: SortOrder
    status?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    actualDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    reasonForVisit?: SortOrder
    clinicalNotes?: SortOrder
    patientCondition?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrder
    caregiverSignature?: SortOrder
    patientSignature?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomeVisitMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patientHomeId?: SortOrder
    caregiverId?: SortOrder
    scheduledDate?: SortOrder
    scheduledStartTime?: SortOrder
    scheduledEndTime?: SortOrder
    estimatedDuration?: SortOrder
    priority?: SortOrder
    visitType?: SortOrder
    status?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    actualDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    reasonForVisit?: SortOrder
    clinicalNotes?: SortOrder
    patientCondition?: SortOrder
    followUpRequired?: SortOrder
    followUpNotes?: SortOrder
    caregiverSignature?: SortOrder
    patientSignature?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomeVisitSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type EnumVisitPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitPriority | EnumVisitPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitPriorityWithAggregatesFilter<$PrismaModel> | $Enums.VisitPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitPriorityFilter<$PrismaModel>
    _max?: NestedEnumVisitPriorityFilter<$PrismaModel>
  }

  export type EnumVisitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitTypeFilter<$PrismaModel>
  }

  export type EnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumCareTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareTaskType | EnumCareTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTaskTypeFilter<$PrismaModel> | $Enums.CareTaskType
  }

  export type EnumTaskCompletionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCompletionStatus | EnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCompletionStatusFilter<$PrismaModel> | $Enums.TaskCompletionStatus
  }

  export type HomeVisitRelationFilter = {
    is?: HomeVisitWhereInput
    isNot?: HomeVisitWhereInput
  }

  export type VisitTaskCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isRequired?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    completedBy?: SortOrder
    notes?: SortOrder
    vitalType?: SortOrder
    vitalValue?: SortOrder
    vitalUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTaskAvgOrderByAggregateInput = {
    sequence?: SortOrder
    vitalValue?: SortOrder
  }

  export type VisitTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isRequired?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    completedBy?: SortOrder
    notes?: SortOrder
    vitalType?: SortOrder
    vitalValue?: SortOrder
    vitalUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTaskMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isRequired?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    completedBy?: SortOrder
    notes?: SortOrder
    vitalType?: SortOrder
    vitalValue?: SortOrder
    vitalUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitTaskSumOrderByAggregateInput = {
    sequence?: SortOrder
    vitalValue?: SortOrder
  }

  export type EnumCareTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareTaskType | EnumCareTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareTaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumCareTaskTypeFilter<$PrismaModel>
  }

  export type EnumTaskCompletionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCompletionStatus | EnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCompletionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskCompletionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskCompletionStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskCompletionStatusFilter<$PrismaModel>
  }

  export type EnumEVVRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVRecordType | EnumEVVRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVRecordTypeFilter<$PrismaModel> | $Enums.EVVRecordType
  }

  export type EnumEVVVerificationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVVerificationMethod | EnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVVerificationMethodFilter<$PrismaModel> | $Enums.EVVVerificationMethod
  }

  export type EVVRecordCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    recordType?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    deviceId?: SortOrder
    deviceType?: SortOrder
    ipAddress?: SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    verificationNotes?: SortOrder
    distanceFromHome?: SortOrder
    isWithinGeofence?: SortOrder
    geofenceRadius?: SortOrder
    createdAt?: SortOrder
  }

  export type EVVRecordAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    distanceFromHome?: SortOrder
    geofenceRadius?: SortOrder
  }

  export type EVVRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    recordType?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    deviceId?: SortOrder
    deviceType?: SortOrder
    ipAddress?: SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    verificationNotes?: SortOrder
    distanceFromHome?: SortOrder
    isWithinGeofence?: SortOrder
    geofenceRadius?: SortOrder
    createdAt?: SortOrder
  }

  export type EVVRecordMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    recordType?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    deviceId?: SortOrder
    deviceType?: SortOrder
    ipAddress?: SortOrder
    isVerified?: SortOrder
    verificationMethod?: SortOrder
    verificationNotes?: SortOrder
    distanceFromHome?: SortOrder
    isWithinGeofence?: SortOrder
    geofenceRadius?: SortOrder
    createdAt?: SortOrder
  }

  export type EVVRecordSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    distanceFromHome?: SortOrder
    geofenceRadius?: SortOrder
  }

  export type EnumEVVRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVRecordType | EnumEVVRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.EVVRecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEVVRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumEVVRecordTypeFilter<$PrismaModel>
  }

  export type EnumEVVVerificationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVVerificationMethod | EnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVVerificationMethodWithAggregatesFilter<$PrismaModel> | $Enums.EVVVerificationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEVVVerificationMethodFilter<$PrismaModel>
    _max?: NestedEnumEVVVerificationMethodFilter<$PrismaModel>
  }

  export type EnumTimeEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryType | EnumTimeEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryTypeFilter<$PrismaModel> | $Enums.TimeEntryType
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type TimeEntryCountOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    visitId?: SortOrder
    entryType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryAvgOrderByAggregateInput = {
    duration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type TimeEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    visitId?: SortOrder
    entryType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryMinOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    visitId?: SortOrder
    entryType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntrySumOrderByAggregateInput = {
    duration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type EnumTimeEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryType | EnumTimeEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.TimeEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumTimeEntryTypeFilter<$PrismaModel>
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type MileageEntryCountOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    date?: SortOrder
    startAddress?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    purpose?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    routeData?: SortOrder
    ratePerMile?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MileageEntryAvgOrderByAggregateInput = {
    distance?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    ratePerMile?: SortOrder
    totalAmount?: SortOrder
  }

  export type MileageEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    date?: SortOrder
    startAddress?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    purpose?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    ratePerMile?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MileageEntryMinOrderByAggregateInput = {
    id?: SortOrder
    caregiverId?: SortOrder
    date?: SortOrder
    startAddress?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    purpose?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    ratePerMile?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MileageEntrySumOrderByAggregateInput = {
    distance?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    ratePerMile?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type HomeAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    assessorId?: SortOrder
    assessmentDate?: SortOrder
    safetyScore?: SortOrder
    fallRisk?: SortOrder
    fireRisk?: SortOrder
    infectionRisk?: SortOrder
    cleanlinessScore?: SortOrder
    adequateLighting?: SortOrder
    adequateVentilation?: SortOrder
    workingUtilities?: SortOrder
    bathroomAccessible?: SortOrder
    bedroomAccessible?: SortOrder
    kitchenAccessible?: SortOrder
    recommendations?: SortOrder
    requiredEquipment?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomeAssessmentAvgOrderByAggregateInput = {
    safetyScore?: SortOrder
    cleanlinessScore?: SortOrder
  }

  export type HomeAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    assessorId?: SortOrder
    assessmentDate?: SortOrder
    safetyScore?: SortOrder
    fallRisk?: SortOrder
    fireRisk?: SortOrder
    infectionRisk?: SortOrder
    cleanlinessScore?: SortOrder
    adequateLighting?: SortOrder
    adequateVentilation?: SortOrder
    workingUtilities?: SortOrder
    bathroomAccessible?: SortOrder
    bedroomAccessible?: SortOrder
    kitchenAccessible?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomeAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    assessorId?: SortOrder
    assessmentDate?: SortOrder
    safetyScore?: SortOrder
    fallRisk?: SortOrder
    fireRisk?: SortOrder
    infectionRisk?: SortOrder
    cleanlinessScore?: SortOrder
    adequateLighting?: SortOrder
    adequateVentilation?: SortOrder
    workingUtilities?: SortOrder
    bathroomAccessible?: SortOrder
    bedroomAccessible?: SortOrder
    kitchenAccessible?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomeAssessmentSumOrderByAggregateInput = {
    safetyScore?: SortOrder
    cleanlinessScore?: SortOrder
  }

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type EnumMedicationRouteFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationRoute | EnumMedicationRouteFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationRouteFilter<$PrismaModel> | $Enums.MedicationRoute
  }

  export type EnumMedicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusFilter<$PrismaModel> | $Enums.MedicationStatus
  }

  export type MedicationAdministrationCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    scheduledTime?: SortOrder
    administeredTime?: SortOrder
    status?: SortOrder
    refusedReason?: SortOrder
    notes?: SortOrder
    administeredBy?: SortOrder
    witnessedBy?: SortOrder
    medicationBarcode?: SortOrder
    patientBarcode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationAdministrationMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    scheduledTime?: SortOrder
    administeredTime?: SortOrder
    status?: SortOrder
    refusedReason?: SortOrder
    notes?: SortOrder
    administeredBy?: SortOrder
    witnessedBy?: SortOrder
    medicationBarcode?: SortOrder
    patientBarcode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationAdministrationMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    medicationName?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    scheduledTime?: SortOrder
    administeredTime?: SortOrder
    status?: SortOrder
    refusedReason?: SortOrder
    notes?: SortOrder
    administeredBy?: SortOrder
    witnessedBy?: SortOrder
    medicationBarcode?: SortOrder
    patientBarcode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMedicationRouteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationRoute | EnumMedicationRouteFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationRouteWithAggregatesFilter<$PrismaModel> | $Enums.MedicationRoute
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicationRouteFilter<$PrismaModel>
    _max?: NestedEnumMedicationRouteFilter<$PrismaModel>
  }

  export type EnumMedicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicationStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicationStatusFilter<$PrismaModel>
  }

  export type EnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type EnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type EnumFallTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FallType | EnumFallTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFallTypeNullableFilter<$PrismaModel> | $Enums.FallType | null
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type HomeVisitNullableRelationFilter = {
    is?: HomeVisitWhereInput | null
    isNot?: HomeVisitWhereInput | null
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    patientId?: SortOrder
    caregiverId?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    occurredAt?: SortOrder
    location?: SortOrder
    description?: SortOrder
    immediateAction?: SortOrder
    witnessNames?: SortOrder
    fallType?: SortOrder
    injuryOccurred?: SortOrder
    injuryDescription?: SortOrder
    medicalAttentionRequired?: SortOrder
    emergencyServicesNotified?: SortOrder
    status?: SortOrder
    investigatedBy?: SortOrder
    investigatedAt?: SortOrder
    rootCause?: SortOrder
    preventiveMeasures?: SortOrder
    familyNotified?: SortOrder
    physicianNotified?: SortOrder
    supervisorNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    patientId?: SortOrder
    caregiverId?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    occurredAt?: SortOrder
    location?: SortOrder
    description?: SortOrder
    immediateAction?: SortOrder
    witnessNames?: SortOrder
    fallType?: SortOrder
    injuryOccurred?: SortOrder
    injuryDescription?: SortOrder
    medicalAttentionRequired?: SortOrder
    emergencyServicesNotified?: SortOrder
    status?: SortOrder
    investigatedBy?: SortOrder
    investigatedAt?: SortOrder
    rootCause?: SortOrder
    preventiveMeasures?: SortOrder
    familyNotified?: SortOrder
    physicianNotified?: SortOrder
    supervisorNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    patientId?: SortOrder
    caregiverId?: SortOrder
    incidentType?: SortOrder
    severity?: SortOrder
    occurredAt?: SortOrder
    location?: SortOrder
    description?: SortOrder
    immediateAction?: SortOrder
    witnessNames?: SortOrder
    fallType?: SortOrder
    injuryOccurred?: SortOrder
    injuryDescription?: SortOrder
    medicalAttentionRequired?: SortOrder
    emergencyServicesNotified?: SortOrder
    status?: SortOrder
    investigatedBy?: SortOrder
    investigatedAt?: SortOrder
    rootCause?: SortOrder
    preventiveMeasures?: SortOrder
    familyNotified?: SortOrder
    physicianNotified?: SortOrder
    supervisorNotified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type EnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type EnumFallTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FallType | EnumFallTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFallTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FallType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFallTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFallTypeNullableFilter<$PrismaModel>
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type VisitDocumentationCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    assessmentData?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitDocumentationAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type VisitDocumentationMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitDocumentationMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    documentType?: SortOrder
    title?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitDocumentationSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumEquipmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeFilter<$PrismaModel> | $Enums.EquipmentType
  }

  export type EnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type EnumEquipmentConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCondition | EnumEquipmentConditionFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentConditionFilter<$PrismaModel> | $Enums.EquipmentCondition
  }

  export type EnumOwnershipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipTypeFilter<$PrismaModel> | $Enums.OwnershipType
  }

  export type PatientEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    equipmentType?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    deliveredDate?: SortOrder
    expectedReturnDate?: SortOrder
    returnedDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    maintenanceNotes?: SortOrder
    ownershipType?: SortOrder
    rentalCompany?: SortOrder
    monthlyRentalCost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientEquipmentAvgOrderByAggregateInput = {
    monthlyRentalCost?: SortOrder
  }

  export type PatientEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    equipmentType?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    deliveredDate?: SortOrder
    expectedReturnDate?: SortOrder
    returnedDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    maintenanceNotes?: SortOrder
    ownershipType?: SortOrder
    rentalCompany?: SortOrder
    monthlyRentalCost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientHomeId?: SortOrder
    equipmentType?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    deliveredDate?: SortOrder
    expectedReturnDate?: SortOrder
    returnedDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    nextMaintenanceDate?: SortOrder
    maintenanceNotes?: SortOrder
    ownershipType?: SortOrder
    rentalCompany?: SortOrder
    monthlyRentalCost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientEquipmentSumOrderByAggregateInput = {
    monthlyRentalCost?: SortOrder
  }

  export type EnumEquipmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentTypeFilter<$PrismaModel>
    _max?: NestedEnumEquipmentTypeFilter<$PrismaModel>
  }

  export type EnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type EnumEquipmentConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCondition | EnumEquipmentConditionFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentConditionWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentConditionFilter<$PrismaModel>
    _max?: NestedEnumEquipmentConditionFilter<$PrismaModel>
  }

  export type EnumOwnershipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipTypeWithAggregatesFilter<$PrismaModel> | $Enums.OwnershipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnershipTypeFilter<$PrismaModel>
    _max?: NestedEnumOwnershipTypeFilter<$PrismaModel>
  }

  export type EnumCommunicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeFilter<$PrismaModel> | $Enums.CommunicationType
  }

  export type FamilyCommunicationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    familyMemberId?: SortOrder
    caregiverId?: SortOrder
    communicationType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    visitId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    parentMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyCommunicationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    familyMemberId?: SortOrder
    caregiverId?: SortOrder
    communicationType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    visitId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    parentMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyCommunicationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    familyMemberId?: SortOrder
    caregiverId?: SortOrder
    communicationType?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    visitId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    parentMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommunicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommunicationTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumSupplyOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplyOrderStatus | EnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplyOrderStatusFilter<$PrismaModel> | $Enums.SupplyOrderStatus
  }

  export type SupplyOrderCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderedBy?: SortOrder
    items?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderedAt?: SortOrder
    expectedDelivery?: SortOrder
    deliveredAt?: SortOrder
    deliveryNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplyOrderAvgOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type SupplyOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderedBy?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderedAt?: SortOrder
    expectedDelivery?: SortOrder
    deliveredAt?: SortOrder
    deliveryNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplyOrderMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderedBy?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderedAt?: SortOrder
    expectedDelivery?: SortOrder
    deliveredAt?: SortOrder
    deliveryNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplyOrderSumOrderByAggregateInput = {
    totalCost?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumSupplyOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplyOrderStatus | EnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplyOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupplyOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupplyOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumSupplyOrderStatusFilter<$PrismaModel>
  }

  export type CaregiverCreatespecialtiesInput = {
    set: string[]
  }

  export type CaregiverCreatelanguagesInput = {
    set: string[]
  }

  export type HomeVisitCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<HomeVisitCreateWithoutCaregiverInput, HomeVisitUncheckedCreateWithoutCaregiverInput> | HomeVisitCreateWithoutCaregiverInput[] | HomeVisitUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutCaregiverInput | HomeVisitCreateOrConnectWithoutCaregiverInput[]
    createMany?: HomeVisitCreateManyCaregiverInputEnvelope
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
  }

  export type CaregiverScheduleCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<CaregiverScheduleCreateWithoutCaregiverInput, CaregiverScheduleUncheckedCreateWithoutCaregiverInput> | CaregiverScheduleCreateWithoutCaregiverInput[] | CaregiverScheduleUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: CaregiverScheduleCreateOrConnectWithoutCaregiverInput | CaregiverScheduleCreateOrConnectWithoutCaregiverInput[]
    createMany?: CaregiverScheduleCreateManyCaregiverInputEnvelope
    connect?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<TimeEntryCreateWithoutCaregiverInput, TimeEntryUncheckedCreateWithoutCaregiverInput> | TimeEntryCreateWithoutCaregiverInput[] | TimeEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutCaregiverInput | TimeEntryCreateOrConnectWithoutCaregiverInput[]
    createMany?: TimeEntryCreateManyCaregiverInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type MileageEntryCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<MileageEntryCreateWithoutCaregiverInput, MileageEntryUncheckedCreateWithoutCaregiverInput> | MileageEntryCreateWithoutCaregiverInput[] | MileageEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: MileageEntryCreateOrConnectWithoutCaregiverInput | MileageEntryCreateOrConnectWithoutCaregiverInput[]
    createMany?: MileageEntryCreateManyCaregiverInputEnvelope
    connect?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
  }

  export type HomeVisitUncheckedCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<HomeVisitCreateWithoutCaregiverInput, HomeVisitUncheckedCreateWithoutCaregiverInput> | HomeVisitCreateWithoutCaregiverInput[] | HomeVisitUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutCaregiverInput | HomeVisitCreateOrConnectWithoutCaregiverInput[]
    createMany?: HomeVisitCreateManyCaregiverInputEnvelope
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
  }

  export type CaregiverScheduleUncheckedCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<CaregiverScheduleCreateWithoutCaregiverInput, CaregiverScheduleUncheckedCreateWithoutCaregiverInput> | CaregiverScheduleCreateWithoutCaregiverInput[] | CaregiverScheduleUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: CaregiverScheduleCreateOrConnectWithoutCaregiverInput | CaregiverScheduleCreateOrConnectWithoutCaregiverInput[]
    createMany?: CaregiverScheduleCreateManyCaregiverInputEnvelope
    connect?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<TimeEntryCreateWithoutCaregiverInput, TimeEntryUncheckedCreateWithoutCaregiverInput> | TimeEntryCreateWithoutCaregiverInput[] | TimeEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutCaregiverInput | TimeEntryCreateOrConnectWithoutCaregiverInput[]
    createMany?: TimeEntryCreateManyCaregiverInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type MileageEntryUncheckedCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<MileageEntryCreateWithoutCaregiverInput, MileageEntryUncheckedCreateWithoutCaregiverInput> | MileageEntryCreateWithoutCaregiverInput[] | MileageEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: MileageEntryCreateOrConnectWithoutCaregiverInput | MileageEntryCreateOrConnectWithoutCaregiverInput[]
    createMany?: MileageEntryCreateManyCaregiverInputEnvelope
    connect?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumLicenseTypeFieldUpdateOperationsInput = {
    set?: $Enums.LicenseType | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CaregiverUpdatespecialtiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CaregiverUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumCaregiverStatusFieldUpdateOperationsInput = {
    set?: $Enums.CaregiverStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HomeVisitUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<HomeVisitCreateWithoutCaregiverInput, HomeVisitUncheckedCreateWithoutCaregiverInput> | HomeVisitCreateWithoutCaregiverInput[] | HomeVisitUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutCaregiverInput | HomeVisitCreateOrConnectWithoutCaregiverInput[]
    upsert?: HomeVisitUpsertWithWhereUniqueWithoutCaregiverInput | HomeVisitUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: HomeVisitCreateManyCaregiverInputEnvelope
    set?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    disconnect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    delete?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    update?: HomeVisitUpdateWithWhereUniqueWithoutCaregiverInput | HomeVisitUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: HomeVisitUpdateManyWithWhereWithoutCaregiverInput | HomeVisitUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: HomeVisitScalarWhereInput | HomeVisitScalarWhereInput[]
  }

  export type CaregiverScheduleUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<CaregiverScheduleCreateWithoutCaregiverInput, CaregiverScheduleUncheckedCreateWithoutCaregiverInput> | CaregiverScheduleCreateWithoutCaregiverInput[] | CaregiverScheduleUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: CaregiverScheduleCreateOrConnectWithoutCaregiverInput | CaregiverScheduleCreateOrConnectWithoutCaregiverInput[]
    upsert?: CaregiverScheduleUpsertWithWhereUniqueWithoutCaregiverInput | CaregiverScheduleUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: CaregiverScheduleCreateManyCaregiverInputEnvelope
    set?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    disconnect?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    delete?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    connect?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    update?: CaregiverScheduleUpdateWithWhereUniqueWithoutCaregiverInput | CaregiverScheduleUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: CaregiverScheduleUpdateManyWithWhereWithoutCaregiverInput | CaregiverScheduleUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: CaregiverScheduleScalarWhereInput | CaregiverScheduleScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<TimeEntryCreateWithoutCaregiverInput, TimeEntryUncheckedCreateWithoutCaregiverInput> | TimeEntryCreateWithoutCaregiverInput[] | TimeEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutCaregiverInput | TimeEntryCreateOrConnectWithoutCaregiverInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutCaregiverInput | TimeEntryUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: TimeEntryCreateManyCaregiverInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutCaregiverInput | TimeEntryUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutCaregiverInput | TimeEntryUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type MileageEntryUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<MileageEntryCreateWithoutCaregiverInput, MileageEntryUncheckedCreateWithoutCaregiverInput> | MileageEntryCreateWithoutCaregiverInput[] | MileageEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: MileageEntryCreateOrConnectWithoutCaregiverInput | MileageEntryCreateOrConnectWithoutCaregiverInput[]
    upsert?: MileageEntryUpsertWithWhereUniqueWithoutCaregiverInput | MileageEntryUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: MileageEntryCreateManyCaregiverInputEnvelope
    set?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    disconnect?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    delete?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    connect?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    update?: MileageEntryUpdateWithWhereUniqueWithoutCaregiverInput | MileageEntryUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: MileageEntryUpdateManyWithWhereWithoutCaregiverInput | MileageEntryUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: MileageEntryScalarWhereInput | MileageEntryScalarWhereInput[]
  }

  export type HomeVisitUncheckedUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<HomeVisitCreateWithoutCaregiverInput, HomeVisitUncheckedCreateWithoutCaregiverInput> | HomeVisitCreateWithoutCaregiverInput[] | HomeVisitUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutCaregiverInput | HomeVisitCreateOrConnectWithoutCaregiverInput[]
    upsert?: HomeVisitUpsertWithWhereUniqueWithoutCaregiverInput | HomeVisitUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: HomeVisitCreateManyCaregiverInputEnvelope
    set?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    disconnect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    delete?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    update?: HomeVisitUpdateWithWhereUniqueWithoutCaregiverInput | HomeVisitUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: HomeVisitUpdateManyWithWhereWithoutCaregiverInput | HomeVisitUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: HomeVisitScalarWhereInput | HomeVisitScalarWhereInput[]
  }

  export type CaregiverScheduleUncheckedUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<CaregiverScheduleCreateWithoutCaregiverInput, CaregiverScheduleUncheckedCreateWithoutCaregiverInput> | CaregiverScheduleCreateWithoutCaregiverInput[] | CaregiverScheduleUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: CaregiverScheduleCreateOrConnectWithoutCaregiverInput | CaregiverScheduleCreateOrConnectWithoutCaregiverInput[]
    upsert?: CaregiverScheduleUpsertWithWhereUniqueWithoutCaregiverInput | CaregiverScheduleUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: CaregiverScheduleCreateManyCaregiverInputEnvelope
    set?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    disconnect?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    delete?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    connect?: CaregiverScheduleWhereUniqueInput | CaregiverScheduleWhereUniqueInput[]
    update?: CaregiverScheduleUpdateWithWhereUniqueWithoutCaregiverInput | CaregiverScheduleUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: CaregiverScheduleUpdateManyWithWhereWithoutCaregiverInput | CaregiverScheduleUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: CaregiverScheduleScalarWhereInput | CaregiverScheduleScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<TimeEntryCreateWithoutCaregiverInput, TimeEntryUncheckedCreateWithoutCaregiverInput> | TimeEntryCreateWithoutCaregiverInput[] | TimeEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutCaregiverInput | TimeEntryCreateOrConnectWithoutCaregiverInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutCaregiverInput | TimeEntryUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: TimeEntryCreateManyCaregiverInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutCaregiverInput | TimeEntryUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutCaregiverInput | TimeEntryUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type MileageEntryUncheckedUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<MileageEntryCreateWithoutCaregiverInput, MileageEntryUncheckedCreateWithoutCaregiverInput> | MileageEntryCreateWithoutCaregiverInput[] | MileageEntryUncheckedCreateWithoutCaregiverInput[]
    connectOrCreate?: MileageEntryCreateOrConnectWithoutCaregiverInput | MileageEntryCreateOrConnectWithoutCaregiverInput[]
    upsert?: MileageEntryUpsertWithWhereUniqueWithoutCaregiverInput | MileageEntryUpsertWithWhereUniqueWithoutCaregiverInput[]
    createMany?: MileageEntryCreateManyCaregiverInputEnvelope
    set?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    disconnect?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    delete?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    connect?: MileageEntryWhereUniqueInput | MileageEntryWhereUniqueInput[]
    update?: MileageEntryUpdateWithWhereUniqueWithoutCaregiverInput | MileageEntryUpdateWithWhereUniqueWithoutCaregiverInput[]
    updateMany?: MileageEntryUpdateManyWithWhereWithoutCaregiverInput | MileageEntryUpdateManyWithWhereWithoutCaregiverInput[]
    deleteMany?: MileageEntryScalarWhereInput | MileageEntryScalarWhereInput[]
  }

  export type CaregiverCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<CaregiverCreateWithoutSchedulesInput, CaregiverUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutSchedulesInput
    connect?: CaregiverWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CaregiverUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<CaregiverCreateWithoutSchedulesInput, CaregiverUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutSchedulesInput
    upsert?: CaregiverUpsertWithoutSchedulesInput
    connect?: CaregiverWhereUniqueInput
    update?: XOR<XOR<CaregiverUpdateToOneWithWhereWithoutSchedulesInput, CaregiverUpdateWithoutSchedulesInput>, CaregiverUncheckedUpdateWithoutSchedulesInput>
  }

  export type PatientHomeCreatespecialEquipmentInput = {
    set: string[]
  }

  export type HomeVisitCreateNestedManyWithoutPatientHomeInput = {
    create?: XOR<HomeVisitCreateWithoutPatientHomeInput, HomeVisitUncheckedCreateWithoutPatientHomeInput> | HomeVisitCreateWithoutPatientHomeInput[] | HomeVisitUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutPatientHomeInput | HomeVisitCreateOrConnectWithoutPatientHomeInput[]
    createMany?: HomeVisitCreateManyPatientHomeInputEnvelope
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
  }

  export type HomeAssessmentCreateNestedManyWithoutPatientHomeInput = {
    create?: XOR<HomeAssessmentCreateWithoutPatientHomeInput, HomeAssessmentUncheckedCreateWithoutPatientHomeInput> | HomeAssessmentCreateWithoutPatientHomeInput[] | HomeAssessmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeAssessmentCreateOrConnectWithoutPatientHomeInput | HomeAssessmentCreateOrConnectWithoutPatientHomeInput[]
    createMany?: HomeAssessmentCreateManyPatientHomeInputEnvelope
    connect?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
  }

  export type PatientEquipmentCreateNestedManyWithoutPatientHomeInput = {
    create?: XOR<PatientEquipmentCreateWithoutPatientHomeInput, PatientEquipmentUncheckedCreateWithoutPatientHomeInput> | PatientEquipmentCreateWithoutPatientHomeInput[] | PatientEquipmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: PatientEquipmentCreateOrConnectWithoutPatientHomeInput | PatientEquipmentCreateOrConnectWithoutPatientHomeInput[]
    createMany?: PatientEquipmentCreateManyPatientHomeInputEnvelope
    connect?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
  }

  export type HomeVisitUncheckedCreateNestedManyWithoutPatientHomeInput = {
    create?: XOR<HomeVisitCreateWithoutPatientHomeInput, HomeVisitUncheckedCreateWithoutPatientHomeInput> | HomeVisitCreateWithoutPatientHomeInput[] | HomeVisitUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutPatientHomeInput | HomeVisitCreateOrConnectWithoutPatientHomeInput[]
    createMany?: HomeVisitCreateManyPatientHomeInputEnvelope
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
  }

  export type HomeAssessmentUncheckedCreateNestedManyWithoutPatientHomeInput = {
    create?: XOR<HomeAssessmentCreateWithoutPatientHomeInput, HomeAssessmentUncheckedCreateWithoutPatientHomeInput> | HomeAssessmentCreateWithoutPatientHomeInput[] | HomeAssessmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeAssessmentCreateOrConnectWithoutPatientHomeInput | HomeAssessmentCreateOrConnectWithoutPatientHomeInput[]
    createMany?: HomeAssessmentCreateManyPatientHomeInputEnvelope
    connect?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
  }

  export type PatientEquipmentUncheckedCreateNestedManyWithoutPatientHomeInput = {
    create?: XOR<PatientEquipmentCreateWithoutPatientHomeInput, PatientEquipmentUncheckedCreateWithoutPatientHomeInput> | PatientEquipmentCreateWithoutPatientHomeInput[] | PatientEquipmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: PatientEquipmentCreateOrConnectWithoutPatientHomeInput | PatientEquipmentCreateOrConnectWithoutPatientHomeInput[]
    createMany?: PatientEquipmentCreateManyPatientHomeInputEnvelope
    connect?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
  }

  export type EnumHomeTypeFieldUpdateOperationsInput = {
    set?: $Enums.HomeType
  }

  export type PatientHomeUpdatespecialEquipmentInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HomeVisitUpdateManyWithoutPatientHomeNestedInput = {
    create?: XOR<HomeVisitCreateWithoutPatientHomeInput, HomeVisitUncheckedCreateWithoutPatientHomeInput> | HomeVisitCreateWithoutPatientHomeInput[] | HomeVisitUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutPatientHomeInput | HomeVisitCreateOrConnectWithoutPatientHomeInput[]
    upsert?: HomeVisitUpsertWithWhereUniqueWithoutPatientHomeInput | HomeVisitUpsertWithWhereUniqueWithoutPatientHomeInput[]
    createMany?: HomeVisitCreateManyPatientHomeInputEnvelope
    set?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    disconnect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    delete?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    update?: HomeVisitUpdateWithWhereUniqueWithoutPatientHomeInput | HomeVisitUpdateWithWhereUniqueWithoutPatientHomeInput[]
    updateMany?: HomeVisitUpdateManyWithWhereWithoutPatientHomeInput | HomeVisitUpdateManyWithWhereWithoutPatientHomeInput[]
    deleteMany?: HomeVisitScalarWhereInput | HomeVisitScalarWhereInput[]
  }

  export type HomeAssessmentUpdateManyWithoutPatientHomeNestedInput = {
    create?: XOR<HomeAssessmentCreateWithoutPatientHomeInput, HomeAssessmentUncheckedCreateWithoutPatientHomeInput> | HomeAssessmentCreateWithoutPatientHomeInput[] | HomeAssessmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeAssessmentCreateOrConnectWithoutPatientHomeInput | HomeAssessmentCreateOrConnectWithoutPatientHomeInput[]
    upsert?: HomeAssessmentUpsertWithWhereUniqueWithoutPatientHomeInput | HomeAssessmentUpsertWithWhereUniqueWithoutPatientHomeInput[]
    createMany?: HomeAssessmentCreateManyPatientHomeInputEnvelope
    set?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    disconnect?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    delete?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    connect?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    update?: HomeAssessmentUpdateWithWhereUniqueWithoutPatientHomeInput | HomeAssessmentUpdateWithWhereUniqueWithoutPatientHomeInput[]
    updateMany?: HomeAssessmentUpdateManyWithWhereWithoutPatientHomeInput | HomeAssessmentUpdateManyWithWhereWithoutPatientHomeInput[]
    deleteMany?: HomeAssessmentScalarWhereInput | HomeAssessmentScalarWhereInput[]
  }

  export type PatientEquipmentUpdateManyWithoutPatientHomeNestedInput = {
    create?: XOR<PatientEquipmentCreateWithoutPatientHomeInput, PatientEquipmentUncheckedCreateWithoutPatientHomeInput> | PatientEquipmentCreateWithoutPatientHomeInput[] | PatientEquipmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: PatientEquipmentCreateOrConnectWithoutPatientHomeInput | PatientEquipmentCreateOrConnectWithoutPatientHomeInput[]
    upsert?: PatientEquipmentUpsertWithWhereUniqueWithoutPatientHomeInput | PatientEquipmentUpsertWithWhereUniqueWithoutPatientHomeInput[]
    createMany?: PatientEquipmentCreateManyPatientHomeInputEnvelope
    set?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    disconnect?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    delete?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    connect?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    update?: PatientEquipmentUpdateWithWhereUniqueWithoutPatientHomeInput | PatientEquipmentUpdateWithWhereUniqueWithoutPatientHomeInput[]
    updateMany?: PatientEquipmentUpdateManyWithWhereWithoutPatientHomeInput | PatientEquipmentUpdateManyWithWhereWithoutPatientHomeInput[]
    deleteMany?: PatientEquipmentScalarWhereInput | PatientEquipmentScalarWhereInput[]
  }

  export type HomeVisitUncheckedUpdateManyWithoutPatientHomeNestedInput = {
    create?: XOR<HomeVisitCreateWithoutPatientHomeInput, HomeVisitUncheckedCreateWithoutPatientHomeInput> | HomeVisitCreateWithoutPatientHomeInput[] | HomeVisitUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeVisitCreateOrConnectWithoutPatientHomeInput | HomeVisitCreateOrConnectWithoutPatientHomeInput[]
    upsert?: HomeVisitUpsertWithWhereUniqueWithoutPatientHomeInput | HomeVisitUpsertWithWhereUniqueWithoutPatientHomeInput[]
    createMany?: HomeVisitCreateManyPatientHomeInputEnvelope
    set?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    disconnect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    delete?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    connect?: HomeVisitWhereUniqueInput | HomeVisitWhereUniqueInput[]
    update?: HomeVisitUpdateWithWhereUniqueWithoutPatientHomeInput | HomeVisitUpdateWithWhereUniqueWithoutPatientHomeInput[]
    updateMany?: HomeVisitUpdateManyWithWhereWithoutPatientHomeInput | HomeVisitUpdateManyWithWhereWithoutPatientHomeInput[]
    deleteMany?: HomeVisitScalarWhereInput | HomeVisitScalarWhereInput[]
  }

  export type HomeAssessmentUncheckedUpdateManyWithoutPatientHomeNestedInput = {
    create?: XOR<HomeAssessmentCreateWithoutPatientHomeInput, HomeAssessmentUncheckedCreateWithoutPatientHomeInput> | HomeAssessmentCreateWithoutPatientHomeInput[] | HomeAssessmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: HomeAssessmentCreateOrConnectWithoutPatientHomeInput | HomeAssessmentCreateOrConnectWithoutPatientHomeInput[]
    upsert?: HomeAssessmentUpsertWithWhereUniqueWithoutPatientHomeInput | HomeAssessmentUpsertWithWhereUniqueWithoutPatientHomeInput[]
    createMany?: HomeAssessmentCreateManyPatientHomeInputEnvelope
    set?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    disconnect?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    delete?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    connect?: HomeAssessmentWhereUniqueInput | HomeAssessmentWhereUniqueInput[]
    update?: HomeAssessmentUpdateWithWhereUniqueWithoutPatientHomeInput | HomeAssessmentUpdateWithWhereUniqueWithoutPatientHomeInput[]
    updateMany?: HomeAssessmentUpdateManyWithWhereWithoutPatientHomeInput | HomeAssessmentUpdateManyWithWhereWithoutPatientHomeInput[]
    deleteMany?: HomeAssessmentScalarWhereInput | HomeAssessmentScalarWhereInput[]
  }

  export type PatientEquipmentUncheckedUpdateManyWithoutPatientHomeNestedInput = {
    create?: XOR<PatientEquipmentCreateWithoutPatientHomeInput, PatientEquipmentUncheckedCreateWithoutPatientHomeInput> | PatientEquipmentCreateWithoutPatientHomeInput[] | PatientEquipmentUncheckedCreateWithoutPatientHomeInput[]
    connectOrCreate?: PatientEquipmentCreateOrConnectWithoutPatientHomeInput | PatientEquipmentCreateOrConnectWithoutPatientHomeInput[]
    upsert?: PatientEquipmentUpsertWithWhereUniqueWithoutPatientHomeInput | PatientEquipmentUpsertWithWhereUniqueWithoutPatientHomeInput[]
    createMany?: PatientEquipmentCreateManyPatientHomeInputEnvelope
    set?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    disconnect?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    delete?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    connect?: PatientEquipmentWhereUniqueInput | PatientEquipmentWhereUniqueInput[]
    update?: PatientEquipmentUpdateWithWhereUniqueWithoutPatientHomeInput | PatientEquipmentUpdateWithWhereUniqueWithoutPatientHomeInput[]
    updateMany?: PatientEquipmentUpdateManyWithWhereWithoutPatientHomeInput | PatientEquipmentUpdateManyWithWhereWithoutPatientHomeInput[]
    deleteMany?: PatientEquipmentScalarWhereInput | PatientEquipmentScalarWhereInput[]
  }

  export type PatientHomeCreateNestedOneWithoutVisitsInput = {
    create?: XOR<PatientHomeCreateWithoutVisitsInput, PatientHomeUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: PatientHomeCreateOrConnectWithoutVisitsInput
    connect?: PatientHomeWhereUniqueInput
  }

  export type CaregiverCreateNestedOneWithoutVisitsInput = {
    create?: XOR<CaregiverCreateWithoutVisitsInput, CaregiverUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutVisitsInput
    connect?: CaregiverWhereUniqueInput
  }

  export type VisitTaskCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitTaskCreateWithoutVisitInput, VisitTaskUncheckedCreateWithoutVisitInput> | VisitTaskCreateWithoutVisitInput[] | VisitTaskUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitTaskCreateOrConnectWithoutVisitInput | VisitTaskCreateOrConnectWithoutVisitInput[]
    createMany?: VisitTaskCreateManyVisitInputEnvelope
    connect?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
  }

  export type EVVRecordCreateNestedManyWithoutVisitInput = {
    create?: XOR<EVVRecordCreateWithoutVisitInput, EVVRecordUncheckedCreateWithoutVisitInput> | EVVRecordCreateWithoutVisitInput[] | EVVRecordUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: EVVRecordCreateOrConnectWithoutVisitInput | EVVRecordCreateOrConnectWithoutVisitInput[]
    createMany?: EVVRecordCreateManyVisitInputEnvelope
    connect?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
  }

  export type MedicationAdministrationCreateNestedManyWithoutVisitInput = {
    create?: XOR<MedicationAdministrationCreateWithoutVisitInput, MedicationAdministrationUncheckedCreateWithoutVisitInput> | MedicationAdministrationCreateWithoutVisitInput[] | MedicationAdministrationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutVisitInput | MedicationAdministrationCreateOrConnectWithoutVisitInput[]
    createMany?: MedicationAdministrationCreateManyVisitInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutVisitInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type VisitDocumentationCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitDocumentationCreateWithoutVisitInput, VisitDocumentationUncheckedCreateWithoutVisitInput> | VisitDocumentationCreateWithoutVisitInput[] | VisitDocumentationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDocumentationCreateOrConnectWithoutVisitInput | VisitDocumentationCreateOrConnectWithoutVisitInput[]
    createMany?: VisitDocumentationCreateManyVisitInputEnvelope
    connect?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
  }

  export type VisitTaskUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitTaskCreateWithoutVisitInput, VisitTaskUncheckedCreateWithoutVisitInput> | VisitTaskCreateWithoutVisitInput[] | VisitTaskUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitTaskCreateOrConnectWithoutVisitInput | VisitTaskCreateOrConnectWithoutVisitInput[]
    createMany?: VisitTaskCreateManyVisitInputEnvelope
    connect?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
  }

  export type EVVRecordUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<EVVRecordCreateWithoutVisitInput, EVVRecordUncheckedCreateWithoutVisitInput> | EVVRecordCreateWithoutVisitInput[] | EVVRecordUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: EVVRecordCreateOrConnectWithoutVisitInput | EVVRecordCreateOrConnectWithoutVisitInput[]
    createMany?: EVVRecordCreateManyVisitInputEnvelope
    connect?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
  }

  export type MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<MedicationAdministrationCreateWithoutVisitInput, MedicationAdministrationUncheckedCreateWithoutVisitInput> | MedicationAdministrationCreateWithoutVisitInput[] | MedicationAdministrationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutVisitInput | MedicationAdministrationCreateOrConnectWithoutVisitInput[]
    createMany?: MedicationAdministrationCreateManyVisitInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitDocumentationCreateWithoutVisitInput, VisitDocumentationUncheckedCreateWithoutVisitInput> | VisitDocumentationCreateWithoutVisitInput[] | VisitDocumentationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDocumentationCreateOrConnectWithoutVisitInput | VisitDocumentationCreateOrConnectWithoutVisitInput[]
    createMany?: VisitDocumentationCreateManyVisitInputEnvelope
    connect?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
  }

  export type EnumVisitPriorityFieldUpdateOperationsInput = {
    set?: $Enums.VisitPriority
  }

  export type EnumVisitTypeFieldUpdateOperationsInput = {
    set?: $Enums.VisitType
  }

  export type EnumVisitStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientHomeUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<PatientHomeCreateWithoutVisitsInput, PatientHomeUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: PatientHomeCreateOrConnectWithoutVisitsInput
    upsert?: PatientHomeUpsertWithoutVisitsInput
    connect?: PatientHomeWhereUniqueInput
    update?: XOR<XOR<PatientHomeUpdateToOneWithWhereWithoutVisitsInput, PatientHomeUpdateWithoutVisitsInput>, PatientHomeUncheckedUpdateWithoutVisitsInput>
  }

  export type CaregiverUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<CaregiverCreateWithoutVisitsInput, CaregiverUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutVisitsInput
    upsert?: CaregiverUpsertWithoutVisitsInput
    connect?: CaregiverWhereUniqueInput
    update?: XOR<XOR<CaregiverUpdateToOneWithWhereWithoutVisitsInput, CaregiverUpdateWithoutVisitsInput>, CaregiverUncheckedUpdateWithoutVisitsInput>
  }

  export type VisitTaskUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitTaskCreateWithoutVisitInput, VisitTaskUncheckedCreateWithoutVisitInput> | VisitTaskCreateWithoutVisitInput[] | VisitTaskUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitTaskCreateOrConnectWithoutVisitInput | VisitTaskCreateOrConnectWithoutVisitInput[]
    upsert?: VisitTaskUpsertWithWhereUniqueWithoutVisitInput | VisitTaskUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitTaskCreateManyVisitInputEnvelope
    set?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    disconnect?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    delete?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    connect?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    update?: VisitTaskUpdateWithWhereUniqueWithoutVisitInput | VisitTaskUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitTaskUpdateManyWithWhereWithoutVisitInput | VisitTaskUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitTaskScalarWhereInput | VisitTaskScalarWhereInput[]
  }

  export type EVVRecordUpdateManyWithoutVisitNestedInput = {
    create?: XOR<EVVRecordCreateWithoutVisitInput, EVVRecordUncheckedCreateWithoutVisitInput> | EVVRecordCreateWithoutVisitInput[] | EVVRecordUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: EVVRecordCreateOrConnectWithoutVisitInput | EVVRecordCreateOrConnectWithoutVisitInput[]
    upsert?: EVVRecordUpsertWithWhereUniqueWithoutVisitInput | EVVRecordUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: EVVRecordCreateManyVisitInputEnvelope
    set?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    disconnect?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    delete?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    connect?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    update?: EVVRecordUpdateWithWhereUniqueWithoutVisitInput | EVVRecordUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: EVVRecordUpdateManyWithWhereWithoutVisitInput | EVVRecordUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: EVVRecordScalarWhereInput | EVVRecordScalarWhereInput[]
  }

  export type MedicationAdministrationUpdateManyWithoutVisitNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutVisitInput, MedicationAdministrationUncheckedCreateWithoutVisitInput> | MedicationAdministrationCreateWithoutVisitInput[] | MedicationAdministrationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutVisitInput | MedicationAdministrationCreateOrConnectWithoutVisitInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutVisitInput | MedicationAdministrationUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: MedicationAdministrationCreateManyVisitInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutVisitInput | MedicationAdministrationUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutVisitInput | MedicationAdministrationUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutVisitNestedInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutVisitInput | IncidentUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutVisitInput | IncidentUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutVisitInput | IncidentUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type VisitDocumentationUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitDocumentationCreateWithoutVisitInput, VisitDocumentationUncheckedCreateWithoutVisitInput> | VisitDocumentationCreateWithoutVisitInput[] | VisitDocumentationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDocumentationCreateOrConnectWithoutVisitInput | VisitDocumentationCreateOrConnectWithoutVisitInput[]
    upsert?: VisitDocumentationUpsertWithWhereUniqueWithoutVisitInput | VisitDocumentationUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitDocumentationCreateManyVisitInputEnvelope
    set?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    disconnect?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    delete?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    connect?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    update?: VisitDocumentationUpdateWithWhereUniqueWithoutVisitInput | VisitDocumentationUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitDocumentationUpdateManyWithWhereWithoutVisitInput | VisitDocumentationUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitDocumentationScalarWhereInput | VisitDocumentationScalarWhereInput[]
  }

  export type VisitTaskUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitTaskCreateWithoutVisitInput, VisitTaskUncheckedCreateWithoutVisitInput> | VisitTaskCreateWithoutVisitInput[] | VisitTaskUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitTaskCreateOrConnectWithoutVisitInput | VisitTaskCreateOrConnectWithoutVisitInput[]
    upsert?: VisitTaskUpsertWithWhereUniqueWithoutVisitInput | VisitTaskUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitTaskCreateManyVisitInputEnvelope
    set?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    disconnect?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    delete?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    connect?: VisitTaskWhereUniqueInput | VisitTaskWhereUniqueInput[]
    update?: VisitTaskUpdateWithWhereUniqueWithoutVisitInput | VisitTaskUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitTaskUpdateManyWithWhereWithoutVisitInput | VisitTaskUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitTaskScalarWhereInput | VisitTaskScalarWhereInput[]
  }

  export type EVVRecordUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<EVVRecordCreateWithoutVisitInput, EVVRecordUncheckedCreateWithoutVisitInput> | EVVRecordCreateWithoutVisitInput[] | EVVRecordUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: EVVRecordCreateOrConnectWithoutVisitInput | EVVRecordCreateOrConnectWithoutVisitInput[]
    upsert?: EVVRecordUpsertWithWhereUniqueWithoutVisitInput | EVVRecordUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: EVVRecordCreateManyVisitInputEnvelope
    set?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    disconnect?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    delete?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    connect?: EVVRecordWhereUniqueInput | EVVRecordWhereUniqueInput[]
    update?: EVVRecordUpdateWithWhereUniqueWithoutVisitInput | EVVRecordUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: EVVRecordUpdateManyWithWhereWithoutVisitInput | EVVRecordUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: EVVRecordScalarWhereInput | EVVRecordScalarWhereInput[]
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutVisitInput, MedicationAdministrationUncheckedCreateWithoutVisitInput> | MedicationAdministrationCreateWithoutVisitInput[] | MedicationAdministrationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutVisitInput | MedicationAdministrationCreateOrConnectWithoutVisitInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutVisitInput | MedicationAdministrationUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: MedicationAdministrationCreateManyVisitInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutVisitInput | MedicationAdministrationUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutVisitInput | MedicationAdministrationUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutVisitInput | IncidentUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutVisitInput | IncidentUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutVisitInput | IncidentUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitDocumentationCreateWithoutVisitInput, VisitDocumentationUncheckedCreateWithoutVisitInput> | VisitDocumentationCreateWithoutVisitInput[] | VisitDocumentationUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitDocumentationCreateOrConnectWithoutVisitInput | VisitDocumentationCreateOrConnectWithoutVisitInput[]
    upsert?: VisitDocumentationUpsertWithWhereUniqueWithoutVisitInput | VisitDocumentationUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitDocumentationCreateManyVisitInputEnvelope
    set?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    disconnect?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    delete?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    connect?: VisitDocumentationWhereUniqueInput | VisitDocumentationWhereUniqueInput[]
    update?: VisitDocumentationUpdateWithWhereUniqueWithoutVisitInput | VisitDocumentationUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitDocumentationUpdateManyWithWhereWithoutVisitInput | VisitDocumentationUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitDocumentationScalarWhereInput | VisitDocumentationScalarWhereInput[]
  }

  export type HomeVisitCreateNestedOneWithoutTasksInput = {
    create?: XOR<HomeVisitCreateWithoutTasksInput, HomeVisitUncheckedCreateWithoutTasksInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutTasksInput
    connect?: HomeVisitWhereUniqueInput
  }

  export type EnumCareTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.CareTaskType
  }

  export type EnumTaskCompletionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskCompletionStatus
  }

  export type HomeVisitUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<HomeVisitCreateWithoutTasksInput, HomeVisitUncheckedCreateWithoutTasksInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutTasksInput
    upsert?: HomeVisitUpsertWithoutTasksInput
    connect?: HomeVisitWhereUniqueInput
    update?: XOR<XOR<HomeVisitUpdateToOneWithWhereWithoutTasksInput, HomeVisitUpdateWithoutTasksInput>, HomeVisitUncheckedUpdateWithoutTasksInput>
  }

  export type HomeVisitCreateNestedOneWithoutEvvRecordsInput = {
    create?: XOR<HomeVisitCreateWithoutEvvRecordsInput, HomeVisitUncheckedCreateWithoutEvvRecordsInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutEvvRecordsInput
    connect?: HomeVisitWhereUniqueInput
  }

  export type EnumEVVRecordTypeFieldUpdateOperationsInput = {
    set?: $Enums.EVVRecordType
  }

  export type EnumEVVVerificationMethodFieldUpdateOperationsInput = {
    set?: $Enums.EVVVerificationMethod
  }

  export type HomeVisitUpdateOneRequiredWithoutEvvRecordsNestedInput = {
    create?: XOR<HomeVisitCreateWithoutEvvRecordsInput, HomeVisitUncheckedCreateWithoutEvvRecordsInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutEvvRecordsInput
    upsert?: HomeVisitUpsertWithoutEvvRecordsInput
    connect?: HomeVisitWhereUniqueInput
    update?: XOR<XOR<HomeVisitUpdateToOneWithWhereWithoutEvvRecordsInput, HomeVisitUpdateWithoutEvvRecordsInput>, HomeVisitUncheckedUpdateWithoutEvvRecordsInput>
  }

  export type CaregiverCreateNestedOneWithoutTimeEntriesInput = {
    create?: XOR<CaregiverCreateWithoutTimeEntriesInput, CaregiverUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutTimeEntriesInput
    connect?: CaregiverWhereUniqueInput
  }

  export type EnumTimeEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.TimeEntryType
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type CaregiverUpdateOneRequiredWithoutTimeEntriesNestedInput = {
    create?: XOR<CaregiverCreateWithoutTimeEntriesInput, CaregiverUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutTimeEntriesInput
    upsert?: CaregiverUpsertWithoutTimeEntriesInput
    connect?: CaregiverWhereUniqueInput
    update?: XOR<XOR<CaregiverUpdateToOneWithWhereWithoutTimeEntriesInput, CaregiverUpdateWithoutTimeEntriesInput>, CaregiverUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type CaregiverCreateNestedOneWithoutMileageEntriesInput = {
    create?: XOR<CaregiverCreateWithoutMileageEntriesInput, CaregiverUncheckedCreateWithoutMileageEntriesInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutMileageEntriesInput
    connect?: CaregiverWhereUniqueInput
  }

  export type CaregiverUpdateOneRequiredWithoutMileageEntriesNestedInput = {
    create?: XOR<CaregiverCreateWithoutMileageEntriesInput, CaregiverUncheckedCreateWithoutMileageEntriesInput>
    connectOrCreate?: CaregiverCreateOrConnectWithoutMileageEntriesInput
    upsert?: CaregiverUpsertWithoutMileageEntriesInput
    connect?: CaregiverWhereUniqueInput
    update?: XOR<XOR<CaregiverUpdateToOneWithWhereWithoutMileageEntriesInput, CaregiverUpdateWithoutMileageEntriesInput>, CaregiverUncheckedUpdateWithoutMileageEntriesInput>
  }

  export type HomeAssessmentCreaterequiredEquipmentInput = {
    set: string[]
  }

  export type PatientHomeCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<PatientHomeCreateWithoutAssessmentsInput, PatientHomeUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: PatientHomeCreateOrConnectWithoutAssessmentsInput
    connect?: PatientHomeWhereUniqueInput
  }

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel
  }

  export type HomeAssessmentUpdaterequiredEquipmentInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PatientHomeUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<PatientHomeCreateWithoutAssessmentsInput, PatientHomeUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: PatientHomeCreateOrConnectWithoutAssessmentsInput
    upsert?: PatientHomeUpsertWithoutAssessmentsInput
    connect?: PatientHomeWhereUniqueInput
    update?: XOR<XOR<PatientHomeUpdateToOneWithWhereWithoutAssessmentsInput, PatientHomeUpdateWithoutAssessmentsInput>, PatientHomeUncheckedUpdateWithoutAssessmentsInput>
  }

  export type HomeVisitCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<HomeVisitCreateWithoutMedicationsInput, HomeVisitUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutMedicationsInput
    connect?: HomeVisitWhereUniqueInput
  }

  export type EnumMedicationRouteFieldUpdateOperationsInput = {
    set?: $Enums.MedicationRoute
  }

  export type EnumMedicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.MedicationStatus
  }

  export type HomeVisitUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<HomeVisitCreateWithoutMedicationsInput, HomeVisitUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutMedicationsInput
    upsert?: HomeVisitUpsertWithoutMedicationsInput
    connect?: HomeVisitWhereUniqueInput
    update?: XOR<XOR<HomeVisitUpdateToOneWithWhereWithoutMedicationsInput, HomeVisitUpdateWithoutMedicationsInput>, HomeVisitUncheckedUpdateWithoutMedicationsInput>
  }

  export type HomeVisitCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<HomeVisitCreateWithoutIncidentsInput, HomeVisitUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutIncidentsInput
    connect?: HomeVisitWhereUniqueInput
  }

  export type EnumIncidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.IncidentType
  }

  export type EnumIncidentSeverityFieldUpdateOperationsInput = {
    set?: $Enums.IncidentSeverity
  }

  export type NullableEnumFallTypeFieldUpdateOperationsInput = {
    set?: $Enums.FallType | null
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type HomeVisitUpdateOneWithoutIncidentsNestedInput = {
    create?: XOR<HomeVisitCreateWithoutIncidentsInput, HomeVisitUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutIncidentsInput
    upsert?: HomeVisitUpsertWithoutIncidentsInput
    disconnect?: HomeVisitWhereInput | boolean
    delete?: HomeVisitWhereInput | boolean
    connect?: HomeVisitWhereUniqueInput
    update?: XOR<XOR<HomeVisitUpdateToOneWithWhereWithoutIncidentsInput, HomeVisitUpdateWithoutIncidentsInput>, HomeVisitUncheckedUpdateWithoutIncidentsInput>
  }

  export type HomeVisitCreateNestedOneWithoutDocumentationInput = {
    create?: XOR<HomeVisitCreateWithoutDocumentationInput, HomeVisitUncheckedCreateWithoutDocumentationInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutDocumentationInput
    connect?: HomeVisitWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type HomeVisitUpdateOneRequiredWithoutDocumentationNestedInput = {
    create?: XOR<HomeVisitCreateWithoutDocumentationInput, HomeVisitUncheckedCreateWithoutDocumentationInput>
    connectOrCreate?: HomeVisitCreateOrConnectWithoutDocumentationInput
    upsert?: HomeVisitUpsertWithoutDocumentationInput
    connect?: HomeVisitWhereUniqueInput
    update?: XOR<XOR<HomeVisitUpdateToOneWithWhereWithoutDocumentationInput, HomeVisitUpdateWithoutDocumentationInput>, HomeVisitUncheckedUpdateWithoutDocumentationInput>
  }

  export type PatientHomeCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<PatientHomeCreateWithoutEquipmentInput, PatientHomeUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: PatientHomeCreateOrConnectWithoutEquipmentInput
    connect?: PatientHomeWhereUniqueInput
  }

  export type EnumEquipmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentType
  }

  export type EnumEquipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentStatus
  }

  export type EnumEquipmentConditionFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentCondition
  }

  export type EnumOwnershipTypeFieldUpdateOperationsInput = {
    set?: $Enums.OwnershipType
  }

  export type PatientHomeUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<PatientHomeCreateWithoutEquipmentInput, PatientHomeUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: PatientHomeCreateOrConnectWithoutEquipmentInput
    upsert?: PatientHomeUpsertWithoutEquipmentInput
    connect?: PatientHomeWhereUniqueInput
    update?: XOR<XOR<PatientHomeUpdateToOneWithWhereWithoutEquipmentInput, PatientHomeUpdateWithoutEquipmentInput>, PatientHomeUncheckedUpdateWithoutEquipmentInput>
  }

  export type EnumCommunicationTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationType
  }

  export type EnumSupplyOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.SupplyOrderStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumLicenseTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseTypeNullableFilter<$PrismaModel> | $Enums.LicenseType | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCaregiverStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CaregiverStatus | EnumCaregiverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaregiverStatusFilter<$PrismaModel> | $Enums.CaregiverStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLicenseTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseType | EnumLicenseTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseType[] | ListEnumLicenseTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.LicenseType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLicenseTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumLicenseTypeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCaregiverStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaregiverStatus | EnumCaregiverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaregiverStatus[] | ListEnumCaregiverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCaregiverStatusWithAggregatesFilter<$PrismaModel> | $Enums.CaregiverStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaregiverStatusFilter<$PrismaModel>
    _max?: NestedEnumCaregiverStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumHomeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeType | EnumHomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeTypeFilter<$PrismaModel> | $Enums.HomeType
  }

  export type NestedEnumHomeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeType | EnumHomeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeType[] | ListEnumHomeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeTypeWithAggregatesFilter<$PrismaModel> | $Enums.HomeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHomeTypeFilter<$PrismaModel>
    _max?: NestedEnumHomeTypeFilter<$PrismaModel>
  }

  export type NestedEnumVisitPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitPriority | EnumVisitPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitPriorityFilter<$PrismaModel> | $Enums.VisitPriority
  }

  export type NestedEnumVisitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeFilter<$PrismaModel> | $Enums.VisitType
  }

  export type NestedEnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type NestedEnumVisitPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitPriority | EnumVisitPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitPriority[] | ListEnumVisitPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitPriorityWithAggregatesFilter<$PrismaModel> | $Enums.VisitPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitPriorityFilter<$PrismaModel>
    _max?: NestedEnumVisitPriorityFilter<$PrismaModel>
  }

  export type NestedEnumVisitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitTypeFilter<$PrismaModel>
  }

  export type NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumCareTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareTaskType | EnumCareTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTaskTypeFilter<$PrismaModel> | $Enums.CareTaskType
  }

  export type NestedEnumTaskCompletionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCompletionStatus | EnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCompletionStatusFilter<$PrismaModel> | $Enums.TaskCompletionStatus
  }

  export type NestedEnumCareTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareTaskType | EnumCareTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareTaskType[] | ListEnumCareTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareTaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumCareTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskCompletionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCompletionStatus | EnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCompletionStatus[] | ListEnumTaskCompletionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCompletionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskCompletionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskCompletionStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskCompletionStatusFilter<$PrismaModel>
  }

  export type NestedEnumEVVRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVRecordType | EnumEVVRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVRecordTypeFilter<$PrismaModel> | $Enums.EVVRecordType
  }

  export type NestedEnumEVVVerificationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVVerificationMethod | EnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVVerificationMethodFilter<$PrismaModel> | $Enums.EVVVerificationMethod
  }

  export type NestedEnumEVVRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVRecordType | EnumEVVRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVRecordType[] | ListEnumEVVRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.EVVRecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEVVRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumEVVRecordTypeFilter<$PrismaModel>
  }

  export type NestedEnumEVVVerificationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EVVVerificationMethod | EnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EVVVerificationMethod[] | ListEnumEVVVerificationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEVVVerificationMethodWithAggregatesFilter<$PrismaModel> | $Enums.EVVVerificationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEVVVerificationMethodFilter<$PrismaModel>
    _max?: NestedEnumEVVVerificationMethodFilter<$PrismaModel>
  }

  export type NestedEnumTimeEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryType | EnumTimeEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryTypeFilter<$PrismaModel> | $Enums.TimeEntryType
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumTimeEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryType | EnumTimeEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryType[] | ListEnumTimeEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.TimeEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumTimeEntryTypeFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type NestedEnumMedicationRouteFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationRoute | EnumMedicationRouteFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationRouteFilter<$PrismaModel> | $Enums.MedicationRoute
  }

  export type NestedEnumMedicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusFilter<$PrismaModel> | $Enums.MedicationStatus
  }

  export type NestedEnumMedicationRouteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationRoute | EnumMedicationRouteFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationRoute[] | ListEnumMedicationRouteFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationRouteWithAggregatesFilter<$PrismaModel> | $Enums.MedicationRoute
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicationRouteFilter<$PrismaModel>
    _max?: NestedEnumMedicationRouteFilter<$PrismaModel>
  }

  export type NestedEnumMedicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicationStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type NestedEnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type NestedEnumFallTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FallType | EnumFallTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFallTypeNullableFilter<$PrismaModel> | $Enums.FallType | null
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type NestedEnumFallTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FallType | EnumFallTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FallType[] | ListEnumFallTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFallTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FallType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFallTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFallTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeFilter<$PrismaModel> | $Enums.EquipmentType
  }

  export type NestedEnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type NestedEnumEquipmentConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCondition | EnumEquipmentConditionFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentConditionFilter<$PrismaModel> | $Enums.EquipmentCondition
  }

  export type NestedEnumOwnershipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipTypeFilter<$PrismaModel> | $Enums.OwnershipType
  }

  export type NestedEnumEquipmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentTypeFilter<$PrismaModel>
    _max?: NestedEnumEquipmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCondition | EnumEquipmentConditionFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCondition[] | ListEnumEquipmentConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentConditionWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentConditionFilter<$PrismaModel>
    _max?: NestedEnumEquipmentConditionFilter<$PrismaModel>
  }

  export type NestedEnumOwnershipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipTypeWithAggregatesFilter<$PrismaModel> | $Enums.OwnershipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnershipTypeFilter<$PrismaModel>
    _max?: NestedEnumOwnershipTypeFilter<$PrismaModel>
  }

  export type NestedEnumCommunicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeFilter<$PrismaModel> | $Enums.CommunicationType
  }

  export type NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommunicationTypeFilter<$PrismaModel>
  }

  export type NestedEnumSupplyOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplyOrderStatus | EnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplyOrderStatusFilter<$PrismaModel> | $Enums.SupplyOrderStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSupplyOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplyOrderStatus | EnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplyOrderStatus[] | ListEnumSupplyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplyOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupplyOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupplyOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumSupplyOrderStatusFilter<$PrismaModel>
  }

  export type HomeVisitCreateWithoutCaregiverInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutVisitsInput
    tasks?: VisitTaskCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateWithoutCaregiverInput = {
    id?: string
    patientId: string
    patientHomeId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: VisitTaskUncheckedCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordUncheckedCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitCreateOrConnectWithoutCaregiverInput = {
    where: HomeVisitWhereUniqueInput
    create: XOR<HomeVisitCreateWithoutCaregiverInput, HomeVisitUncheckedCreateWithoutCaregiverInput>
  }

  export type HomeVisitCreateManyCaregiverInputEnvelope = {
    data: HomeVisitCreateManyCaregiverInput | HomeVisitCreateManyCaregiverInput[]
    skipDuplicates?: boolean
  }

  export type CaregiverScheduleCreateWithoutCaregiverInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaregiverScheduleUncheckedCreateWithoutCaregiverInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaregiverScheduleCreateOrConnectWithoutCaregiverInput = {
    where: CaregiverScheduleWhereUniqueInput
    create: XOR<CaregiverScheduleCreateWithoutCaregiverInput, CaregiverScheduleUncheckedCreateWithoutCaregiverInput>
  }

  export type CaregiverScheduleCreateManyCaregiverInputEnvelope = {
    data: CaregiverScheduleCreateManyCaregiverInput | CaregiverScheduleCreateManyCaregiverInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutCaregiverInput = {
    id?: string
    visitId?: string | null
    entryType: $Enums.TimeEntryType
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryUncheckedCreateWithoutCaregiverInput = {
    id?: string
    visitId?: string | null
    entryType: $Enums.TimeEntryType
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutCaregiverInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutCaregiverInput, TimeEntryUncheckedCreateWithoutCaregiverInput>
  }

  export type TimeEntryCreateManyCaregiverInputEnvelope = {
    data: TimeEntryCreateManyCaregiverInput | TimeEntryCreateManyCaregiverInput[]
    skipDuplicates?: boolean
  }

  export type MileageEntryCreateWithoutCaregiverInput = {
    id?: string
    date?: Date | string
    startAddress: string
    endAddress: string
    distance: number
    purpose?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: number
    totalAmount?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MileageEntryUncheckedCreateWithoutCaregiverInput = {
    id?: string
    date?: Date | string
    startAddress: string
    endAddress: string
    distance: number
    purpose?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: number
    totalAmount?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MileageEntryCreateOrConnectWithoutCaregiverInput = {
    where: MileageEntryWhereUniqueInput
    create: XOR<MileageEntryCreateWithoutCaregiverInput, MileageEntryUncheckedCreateWithoutCaregiverInput>
  }

  export type MileageEntryCreateManyCaregiverInputEnvelope = {
    data: MileageEntryCreateManyCaregiverInput | MileageEntryCreateManyCaregiverInput[]
    skipDuplicates?: boolean
  }

  export type HomeVisitUpsertWithWhereUniqueWithoutCaregiverInput = {
    where: HomeVisitWhereUniqueInput
    update: XOR<HomeVisitUpdateWithoutCaregiverInput, HomeVisitUncheckedUpdateWithoutCaregiverInput>
    create: XOR<HomeVisitCreateWithoutCaregiverInput, HomeVisitUncheckedCreateWithoutCaregiverInput>
  }

  export type HomeVisitUpdateWithWhereUniqueWithoutCaregiverInput = {
    where: HomeVisitWhereUniqueInput
    data: XOR<HomeVisitUpdateWithoutCaregiverInput, HomeVisitUncheckedUpdateWithoutCaregiverInput>
  }

  export type HomeVisitUpdateManyWithWhereWithoutCaregiverInput = {
    where: HomeVisitScalarWhereInput
    data: XOR<HomeVisitUpdateManyMutationInput, HomeVisitUncheckedUpdateManyWithoutCaregiverInput>
  }

  export type HomeVisitScalarWhereInput = {
    AND?: HomeVisitScalarWhereInput | HomeVisitScalarWhereInput[]
    OR?: HomeVisitScalarWhereInput[]
    NOT?: HomeVisitScalarWhereInput | HomeVisitScalarWhereInput[]
    id?: StringFilter<"HomeVisit"> | string
    patientId?: StringFilter<"HomeVisit"> | string
    patientHomeId?: StringFilter<"HomeVisit"> | string
    caregiverId?: StringFilter<"HomeVisit"> | string
    scheduledDate?: DateTimeFilter<"HomeVisit"> | Date | string
    scheduledStartTime?: StringFilter<"HomeVisit"> | string
    scheduledEndTime?: StringFilter<"HomeVisit"> | string
    estimatedDuration?: IntFilter<"HomeVisit"> | number
    priority?: EnumVisitPriorityFilter<"HomeVisit"> | $Enums.VisitPriority
    visitType?: EnumVisitTypeFilter<"HomeVisit"> | $Enums.VisitType
    status?: EnumVisitStatusFilter<"HomeVisit"> | $Enums.VisitStatus
    actualStartTime?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    actualDuration?: IntNullableFilter<"HomeVisit"> | number | null
    startLatitude?: FloatNullableFilter<"HomeVisit"> | number | null
    startLongitude?: FloatNullableFilter<"HomeVisit"> | number | null
    endLatitude?: FloatNullableFilter<"HomeVisit"> | number | null
    endLongitude?: FloatNullableFilter<"HomeVisit"> | number | null
    reasonForVisit?: StringNullableFilter<"HomeVisit"> | string | null
    clinicalNotes?: StringNullableFilter<"HomeVisit"> | string | null
    patientCondition?: StringNullableFilter<"HomeVisit"> | string | null
    followUpRequired?: BoolFilter<"HomeVisit"> | boolean
    followUpNotes?: StringNullableFilter<"HomeVisit"> | string | null
    caregiverSignature?: StringNullableFilter<"HomeVisit"> | string | null
    patientSignature?: StringNullableFilter<"HomeVisit"> | string | null
    signedAt?: DateTimeNullableFilter<"HomeVisit"> | Date | string | null
    createdAt?: DateTimeFilter<"HomeVisit"> | Date | string
    updatedAt?: DateTimeFilter<"HomeVisit"> | Date | string
  }

  export type CaregiverScheduleUpsertWithWhereUniqueWithoutCaregiverInput = {
    where: CaregiverScheduleWhereUniqueInput
    update: XOR<CaregiverScheduleUpdateWithoutCaregiverInput, CaregiverScheduleUncheckedUpdateWithoutCaregiverInput>
    create: XOR<CaregiverScheduleCreateWithoutCaregiverInput, CaregiverScheduleUncheckedCreateWithoutCaregiverInput>
  }

  export type CaregiverScheduleUpdateWithWhereUniqueWithoutCaregiverInput = {
    where: CaregiverScheduleWhereUniqueInput
    data: XOR<CaregiverScheduleUpdateWithoutCaregiverInput, CaregiverScheduleUncheckedUpdateWithoutCaregiverInput>
  }

  export type CaregiverScheduleUpdateManyWithWhereWithoutCaregiverInput = {
    where: CaregiverScheduleScalarWhereInput
    data: XOR<CaregiverScheduleUpdateManyMutationInput, CaregiverScheduleUncheckedUpdateManyWithoutCaregiverInput>
  }

  export type CaregiverScheduleScalarWhereInput = {
    AND?: CaregiverScheduleScalarWhereInput | CaregiverScheduleScalarWhereInput[]
    OR?: CaregiverScheduleScalarWhereInput[]
    NOT?: CaregiverScheduleScalarWhereInput | CaregiverScheduleScalarWhereInput[]
    id?: StringFilter<"CaregiverSchedule"> | string
    caregiverId?: StringFilter<"CaregiverSchedule"> | string
    dayOfWeek?: IntFilter<"CaregiverSchedule"> | number
    startTime?: StringFilter<"CaregiverSchedule"> | string
    endTime?: StringFilter<"CaregiverSchedule"> | string
    isAvailable?: BoolFilter<"CaregiverSchedule"> | boolean
    createdAt?: DateTimeFilter<"CaregiverSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CaregiverSchedule"> | Date | string
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutCaregiverInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutCaregiverInput, TimeEntryUncheckedUpdateWithoutCaregiverInput>
    create: XOR<TimeEntryCreateWithoutCaregiverInput, TimeEntryUncheckedCreateWithoutCaregiverInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutCaregiverInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutCaregiverInput, TimeEntryUncheckedUpdateWithoutCaregiverInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutCaregiverInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutCaregiverInput>
  }

  export type TimeEntryScalarWhereInput = {
    AND?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    OR?: TimeEntryScalarWhereInput[]
    NOT?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    caregiverId?: StringFilter<"TimeEntry"> | string
    visitId?: StringNullableFilter<"TimeEntry"> | string | null
    entryType?: EnumTimeEntryTypeFilter<"TimeEntry"> | $Enums.TimeEntryType
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntNullableFilter<"TimeEntry"> | number | null
    startLatitude?: FloatNullableFilter<"TimeEntry"> | number | null
    startLongitude?: FloatNullableFilter<"TimeEntry"> | number | null
    endLatitude?: FloatNullableFilter<"TimeEntry"> | number | null
    endLongitude?: FloatNullableFilter<"TimeEntry"> | number | null
    status?: EnumApprovalStatusFilter<"TimeEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableFilter<"TimeEntry"> | string | null
    approvedAt?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    notes?: StringNullableFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
  }

  export type MileageEntryUpsertWithWhereUniqueWithoutCaregiverInput = {
    where: MileageEntryWhereUniqueInput
    update: XOR<MileageEntryUpdateWithoutCaregiverInput, MileageEntryUncheckedUpdateWithoutCaregiverInput>
    create: XOR<MileageEntryCreateWithoutCaregiverInput, MileageEntryUncheckedCreateWithoutCaregiverInput>
  }

  export type MileageEntryUpdateWithWhereUniqueWithoutCaregiverInput = {
    where: MileageEntryWhereUniqueInput
    data: XOR<MileageEntryUpdateWithoutCaregiverInput, MileageEntryUncheckedUpdateWithoutCaregiverInput>
  }

  export type MileageEntryUpdateManyWithWhereWithoutCaregiverInput = {
    where: MileageEntryScalarWhereInput
    data: XOR<MileageEntryUpdateManyMutationInput, MileageEntryUncheckedUpdateManyWithoutCaregiverInput>
  }

  export type MileageEntryScalarWhereInput = {
    AND?: MileageEntryScalarWhereInput | MileageEntryScalarWhereInput[]
    OR?: MileageEntryScalarWhereInput[]
    NOT?: MileageEntryScalarWhereInput | MileageEntryScalarWhereInput[]
    id?: StringFilter<"MileageEntry"> | string
    caregiverId?: StringFilter<"MileageEntry"> | string
    date?: DateTimeFilter<"MileageEntry"> | Date | string
    startAddress?: StringFilter<"MileageEntry"> | string
    endAddress?: StringFilter<"MileageEntry"> | string
    distance?: FloatFilter<"MileageEntry"> | number
    purpose?: StringNullableFilter<"MileageEntry"> | string | null
    startLatitude?: FloatNullableFilter<"MileageEntry"> | number | null
    startLongitude?: FloatNullableFilter<"MileageEntry"> | number | null
    endLatitude?: FloatNullableFilter<"MileageEntry"> | number | null
    endLongitude?: FloatNullableFilter<"MileageEntry"> | number | null
    routeData?: JsonNullableFilter<"MileageEntry">
    ratePerMile?: FloatFilter<"MileageEntry"> | number
    totalAmount?: FloatNullableFilter<"MileageEntry"> | number | null
    status?: EnumApprovalStatusFilter<"MileageEntry"> | $Enums.ApprovalStatus
    approvedBy?: StringNullableFilter<"MileageEntry"> | string | null
    approvedAt?: DateTimeNullableFilter<"MileageEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"MileageEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MileageEntry"> | Date | string
  }

  export type CaregiverCreateWithoutSchedulesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverUncheckedCreateWithoutSchedulesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitUncheckedCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryUncheckedCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverCreateOrConnectWithoutSchedulesInput = {
    where: CaregiverWhereUniqueInput
    create: XOR<CaregiverCreateWithoutSchedulesInput, CaregiverUncheckedCreateWithoutSchedulesInput>
  }

  export type CaregiverUpsertWithoutSchedulesInput = {
    update: XOR<CaregiverUpdateWithoutSchedulesInput, CaregiverUncheckedUpdateWithoutSchedulesInput>
    create: XOR<CaregiverCreateWithoutSchedulesInput, CaregiverUncheckedCreateWithoutSchedulesInput>
    where?: CaregiverWhereInput
  }

  export type CaregiverUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: CaregiverWhereInput
    data: XOR<CaregiverUpdateWithoutSchedulesInput, CaregiverUncheckedUpdateWithoutSchedulesInput>
  }

  export type CaregiverUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUpdateManyWithoutCaregiverNestedInput
  }

  export type CaregiverUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUncheckedUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUncheckedUpdateManyWithoutCaregiverNestedInput
  }

  export type HomeVisitCreateWithoutPatientHomeInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caregiver: CaregiverCreateNestedOneWithoutVisitsInput
    tasks?: VisitTaskCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateWithoutPatientHomeInput = {
    id?: string
    patientId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: VisitTaskUncheckedCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordUncheckedCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitCreateOrConnectWithoutPatientHomeInput = {
    where: HomeVisitWhereUniqueInput
    create: XOR<HomeVisitCreateWithoutPatientHomeInput, HomeVisitUncheckedCreateWithoutPatientHomeInput>
  }

  export type HomeVisitCreateManyPatientHomeInputEnvelope = {
    data: HomeVisitCreateManyPatientHomeInput | HomeVisitCreateManyPatientHomeInput[]
    skipDuplicates?: boolean
  }

  export type HomeAssessmentCreateWithoutPatientHomeInput = {
    id?: string
    assessorId: string
    assessmentDate?: Date | string
    safetyScore?: number | null
    fallRisk?: $Enums.RiskLevel
    fireRisk?: $Enums.RiskLevel
    infectionRisk?: $Enums.RiskLevel
    cleanlinessScore?: number | null
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentCreaterequiredEquipmentInput | string[]
    followUpDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeAssessmentUncheckedCreateWithoutPatientHomeInput = {
    id?: string
    assessorId: string
    assessmentDate?: Date | string
    safetyScore?: number | null
    fallRisk?: $Enums.RiskLevel
    fireRisk?: $Enums.RiskLevel
    infectionRisk?: $Enums.RiskLevel
    cleanlinessScore?: number | null
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentCreaterequiredEquipmentInput | string[]
    followUpDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeAssessmentCreateOrConnectWithoutPatientHomeInput = {
    where: HomeAssessmentWhereUniqueInput
    create: XOR<HomeAssessmentCreateWithoutPatientHomeInput, HomeAssessmentUncheckedCreateWithoutPatientHomeInput>
  }

  export type HomeAssessmentCreateManyPatientHomeInputEnvelope = {
    data: HomeAssessmentCreateManyPatientHomeInput | HomeAssessmentCreateManyPatientHomeInput[]
    skipDuplicates?: boolean
  }

  export type PatientEquipmentCreateWithoutPatientHomeInput = {
    id?: string
    equipmentType: $Enums.EquipmentType
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    status?: $Enums.EquipmentStatus
    condition?: $Enums.EquipmentCondition
    deliveredDate?: Date | string | null
    expectedReturnDate?: Date | string | null
    returnedDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    maintenanceNotes?: string | null
    ownershipType?: $Enums.OwnershipType
    rentalCompany?: string | null
    monthlyRentalCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientEquipmentUncheckedCreateWithoutPatientHomeInput = {
    id?: string
    equipmentType: $Enums.EquipmentType
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    status?: $Enums.EquipmentStatus
    condition?: $Enums.EquipmentCondition
    deliveredDate?: Date | string | null
    expectedReturnDate?: Date | string | null
    returnedDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    maintenanceNotes?: string | null
    ownershipType?: $Enums.OwnershipType
    rentalCompany?: string | null
    monthlyRentalCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientEquipmentCreateOrConnectWithoutPatientHomeInput = {
    where: PatientEquipmentWhereUniqueInput
    create: XOR<PatientEquipmentCreateWithoutPatientHomeInput, PatientEquipmentUncheckedCreateWithoutPatientHomeInput>
  }

  export type PatientEquipmentCreateManyPatientHomeInputEnvelope = {
    data: PatientEquipmentCreateManyPatientHomeInput | PatientEquipmentCreateManyPatientHomeInput[]
    skipDuplicates?: boolean
  }

  export type HomeVisitUpsertWithWhereUniqueWithoutPatientHomeInput = {
    where: HomeVisitWhereUniqueInput
    update: XOR<HomeVisitUpdateWithoutPatientHomeInput, HomeVisitUncheckedUpdateWithoutPatientHomeInput>
    create: XOR<HomeVisitCreateWithoutPatientHomeInput, HomeVisitUncheckedCreateWithoutPatientHomeInput>
  }

  export type HomeVisitUpdateWithWhereUniqueWithoutPatientHomeInput = {
    where: HomeVisitWhereUniqueInput
    data: XOR<HomeVisitUpdateWithoutPatientHomeInput, HomeVisitUncheckedUpdateWithoutPatientHomeInput>
  }

  export type HomeVisitUpdateManyWithWhereWithoutPatientHomeInput = {
    where: HomeVisitScalarWhereInput
    data: XOR<HomeVisitUpdateManyMutationInput, HomeVisitUncheckedUpdateManyWithoutPatientHomeInput>
  }

  export type HomeAssessmentUpsertWithWhereUniqueWithoutPatientHomeInput = {
    where: HomeAssessmentWhereUniqueInput
    update: XOR<HomeAssessmentUpdateWithoutPatientHomeInput, HomeAssessmentUncheckedUpdateWithoutPatientHomeInput>
    create: XOR<HomeAssessmentCreateWithoutPatientHomeInput, HomeAssessmentUncheckedCreateWithoutPatientHomeInput>
  }

  export type HomeAssessmentUpdateWithWhereUniqueWithoutPatientHomeInput = {
    where: HomeAssessmentWhereUniqueInput
    data: XOR<HomeAssessmentUpdateWithoutPatientHomeInput, HomeAssessmentUncheckedUpdateWithoutPatientHomeInput>
  }

  export type HomeAssessmentUpdateManyWithWhereWithoutPatientHomeInput = {
    where: HomeAssessmentScalarWhereInput
    data: XOR<HomeAssessmentUpdateManyMutationInput, HomeAssessmentUncheckedUpdateManyWithoutPatientHomeInput>
  }

  export type HomeAssessmentScalarWhereInput = {
    AND?: HomeAssessmentScalarWhereInput | HomeAssessmentScalarWhereInput[]
    OR?: HomeAssessmentScalarWhereInput[]
    NOT?: HomeAssessmentScalarWhereInput | HomeAssessmentScalarWhereInput[]
    id?: StringFilter<"HomeAssessment"> | string
    patientHomeId?: StringFilter<"HomeAssessment"> | string
    assessorId?: StringFilter<"HomeAssessment"> | string
    assessmentDate?: DateTimeFilter<"HomeAssessment"> | Date | string
    safetyScore?: IntNullableFilter<"HomeAssessment"> | number | null
    fallRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFilter<"HomeAssessment"> | $Enums.RiskLevel
    cleanlinessScore?: IntNullableFilter<"HomeAssessment"> | number | null
    adequateLighting?: BoolFilter<"HomeAssessment"> | boolean
    adequateVentilation?: BoolFilter<"HomeAssessment"> | boolean
    workingUtilities?: BoolFilter<"HomeAssessment"> | boolean
    bathroomAccessible?: BoolFilter<"HomeAssessment"> | boolean
    bedroomAccessible?: BoolFilter<"HomeAssessment"> | boolean
    kitchenAccessible?: BoolFilter<"HomeAssessment"> | boolean
    recommendations?: JsonNullableFilter<"HomeAssessment">
    requiredEquipment?: StringNullableListFilter<"HomeAssessment">
    followUpDate?: DateTimeNullableFilter<"HomeAssessment"> | Date | string | null
    notes?: StringNullableFilter<"HomeAssessment"> | string | null
    createdAt?: DateTimeFilter<"HomeAssessment"> | Date | string
    updatedAt?: DateTimeFilter<"HomeAssessment"> | Date | string
  }

  export type PatientEquipmentUpsertWithWhereUniqueWithoutPatientHomeInput = {
    where: PatientEquipmentWhereUniqueInput
    update: XOR<PatientEquipmentUpdateWithoutPatientHomeInput, PatientEquipmentUncheckedUpdateWithoutPatientHomeInput>
    create: XOR<PatientEquipmentCreateWithoutPatientHomeInput, PatientEquipmentUncheckedCreateWithoutPatientHomeInput>
  }

  export type PatientEquipmentUpdateWithWhereUniqueWithoutPatientHomeInput = {
    where: PatientEquipmentWhereUniqueInput
    data: XOR<PatientEquipmentUpdateWithoutPatientHomeInput, PatientEquipmentUncheckedUpdateWithoutPatientHomeInput>
  }

  export type PatientEquipmentUpdateManyWithWhereWithoutPatientHomeInput = {
    where: PatientEquipmentScalarWhereInput
    data: XOR<PatientEquipmentUpdateManyMutationInput, PatientEquipmentUncheckedUpdateManyWithoutPatientHomeInput>
  }

  export type PatientEquipmentScalarWhereInput = {
    AND?: PatientEquipmentScalarWhereInput | PatientEquipmentScalarWhereInput[]
    OR?: PatientEquipmentScalarWhereInput[]
    NOT?: PatientEquipmentScalarWhereInput | PatientEquipmentScalarWhereInput[]
    id?: StringFilter<"PatientEquipment"> | string
    patientHomeId?: StringFilter<"PatientEquipment"> | string
    equipmentType?: EnumEquipmentTypeFilter<"PatientEquipment"> | $Enums.EquipmentType
    name?: StringFilter<"PatientEquipment"> | string
    serialNumber?: StringNullableFilter<"PatientEquipment"> | string | null
    manufacturer?: StringNullableFilter<"PatientEquipment"> | string | null
    model?: StringNullableFilter<"PatientEquipment"> | string | null
    status?: EnumEquipmentStatusFilter<"PatientEquipment"> | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFilter<"PatientEquipment"> | $Enums.EquipmentCondition
    deliveredDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    expectedReturnDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    returnedDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    nextMaintenanceDate?: DateTimeNullableFilter<"PatientEquipment"> | Date | string | null
    maintenanceNotes?: StringNullableFilter<"PatientEquipment"> | string | null
    ownershipType?: EnumOwnershipTypeFilter<"PatientEquipment"> | $Enums.OwnershipType
    rentalCompany?: StringNullableFilter<"PatientEquipment"> | string | null
    monthlyRentalCost?: FloatNullableFilter<"PatientEquipment"> | number | null
    notes?: StringNullableFilter<"PatientEquipment"> | string | null
    createdAt?: DateTimeFilter<"PatientEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"PatientEquipment"> | Date | string
  }

  export type PatientHomeCreateWithoutVisitsInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    assessments?: HomeAssessmentCreateNestedManyWithoutPatientHomeInput
    equipment?: PatientEquipmentCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeUncheckedCreateWithoutVisitsInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    assessments?: HomeAssessmentUncheckedCreateNestedManyWithoutPatientHomeInput
    equipment?: PatientEquipmentUncheckedCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeCreateOrConnectWithoutVisitsInput = {
    where: PatientHomeWhereUniqueInput
    create: XOR<PatientHomeCreateWithoutVisitsInput, PatientHomeUncheckedCreateWithoutVisitsInput>
  }

  export type CaregiverCreateWithoutVisitsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: CaregiverScheduleCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverUncheckedCreateWithoutVisitsInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: CaregiverScheduleUncheckedCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryUncheckedCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverCreateOrConnectWithoutVisitsInput = {
    where: CaregiverWhereUniqueInput
    create: XOR<CaregiverCreateWithoutVisitsInput, CaregiverUncheckedCreateWithoutVisitsInput>
  }

  export type VisitTaskCreateWithoutVisitInput = {
    id?: string
    taskType: $Enums.CareTaskType
    title: string
    description?: string | null
    isRequired?: boolean
    sequence?: number
    status?: $Enums.TaskCompletionStatus
    completedAt?: Date | string | null
    completedBy?: string | null
    notes?: string | null
    vitalType?: string | null
    vitalValue?: number | null
    vitalUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitTaskUncheckedCreateWithoutVisitInput = {
    id?: string
    taskType: $Enums.CareTaskType
    title: string
    description?: string | null
    isRequired?: boolean
    sequence?: number
    status?: $Enums.TaskCompletionStatus
    completedAt?: Date | string | null
    completedBy?: string | null
    notes?: string | null
    vitalType?: string | null
    vitalValue?: number | null
    vitalUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitTaskCreateOrConnectWithoutVisitInput = {
    where: VisitTaskWhereUniqueInput
    create: XOR<VisitTaskCreateWithoutVisitInput, VisitTaskUncheckedCreateWithoutVisitInput>
  }

  export type VisitTaskCreateManyVisitInputEnvelope = {
    data: VisitTaskCreateManyVisitInput | VisitTaskCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type EVVRecordCreateWithoutVisitInput = {
    id?: string
    recordType: $Enums.EVVRecordType
    timestamp?: Date | string
    latitude: number
    longitude: number
    accuracy?: number | null
    deviceId?: string | null
    deviceType?: string | null
    ipAddress?: string | null
    isVerified?: boolean
    verificationMethod: $Enums.EVVVerificationMethod
    verificationNotes?: string | null
    distanceFromHome?: number | null
    isWithinGeofence?: boolean
    geofenceRadius?: number
    createdAt?: Date | string
  }

  export type EVVRecordUncheckedCreateWithoutVisitInput = {
    id?: string
    recordType: $Enums.EVVRecordType
    timestamp?: Date | string
    latitude: number
    longitude: number
    accuracy?: number | null
    deviceId?: string | null
    deviceType?: string | null
    ipAddress?: string | null
    isVerified?: boolean
    verificationMethod: $Enums.EVVVerificationMethod
    verificationNotes?: string | null
    distanceFromHome?: number | null
    isWithinGeofence?: boolean
    geofenceRadius?: number
    createdAt?: Date | string
  }

  export type EVVRecordCreateOrConnectWithoutVisitInput = {
    where: EVVRecordWhereUniqueInput
    create: XOR<EVVRecordCreateWithoutVisitInput, EVVRecordUncheckedCreateWithoutVisitInput>
  }

  export type EVVRecordCreateManyVisitInputEnvelope = {
    data: EVVRecordCreateManyVisitInput | EVVRecordCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type MedicationAdministrationCreateWithoutVisitInput = {
    id?: string
    medicationName: string
    dosage: string
    route: $Enums.MedicationRoute
    scheduledTime: Date | string
    administeredTime?: Date | string | null
    status?: $Enums.MedicationStatus
    refusedReason?: string | null
    notes?: string | null
    administeredBy?: string | null
    witnessedBy?: string | null
    medicationBarcode?: string | null
    patientBarcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationAdministrationUncheckedCreateWithoutVisitInput = {
    id?: string
    medicationName: string
    dosage: string
    route: $Enums.MedicationRoute
    scheduledTime: Date | string
    administeredTime?: Date | string | null
    status?: $Enums.MedicationStatus
    refusedReason?: string | null
    notes?: string | null
    administeredBy?: string | null
    witnessedBy?: string | null
    medicationBarcode?: string | null
    patientBarcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationAdministrationCreateOrConnectWithoutVisitInput = {
    where: MedicationAdministrationWhereUniqueInput
    create: XOR<MedicationAdministrationCreateWithoutVisitInput, MedicationAdministrationUncheckedCreateWithoutVisitInput>
  }

  export type MedicationAdministrationCreateManyVisitInputEnvelope = {
    data: MedicationAdministrationCreateManyVisitInput | MedicationAdministrationCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutVisitInput = {
    id?: string
    patientId: string
    caregiverId?: string | null
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    occurredAt: Date | string
    location?: string | null
    description: string
    immediateAction?: string | null
    witnessNames?: string | null
    fallType?: $Enums.FallType | null
    injuryOccurred?: boolean
    injuryDescription?: string | null
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: $Enums.IncidentStatus
    investigatedBy?: string | null
    investigatedAt?: Date | string | null
    rootCause?: string | null
    preventiveMeasures?: string | null
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUncheckedCreateWithoutVisitInput = {
    id?: string
    patientId: string
    caregiverId?: string | null
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    occurredAt: Date | string
    location?: string | null
    description: string
    immediateAction?: string | null
    witnessNames?: string | null
    fallType?: $Enums.FallType | null
    injuryOccurred?: boolean
    injuryDescription?: string | null
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: $Enums.IncidentStatus
    investigatedBy?: string | null
    investigatedAt?: Date | string | null
    rootCause?: string | null
    preventiveMeasures?: string | null
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateOrConnectWithoutVisitInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput>
  }

  export type IncidentCreateManyVisitInputEnvelope = {
    data: IncidentCreateManyVisitInput | IncidentCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type VisitDocumentationCreateWithoutVisitInput = {
    id?: string
    documentType: $Enums.DocumentType
    title: string
    content?: string | null
    fileUrl?: string | null
    fileType?: string | null
    fileSize?: number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitDocumentationUncheckedCreateWithoutVisitInput = {
    id?: string
    documentType: $Enums.DocumentType
    title: string
    content?: string | null
    fileUrl?: string | null
    fileType?: string | null
    fileSize?: number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitDocumentationCreateOrConnectWithoutVisitInput = {
    where: VisitDocumentationWhereUniqueInput
    create: XOR<VisitDocumentationCreateWithoutVisitInput, VisitDocumentationUncheckedCreateWithoutVisitInput>
  }

  export type VisitDocumentationCreateManyVisitInputEnvelope = {
    data: VisitDocumentationCreateManyVisitInput | VisitDocumentationCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type PatientHomeUpsertWithoutVisitsInput = {
    update: XOR<PatientHomeUpdateWithoutVisitsInput, PatientHomeUncheckedUpdateWithoutVisitsInput>
    create: XOR<PatientHomeCreateWithoutVisitsInput, PatientHomeUncheckedCreateWithoutVisitsInput>
    where?: PatientHomeWhereInput
  }

  export type PatientHomeUpdateToOneWithWhereWithoutVisitsInput = {
    where?: PatientHomeWhereInput
    data: XOR<PatientHomeUpdateWithoutVisitsInput, PatientHomeUncheckedUpdateWithoutVisitsInput>
  }

  export type PatientHomeUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessments?: HomeAssessmentUpdateManyWithoutPatientHomeNestedInput
    equipment?: PatientEquipmentUpdateManyWithoutPatientHomeNestedInput
  }

  export type PatientHomeUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessments?: HomeAssessmentUncheckedUpdateManyWithoutPatientHomeNestedInput
    equipment?: PatientEquipmentUncheckedUpdateManyWithoutPatientHomeNestedInput
  }

  export type CaregiverUpsertWithoutVisitsInput = {
    update: XOR<CaregiverUpdateWithoutVisitsInput, CaregiverUncheckedUpdateWithoutVisitsInput>
    create: XOR<CaregiverCreateWithoutVisitsInput, CaregiverUncheckedCreateWithoutVisitsInput>
    where?: CaregiverWhereInput
  }

  export type CaregiverUpdateToOneWithWhereWithoutVisitsInput = {
    where?: CaregiverWhereInput
    data: XOR<CaregiverUpdateWithoutVisitsInput, CaregiverUncheckedUpdateWithoutVisitsInput>
  }

  export type CaregiverUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: CaregiverScheduleUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUpdateManyWithoutCaregiverNestedInput
  }

  export type CaregiverUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: CaregiverScheduleUncheckedUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUncheckedUpdateManyWithoutCaregiverNestedInput
  }

  export type VisitTaskUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitTaskWhereUniqueInput
    update: XOR<VisitTaskUpdateWithoutVisitInput, VisitTaskUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitTaskCreateWithoutVisitInput, VisitTaskUncheckedCreateWithoutVisitInput>
  }

  export type VisitTaskUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitTaskWhereUniqueInput
    data: XOR<VisitTaskUpdateWithoutVisitInput, VisitTaskUncheckedUpdateWithoutVisitInput>
  }

  export type VisitTaskUpdateManyWithWhereWithoutVisitInput = {
    where: VisitTaskScalarWhereInput
    data: XOR<VisitTaskUpdateManyMutationInput, VisitTaskUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitTaskScalarWhereInput = {
    AND?: VisitTaskScalarWhereInput | VisitTaskScalarWhereInput[]
    OR?: VisitTaskScalarWhereInput[]
    NOT?: VisitTaskScalarWhereInput | VisitTaskScalarWhereInput[]
    id?: StringFilter<"VisitTask"> | string
    visitId?: StringFilter<"VisitTask"> | string
    taskType?: EnumCareTaskTypeFilter<"VisitTask"> | $Enums.CareTaskType
    title?: StringFilter<"VisitTask"> | string
    description?: StringNullableFilter<"VisitTask"> | string | null
    isRequired?: BoolFilter<"VisitTask"> | boolean
    sequence?: IntFilter<"VisitTask"> | number
    status?: EnumTaskCompletionStatusFilter<"VisitTask"> | $Enums.TaskCompletionStatus
    completedAt?: DateTimeNullableFilter<"VisitTask"> | Date | string | null
    completedBy?: StringNullableFilter<"VisitTask"> | string | null
    notes?: StringNullableFilter<"VisitTask"> | string | null
    vitalType?: StringNullableFilter<"VisitTask"> | string | null
    vitalValue?: FloatNullableFilter<"VisitTask"> | number | null
    vitalUnit?: StringNullableFilter<"VisitTask"> | string | null
    createdAt?: DateTimeFilter<"VisitTask"> | Date | string
    updatedAt?: DateTimeFilter<"VisitTask"> | Date | string
  }

  export type EVVRecordUpsertWithWhereUniqueWithoutVisitInput = {
    where: EVVRecordWhereUniqueInput
    update: XOR<EVVRecordUpdateWithoutVisitInput, EVVRecordUncheckedUpdateWithoutVisitInput>
    create: XOR<EVVRecordCreateWithoutVisitInput, EVVRecordUncheckedCreateWithoutVisitInput>
  }

  export type EVVRecordUpdateWithWhereUniqueWithoutVisitInput = {
    where: EVVRecordWhereUniqueInput
    data: XOR<EVVRecordUpdateWithoutVisitInput, EVVRecordUncheckedUpdateWithoutVisitInput>
  }

  export type EVVRecordUpdateManyWithWhereWithoutVisitInput = {
    where: EVVRecordScalarWhereInput
    data: XOR<EVVRecordUpdateManyMutationInput, EVVRecordUncheckedUpdateManyWithoutVisitInput>
  }

  export type EVVRecordScalarWhereInput = {
    AND?: EVVRecordScalarWhereInput | EVVRecordScalarWhereInput[]
    OR?: EVVRecordScalarWhereInput[]
    NOT?: EVVRecordScalarWhereInput | EVVRecordScalarWhereInput[]
    id?: StringFilter<"EVVRecord"> | string
    visitId?: StringFilter<"EVVRecord"> | string
    recordType?: EnumEVVRecordTypeFilter<"EVVRecord"> | $Enums.EVVRecordType
    timestamp?: DateTimeFilter<"EVVRecord"> | Date | string
    latitude?: FloatFilter<"EVVRecord"> | number
    longitude?: FloatFilter<"EVVRecord"> | number
    accuracy?: FloatNullableFilter<"EVVRecord"> | number | null
    deviceId?: StringNullableFilter<"EVVRecord"> | string | null
    deviceType?: StringNullableFilter<"EVVRecord"> | string | null
    ipAddress?: StringNullableFilter<"EVVRecord"> | string | null
    isVerified?: BoolFilter<"EVVRecord"> | boolean
    verificationMethod?: EnumEVVVerificationMethodFilter<"EVVRecord"> | $Enums.EVVVerificationMethod
    verificationNotes?: StringNullableFilter<"EVVRecord"> | string | null
    distanceFromHome?: FloatNullableFilter<"EVVRecord"> | number | null
    isWithinGeofence?: BoolFilter<"EVVRecord"> | boolean
    geofenceRadius?: FloatFilter<"EVVRecord"> | number
    createdAt?: DateTimeFilter<"EVVRecord"> | Date | string
  }

  export type MedicationAdministrationUpsertWithWhereUniqueWithoutVisitInput = {
    where: MedicationAdministrationWhereUniqueInput
    update: XOR<MedicationAdministrationUpdateWithoutVisitInput, MedicationAdministrationUncheckedUpdateWithoutVisitInput>
    create: XOR<MedicationAdministrationCreateWithoutVisitInput, MedicationAdministrationUncheckedCreateWithoutVisitInput>
  }

  export type MedicationAdministrationUpdateWithWhereUniqueWithoutVisitInput = {
    where: MedicationAdministrationWhereUniqueInput
    data: XOR<MedicationAdministrationUpdateWithoutVisitInput, MedicationAdministrationUncheckedUpdateWithoutVisitInput>
  }

  export type MedicationAdministrationUpdateManyWithWhereWithoutVisitInput = {
    where: MedicationAdministrationScalarWhereInput
    data: XOR<MedicationAdministrationUpdateManyMutationInput, MedicationAdministrationUncheckedUpdateManyWithoutVisitInput>
  }

  export type MedicationAdministrationScalarWhereInput = {
    AND?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
    OR?: MedicationAdministrationScalarWhereInput[]
    NOT?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
    id?: StringFilter<"MedicationAdministration"> | string
    visitId?: StringFilter<"MedicationAdministration"> | string
    medicationName?: StringFilter<"MedicationAdministration"> | string
    dosage?: StringFilter<"MedicationAdministration"> | string
    route?: EnumMedicationRouteFilter<"MedicationAdministration"> | $Enums.MedicationRoute
    scheduledTime?: DateTimeFilter<"MedicationAdministration"> | Date | string
    administeredTime?: DateTimeNullableFilter<"MedicationAdministration"> | Date | string | null
    status?: EnumMedicationStatusFilter<"MedicationAdministration"> | $Enums.MedicationStatus
    refusedReason?: StringNullableFilter<"MedicationAdministration"> | string | null
    notes?: StringNullableFilter<"MedicationAdministration"> | string | null
    administeredBy?: StringNullableFilter<"MedicationAdministration"> | string | null
    witnessedBy?: StringNullableFilter<"MedicationAdministration"> | string | null
    medicationBarcode?: StringNullableFilter<"MedicationAdministration"> | string | null
    patientBarcode?: StringNullableFilter<"MedicationAdministration"> | string | null
    createdAt?: DateTimeFilter<"MedicationAdministration"> | Date | string
    updatedAt?: DateTimeFilter<"MedicationAdministration"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutVisitInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutVisitInput, IncidentUncheckedUpdateWithoutVisitInput>
    create: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutVisitInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutVisitInput, IncidentUncheckedUpdateWithoutVisitInput>
  }

  export type IncidentUpdateManyWithWhereWithoutVisitInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutVisitInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    visitId?: StringNullableFilter<"Incident"> | string | null
    patientId?: StringFilter<"Incident"> | string
    caregiverId?: StringNullableFilter<"Incident"> | string | null
    incidentType?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    occurredAt?: DateTimeFilter<"Incident"> | Date | string
    location?: StringNullableFilter<"Incident"> | string | null
    description?: StringFilter<"Incident"> | string
    immediateAction?: StringNullableFilter<"Incident"> | string | null
    witnessNames?: StringNullableFilter<"Incident"> | string | null
    fallType?: EnumFallTypeNullableFilter<"Incident"> | $Enums.FallType | null
    injuryOccurred?: BoolFilter<"Incident"> | boolean
    injuryDescription?: StringNullableFilter<"Incident"> | string | null
    medicalAttentionRequired?: BoolFilter<"Incident"> | boolean
    emergencyServicesNotified?: BoolFilter<"Incident"> | boolean
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    investigatedBy?: StringNullableFilter<"Incident"> | string | null
    investigatedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableFilter<"Incident"> | string | null
    preventiveMeasures?: StringNullableFilter<"Incident"> | string | null
    familyNotified?: BoolFilter<"Incident"> | boolean
    physicianNotified?: BoolFilter<"Incident"> | boolean
    supervisorNotified?: BoolFilter<"Incident"> | boolean
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
  }

  export type VisitDocumentationUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitDocumentationWhereUniqueInput
    update: XOR<VisitDocumentationUpdateWithoutVisitInput, VisitDocumentationUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitDocumentationCreateWithoutVisitInput, VisitDocumentationUncheckedCreateWithoutVisitInput>
  }

  export type VisitDocumentationUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitDocumentationWhereUniqueInput
    data: XOR<VisitDocumentationUpdateWithoutVisitInput, VisitDocumentationUncheckedUpdateWithoutVisitInput>
  }

  export type VisitDocumentationUpdateManyWithWhereWithoutVisitInput = {
    where: VisitDocumentationScalarWhereInput
    data: XOR<VisitDocumentationUpdateManyMutationInput, VisitDocumentationUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitDocumentationScalarWhereInput = {
    AND?: VisitDocumentationScalarWhereInput | VisitDocumentationScalarWhereInput[]
    OR?: VisitDocumentationScalarWhereInput[]
    NOT?: VisitDocumentationScalarWhereInput | VisitDocumentationScalarWhereInput[]
    id?: StringFilter<"VisitDocumentation"> | string
    visitId?: StringFilter<"VisitDocumentation"> | string
    documentType?: EnumDocumentTypeFilter<"VisitDocumentation"> | $Enums.DocumentType
    title?: StringFilter<"VisitDocumentation"> | string
    content?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileUrl?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileType?: StringNullableFilter<"VisitDocumentation"> | string | null
    fileSize?: IntNullableFilter<"VisitDocumentation"> | number | null
    assessmentData?: JsonNullableFilter<"VisitDocumentation">
    createdBy?: StringFilter<"VisitDocumentation"> | string
    createdAt?: DateTimeFilter<"VisitDocumentation"> | Date | string
    updatedAt?: DateTimeFilter<"VisitDocumentation"> | Date | string
  }

  export type HomeVisitCreateWithoutTasksInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutVisitsInput
    caregiver: CaregiverCreateNestedOneWithoutVisitsInput
    evvRecords?: EVVRecordCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateWithoutTasksInput = {
    id?: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evvRecords?: EVVRecordUncheckedCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitCreateOrConnectWithoutTasksInput = {
    where: HomeVisitWhereUniqueInput
    create: XOR<HomeVisitCreateWithoutTasksInput, HomeVisitUncheckedCreateWithoutTasksInput>
  }

  export type HomeVisitUpsertWithoutTasksInput = {
    update: XOR<HomeVisitUpdateWithoutTasksInput, HomeVisitUncheckedUpdateWithoutTasksInput>
    create: XOR<HomeVisitCreateWithoutTasksInput, HomeVisitUncheckedCreateWithoutTasksInput>
    where?: HomeVisitWhereInput
  }

  export type HomeVisitUpdateToOneWithWhereWithoutTasksInput = {
    where?: HomeVisitWhereInput
    data: XOR<HomeVisitUpdateWithoutTasksInput, HomeVisitUncheckedUpdateWithoutTasksInput>
  }

  export type HomeVisitUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutVisitsNestedInput
    caregiver?: CaregiverUpdateOneRequiredWithoutVisitsNestedInput
    evvRecords?: EVVRecordUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evvRecords?: EVVRecordUncheckedUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitCreateWithoutEvvRecordsInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutVisitsInput
    caregiver: CaregiverCreateNestedOneWithoutVisitsInput
    tasks?: VisitTaskCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateWithoutEvvRecordsInput = {
    id?: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: VisitTaskUncheckedCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitCreateOrConnectWithoutEvvRecordsInput = {
    where: HomeVisitWhereUniqueInput
    create: XOR<HomeVisitCreateWithoutEvvRecordsInput, HomeVisitUncheckedCreateWithoutEvvRecordsInput>
  }

  export type HomeVisitUpsertWithoutEvvRecordsInput = {
    update: XOR<HomeVisitUpdateWithoutEvvRecordsInput, HomeVisitUncheckedUpdateWithoutEvvRecordsInput>
    create: XOR<HomeVisitCreateWithoutEvvRecordsInput, HomeVisitUncheckedCreateWithoutEvvRecordsInput>
    where?: HomeVisitWhereInput
  }

  export type HomeVisitUpdateToOneWithWhereWithoutEvvRecordsInput = {
    where?: HomeVisitWhereInput
    data: XOR<HomeVisitUpdateWithoutEvvRecordsInput, HomeVisitUncheckedUpdateWithoutEvvRecordsInput>
  }

  export type HomeVisitUpdateWithoutEvvRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutVisitsNestedInput
    caregiver?: CaregiverUpdateOneRequiredWithoutVisitsNestedInput
    tasks?: VisitTaskUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateWithoutEvvRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: VisitTaskUncheckedUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type CaregiverCreateWithoutTimeEntriesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitCreateNestedManyWithoutCaregiverInput
    schedules?: CaregiverScheduleCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverUncheckedCreateWithoutTimeEntriesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitUncheckedCreateNestedManyWithoutCaregiverInput
    schedules?: CaregiverScheduleUncheckedCreateNestedManyWithoutCaregiverInput
    mileageEntries?: MileageEntryUncheckedCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverCreateOrConnectWithoutTimeEntriesInput = {
    where: CaregiverWhereUniqueInput
    create: XOR<CaregiverCreateWithoutTimeEntriesInput, CaregiverUncheckedCreateWithoutTimeEntriesInput>
  }

  export type CaregiverUpsertWithoutTimeEntriesInput = {
    update: XOR<CaregiverUpdateWithoutTimeEntriesInput, CaregiverUncheckedUpdateWithoutTimeEntriesInput>
    create: XOR<CaregiverCreateWithoutTimeEntriesInput, CaregiverUncheckedCreateWithoutTimeEntriesInput>
    where?: CaregiverWhereInput
  }

  export type CaregiverUpdateToOneWithWhereWithoutTimeEntriesInput = {
    where?: CaregiverWhereInput
    data: XOR<CaregiverUpdateWithoutTimeEntriesInput, CaregiverUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type CaregiverUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUpdateManyWithoutCaregiverNestedInput
    schedules?: CaregiverScheduleUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUpdateManyWithoutCaregiverNestedInput
  }

  export type CaregiverUncheckedUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUncheckedUpdateManyWithoutCaregiverNestedInput
    schedules?: CaregiverScheduleUncheckedUpdateManyWithoutCaregiverNestedInput
    mileageEntries?: MileageEntryUncheckedUpdateManyWithoutCaregiverNestedInput
  }

  export type CaregiverCreateWithoutMileageEntriesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitCreateNestedManyWithoutCaregiverInput
    schedules?: CaregiverScheduleCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverUncheckedCreateWithoutMileageEntriesInput = {
    id?: string
    userId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    licenseNumber?: string | null
    licenseType?: $Enums.LicenseType | null
    licenseExpiry?: Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverCreatespecialtiesInput | string[]
    languages?: CaregiverCreatelanguagesInput | string[]
    status?: $Enums.CaregiverStatus
    hourlyRate?: number | null
    maxDailyVisits?: number
    maxWeeklyHours?: number
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    homeLatitude?: number | null
    homeLongitude?: number | null
    homeAddress?: string | null
    serviceRadius?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitUncheckedCreateNestedManyWithoutCaregiverInput
    schedules?: CaregiverScheduleUncheckedCreateNestedManyWithoutCaregiverInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutCaregiverInput
  }

  export type CaregiverCreateOrConnectWithoutMileageEntriesInput = {
    where: CaregiverWhereUniqueInput
    create: XOR<CaregiverCreateWithoutMileageEntriesInput, CaregiverUncheckedCreateWithoutMileageEntriesInput>
  }

  export type CaregiverUpsertWithoutMileageEntriesInput = {
    update: XOR<CaregiverUpdateWithoutMileageEntriesInput, CaregiverUncheckedUpdateWithoutMileageEntriesInput>
    create: XOR<CaregiverCreateWithoutMileageEntriesInput, CaregiverUncheckedCreateWithoutMileageEntriesInput>
    where?: CaregiverWhereInput
  }

  export type CaregiverUpdateToOneWithWhereWithoutMileageEntriesInput = {
    where?: CaregiverWhereInput
    data: XOR<CaregiverUpdateWithoutMileageEntriesInput, CaregiverUncheckedUpdateWithoutMileageEntriesInput>
  }

  export type CaregiverUpdateWithoutMileageEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUpdateManyWithoutCaregiverNestedInput
    schedules?: CaregiverScheduleUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutCaregiverNestedInput
  }

  export type CaregiverUncheckedUpdateWithoutMileageEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableEnumLicenseTypeFieldUpdateOperationsInput | $Enums.LicenseType | null
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifications?: NullableJsonNullValueInput | InputJsonValue
    specialties?: CaregiverUpdatespecialtiesInput | string[]
    languages?: CaregiverUpdatelanguagesInput | string[]
    status?: EnumCaregiverStatusFieldUpdateOperationsInput | $Enums.CaregiverStatus
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDailyVisits?: IntFieldUpdateOperationsInput | number
    maxWeeklyHours?: FloatFieldUpdateOperationsInput | number
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    serviceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUncheckedUpdateManyWithoutCaregiverNestedInput
    schedules?: CaregiverScheduleUncheckedUpdateManyWithoutCaregiverNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutCaregiverNestedInput
  }

  export type PatientHomeCreateWithoutAssessmentsInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitCreateNestedManyWithoutPatientHomeInput
    equipment?: PatientEquipmentCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeUncheckedCreateWithoutAssessmentsInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitUncheckedCreateNestedManyWithoutPatientHomeInput
    equipment?: PatientEquipmentUncheckedCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeCreateOrConnectWithoutAssessmentsInput = {
    where: PatientHomeWhereUniqueInput
    create: XOR<PatientHomeCreateWithoutAssessmentsInput, PatientHomeUncheckedCreateWithoutAssessmentsInput>
  }

  export type PatientHomeUpsertWithoutAssessmentsInput = {
    update: XOR<PatientHomeUpdateWithoutAssessmentsInput, PatientHomeUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<PatientHomeCreateWithoutAssessmentsInput, PatientHomeUncheckedCreateWithoutAssessmentsInput>
    where?: PatientHomeWhereInput
  }

  export type PatientHomeUpdateToOneWithWhereWithoutAssessmentsInput = {
    where?: PatientHomeWhereInput
    data: XOR<PatientHomeUpdateWithoutAssessmentsInput, PatientHomeUncheckedUpdateWithoutAssessmentsInput>
  }

  export type PatientHomeUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUpdateManyWithoutPatientHomeNestedInput
    equipment?: PatientEquipmentUpdateManyWithoutPatientHomeNestedInput
  }

  export type PatientHomeUncheckedUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUncheckedUpdateManyWithoutPatientHomeNestedInput
    equipment?: PatientEquipmentUncheckedUpdateManyWithoutPatientHomeNestedInput
  }

  export type HomeVisitCreateWithoutMedicationsInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutVisitsInput
    caregiver: CaregiverCreateNestedOneWithoutVisitsInput
    tasks?: VisitTaskCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateWithoutMedicationsInput = {
    id?: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: VisitTaskUncheckedCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitCreateOrConnectWithoutMedicationsInput = {
    where: HomeVisitWhereUniqueInput
    create: XOR<HomeVisitCreateWithoutMedicationsInput, HomeVisitUncheckedCreateWithoutMedicationsInput>
  }

  export type HomeVisitUpsertWithoutMedicationsInput = {
    update: XOR<HomeVisitUpdateWithoutMedicationsInput, HomeVisitUncheckedUpdateWithoutMedicationsInput>
    create: XOR<HomeVisitCreateWithoutMedicationsInput, HomeVisitUncheckedCreateWithoutMedicationsInput>
    where?: HomeVisitWhereInput
  }

  export type HomeVisitUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: HomeVisitWhereInput
    data: XOR<HomeVisitUpdateWithoutMedicationsInput, HomeVisitUncheckedUpdateWithoutMedicationsInput>
  }

  export type HomeVisitUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutVisitsNestedInput
    caregiver?: CaregiverUpdateOneRequiredWithoutVisitsNestedInput
    tasks?: VisitTaskUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: VisitTaskUncheckedUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitCreateWithoutIncidentsInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutVisitsInput
    caregiver: CaregiverCreateNestedOneWithoutVisitsInput
    tasks?: VisitTaskCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateWithoutIncidentsInput = {
    id?: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: VisitTaskUncheckedCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordUncheckedCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput
    documentation?: VisitDocumentationUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitCreateOrConnectWithoutIncidentsInput = {
    where: HomeVisitWhereUniqueInput
    create: XOR<HomeVisitCreateWithoutIncidentsInput, HomeVisitUncheckedCreateWithoutIncidentsInput>
  }

  export type HomeVisitUpsertWithoutIncidentsInput = {
    update: XOR<HomeVisitUpdateWithoutIncidentsInput, HomeVisitUncheckedUpdateWithoutIncidentsInput>
    create: XOR<HomeVisitCreateWithoutIncidentsInput, HomeVisitUncheckedCreateWithoutIncidentsInput>
    where?: HomeVisitWhereInput
  }

  export type HomeVisitUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: HomeVisitWhereInput
    data: XOR<HomeVisitUpdateWithoutIncidentsInput, HomeVisitUncheckedUpdateWithoutIncidentsInput>
  }

  export type HomeVisitUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutVisitsNestedInput
    caregiver?: CaregiverUpdateOneRequiredWithoutVisitsNestedInput
    tasks?: VisitTaskUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: VisitTaskUncheckedUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUncheckedUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitCreateWithoutDocumentationInput = {
    id?: string
    patientId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientHome: PatientHomeCreateNestedOneWithoutVisitsInput
    caregiver: CaregiverCreateNestedOneWithoutVisitsInput
    tasks?: VisitTaskCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitUncheckedCreateWithoutDocumentationInput = {
    id?: string
    patientId: string
    patientHomeId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: VisitTaskUncheckedCreateNestedManyWithoutVisitInput
    evvRecords?: EVVRecordUncheckedCreateNestedManyWithoutVisitInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
  }

  export type HomeVisitCreateOrConnectWithoutDocumentationInput = {
    where: HomeVisitWhereUniqueInput
    create: XOR<HomeVisitCreateWithoutDocumentationInput, HomeVisitUncheckedCreateWithoutDocumentationInput>
  }

  export type HomeVisitUpsertWithoutDocumentationInput = {
    update: XOR<HomeVisitUpdateWithoutDocumentationInput, HomeVisitUncheckedUpdateWithoutDocumentationInput>
    create: XOR<HomeVisitCreateWithoutDocumentationInput, HomeVisitUncheckedCreateWithoutDocumentationInput>
    where?: HomeVisitWhereInput
  }

  export type HomeVisitUpdateToOneWithWhereWithoutDocumentationInput = {
    where?: HomeVisitWhereInput
    data: XOR<HomeVisitUpdateWithoutDocumentationInput, HomeVisitUncheckedUpdateWithoutDocumentationInput>
  }

  export type HomeVisitUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutVisitsNestedInput
    caregiver?: CaregiverUpdateOneRequiredWithoutVisitsNestedInput
    tasks?: VisitTaskUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: VisitTaskUncheckedUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUncheckedUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type PatientHomeCreateWithoutEquipmentInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitCreateNestedManyWithoutPatientHomeInput
    assessments?: HomeAssessmentCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeUncheckedCreateWithoutEquipmentInput = {
    id?: string
    patientId: string
    address: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    accessInstructions?: string | null
    gateCode?: string | null
    parkingInfo?: string | null
    petInfo?: string | null
    emergencyContact?: string | null
    emergencyPhone?: string | null
    homeType?: $Enums.HomeType
    hasStairs?: boolean
    wheelchairAccessible?: boolean
    oxygenInHome?: boolean
    safetyHazards?: string | null
    specialEquipment?: PatientHomeCreatespecialEquipmentInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: HomeVisitUncheckedCreateNestedManyWithoutPatientHomeInput
    assessments?: HomeAssessmentUncheckedCreateNestedManyWithoutPatientHomeInput
  }

  export type PatientHomeCreateOrConnectWithoutEquipmentInput = {
    where: PatientHomeWhereUniqueInput
    create: XOR<PatientHomeCreateWithoutEquipmentInput, PatientHomeUncheckedCreateWithoutEquipmentInput>
  }

  export type PatientHomeUpsertWithoutEquipmentInput = {
    update: XOR<PatientHomeUpdateWithoutEquipmentInput, PatientHomeUncheckedUpdateWithoutEquipmentInput>
    create: XOR<PatientHomeCreateWithoutEquipmentInput, PatientHomeUncheckedCreateWithoutEquipmentInput>
    where?: PatientHomeWhereInput
  }

  export type PatientHomeUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: PatientHomeWhereInput
    data: XOR<PatientHomeUpdateWithoutEquipmentInput, PatientHomeUncheckedUpdateWithoutEquipmentInput>
  }

  export type PatientHomeUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUpdateManyWithoutPatientHomeNestedInput
    assessments?: HomeAssessmentUpdateManyWithoutPatientHomeNestedInput
  }

  export type PatientHomeUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    gateCode?: NullableStringFieldUpdateOperationsInput | string | null
    parkingInfo?: NullableStringFieldUpdateOperationsInput | string | null
    petInfo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    homeType?: EnumHomeTypeFieldUpdateOperationsInput | $Enums.HomeType
    hasStairs?: BoolFieldUpdateOperationsInput | boolean
    wheelchairAccessible?: BoolFieldUpdateOperationsInput | boolean
    oxygenInHome?: BoolFieldUpdateOperationsInput | boolean
    safetyHazards?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: PatientHomeUpdatespecialEquipmentInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: HomeVisitUncheckedUpdateManyWithoutPatientHomeNestedInput
    assessments?: HomeAssessmentUncheckedUpdateManyWithoutPatientHomeNestedInput
  }

  export type HomeVisitCreateManyCaregiverInput = {
    id?: string
    patientId: string
    patientHomeId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaregiverScheduleCreateManyCaregiverInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateManyCaregiverInput = {
    id?: string
    visitId?: string | null
    entryType: $Enums.TimeEntryType
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MileageEntryCreateManyCaregiverInput = {
    id?: string
    date?: Date | string
    startAddress: string
    endAddress: string
    distance: number
    purpose?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: number
    totalAmount?: number | null
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeVisitUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientHome?: PatientHomeUpdateOneRequiredWithoutVisitsNestedInput
    tasks?: VisitTaskUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: VisitTaskUncheckedUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUncheckedUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateManyWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientHomeId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaregiverScheduleUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaregiverScheduleUncheckedUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaregiverScheduleUncheckedUpdateManyWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumTimeEntryTypeFieldUpdateOperationsInput | $Enums.TimeEntryType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumTimeEntryTypeFieldUpdateOperationsInput | $Enums.TimeEntryType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    entryType?: EnumTimeEntryTypeFieldUpdateOperationsInput | $Enums.TimeEntryType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MileageEntryUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startAddress?: StringFieldUpdateOperationsInput | string
    endAddress?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: FloatFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MileageEntryUncheckedUpdateWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startAddress?: StringFieldUpdateOperationsInput | string
    endAddress?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: FloatFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MileageEntryUncheckedUpdateManyWithoutCaregiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startAddress?: StringFieldUpdateOperationsInput | string
    endAddress?: StringFieldUpdateOperationsInput | string
    distance?: FloatFieldUpdateOperationsInput | number
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeData?: NullableJsonNullValueInput | InputJsonValue
    ratePerMile?: FloatFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeVisitCreateManyPatientHomeInput = {
    id?: string
    patientId: string
    caregiverId: string
    scheduledDate: Date | string
    scheduledStartTime: string
    scheduledEndTime: string
    estimatedDuration: number
    priority?: $Enums.VisitPriority
    visitType: $Enums.VisitType
    status?: $Enums.VisitStatus
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    actualDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    reasonForVisit?: string | null
    clinicalNotes?: string | null
    patientCondition?: string | null
    followUpRequired?: boolean
    followUpNotes?: string | null
    caregiverSignature?: string | null
    patientSignature?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeAssessmentCreateManyPatientHomeInput = {
    id?: string
    assessorId: string
    assessmentDate?: Date | string
    safetyScore?: number | null
    fallRisk?: $Enums.RiskLevel
    fireRisk?: $Enums.RiskLevel
    infectionRisk?: $Enums.RiskLevel
    cleanlinessScore?: number | null
    adequateLighting?: boolean
    adequateVentilation?: boolean
    workingUtilities?: boolean
    bathroomAccessible?: boolean
    bedroomAccessible?: boolean
    kitchenAccessible?: boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentCreaterequiredEquipmentInput | string[]
    followUpDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientEquipmentCreateManyPatientHomeInput = {
    id?: string
    equipmentType: $Enums.EquipmentType
    name: string
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    status?: $Enums.EquipmentStatus
    condition?: $Enums.EquipmentCondition
    deliveredDate?: Date | string | null
    expectedReturnDate?: Date | string | null
    returnedDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    nextMaintenanceDate?: Date | string | null
    maintenanceNotes?: string | null
    ownershipType?: $Enums.OwnershipType
    rentalCompany?: string | null
    monthlyRentalCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeVisitUpdateWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caregiver?: CaregiverUpdateOneRequiredWithoutVisitsNestedInput
    tasks?: VisitTaskUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: VisitTaskUncheckedUpdateManyWithoutVisitNestedInput
    evvRecords?: EVVRecordUncheckedUpdateManyWithoutVisitNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    documentation?: VisitDocumentationUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type HomeVisitUncheckedUpdateManyWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledStartTime?: StringFieldUpdateOperationsInput | string
    scheduledEndTime?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    priority?: EnumVisitPriorityFieldUpdateOperationsInput | $Enums.VisitPriority
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    reasonForVisit?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    patientCondition?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    caregiverSignature?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignature?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeAssessmentUpdateWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessorId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    fallRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    cleanlinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    adequateLighting?: BoolFieldUpdateOperationsInput | boolean
    adequateVentilation?: BoolFieldUpdateOperationsInput | boolean
    workingUtilities?: BoolFieldUpdateOperationsInput | boolean
    bathroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    bedroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    kitchenAccessible?: BoolFieldUpdateOperationsInput | boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentUpdaterequiredEquipmentInput | string[]
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeAssessmentUncheckedUpdateWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessorId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    fallRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    cleanlinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    adequateLighting?: BoolFieldUpdateOperationsInput | boolean
    adequateVentilation?: BoolFieldUpdateOperationsInput | boolean
    workingUtilities?: BoolFieldUpdateOperationsInput | boolean
    bathroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    bedroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    kitchenAccessible?: BoolFieldUpdateOperationsInput | boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentUpdaterequiredEquipmentInput | string[]
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeAssessmentUncheckedUpdateManyWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessorId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    fallRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    fireRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    infectionRisk?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    cleanlinessScore?: NullableIntFieldUpdateOperationsInput | number | null
    adequateLighting?: BoolFieldUpdateOperationsInput | boolean
    adequateVentilation?: BoolFieldUpdateOperationsInput | boolean
    workingUtilities?: BoolFieldUpdateOperationsInput | boolean
    bathroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    bedroomAccessible?: BoolFieldUpdateOperationsInput | boolean
    kitchenAccessible?: BoolFieldUpdateOperationsInput | boolean
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    requiredEquipment?: HomeAssessmentUpdaterequiredEquipmentInput | string[]
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientEquipmentUpdateWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentType?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFieldUpdateOperationsInput | $Enums.EquipmentCondition
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: EnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType
    rentalCompany?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientEquipmentUncheckedUpdateWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentType?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFieldUpdateOperationsInput | $Enums.EquipmentCondition
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: EnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType
    rentalCompany?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientEquipmentUncheckedUpdateManyWithoutPatientHomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentType?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    condition?: EnumEquipmentConditionFieldUpdateOperationsInput | $Enums.EquipmentCondition
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: EnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType
    rentalCompany?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitTaskCreateManyVisitInput = {
    id?: string
    taskType: $Enums.CareTaskType
    title: string
    description?: string | null
    isRequired?: boolean
    sequence?: number
    status?: $Enums.TaskCompletionStatus
    completedAt?: Date | string | null
    completedBy?: string | null
    notes?: string | null
    vitalType?: string | null
    vitalValue?: number | null
    vitalUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EVVRecordCreateManyVisitInput = {
    id?: string
    recordType: $Enums.EVVRecordType
    timestamp?: Date | string
    latitude: number
    longitude: number
    accuracy?: number | null
    deviceId?: string | null
    deviceType?: string | null
    ipAddress?: string | null
    isVerified?: boolean
    verificationMethod: $Enums.EVVVerificationMethod
    verificationNotes?: string | null
    distanceFromHome?: number | null
    isWithinGeofence?: boolean
    geofenceRadius?: number
    createdAt?: Date | string
  }

  export type MedicationAdministrationCreateManyVisitInput = {
    id?: string
    medicationName: string
    dosage: string
    route: $Enums.MedicationRoute
    scheduledTime: Date | string
    administeredTime?: Date | string | null
    status?: $Enums.MedicationStatus
    refusedReason?: string | null
    notes?: string | null
    administeredBy?: string | null
    witnessedBy?: string | null
    medicationBarcode?: string | null
    patientBarcode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyVisitInput = {
    id?: string
    patientId: string
    caregiverId?: string | null
    incidentType: $Enums.IncidentType
    severity: $Enums.IncidentSeverity
    occurredAt: Date | string
    location?: string | null
    description: string
    immediateAction?: string | null
    witnessNames?: string | null
    fallType?: $Enums.FallType | null
    injuryOccurred?: boolean
    injuryDescription?: string | null
    medicalAttentionRequired?: boolean
    emergencyServicesNotified?: boolean
    status?: $Enums.IncidentStatus
    investigatedBy?: string | null
    investigatedAt?: Date | string | null
    rootCause?: string | null
    preventiveMeasures?: string | null
    familyNotified?: boolean
    physicianNotified?: boolean
    supervisorNotified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitDocumentationCreateManyVisitInput = {
    id?: string
    documentType: $Enums.DocumentType
    title: string
    content?: string | null
    fileUrl?: string | null
    fileType?: string | null
    fileSize?: number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitTaskUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumCareTaskTypeFieldUpdateOperationsInput | $Enums.CareTaskType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumTaskCompletionStatusFieldUpdateOperationsInput | $Enums.TaskCompletionStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vitalType?: NullableStringFieldUpdateOperationsInput | string | null
    vitalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    vitalUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitTaskUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumCareTaskTypeFieldUpdateOperationsInput | $Enums.CareTaskType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumTaskCompletionStatusFieldUpdateOperationsInput | $Enums.TaskCompletionStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vitalType?: NullableStringFieldUpdateOperationsInput | string | null
    vitalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    vitalUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitTaskUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumCareTaskTypeFieldUpdateOperationsInput | $Enums.CareTaskType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumTaskCompletionStatusFieldUpdateOperationsInput | $Enums.TaskCompletionStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vitalType?: NullableStringFieldUpdateOperationsInput | string | null
    vitalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    vitalUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EVVRecordUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumEVVRecordTypeFieldUpdateOperationsInput | $Enums.EVVRecordType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: EnumEVVVerificationMethodFieldUpdateOperationsInput | $Enums.EVVVerificationMethod
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromHome?: NullableFloatFieldUpdateOperationsInput | number | null
    isWithinGeofence?: BoolFieldUpdateOperationsInput | boolean
    geofenceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EVVRecordUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumEVVRecordTypeFieldUpdateOperationsInput | $Enums.EVVRecordType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: EnumEVVVerificationMethodFieldUpdateOperationsInput | $Enums.EVVVerificationMethod
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromHome?: NullableFloatFieldUpdateOperationsInput | number | null
    isWithinGeofence?: BoolFieldUpdateOperationsInput | boolean
    geofenceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EVVRecordUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumEVVRecordTypeFieldUpdateOperationsInput | $Enums.EVVRecordType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationMethod?: EnumEVVVerificationMethodFieldUpdateOperationsInput | $Enums.EVVVerificationMethod
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    distanceFromHome?: NullableFloatFieldUpdateOperationsInput | number | null
    isWithinGeofence?: BoolFieldUpdateOperationsInput | boolean
    geofenceRadius?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: EnumMedicationRouteFieldUpdateOperationsInput | $Enums.MedicationRoute
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    refusedReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    administeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    witnessedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medicationBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    patientBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: EnumMedicationRouteFieldUpdateOperationsInput | $Enums.MedicationRoute
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    refusedReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    administeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    witnessedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medicationBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    patientBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: EnumMedicationRouteFieldUpdateOperationsInput | $Enums.MedicationRoute
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    refusedReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    administeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    witnessedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medicationBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    patientBarcode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    immediateAction?: NullableStringFieldUpdateOperationsInput | string | null
    witnessNames?: NullableStringFieldUpdateOperationsInput | string | null
    fallType?: NullableEnumFallTypeFieldUpdateOperationsInput | $Enums.FallType | null
    injuryOccurred?: BoolFieldUpdateOperationsInput | boolean
    injuryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    medicalAttentionRequired?: BoolFieldUpdateOperationsInput | boolean
    emergencyServicesNotified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    investigatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveMeasures?: NullableStringFieldUpdateOperationsInput | string | null
    familyNotified?: BoolFieldUpdateOperationsInput | boolean
    physicianNotified?: BoolFieldUpdateOperationsInput | boolean
    supervisorNotified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    immediateAction?: NullableStringFieldUpdateOperationsInput | string | null
    witnessNames?: NullableStringFieldUpdateOperationsInput | string | null
    fallType?: NullableEnumFallTypeFieldUpdateOperationsInput | $Enums.FallType | null
    injuryOccurred?: BoolFieldUpdateOperationsInput | boolean
    injuryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    medicalAttentionRequired?: BoolFieldUpdateOperationsInput | boolean
    emergencyServicesNotified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    investigatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveMeasures?: NullableStringFieldUpdateOperationsInput | string | null
    familyNotified?: BoolFieldUpdateOperationsInput | boolean
    physicianNotified?: BoolFieldUpdateOperationsInput | boolean
    supervisorNotified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    caregiverId?: NullableStringFieldUpdateOperationsInput | string | null
    incidentType?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    immediateAction?: NullableStringFieldUpdateOperationsInput | string | null
    witnessNames?: NullableStringFieldUpdateOperationsInput | string | null
    fallType?: NullableEnumFallTypeFieldUpdateOperationsInput | $Enums.FallType | null
    injuryOccurred?: BoolFieldUpdateOperationsInput | boolean
    injuryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    medicalAttentionRequired?: BoolFieldUpdateOperationsInput | boolean
    emergencyServicesNotified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    investigatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    preventiveMeasures?: NullableStringFieldUpdateOperationsInput | string | null
    familyNotified?: BoolFieldUpdateOperationsInput | boolean
    physicianNotified?: BoolFieldUpdateOperationsInput | boolean
    supervisorNotified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDocumentationUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDocumentationUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitDocumentationUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentData?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CaregiverCountOutputTypeDefaultArgs instead
     */
    export type CaregiverCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CaregiverCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientHomeCountOutputTypeDefaultArgs instead
     */
    export type PatientHomeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientHomeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HomeVisitCountOutputTypeDefaultArgs instead
     */
    export type HomeVisitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HomeVisitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CaregiverDefaultArgs instead
     */
    export type CaregiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CaregiverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CaregiverScheduleDefaultArgs instead
     */
    export type CaregiverScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CaregiverScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientHomeDefaultArgs instead
     */
    export type PatientHomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientHomeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HomeVisitDefaultArgs instead
     */
    export type HomeVisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HomeVisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitTaskDefaultArgs instead
     */
    export type VisitTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EVVRecordDefaultArgs instead
     */
    export type EVVRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EVVRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeEntryDefaultArgs instead
     */
    export type TimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MileageEntryDefaultArgs instead
     */
    export type MileageEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MileageEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HomeAssessmentDefaultArgs instead
     */
    export type HomeAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HomeAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicationAdministrationDefaultArgs instead
     */
    export type MedicationAdministrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicationAdministrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentDefaultArgs instead
     */
    export type IncidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitDocumentationDefaultArgs instead
     */
    export type VisitDocumentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitDocumentationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientEquipmentDefaultArgs instead
     */
    export type PatientEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientEquipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FamilyCommunicationDefaultArgs instead
     */
    export type FamilyCommunicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FamilyCommunicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplyOrderDefaultArgs instead
     */
    export type SupplyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplyOrderDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}